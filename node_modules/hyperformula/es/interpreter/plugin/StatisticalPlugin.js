function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

import "core-js/modules/es.math.trunc.js";
import "core-js/modules/es.object.get-prototype-of.js";
import "core-js/modules/es.reflect.construct.js";
import "core-js/modules/es.symbol.js";
import "core-js/modules/es.symbol.description.js";
import "core-js/modules/es.object.to-string.js";
import "core-js/modules/es.symbol.iterator.js";
import "core-js/modules/es.array.iterator.js";
import "core-js/modules/es.string.iterator.js";
import "core-js/modules/web.dom-collections.iterator.js";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * @license
 * Copyright (c) 2021 Handsoncode. All rights reserved.
 */
import { CellError, ErrorType } from '../../Cell';
import { ErrorMessage } from '../../error-message';
import { besseli, besselj, besselk, bessely } from './3rdparty/bessel/bessel';
import { beta, binomial, centralF, chisquare, erf as _erf, erfc as _erfc, exponential, gamma, gammafn, gammaln as _gammaln, hypgeom, lognormal, negbin, normal, normalci, poisson, studentt, tci, weibull } from './3rdparty/jstat/jstat';
import { ArgumentTypes, FunctionPlugin } from './FunctionPlugin';
export var StatisticalPlugin = /*#__PURE__*/function (_FunctionPlugin) {
  _inherits(StatisticalPlugin, _FunctionPlugin);

  var _super = _createSuper(StatisticalPlugin);

  function StatisticalPlugin() {
    _classCallCheck(this, StatisticalPlugin);

    return _super.apply(this, arguments);
  }

  _createClass(StatisticalPlugin, [{
    key: "erf",
    value: function erf(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('ERF'), function (lowerBound, upperBound) {
        if (upperBound === undefined) {
          return _erf(lowerBound);
        } else {
          return _erf(upperBound) - _erf(lowerBound);
        }
      });
    }
  }, {
    key: "erfc",
    value: function erfc(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('ERFC'), _erfc);
    }
  }, {
    key: "expondist",
    value: function expondist(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('EXPON.DIST'), function (x, lambda, cumulative) {
        if (cumulative) {
          return exponential.cdf(x, lambda);
        } else {
          return exponential.pdf(x, lambda);
        }
      });
    }
  }, {
    key: "fisher",
    value: function fisher(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('FISHER'), function (x) {
        return Math.log((1 + x) / (1 - x)) / 2;
      });
    }
  }, {
    key: "fisherinv",
    value: function fisherinv(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('FISHERINV'), function (y) {
        return 1 - 2 / (Math.exp(2 * y) + 1);
      });
    }
  }, {
    key: "gamma",
    value: function gamma(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('GAMMA'), gammafn);
    }
  }, {
    key: "gammadist",
    value: function gammadist(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('GAMMA.DIST'), function (value, alphaVal, betaVal, cumulative) {
        if (cumulative) {
          return gamma.cdf(value, alphaVal, betaVal);
        } else {
          return gamma.pdf(value, alphaVal, betaVal);
        }
      });
    }
  }, {
    key: "gammaln",
    value: function gammaln(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('GAMMALN'), _gammaln);
    }
  }, {
    key: "gammainv",
    value: function gammainv(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('GAMMA.INV'), gamma.inv);
    }
  }, {
    key: "gauss",
    value: function gauss(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('GAUSS'), function (z) {
        return normal.cdf(z, 0, 1) - 0.5;
      });
    }
  }, {
    key: "betadist",
    value: function betadist(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('BETA.DIST'), function (x, alphaVal, betaVal, cumulative, A, B) {
        if (x <= A) {
          return new CellError(ErrorType.NUM, ErrorMessage.ValueSmall);
        } else if (x >= B) {
          return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);
        }

        x = (x - A) / (B - A);

        if (cumulative) {
          return beta.cdf(x, alphaVal, betaVal);
        } else {
          return beta.pdf(x, alphaVal, betaVal);
        }
      });
    }
  }, {
    key: "betainv",
    value: function betainv(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('BETA.INV'), function (x, alphaVal, betaVal, A, B) {
        if (A >= B) {
          return new CellError(ErrorType.NUM, ErrorMessage.WrongOrder);
        } else {
          return beta.inv(x, alphaVal, betaVal) * (B - A) + A;
        }
      });
    }
  }, {
    key: "binomialdist",
    value: function binomialdist(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('BINOM.DIST'), function (succ, trials, prob, cumulative) {
        if (succ > trials) {
          return new CellError(ErrorType.NUM, ErrorMessage.WrongOrder);
        }

        succ = Math.trunc(succ);
        trials = Math.trunc(trials);

        if (cumulative) {
          return binomial.cdf(succ, trials, prob);
        } else {
          return binomial.pdf(succ, trials, prob);
        }
      });
    }
  }, {
    key: "binomialinv",
    value: function binomialinv(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('BINOM.INV'), function (trials, prob, alpha) {
        trials = Math.trunc(trials);
        var lower = -1;
        var upper = trials;

        while (upper > lower + 1) {
          var mid = Math.trunc((lower + upper) / 2);

          if (binomial.cdf(mid, trials, prob) >= alpha) {
            upper = mid;
          } else {
            lower = mid;
          }
        }

        return upper;
      });
    }
  }, {
    key: "besselifn",
    value: function besselifn(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('BESSELI'), function (x, n) {
        return besseli(x, Math.trunc(n));
      });
    }
  }, {
    key: "besseljfn",
    value: function besseljfn(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('BESSELJ'), function (x, n) {
        return besselj(x, Math.trunc(n));
      });
    }
  }, {
    key: "besselkfn",
    value: function besselkfn(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('BESSELK'), function (x, n) {
        return besselk(x, Math.trunc(n));
      });
    }
  }, {
    key: "besselyfn",
    value: function besselyfn(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('BESSELY'), function (x, n) {
        return bessely(x, Math.trunc(n));
      });
    }
  }, {
    key: "chisqdist",
    value: function chisqdist(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('CHISQ.DIST'), function (x, deg, cumulative) {
        deg = Math.trunc(deg);

        if (cumulative) {
          return chisquare.cdf(x, deg);
        } else {
          return chisquare.pdf(x, deg);
        }
      });
    }
  }, {
    key: "chisqdistrt",
    value: function chisqdistrt(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('CHISQ.DIST.RT'), function (x, deg) {
        return 1 - chisquare.cdf(x, Math.trunc(deg));
      });
    }
  }, {
    key: "chisqinv",
    value: function chisqinv(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('CHISQ.INV'), function (p, deg) {
        return chisquare.inv(p, Math.trunc(deg));
      });
    }
  }, {
    key: "chisqinvrt",
    value: function chisqinvrt(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('CHISQ.INV.RT'), function (p, deg) {
        return chisquare.inv(1.0 - p, Math.trunc(deg));
      });
    }
  }, {
    key: "fdist",
    value: function fdist(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('F.DIST'), function (x, deg1, deg2, cumulative) {
        deg1 = Math.trunc(deg1);
        deg2 = Math.trunc(deg2);

        if (cumulative) {
          return centralF.cdf(x, deg1, deg2);
        } else {
          return centralF.pdf(x, deg1, deg2);
        }
      });
    }
  }, {
    key: "fdistrt",
    value: function fdistrt(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('F.DIST.RT'), function (x, deg1, deg2) {
        return 1 - centralF.cdf(x, Math.trunc(deg1), Math.trunc(deg2));
      });
    }
  }, {
    key: "finv",
    value: function finv(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('F.INV'), function (p, deg1, deg2) {
        return centralF.inv(p, Math.trunc(deg1), Math.trunc(deg2));
      });
    }
  }, {
    key: "finvrt",
    value: function finvrt(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('F.INV.RT'), function (p, deg1, deg2) {
        return centralF.inv(1.0 - p, Math.trunc(deg1), Math.trunc(deg2));
      });
    }
  }, {
    key: "weibulldist",
    value: function weibulldist(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('WEIBULL.DIST'), function (x, shape, scale, cumulative) {
        if (cumulative) {
          return weibull.cdf(x, scale, shape);
        } else {
          return weibull.pdf(x, scale, shape);
        }
      });
    }
  }, {
    key: "poissondist",
    value: function poissondist(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('POISSON.DIST'), function (x, mean, cumulative) {
        x = Math.trunc(x);

        if (cumulative) {
          return poisson.cdf(x, mean);
        } else {
          return poisson.pdf(x, mean);
        }
      });
    }
  }, {
    key: "hypgeomdist",
    value: function hypgeomdist(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('HYPGEOM.DIST'), function (s, numberS, populationS, numberPop, cumulative) {
        if (s > numberS || s > populationS || numberS > numberPop || populationS > numberPop) {
          return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);
        }

        if (s + numberPop < populationS + numberS) {
          return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);
        }

        s = Math.trunc(s);
        numberS = Math.trunc(numberS);
        populationS = Math.trunc(populationS);
        numberPop = Math.trunc(numberPop);

        if (cumulative) {
          return hypgeom.cdf(s, numberPop, populationS, numberS);
        } else {
          return hypgeom.pdf(s, numberPop, populationS, numberS);
        }
      });
    }
  }, {
    key: "tdist",
    value: function tdist(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('T.DIST'), function (x, deg, cumulative) {
        deg = Math.trunc(deg);

        if (cumulative) {
          return studentt.cdf(x, deg);
        } else {
          return studentt.pdf(x, deg);
        }
      });
    }
  }, {
    key: "tdist2t",
    value: function tdist2t(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('T.DIST.2T'), function (x, deg) {
        return (1 - studentt.cdf(x, Math.trunc(deg))) * 2;
      });
    }
  }, {
    key: "tdistrt",
    value: function tdistrt(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('T.DIST.RT'), function (x, deg) {
        return 1 - studentt.cdf(x, Math.trunc(deg));
      });
    }
  }, {
    key: "tdistold",
    value: function tdistold(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('TDIST'), function (x, deg, mode) {
        return mode * (1 - studentt.cdf(x, Math.trunc(deg)));
      });
    }
  }, {
    key: "tinv",
    value: function tinv(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('T.INV'), function (p, deg) {
        return studentt.inv(p, Math.trunc(deg));
      });
    }
  }, {
    key: "tinv2t",
    value: function tinv2t(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('T.INV.2T'), function (p, deg) {
        return studentt.inv(1 - p / 2, Math.trunc(deg));
      });
    }
  }, {
    key: "lognormdist",
    value: function lognormdist(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('LOGNORM.DIST'), function (x, mean, stddev, cumulative) {
        if (cumulative) {
          return lognormal.cdf(x, mean, stddev);
        } else {
          return lognormal.pdf(x, mean, stddev);
        }
      });
    }
  }, {
    key: "lognorminv",
    value: function lognorminv(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('LOGNORM.INV'), function (p, mean, stddev) {
        return lognormal.inv(p, mean, stddev);
      });
    }
  }, {
    key: "normdist",
    value: function normdist(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('NORM.DIST'), function (x, mean, stddev, cumulative) {
        if (cumulative) {
          return normal.cdf(x, mean, stddev);
        } else {
          return normal.pdf(x, mean, stddev);
        }
      });
    }
  }, {
    key: "norminv",
    value: function norminv(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('NORM.INV'), function (p, mean, stddev) {
        return normal.inv(p, mean, stddev);
      });
    }
  }, {
    key: "normsdist",
    value: function normsdist(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('NORM.S.DIST'), function (x, cumulative) {
        if (cumulative) {
          return normal.cdf(x, 0, 1);
        } else {
          return normal.pdf(x, 0, 1);
        }
      });
    }
  }, {
    key: "normsinv",
    value: function normsinv(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('NORM.S.INV'), function (p) {
        return normal.inv(p, 0, 1);
      });
    }
  }, {
    key: "phi",
    value: function phi(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('PHI'), function (x) {
        return normal.pdf(x, 0, 1);
      });
    }
  }, {
    key: "negbinomdist",
    value: function negbinomdist(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('NEGBINOM.DIST'), function (nf, ns, p, cumulative) {
        nf = Math.trunc(nf);
        ns = Math.trunc(ns);

        if (cumulative) {
          return negbin.cdf(nf, ns, p);
        } else {
          return negbin.pdf(nf, ns, p);
        }
      });
    }
  }, {
    key: "confidencenorm",
    value: function confidencenorm(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('CONFIDENCE.NORM'), // eslint-disable-next-line
      // @ts-ignore
      function (alpha, stddev, size) {
        return normalci(1, alpha, stddev, Math.trunc(size))[1] - 1;
      });
    }
  }, {
    key: "confidencet",
    value: function confidencet(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('CONFIDENCE.T'), function (alpha, stddev, size) {
        size = Math.trunc(size);

        if (size === 1) {
          return new CellError(ErrorType.DIV_BY_ZERO);
        } // eslint-disable-next-line
        // @ts-ignore


        return tci(1, alpha, stddev, size)[1] - 1;
      });
    }
  }, {
    key: "standardize",
    value: function standardize(ast, formulaAddress) {
      return this.runFunction(ast.args, formulaAddress, this.metadata('STANDARDIZE'), function (x, mean, stddev) {
        return (x - mean) / stddev;
      });
    }
  }]);

  return StatisticalPlugin;
}(FunctionPlugin);
StatisticalPlugin.implementedFunctions = {
  'ERF': {
    method: 'erf',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER
    }, {
      argumentType: ArgumentTypes.NUMBER,
      optionalArg: true
    }]
  },
  'ERFC': {
    method: 'erfc',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER
    }]
  },
  'EXPON.DIST': {
    method: 'expondist',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }, {
      argumentType: ArgumentTypes.BOOLEAN
    }]
  },
  'FISHER': {
    method: 'fisher',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: -1,
      lessThan: 1
    }]
  },
  'FISHERINV': {
    method: 'fisherinv',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER
    }]
  },
  'GAMMA': {
    method: 'gamma',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER
    }]
  },
  'GAMMA.DIST': {
    method: 'gammadist',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }, {
      argumentType: ArgumentTypes.BOOLEAN
    }]
  },
  'GAMMALN': {
    method: 'gammaln',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }]
  },
  'GAMMA.INV': {
    method: 'gammainv',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0,
      lessThan: 1
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }]
  },
  'GAUSS': {
    method: 'gauss',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER
    }]
  },
  'BETA.DIST': {
    method: 'betadist',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }, {
      argumentType: ArgumentTypes.BOOLEAN
    }, {
      argumentType: ArgumentTypes.NUMBER,
      defaultValue: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      defaultValue: 1
    }]
  },
  'BETA.INV': {
    method: 'betainv',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0,
      maxValue: 1
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      defaultValue: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      defaultValue: 1
    }]
  },
  'BINOM.DIST': {
    method: 'binomialdist',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: ArgumentTypes.BOOLEAN
    }]
  },
  'BINOM.INV': {
    method: 'binomialinv',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }]
  },
  'BESSELI': {
    method: 'besselifn',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0
    }]
  },
  'BESSELJ': {
    method: 'besseljfn',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0
    }]
  },
  'BESSELK': {
    method: 'besselkfn',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0
    }]
  },
  'BESSELY': {
    method: 'besselyfn',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0
    }]
  },
  'CHISQ.DIST': {
    method: 'chisqdist',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1,
      maxValue: 1e10
    }, {
      argumentType: ArgumentTypes.BOOLEAN
    }]
  },
  'CHISQ.DIST.RT': {
    method: 'chisqdistrt',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1,
      maxValue: 1e10
    }]
  },
  'CHISQ.INV': {
    method: 'chisqinv',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1,
      maxValue: 1e10
    }]
  },
  'CHISQ.INV.RT': {
    method: 'chisqinvrt',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1
    }]
  },
  'F.DIST': {
    method: 'fdist',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1
    }, {
      argumentType: ArgumentTypes.BOOLEAN
    }]
  },
  'F.DIST.RT': {
    method: 'fdistrt',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1
    }]
  },
  'F.INV': {
    method: 'finv',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1
    }]
  },
  'F.INV.RT': {
    method: 'finvrt',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1
    }]
  },
  'WEIBULL.DIST': {
    method: 'weibulldist',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }, {
      argumentType: ArgumentTypes.BOOLEAN
    }]
  },
  'POISSON.DIST': {
    method: 'poissondist',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0
    }, {
      argumentType: ArgumentTypes.BOOLEAN
    }]
  },
  'HYPGEOM.DIST': {
    method: 'hypgeomdist',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }, {
      argumentType: ArgumentTypes.BOOLEAN
    }]
  },
  'T.DIST': {
    method: 'tdist',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1
    }, {
      argumentType: ArgumentTypes.BOOLEAN
    }]
  },
  'T.DIST.2T': {
    method: 'tdist2t',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1
    }]
  },
  'T.DIST.RT': {
    method: 'tdistrt',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1
    }]
  },
  'TDIST': {
    method: 'tdistold',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1
    }, {
      argumentType: ArgumentTypes.INTEGER,
      minValue: 1,
      maxValue: 2
    }]
  },
  'T.INV': {
    method: 'tinv',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1
    }]
  },
  'T.INV.2T': {
    method: 'tinv2t',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0,
      maxValue: 1
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1
    }]
  },
  'LOGNORM.DIST': {
    method: 'lognormdist',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }, {
      argumentType: ArgumentTypes.NUMBER
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }, {
      argumentType: ArgumentTypes.BOOLEAN
    }]
  },
  'LOGNORM.INV': {
    method: 'lognorminv',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }, {
      argumentType: ArgumentTypes.NUMBER
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }]
  },
  'NORM.DIST': {
    method: 'normdist',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER
    }, {
      argumentType: ArgumentTypes.NUMBER
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }, {
      argumentType: ArgumentTypes.BOOLEAN
    }]
  },
  'NORM.INV': {
    method: 'norminv',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }, {
      argumentType: ArgumentTypes.NUMBER
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }]
  },
  'NORM.S.DIST': {
    method: 'normsdist',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER
    }, {
      argumentType: ArgumentTypes.BOOLEAN
    }]
  },
  'NORM.S.INV': {
    method: 'normsinv',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }]
  },
  'PHI': {
    method: 'phi',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER
    }]
  },
  'NEGBINOM.DIST': {
    method: 'negbinomdist',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: ArgumentTypes.BOOLEAN
    }]
  },
  'CONFIDENCE.NORM': {
    method: 'confidencenorm',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1
    }]
  },
  'CONFIDENCE.T': {
    method: 'confidencet',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }, {
      argumentType: ArgumentTypes.NUMBER,
      minValue: 1
    }]
  },
  'STANDARDIZE': {
    method: 'standardize',
    parameters: [{
      argumentType: ArgumentTypes.NUMBER
    }, {
      argumentType: ArgumentTypes.NUMBER
    }, {
      argumentType: ArgumentTypes.NUMBER,
      greaterThan: 0
    }]
  }
};
StatisticalPlugin.aliases = {
  NEGBINOMDIST: 'NEGBINOM.DIST',
  EXPONDIST: 'EXPON.DIST',
  BETADIST: 'BETA.DIST',
  NORMDIST: 'NORM.DIST',
  NORMINV: 'NORM.INV',
  NORMSDIST: 'NORM.S.DIST',
  NORMSINV: 'NORM.S.INV',
  LOGNORMDIST: 'LOGNORM.DIST',
  LOGINV: 'LOGNORM.INV',
  TINV: 'T.INV.2T',
  HYPGEOMDIST: 'HYPGEOM.DIST',
  POISSON: 'POISSON.DIST',
  WEIBULL: 'WEIBULL.DIST',
  FINV: 'F.INV.RT',
  FDIST: 'F.DIST.RT',
  CHIDIST: 'CHISQ.DIST.RT',
  CHIINV: 'CHISQ.INV.RT',
  GAMMADIST: 'GAMMA.DIST',
  'GAMMALN.PRECISE': 'GAMMALN',
  GAMMAINV: 'GAMMA.INV',
  BETAINV: 'BETA.INV',
  BINOMDIST: 'BINOM.DIST',
  CONFIDENCE: 'CONFIDENCE.NORM',
  CRITBINOM: 'BINOM.INV',
  WEIBULLDIST: 'WEIBULL.DIST',
  TINV2T: 'T.INV.2T',
  TDISTRT: 'T.DIST.RT',
  TDIST2T: 'T.DIST.2T',
  FINVRT: 'F.INV.RT',
  FDISTRT: 'F.DIST.RT',
  CHIDISTRT: 'CHISQ.DIST.RT',
  CHIINVRT: 'CHISQ.INV.RT',
  LOGNORMINV: 'LOGNORM.INV',
  POISSONDIST: 'POISSON.DIST'
};