function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import "core-js/modules/es.array.concat.js";
import "core-js/modules/es.regexp.exec.js";
import "core-js/modules/es.regexp.constructor.js";
import "core-js/modules/es.regexp.to-string.js";
import "core-js/modules/es.string.replace.js";
import "core-js/modules/es.string.trim.js";
import "core-js/modules/es.number.constructor.js";
import "core-js/modules/es.object.to-string.js";
import "core-js/modules/es.array.includes.js";
import "core-js/modules/es.array.slice.js";
import "core-js/modules/es.function.name.js";
import "core-js/modules/es.array.from.js";
import "core-js/modules/es.string.iterator.js";
import "core-js/modules/es.symbol.js";
import "core-js/modules/es.symbol.description.js";
import "core-js/modules/es.symbol.iterator.js";
import "core-js/modules/es.array.iterator.js";
import "core-js/modules/web.dom-collections.iterator.js";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @license
 * Copyright (c) 2021 Handsoncode. All rights reserved.
 */
import unorm from 'unorm';
import { CellError, CellValueTypeOrd, ErrorType, getCellValueType } from '../Cell';
import { ErrorMessage } from '../error-message';
import { collatorFromConfig } from '../StringHelper';
import { cloneNumber, CurrencyNumber, DateNumber, DateTimeNumber, EmptyValue, getRawValue, getTypeFormatOfExtendedNumber, isExtendedNumber, NumberType, PercentNumber, TimeNumber } from './InterpreterValue';
import { SimpleRangeValue } from './SimpleRangeValue';
var COMPLEX_NUMBER_SYMBOL = 'i';
var complexParsingRegexp = /^\s*([+-]?)\s*(([\d\.,]+(e[+-]?\d+)?)\s*([ij]?)|([ij]))\s*(([+-])\s*([+-]?)\s*(([\d\.,]+(e[+-]?\d+)?)\s*([ij]?)|([ij])))?$/;
export var ArithmeticHelper = /*#__PURE__*/function () {
  function ArithmeticHelper(config, dateTimeHelper, numberLiteralsHelper) {
    var _this = this;

    _classCallCheck(this, ArithmeticHelper);

    this.config = config;
    this.dateTimeHelper = dateTimeHelper;
    this.numberLiteralsHelper = numberLiteralsHelper;

    this.lt = function (left, right) {
      return _this.compare(left, right) < 0;
    };

    this.leq = function (left, right) {
      return _this.compare(left, right) <= 0;
    };

    this.gt = function (left, right) {
      return _this.compare(left, right) > 0;
    };

    this.geq = function (left, right) {
      return _this.compare(left, right) >= 0;
    };

    this.eq = function (left, right) {
      return _this.compare(left, right) === 0;
    };

    this.neq = function (left, right) {
      return _this.compare(left, right) !== 0;
    };

    this.pow = function (left, right) {
      return Math.pow(getRawValue(left), getRawValue(right));
    };

    this.addWithEpsilonRaw = function (left, right) {
      var ret = left + right;

      if (Math.abs(ret) < _this.actualEps * Math.abs(left)) {
        return 0;
      } else {
        return ret;
      }
    };

    this.addWithEpsilon = function (left, right) {
      var typeOfResult = inferExtendedNumberTypeAdditive(left, right);
      return _this.ExtendedNumberFactory(_this.addWithEpsilonRaw(getRawValue(left), getRawValue(right)), typeOfResult);
    };

    this.unaryMinus = function (arg) {
      return cloneNumber(arg, -getRawValue(arg));
    };

    this.unaryPlus = function (arg) {
      return arg;
    };

    this.unaryPercent = function (arg) {
      return new PercentNumber(getRawValue(arg) / 100);
    };

    this.concat = function (left, right) {
      return left.concat(right);
    };

    this.nonstrictadd = function (left, right) {
      if (left instanceof CellError) {
        return left;
      } else if (right instanceof CellError) {
        return right;
      } else if (typeof left === 'number') {
        if (typeof right === 'number') {
          return _this.addWithEpsilonRaw(left, right);
        } else {
          return left;
        }
      } else if (typeof right === 'number') {
        return right;
      } else {
        return 0;
      }
    };
    /**
     * Subtracts two numbers
     *
     * Implementation of subtracting which is used in interpreter.
     *
     * @param left - left operand of subtraction
     * @param right - right operand of subtraction
     * @param eps - precision of comparison
     */


    this.subtract = function (leftArg, rightArg) {
      var typeOfResult = inferExtendedNumberTypeAdditive(leftArg, rightArg);
      var left = getRawValue(leftArg);
      var right = getRawValue(rightArg);
      var ret = left - right;

      if (Math.abs(ret) < _this.actualEps * Math.abs(left)) {
        ret = 0;
      }

      return _this.ExtendedNumberFactory(ret, typeOfResult);
    };

    this.divide = function (leftArg, rightArg) {
      var left = getRawValue(leftArg);
      var right = getRawValue(rightArg);

      if (right === 0) {
        return new CellError(ErrorType.DIV_BY_ZERO);
      } else {
        var typeOfResult = inferExtendedNumberTypeMultiplicative(leftArg, rightArg);
        return _this.ExtendedNumberFactory(left / right, typeOfResult);
      }
    };

    this.multiply = function (left, right) {
      var typeOfResult = inferExtendedNumberTypeMultiplicative(left, right);
      return _this.ExtendedNumberFactory(getRawValue(left) * getRawValue(right), typeOfResult);
    };

    this.manyToExactComplex = function (args) {
      var ret = [];

      var _iterator = _createForOfIteratorHelper(args),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var arg = _step.value;

          if (arg instanceof CellError) {
            return arg;
          } else if (isExtendedNumber(arg) || typeof arg === 'string') {
            var coerced = _this.coerceScalarToComplex(arg);

            if (!(coerced instanceof CellError)) {
              ret.push(coerced);
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return ret;
    };

    this.coerceNumbersExactRanges = function (args) {
      return _this.manyToNumbers(args, _this.manyToExactNumbers);
    };

    this.coerceNumbersCoerceRangesDropNulls = function (args) {
      return _this.manyToNumbers(args, _this.manyToCoercedNumbersDropNulls);
    };

    this.manyToExactNumbers = function (args) {
      var ret = [];

      var _iterator2 = _createForOfIteratorHelper(args),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var arg = _step2.value;

          if (arg instanceof CellError) {
            return arg;
          } else if (isExtendedNumber(arg)) {
            ret.push(getRawValue(arg));
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return ret;
    };

    this.manyToOnlyNumbersDropNulls = function (args) {
      var ret = [];

      var _iterator3 = _createForOfIteratorHelper(args),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var arg = _step3.value;

          if (arg instanceof CellError) {
            return arg;
          } else if (arg === EmptyValue) {
            continue;
          } else if (isExtendedNumber(arg)) {
            ret.push(getRawValue(arg));
          } else {
            return new CellError(ErrorType.VALUE, ErrorMessage.NumberExpected);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return ret;
    };

    this.manyToCoercedNumbersDropNulls = function (args) {
      var ret = [];

      var _iterator4 = _createForOfIteratorHelper(args),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var arg = _step4.value;

          if (arg instanceof CellError) {
            return arg;
          }

          if (arg === EmptyValue) {
            continue;
          }

          var coerced = _this.coerceScalarToNumberOrError(arg);

          if (isExtendedNumber(coerced)) {
            ret.push(getRawValue(coerced));
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      return ret;
    };

    this.collator = collatorFromConfig(config);
    this.actualEps = config.smartRounding ? config.precisionEpsilon : 0;
  }

  _createClass(ArithmeticHelper, [{
    key: "eqMatcherFunction",
    value: function eqMatcherFunction(pattern) {
      var _this2 = this;

      var regexp = this.buildRegex(pattern);
      return function (cellValue) {
        return typeof cellValue === 'string' && regexp.test(_this2.normalizeString(cellValue));
      };
    }
  }, {
    key: "neqMatcherFunction",
    value: function neqMatcherFunction(pattern) {
      var _this3 = this;

      var regexp = this.buildRegex(pattern);
      return function (cellValue) {
        return !(typeof cellValue === 'string') || !regexp.test(_this3.normalizeString(cellValue));
      };
    }
  }, {
    key: "searchString",
    value: function searchString(pattern, text) {
      var _a;

      var regexp = this.buildRegex(pattern, false);
      var result = regexp.exec(text);
      return (_a = result === null || result === void 0 ? void 0 : result.index) !== null && _a !== void 0 ? _a : -1;
    }
  }, {
    key: "requiresRegex",
    value: function requiresRegex(pattern) {
      if (!this.config.useRegularExpressions && !this.config.useWildcards) {
        return !this.config.matchWholeCell;
      }

      for (var i = 0; i < pattern.length; i++) {
        var c = pattern.charAt(i);

        if (isWildcard(c) || this.config.useRegularExpressions && needsEscape(c)) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "buildRegex",
    value: function buildRegex(pattern) {
      var matchWholeCell = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      pattern = this.normalizeString(pattern);
      var regexpStr;
      var useWildcards = this.config.useWildcards;
      var useRegularExpressions = this.config.useRegularExpressions;

      if (useRegularExpressions) {
        try {
          RegExp(pattern);
        } catch (e) {
          useRegularExpressions = false;
          useWildcards = false;
        }
      }

      if (useRegularExpressions) {
        regexpStr = escapeNoCharacters(pattern, this.config.caseSensitive);
      } else if (useWildcards) {
        regexpStr = escapeNonWildcards(pattern, this.config.caseSensitive);
      } else {
        regexpStr = escapeAllCharacters(pattern, this.config.caseSensitive);
      }

      if (this.config.matchWholeCell && matchWholeCell) {
        return RegExp('^(' + regexpStr + ')$');
      } else {
        return RegExp(regexpStr);
      }
    }
  }, {
    key: "normalizeString",
    value: function normalizeString(str) {
      if (!this.config.caseSensitive) {
        str = str.toLowerCase();
      }

      if (!this.config.accentSensitive) {
        str = _normalizeString(str, 'nfd').replace(/[\u0300-\u036f]/g, '');
      }

      return str;
    }
  }, {
    key: "compare",
    value: function compare(left, right) {
      if (typeof left === 'string' || typeof right === 'string') {
        var leftTmp = typeof left === 'string' ? this.dateTimeHelper.dateStringToDateNumber(left) : left;
        var rightTmp = typeof right === 'string' ? this.dateTimeHelper.dateStringToDateNumber(right) : right;

        if (isExtendedNumber(leftTmp) && isExtendedNumber(rightTmp)) {
          return this.floatCmp(leftTmp, rightTmp);
        }
      }

      if (left === EmptyValue) {
        left = coerceEmptyToValue(right);
      } else if (right === EmptyValue) {
        right = coerceEmptyToValue(left);
      }

      if (typeof left === 'string' && typeof right === 'string') {
        return this.stringCmp(left, right);
      } else if (typeof left === 'boolean' && typeof right === 'boolean') {
        return numberCmp(coerceBooleanToNumber(left), coerceBooleanToNumber(right));
      } else if (isExtendedNumber(left) && isExtendedNumber(right)) {
        return this.floatCmp(left, right);
      } else if (left === EmptyValue && right === EmptyValue) {
        return 0;
      } else {
        return numberCmp(CellValueTypeOrd(getCellValueType(left)), CellValueTypeOrd(getCellValueType(right)));
      }
    }
  }, {
    key: "floatCmp",
    value: function floatCmp(leftArg, rightArg) {
      var left = getRawValue(leftArg);
      var right = getRawValue(rightArg);
      var mod = 1 + this.actualEps;

      if (right >= 0 && left * mod >= right && left <= right * mod) {
        return 0;
      } else if (right <= 0 && left * mod <= right && left >= right * mod) {
        return 0;
      } else if (left > right) {
        return 1;
      } else {
        return -1;
      }
    }
  }, {
    key: "stringCmp",
    value: function stringCmp(left, right) {
      return this.collator.compare(left, right);
    }
  }, {
    key: "coerceScalarToNumberOrError",
    value: function coerceScalarToNumberOrError(arg) {
      var _a;

      if (arg instanceof CellError) {
        return arg;
      }

      return (_a = this.coerceToMaybeNumber(arg)) !== null && _a !== void 0 ? _a : new CellError(ErrorType.VALUE, ErrorMessage.NumberCoercion);
    }
  }, {
    key: "coerceToMaybeNumber",
    value: function coerceToMaybeNumber(arg) {
      var _a;

      return (_a = this.coerceNonDateScalarToMaybeNumber(arg)) !== null && _a !== void 0 ? _a : typeof arg === 'string' ? this.dateTimeHelper.dateStringToDateNumber(arg) : undefined;
    }
  }, {
    key: "coerceNonDateScalarToMaybeNumber",
    value: function coerceNonDateScalarToMaybeNumber(arg) {
      if (arg === EmptyValue) {
        return 0;
      } else if (typeof arg === 'string') {
        if (arg === '') {
          return 0;
        }

        return this.numberLiteralsHelper.numericStringToMaybeNumber(arg.trim());
      } else if (isExtendedNumber(arg)) {
        return arg;
      } else if (typeof arg === 'boolean') {
        return Number(arg);
      } else {
        return undefined;
      }
    }
  }, {
    key: "coerceComplexExactRanges",
    value: function coerceComplexExactRanges(args) {
      var vals = [];

      var _iterator5 = _createForOfIteratorHelper(args),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var arg = _step5.value;

          if (arg instanceof SimpleRangeValue) {
            vals.push(arg);
          } else if (arg !== EmptyValue) {
            var coerced = this.coerceScalarToComplex(arg);

            if (coerced instanceof CellError) {
              return coerced;
            } else {
              vals.push(coerced);
            }
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      var expandedVals = [];

      for (var _i = 0, _vals = vals; _i < _vals.length; _i++) {
        var val = _vals[_i];

        if (val instanceof SimpleRangeValue) {
          var arr = this.manyToExactComplex(val.valuesFromTopLeftCorner());

          if (arr instanceof CellError) {
            return arr;
          } else {
            expandedVals.push.apply(expandedVals, _toConsumableArray(arr));
          }
        } else {
          expandedVals.push(val);
        }
      }

      return expandedVals;
    }
  }, {
    key: "manyToNumbers",
    value: function manyToNumbers(args, rangeFn) {
      var vals = [];

      var _iterator6 = _createForOfIteratorHelper(args),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var arg = _step6.value;

          if (arg instanceof SimpleRangeValue) {
            vals.push(arg);
          } else {
            var coerced = getRawValue(this.coerceScalarToNumberOrError(arg));

            if (coerced instanceof CellError) {
              return coerced;
            } else {
              vals.push(coerced);
            }
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      var expandedVals = [];

      for (var _i2 = 0, _vals2 = vals; _i2 < _vals2.length; _i2++) {
        var val = _vals2[_i2];

        if (val instanceof SimpleRangeValue) {
          var arr = rangeFn(val.valuesFromTopLeftCorner());

          if (arr instanceof CellError) {
            return arr;
          } else {
            expandedVals.push.apply(expandedVals, _toConsumableArray(arr));
          }
        } else {
          expandedVals.push(val);
        }
      }

      return expandedVals;
    }
  }, {
    key: "coerceScalarToComplex",
    value: function coerceScalarToComplex(arg) {
      if (arg instanceof CellError) {
        return arg;
      } else if (arg === EmptyValue) {
        return [0, 0];
      } else if (isExtendedNumber(arg)) {
        return [getRawValue(arg), 0];
      } else if (typeof arg === 'string') {
        return this.coerceStringToComplex(arg);
      } else {
        return new CellError(ErrorType.NUM, ErrorMessage.ComplexNumberExpected);
      }
    }
  }, {
    key: "coerceStringToComplex",
    value: function coerceStringToComplex(arg) {
      var match = complexParsingRegexp.exec(arg);

      if (match === null) {
        return new CellError(ErrorType.NUM, ErrorMessage.ComplexNumberExpected);
      }

      var val1;

      if (match[6] !== undefined) {
        val1 = match[1] === '-' ? [0, -1] : [0, 1];
      } else {
        val1 = this.parseComplexToken(match[1] + match[3], match[5]);
      }

      if (val1 instanceof CellError) {
        return val1;
      }

      if (match[8] === undefined) {
        return val1;
      }

      var val2;

      if (match[14] !== undefined) {
        val2 = match[9] === '-' ? [0, -1] : [0, 1];
      } else {
        val2 = this.parseComplexToken(match[9] + match[11], match[13]);
      }

      if (val2 instanceof CellError) {
        return val2;
      }

      if (match[5] !== '' || match[13] === '') {
        return new CellError(ErrorType.NUM, ErrorMessage.ComplexNumberExpected);
      }

      if (match[8] === '+') {
        return [val1[0] + val2[0], val1[1] + val2[1]];
      } else {
        return [val1[0] - val2[0], val1[1] - val2[1]];
      }
    }
  }, {
    key: "parseComplexToken",
    value: function parseComplexToken(arg, mod) {
      var val = getRawValue(this.coerceNonDateScalarToMaybeNumber(arg));

      if (val === undefined) {
        return new CellError(ErrorType.NUM, ErrorMessage.ComplexNumberExpected);
      }

      if (mod === '') {
        return [val, 0];
      } else {
        return [0, val];
      }
    }
  }, {
    key: "ExtendedNumberFactory",
    value: function ExtendedNumberFactory(value, typeFormat) {
      var type = typeFormat.type,
          format = typeFormat.format;

      switch (type) {
        case NumberType.NUMBER_RAW:
          return value;

        case NumberType.NUMBER_CURRENCY:
          {
            return new CurrencyNumber(value, format !== null && format !== void 0 ? format : this.config.currencySymbol[0]);
          }

        case NumberType.NUMBER_DATE:
          return new DateNumber(value, format);

        case NumberType.NUMBER_DATETIME:
          return new DateTimeNumber(value, format);

        case NumberType.NUMBER_TIME:
          return new TimeNumber(value, format);

        case NumberType.NUMBER_PERCENT:
          return new PercentNumber(value, format);
      }
    }
  }]);

  return ArithmeticHelper;
}();
export function coerceComplexToString(_ref, symb) {
  var _ref2 = _slicedToArray(_ref, 2),
      re = _ref2[0],
      im = _ref2[1];

  if (!isFinite(re) || !isFinite(im)) {
    return new CellError(ErrorType.NUM, ErrorMessage.NaN);
  }

  symb = symb !== null && symb !== void 0 ? symb : COMPLEX_NUMBER_SYMBOL;

  if (im === 0) {
    return "".concat(re);
  }

  var imStr = "".concat(im === -1 || im === 1 ? '' : Math.abs(im)).concat(symb);

  if (re === 0) {
    return "".concat(im < 0 ? '-' : '').concat(imStr);
  }

  return "".concat(re).concat(im < 0 ? '-' : '+').concat(imStr);
}
export function coerceToRange(arg) {
  if (arg instanceof SimpleRangeValue) {
    return arg;
  } else {
    return SimpleRangeValue.fromScalar(arg);
  }
}
export function coerceToRangeNumbersOrError(arg) {
  if (arg instanceof SimpleRangeValue && arg.hasOnlyNumbers() || arg instanceof CellError) {
    return arg;
  } else if (isExtendedNumber(arg)) {
    return SimpleRangeValue.fromScalar(arg);
  } else {
    return null;
  }
}
export function coerceBooleanToNumber(arg) {
  return Number(arg);
}
export function coerceEmptyToValue(arg) {
  if (typeof arg === 'string') {
    return '';
  } else if (isExtendedNumber(arg)) {
    return 0;
  } else if (typeof arg === 'boolean') {
    return false;
  } else {
    return EmptyValue;
  }
}
/**
 * Coerce scalar value to boolean if possible, or error if value is an error
 *
 * @param arg
 */

export function coerceScalarToBoolean(arg) {
  if (arg instanceof CellError || typeof arg === 'boolean') {
    return arg;
  } else if (arg === EmptyValue) {
    return false;
  } else if (isExtendedNumber(arg)) {
    return getRawValue(arg) !== 0;
  } else {
    var argUppered = arg.toUpperCase();

    if (argUppered === 'TRUE') {
      return true;
    } else if (argUppered === 'FALSE') {
      return false;
    } else if (argUppered === '') {
      return false;
    } else {
      return undefined;
    }
  }
}
export function coerceScalarToString(arg) {
  if (arg instanceof CellError || typeof arg === 'string') {
    return arg;
  } else if (arg === EmptyValue) {
    return '';
  } else if (isExtendedNumber(arg)) {
    return getRawValue(arg).toString();
  } else {
    return arg ? 'TRUE' : 'FALSE';
  }
}
export function zeroIfEmpty(arg) {
  return arg === EmptyValue ? 0 : arg;
}
export function numberCmp(leftArg, rightArg) {
  var left = getRawValue(leftArg);
  var right = getRawValue(rightArg);

  if (left > right) {
    return 1;
  } else if (left < right) {
    return -1;
  } else {
    return 0;
  }
}
export function isNumberOverflow(arg) {
  return isNaN(arg) || arg === Infinity || arg === -Infinity;
}
export function fixNegativeZero(arg) {
  if (arg === 0) {
    return 0;
  } else {
    return arg;
  }
}

function isWildcard(c) {
  return ['*', '?'].includes(c);
}

var escapedCharacters = ['{', '}', '[', ']', '(', ')', '<', '>', '=', '.', '+', '-', ',', '\\', '$', '^', '!'];

function needsEscape(c) {
  return escapedCharacters.includes(c);
}

function escapeNonWildcards(pattern, caseSensitive) {
  var str = '';

  for (var i = 0; i < pattern.length; i++) {
    var c = pattern.charAt(i);

    if (c === '~') {
      if (i == pattern.length - 1) {
        str += '~';
        continue;
      }

      var d = pattern.charAt(i + 1);

      if (isWildcard(d) || needsEscape(d)) {
        str += '\\' + d;
        i++;
      } else {
        str += d;
        i++;
      }
    } else if (isWildcard(c)) {
      str += '.' + c;
    } else if (needsEscape(c)) {
      str += '\\' + c;
    } else if (caseSensitive) {
      str += c;
    } else {
      str += c.toLowerCase();
    }
  }

  return str;
}

function escapeAllCharacters(pattern, caseSensitive) {
  var str = '';

  for (var i = 0; i < pattern.length; i++) {
    var c = pattern.charAt(i);

    if (isWildcard(c) || needsEscape(c)) {
      str += '\\' + c;
    } else if (caseSensitive) {
      str += c;
    } else {
      str += c.toLowerCase();
    }
  }

  return str;
}

function escapeNoCharacters(pattern, caseSensitive) {
  var str = '';

  for (var i = 0; i < pattern.length; i++) {
    var c = pattern.charAt(i);

    if (isWildcard(c) || needsEscape(c)) {
      str += c;
    } else if (caseSensitive) {
      str += c;
    } else {
      str += c.toLowerCase();
    }
  }

  return str;
}

function inferExtendedNumberTypeAdditive(leftArg, rightArg) {
  var _getTypeFormatOfExten = getTypeFormatOfExtendedNumber(leftArg),
      leftType = _getTypeFormatOfExten.type,
      leftFormat = _getTypeFormatOfExten.format;

  var _getTypeFormatOfExten2 = getTypeFormatOfExtendedNumber(rightArg),
      rightType = _getTypeFormatOfExten2.type,
      rightFormat = _getTypeFormatOfExten2.format;

  if (leftType === NumberType.NUMBER_RAW) {
    return {
      type: rightType,
      format: rightFormat
    };
  }

  if (rightType === NumberType.NUMBER_RAW) {
    return {
      type: leftType,
      format: leftFormat
    };
  }

  if ((leftType === NumberType.NUMBER_DATETIME || leftType === NumberType.NUMBER_DATE) && (rightType === NumberType.NUMBER_DATETIME || rightType === NumberType.NUMBER_DATE)) {
    return {
      type: NumberType.NUMBER_RAW
    };
  }

  if (leftType === NumberType.NUMBER_TIME) {
    if (rightType === NumberType.NUMBER_DATE) {
      return {
        type: NumberType.NUMBER_DATETIME,
        format: rightFormat + ' ' + leftFormat
      };
    }

    if (rightType === NumberType.NUMBER_DATETIME) {
      return {
        type: NumberType.NUMBER_DATETIME,
        format: rightFormat
      };
    }
  }

  if (rightType === NumberType.NUMBER_TIME) {
    if (leftType === NumberType.NUMBER_DATE) {
      return {
        type: NumberType.NUMBER_DATETIME,
        format: leftFormat + ' ' + rightFormat
      };
    }

    if (leftType === NumberType.NUMBER_DATETIME) {
      return {
        type: NumberType.NUMBER_DATETIME,
        format: leftFormat
      };
    }
  }

  return {
    type: leftType,
    format: leftFormat
  };
}

function inferExtendedNumberTypeMultiplicative(leftArg, rightArg) {
  var _getTypeFormatOfExten3 = getTypeFormatOfExtendedNumber(leftArg),
      leftType = _getTypeFormatOfExten3.type,
      leftFormat = _getTypeFormatOfExten3.format;

  var _getTypeFormatOfExten4 = getTypeFormatOfExtendedNumber(rightArg),
      rightType = _getTypeFormatOfExten4.type,
      rightFormat = _getTypeFormatOfExten4.format;

  if (leftType === NumberType.NUMBER_PERCENT) {
    leftType = NumberType.NUMBER_RAW;
    leftFormat = undefined;
  }

  if (rightType === NumberType.NUMBER_PERCENT) {
    rightType = NumberType.NUMBER_RAW;
    rightFormat = undefined;
  }

  if (leftType === NumberType.NUMBER_RAW) {
    return {
      type: rightType,
      format: rightFormat
    };
  }

  if (rightType === NumberType.NUMBER_RAW) {
    return {
      type: leftType,
      format: leftFormat
    };
  }

  return {
    type: NumberType.NUMBER_RAW
  };
}

export function forceNormalizeString(str) {
  return _normalizeString(str.toLowerCase(), 'nfd').replace(/[\u0300-\u036f]/g, '');
}

function _normalizeString(str, form) {
  return typeof str.normalize === 'function' ? str.normalize(form.toUpperCase()) : unorm[form](str);
}

export { _normalizeString as normalizeString };