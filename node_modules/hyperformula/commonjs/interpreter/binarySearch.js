"use strict";

exports.__esModule = true;
exports.rangeLowerBound = rangeLowerBound;
exports.lowerBound = lowerBound;
exports.compare = compare;

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.symbol.iterator.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

var _Cell = require("../Cell");

var _InterpreterValue = require("./InterpreterValue");

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*
* If key exists returns first index of key element in range of sorted values
* Otherwise returns first index of greatest element smaller than key
* assuming sorted values in range
* */
function rangeLowerBound(range, key, dependencyGraph, coordinate) {
  //IMPORTANT: this function does not normalize input strings
  var end;

  if (coordinate === 'col') {
    end = range.effectiveEndColumn(dependencyGraph);
  } else {
    end = range.effectiveEndRow(dependencyGraph);
  }

  var start = range.start[coordinate];
  var centerValueFn;

  if (coordinate === 'row') {
    centerValueFn = function centerValueFn(center) {
      return (0, _InterpreterValue.getRawValue)(dependencyGraph.getCellValue((0, _Cell.simpleCellAddress)(range.sheet, range.start.col, center)));
    };
  } else {
    centerValueFn = function centerValueFn(center) {
      return (0, _InterpreterValue.getRawValue)(dependencyGraph.getCellValue((0, _Cell.simpleCellAddress)(range.sheet, center, range.start.row)));
    };
  }

  return lowerBound(centerValueFn, key, start, end);
}
/*
* If key exists returns first index of key element
* Otherwise returns first index of greatest element smaller than key
* assuming sorted values
* */


function lowerBound(value, key, start, end) {
  while (start <= end) {
    var center = Math.floor((start + end) / 2);
    var cmp = compare(key, value(center));

    if (cmp > 0) {
      start = center + 1;
    } else if (cmp < 0) {
      end = center - 1;
    } else if (start != center) {
      end = center;
    } else {
      return center;
    }
  }

  return end;
}
/*
* numbers < strings < false < true
* */


function compare(left, right) {
  if (_typeof(left) === _typeof(right)) {
    if (left === _InterpreterValue.EmptyValue) {
      return 0;
    }

    return left < right ? -1 : left > right ? 1 : 0;
  }

  if (left === _InterpreterValue.EmptyValue) {
    return -1;
  }

  if (right === _InterpreterValue.EmptyValue) {
    return 1;
  }

  if (right instanceof _Cell.CellError) {
    return -1;
  }

  if (typeof left === 'number' && typeof right === 'string') {
    return -1;
  }

  if (typeof left === 'number' && typeof right === 'boolean') {
    return -1;
  }

  if (typeof left === 'string' && typeof right === 'number') {
    return 1;
  }

  if (typeof left === 'string' && typeof right === 'boolean') {
    return -1;
  }

  return 1;
}