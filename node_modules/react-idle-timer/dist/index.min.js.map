{"version":3,"file":"index.min.js","sources":["../src/utils.js","../src/MessageChannel/methods/broadcastChannel.js","../src/MessageChannel/ObliviousSet.js","../src/MessageChannel/methods/localStorage.js","../src/MessageChannel/methods/simulate.js","../src/MessageChannel/methodChooser.js","../src/MessageChannel/MessageChannel.js","../src/MessageChannel/leaderElection.js","../src/TabManager.js","../src/IdleTimer.js","../src/useIdleTimer.js"],"sourcesContent":["/**\n * Determine if we are in a browser\n * or a server environment\n * @type {Boolean}\n * @private\n */\nexport const IS_BROWSER =\n  (typeof window === 'undefined' ? 'undefined' : typeof window) === 'object'\n\n/**\n * Default element to listen for events on\n * @type {Object}\n * @private\n */\nexport const DEFAULT_ELEMENT = IS_BROWSER ? document : {}\n\n/**\n * The default events to determine activity\n * @type {Array}\n * @private\n */\nexport const DEFAULT_EVENTS = [\n  'mousemove',\n  'keydown',\n  'wheel',\n  'DOMMouseScroll',\n  'mousewheel',\n  'mousedown',\n  'touchstart',\n  'touchmove',\n  'MSPointerDown',\n  'MSPointerMove',\n  'visibilitychange'\n]\n\n/**\n * Creates a debounced function that delays invoking func until\n * after delay milliseconds has elapsed since the last time the\n * debounced function was invoked.\n * @name debounced\n * @param  {Function} fn   Function to debounce\n * @param  {Number} delay  How long to wait\n * @return {Function}      Executed Function\n * @private\n **/\nexport function debounced (fn, delay) {\n  let timerId\n  function result (...args) {\n    if (timerId) {\n      clearTimeout(timerId)\n    }\n    timerId = setTimeout(() => {\n      fn(...args)\n      timerId = null\n    }, delay)\n  }\n\n  result.cancel = function () {\n    clearTimeout(timerId)\n  }\n\n  return result\n}\n\n/**\n * Creates a throttled function that only invokes func at most\n * once per every wait milliseconds.\n * @name throttled\n * @param  {Function} fn   Function to debounce\n * @param  {Number} delay  How long to wait\n * @return {Function}      Executed Function\n * @private\n **/\nexport function throttled (fn, delay) {\n  let lastCall = 0\n  return function (...args) {\n    const now = new Date().getTime()\n    if (now - lastCall < delay) {\n      return\n    }\n    lastCall = now\n    return fn(...args)\n  }\n}\n\nlet lastMs = 0\nlet additional = 0\n\n/**\n * Returns current time in microseconds.\n *\n * @returns {Number} current time in microseconds\n * @private\n */\nexport function microSeconds () {\n  const ms = new Date().getTime()\n  if (ms === lastMs) {\n    additional++\n    return ms * 1000 + additional\n  } else {\n    lastMs = ms\n    additional = 0\n    return ms * 1000\n  }\n}\n\n/**\n * Generate and return a random token.\n *\n * @returns {String} Random token.\n * @private\n */\nexport function randomToken () {\n  return Math.random().toString(36).substring(2)\n}\n\n/**\n * Checks if a js object is a promise.\n *\n * @param {*} obj  Any javascript object.\n * @returns {Boolean} Wether or not this object is a promise.\n */\nexport function isPromise (obj) {\n  if (obj && typeof obj.then === 'function') {\n    /* istanbul ignore next */\n    return true\n  } else {\n    return false\n  }\n}\n\n/**\n * Sleeps for x amount of milliseconds.\n *\n * @param {Number} time   Amount of time in milliseconds.\n * @returns {Promise}\n * @private\n */\nexport function sleep (time = 0) {\n  return new Promise(resolve => setTimeout(resolve, time))\n}\n\n/**\n * Get the current timestamp.\n *\n * @returns {Number}\n * @private\n */\nexport function now () {\n  return new Date().getTime()\n}\n\n/**\n * Waits until the given function returns true\n * @param  {function}  fn\n * @return {Promise}\n */\nexport function waitUntil (fn, timeout = 0, interval = 20) {\n  let timedOut = false\n  let ok = false\n\n  /* istanbul ignore next */\n  if (timeout !== 0) {\n    sleep(timeout).then(() => {\n      timedOut = true\n    })\n  }\n\n  return new Promise((resolve, reject) => {\n    const runLoop = () => {\n      if (ok) {\n        resolve()\n        return\n      }\n      /* istanbul ignore next */\n      if (timedOut) {\n        reject(new Error(`❌ waitUntil reached timeout of ${timeout}ms`))\n        return\n      }\n      sleep(interval).then(() => {\n        ok = fn()\n        runLoop()\n      })\n    }\n    runLoop()\n  })\n}\n","/* eslint-env browser */\nimport { microSeconds } from '../../utils'\n\nexport const type = 'broadcastChannel'\n\nexport function create (channelName) {\n  const state = {\n    messagesCallback: null,\n    bc: new BroadcastChannel(channelName)\n  }\n\n  state.bc.onmessage = msg => {\n    if (state.messagesCallback) {\n      state.messagesCallback(msg.data)\n    }\n  }\n\n  return state\n}\n\nexport function close (channelState) {\n  channelState.bc.close()\n}\n\nexport function postMessage (channelState, messageJson) {\n  try {\n    channelState.bc.postMessage(messageJson, false)\n    return Promise.resolve()\n  } catch (err) {\n    /* istanbul ignore next */\n    return Promise.reject(err)\n  }\n}\n\nexport function onMessage (channelState, fn) {\n  channelState.messagesCallback = fn\n}\n\nexport function canBeUsed () {\n  if (typeof BroadcastChannel === 'function') {\n    return true\n  } else {\n    /* istanbul ignore next */\n    return false\n  }\n}\n\nexport function averageResponseTime () {\n  return 150\n}\n\nexport default {\n  create,\n  close,\n  onMessage,\n  postMessage,\n  canBeUsed,\n  type,\n  averageResponseTime,\n  microSeconds\n}\n","import { now } from '../utils'\n\nexport default class ObliviousSet {\n  constructor (ttl = 1000 * 60) {\n    this.ttl = ttl\n    this.set = new Set()\n    this.timeMap = new Map()\n  }\n\n  has (value) {\n    return this.set.has(value)\n  }\n\n  add (value) {\n    this.timeMap.set(value, now())\n    this.set.add(value)\n    this._removeTooOldValues()\n  }\n\n  clear () {\n    this.set.clear()\n    this.timeMap.clear()\n  }\n\n  _removeTooOldValues () {\n    const olderThen = now() - this.ttl\n    const iterator = this.set[Symbol.iterator]()\n\n    while (true) {\n      const value = iterator.next().value\n      if (!value) return // no more elements\n      const time = this.timeMap.get(value)\n      if (time < olderThen) {\n        this.timeMap.delete(value)\n        this.set.delete(value)\n      } else {\n        // We reached a value that is not old enough\n        return\n      }\n    }\n  }\n}\n","import ObliviousSet from '../ObliviousSet'\n\nimport {\n  randomToken,\n  microSeconds\n} from '../../utils'\n\nexport const type = 'localStorage'\n\n/**\n * Returns local storage instance\n */\nexport function getLocalStorage () {\n  let localStorage\n  if (typeof window === 'undefined') return null\n  try {\n    localStorage = window.localStorage\n    localStorage = window['ie8-eventlistener/storage'] || window.localStorage\n  } catch (e) {\n    // New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n  }\n  return localStorage\n}\n\nexport function storageKey (channelName) {\n  return channelName\n}\n\n/**\n* writes the new message to the storage\n* and fires the storage-event so other readers can find it\n*/\nexport function postMessage (channelState, messageJson) {\n  return new Promise(resolve => {\n    const key = storageKey(channelState.channelName)\n    const writeObj = {\n      token: randomToken(),\n      time: new Date().getTime(),\n      data: messageJson,\n      uuid: channelState.uuid\n    }\n    const value = JSON.stringify(writeObj)\n    getLocalStorage().setItem(key, value)\n\n    /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */\n    const ev = document.createEvent('Event')\n    ev.initEvent('storage', true, true)\n    ev.key = key\n    ev.newValue = value\n    window.dispatchEvent(ev)\n\n    resolve()\n  })\n}\n\nexport function addStorageEventListener (channelName, fn) {\n  const key = storageKey(channelName)\n  const listener = ev => {\n    if (ev.key === key) {\n      fn(JSON.parse(ev.newValue))\n    }\n  }\n  window.addEventListener('storage', listener)\n  return listener\n}\nexport function removeStorageEventListener (listener) {\n  window.removeEventListener('storage', listener)\n}\n\nexport function create (channelName, options = {}) {\n  if (!canBeUsed()) {\n    /* istanbul ignore next */\n    throw new Error('❌ localStorage cannot be used.')\n  }\n\n  const uuid = randomToken()\n\n  /**\n     * eMIs\n     * contains all messages that have been emitted before\n     * @type {ObliviousSet}\n     */\n  const eMIs = new ObliviousSet(options.removeTimeout)\n\n  const state = {\n    channelName,\n    uuid,\n    eMIs // emittedMessagesIds\n  }\n\n  state.listener = addStorageEventListener(\n    channelName,\n    (msgObj) => {\n      if (!state.messagesCallback) return // no listener\n      if (msgObj.uuid === uuid) return // own message\n      if (!msgObj.token || eMIs.has(msgObj.token)) return // already emitted\n      if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return // too old\n\n      eMIs.add(msgObj.token)\n      state.messagesCallback(msgObj.data)\n    }\n  )\n\n  return state\n}\n\nexport function close (channelState) {\n  removeStorageEventListener(channelState.listener)\n}\n\nexport function onMessage (channelState, fn, time) {\n  channelState.messagesCallbackTime = time\n  channelState.messagesCallback = fn\n}\n\nexport function canBeUsed () {\n  const ls = getLocalStorage()\n\n  if (!ls) return false\n\n  try {\n    const key = '__check'\n    ls.setItem(key, 'works')\n    ls.removeItem(key)\n  } catch (e) {\n    // Safari 10 in private mode will not allow write access to local\n    // storage and fail with a QuotaExceededError. See\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\n\n    /* istanbul ignore next */\n    return false\n  }\n\n  return true\n}\n\n/* istanbul ignore next */\nexport function averageResponseTime () {\n  const defaultTime = 120\n  const userAgent = navigator.userAgent.toLowerCase()\n  if (userAgent.includes('safari') && !userAgent.includes('chrome')) {\n    // safari is much slower so this time is higher\n    return defaultTime * 2\n  }\n  return defaultTime\n}\n\nexport default {\n  create,\n  close,\n  onMessage,\n  postMessage,\n  canBeUsed,\n  type,\n  averageResponseTime,\n  microSeconds\n}\n","import { microSeconds } from '../../utils'\n\nexport const type = 'simulate'\n\nconst SIMULATE_CHANNELS = new Set()\n\nexport function create (channelName) {\n  const state = {\n    name: channelName,\n    messagesCallback: null\n  }\n  SIMULATE_CHANNELS.add(state)\n\n  return state\n}\n\nexport function close (channelState) {\n  SIMULATE_CHANNELS.delete(channelState)\n}\n\nexport function postMessage (channelState, messageJson) {\n  return new Promise(resolve => setTimeout(() => {\n    const channelArray = Array.from(SIMULATE_CHANNELS)\n    channelArray\n      .filter(channel => channel.name === channelState.name)\n      .filter(channel => channel !== channelState)\n      .filter(channel => !!channel.messagesCallback)\n      .forEach(channel => channel.messagesCallback(messageJson))\n    resolve()\n  }, 5))\n}\n\nexport function onMessage (channelState, fn) {\n  channelState.messagesCallback = fn\n}\n\n/* istanbul ignore next */\nexport function canBeUsed () {\n  return true\n}\n\n/* istanbul ignore next */\nexport function averageResponseTime () {\n  return 5\n}\n\nexport default {\n  create,\n  close,\n  onMessage,\n  postMessage,\n  canBeUsed,\n  type,\n  averageResponseTime,\n  microSeconds\n}\n","import BroadcastChannelMethod from './methods/broadcastChannel'\nimport LocalStorageMethod from './methods/localStorage'\nimport SimulateMethod from './methods/simulate'\n\n// Order is important\nconst METHODS = [\n  BroadcastChannelMethod,\n  LocalStorageMethod\n]\n\nexport function chooseMethod (options = {}) {\n  if (options.type) {\n    // For testing\n    if (options.type === 'simulate') {\n      return SimulateMethod\n    }\n\n    // Chosen type\n    const method = METHODS.find(m => m.type === options.type)\n    if (!method) throw new Error(`❌ Method ${options.type} is not supported.`)\n    else return method\n  }\n\n  const useMethod = METHODS.find(method => method.canBeUsed())\n\n  /* istanbul ignore next */\n  if (!useMethod) {\n    throw new Error(`❌ No method found ${JSON.stringify(METHODS.map(m => m.type))}`)\n  }\n  return useMethod\n}\n","import { chooseMethod } from './methodChooser'\nimport { isPromise } from '../utils'\n\nexport class MessageChannel {\n  constructor (name, options = {}) {\n    this.name = name\n    this.options = options\n    this.method = chooseMethod(this.options)\n    this.closed = false\n\n    // isListening\n    this._isListening = false\n\n    /**\n     * _onMessageListener\n     * setting onmessage twice,\n     * will overwrite the first listener\n     */\n    this._onMessageListener = null\n\n    /**\n     * _addEventListeners\n     */\n    this._addEventListeners = {\n      message: [],\n      internal: []\n    }\n\n    /**\n     * Un send message promises\n     * where the sending is still in progress\n     * @type {Set<Promise>}\n     */\n    this._unSendMessagePromises = new Set()\n\n    /**\n     * _beforeClose\n     * array of promises that will be awaited\n     * before the channel is closed\n     */\n    this._beforeClose = []\n\n    /**\n     * _preparePromise\n     */\n    this._preparePromises = null\n    _prepareChannel(this)\n  }\n\n  postMessage (msg) {\n    if (this.closed) {\n      throw new Error(\n        '❌ Cannot post message after channel has closed'\n      )\n    }\n    return _post(this, 'message', msg)\n  }\n\n  postInternal (msg) {\n    return _post(this, 'internal', msg)\n  }\n\n  set onmessage (fn) {\n    const time = this.method.microSeconds()\n    const listenObj = {\n      time,\n      fn\n    }\n    _removeListenerObject(this, 'message', this._onMessageListener)\n    if (fn && typeof fn === 'function') {\n      this._onMessageListener = listenObj\n      _addListenerObject(this, 'message', listenObj)\n    } else {\n      /* istanbul ignore next */\n      this._onMessageListener = null\n    }\n  }\n\n  /* istanbul ignore next */\n  get onmessage () {\n    return this._onMessageListener\n  }\n\n  addEventListener (type, fn) {\n    const time = this.method.microSeconds()\n    const listenObj = {\n      time,\n      fn\n    }\n    _addListenerObject(this, type, listenObj)\n  }\n\n  removeEventListener (type, fn) {\n    const obj = this._addEventListeners[type].find(obj => obj.fn === fn)\n    _removeListenerObject(this, type, obj)\n  }\n\n  close () {\n    if (this.closed) {\n      return\n    }\n    this.closed = true\n    const awaitPrepare = this._preparePromises ? this._preparePromises : Promise.resolve()\n\n    this._onMessageListener = null\n    this._addEventListeners.message = []\n\n    return awaitPrepare\n      // Wait until all current sending are processed\n      .then(() => Promise.all(Array.from(this._unSendMessagePromises)))\n      // Run before-close hooks\n      .then(() => Promise.all(this._beforeClose.map(fn => fn())))\n      // Close the channel\n      .then(() => this.method.close(this._state))\n  }\n\n  get type () {\n    return this.method.type\n  }\n\n  isClosed () {\n    return this.closed\n  }\n}\n\nfunction _post (messageChannel, type, msg) {\n  const time = messageChannel.method.microSeconds()\n  const msgObj = {\n    time,\n    type,\n    data: msg\n  }\n\n  const awaitPrepare = messageChannel._preparePromises ? messageChannel._preparePromises : Promise.resolve()\n  return awaitPrepare.then(() => {\n    const sendPromise = messageChannel.method.postMessage(\n      messageChannel._state,\n      msgObj\n    )\n\n    // add/remove to un-send messages list\n    messageChannel._unSendMessagePromises.add(sendPromise)\n    sendPromise\n      .catch()\n      .then(() => messageChannel._unSendMessagePromises.delete(sendPromise))\n\n    return sendPromise\n  })\n}\n\nfunction _prepareChannel (channel) {\n  const maybePromise = channel.method.create(channel.name, channel.options)\n  /* istanbul ignore next */\n  if (isPromise(maybePromise)) {\n    channel._preparePromises = maybePromise\n    maybePromise.then(s => {\n      channel._state = s\n    })\n  } else {\n    channel._state = maybePromise\n  }\n}\n\nfunction _hasMessageListeners (channel) {\n  if (channel._addEventListeners.message.length > 0) return true\n  if (channel._addEventListeners.internal.length > 0) return true\n  return false\n}\n\nfunction _addListenerObject (channel, type, obj) {\n  channel._addEventListeners[type].push(obj)\n  _startListening(channel)\n}\n\nfunction _removeListenerObject (channel, type, obj) {\n  channel._addEventListeners[type] = channel._addEventListeners[type].filter(o => o !== obj)\n  _stopListening(channel)\n}\n\nfunction _startListening (channel) {\n  if (!channel._isListening && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n\n    const listenerFn = msgObj => {\n      channel._addEventListeners[msgObj.type].forEach(obj => {\n        if (msgObj.time >= obj.time) {\n          obj.fn(msgObj.data)\n        }\n      })\n    }\n\n    const time = channel.method.microSeconds()\n    if (channel._preparePromises) {\n      /* istanbul ignore next */\n      channel._preparePromises.then(() => {\n        channel._isListening = true\n        channel.method.onMessage(\n          channel._state,\n          listenerFn,\n          time\n        )\n      })\n    } else {\n      channel._isListening = true\n      channel.method.onMessage(\n        channel._state,\n        listenerFn,\n        time\n      )\n    }\n  }\n}\n\nfunction _stopListening (channel) {\n  if (channel._isListening && !_hasMessageListeners(channel)) {\n    // no one is listening, stop subscribing\n    channel._isListening = false\n    const time = channel.method.microSeconds()\n    channel.method.onMessage(\n      channel._state,\n      null,\n      time\n    )\n  }\n}\n","import { IS_BROWSER, sleep, randomToken } from '../utils'\n\nclass LeaderElection {\n  constructor (channel, options) {\n    this._channel = channel\n    this._options = options\n\n    this.isLeader = false\n    this.isDead = false\n    this.token = randomToken()\n\n    this._isApplying = false\n    this._reApply = false\n\n    // things to clean up\n    this._unloadFns = []\n    this._listeners = []\n    this._intervals = []\n    this._duplicateListeners = () => { }\n    this._duplicateCalled = false\n    this._onBeforeDie = async () => {}\n\n    const unloadFn = async () => this.die()\n\n    if (IS_BROWSER) {\n      window.addEventListener('beforeUnload', unloadFn)\n      window.addEventListener('unload', unloadFn)\n\n      this._unloadFns.push(['beforeUnload', unloadFn])\n      this._unloadFns.push(['unload', unloadFn])\n    }\n  }\n\n  applyOnce () {\n    if (this.isLeader) return Promise.resolve(false)\n    if (this.isDead) return Promise.resolve(false)\n\n    // do nothing if already running\n    if (this._isApplying) {\n      this._reApply = true\n      return Promise.resolve(false)\n    }\n    this._isApplying = true\n\n    let stopCriteria = false\n    const received = []\n\n    const handleMessage = (msg) => {\n      if (msg.context === 'leader' && msg.token !== this.token) {\n        received.push(msg)\n\n        if (msg.action === 'apply') {\n          // Other is applying\n          if (msg.token > this.token) {\n            // Other has higher token, stop applying\n            stopCriteria = true\n          }\n        }\n\n        if (msg.action === 'tell') {\n          // Other is already leader\n          stopCriteria = true\n        }\n      }\n    }\n    this._channel.addEventListener('internal', handleMessage)\n\n    return _sendMessage(this, 'apply') // send out that this one is applying\n      .then(() => sleep(this._options.responseTime)) // let others time to respond\n      .then(() => {\n        if (stopCriteria) return Promise.reject(new Error())\n        else return _sendMessage(this, 'apply')\n      })\n      .then(() => sleep(this._options.responseTime)) // let others time to respond\n      .then(() => {\n        if (stopCriteria) return Promise.reject(new Error())\n        else return _sendMessage(this)\n      })\n      .then(() => beLeader(this)) // no one disagreed -> this one is now leader\n      .then(() => true)\n      .catch(() => false) // apply not successful\n      .then(success => {\n        this._channel.removeEventListener('internal', handleMessage)\n        this._isApplying = false\n        if (!success && this._reApply) {\n          this._reApply = false\n          return this.applyOnce()\n        } else return success\n      })\n  }\n\n  awaitLeadership () {\n    if (\n      !this._awaitLeadershipPromise\n    ) {\n      this._awaitLeadershipPromise = _awaitLeadershipOnce(this)\n    }\n    return this._awaitLeadershipPromise\n  }\n\n  set onDuplicate (fn) {\n    this._duplicateListeners = fn\n  }\n\n  /* istanbul ignore next */\n  get onDuplicate () {\n    return this._duplicateListeners\n  }\n\n  set onBeforeDie (fn) {\n    this._onBeforeDie = fn\n  }\n\n  /* istanbul ignore next */\n  get onBeforeDie () {\n    return this._onBeforeDie\n  }\n\n  async die () {\n    if (this.isDead) return\n    this.isDead = true\n\n    await this.onBeforeDie()\n    this._listeners.forEach(listener => this._channel.removeEventListener('internal', listener))\n    this._intervals.forEach(interval => clearInterval(interval))\n    this._unloadFns.forEach(uFn => {\n      if (IS_BROWSER) {\n        window.removeEventListener(uFn[0], uFn[1])\n      }\n    })\n    return _sendMessage(this, 'death')\n  }\n}\n\nfunction _awaitLeadershipOnce (leaderElector) {\n  if (leaderElector.isLeader) return Promise.resolve()\n\n  return new Promise(resolve => {\n    let resolved = false\n\n    function finish () {\n      /* istanbul ignore next */\n      if (resolved) {\n        return\n      }\n      resolved = true\n      clearInterval(interval)\n      leaderElector._channel.removeEventListener('internal', whenDeathListener)\n      resolve(true)\n    }\n\n    // try once now\n    leaderElector.applyOnce().then(() => {\n      if (leaderElector.isLeader) {\n        finish()\n      }\n    })\n\n    // try on fallbackInterval\n    const interval = setInterval(() => {\n      /* istanbul ignore next */\n      leaderElector.applyOnce().then(() => {\n        if (leaderElector.isLeader) {\n          finish()\n        }\n      })\n    }, leaderElector._options.fallbackInterval)\n    leaderElector._intervals.push(interval)\n\n    // try when other leader dies\n    const whenDeathListener = msg => {\n      if (msg.context === 'leader' && msg.action === 'death') {\n        leaderElector.applyOnce().then(() => {\n          if (leaderElector.isLeader) finish()\n        })\n      }\n    }\n    leaderElector._channel.addEventListener('internal', whenDeathListener)\n    leaderElector._listeners.push(whenDeathListener)\n  })\n}\n\n/**\n * Sends and internal message over the broadcast-channel\n */\nfunction _sendMessage (leaderElector, action) {\n  const msgJson = {\n    context: 'leader',\n    action,\n    token: leaderElector.token\n  }\n  return leaderElector._channel.postInternal(msgJson)\n}\n\nexport function beLeader (leaderElector) {\n  leaderElector.isLeader = true\n\n  const isLeaderListener = msg => {\n    if (msg.context === 'leader' && msg.action === 'apply') {\n      _sendMessage(leaderElector, 'tell')\n    }\n\n    if (msg.context === 'leader' && msg.action === 'tell' && !leaderElector._duplicateCalled) {\n      /**\n       * Another instance is also leader!\n       * This can happen on rare events\n       * like when the CPU is at 100% for long time\n       * or the tabs are open very long and the browser throttles them.\n       */\n      leaderElector._duplicateCalled = true\n      leaderElector._duplicateListeners() // message the lib user so the app can handle the problem\n      _sendMessage(leaderElector, 'tell') // ensure other leader also knows the problem\n    }\n  }\n  leaderElector._channel.addEventListener('internal', isLeaderListener)\n  leaderElector._listeners.push(isLeaderListener)\n  return _sendMessage(leaderElector, 'tell')\n}\n\nexport function createLeaderElection (channel, options) {\n  if (channel._leaderElector) {\n    throw new Error('❌ MessageChannel already has a leader-elector')\n  }\n\n  const elector = new LeaderElection(channel, options)\n  channel._beforeClose.push(async () => elector.die())\n\n  channel._leaderElector = elector\n  return elector\n}\n","import { MessageChannel, createLeaderElection } from './MessageChannel'\nexport const TabManager = ({\n  type,\n  channelName,\n  fallbackInterval,\n  responseTime,\n  emitOnAllTabs,\n  callbacks,\n  start,\n  reset,\n  pause,\n  resume\n}) => {\n  const channel = new MessageChannel(channelName, { type })\n  const elector = createLeaderElection(channel, { fallbackInterval, responseTime })\n  const registry = {}\n\n  // Register self\n  registry[elector.token] = false\n\n  let leader = false\n  let allIdle = true\n\n  const isLeader = () => leader\n\n  elector.awaitLeadership().then(() => {\n    leader = true\n  })\n\n  channel.addEventListener('message', ([type, id]) => {\n    switch (type) {\n      case 'register':\n        registry[id] = false\n        break\n      case 'deregister':\n        delete registry[id]\n        break\n      case 'idle':\n        idle(id)\n        break\n      case 'active':\n        active(id)\n        break\n      case 'emitIdle':\n        callbacks.onIdle()\n        break\n      case 'emitActive':\n        callbacks.onActive()\n        break\n      case 'start':\n        start(true)\n        break\n      case 'reset':\n        reset(true)\n        break\n      case 'pause':\n        pause(true)\n        break\n      case 'resume':\n        resume(true)\n        break\n      default:\n        // no op\n    }\n  })\n\n  const setAllIdle = bool => {\n    allIdle = bool\n  }\n\n  const isAllIdle = () => allIdle\n\n  const idle = (id = elector.token) => {\n    registry[id] = true\n    const isIdle = Object.values(registry).every(v => v)\n    if (!allIdle && isIdle) {\n      allIdle = true\n      if (isLeader()) {\n        callbacks.onIdle()\n        if (emitOnAllTabs) send('emitIdle')\n      } else {\n        send('idle')\n      }\n    }\n  }\n\n  const active = (id = elector.token) => {\n    registry[id] = false\n    const isActive = Object.values(registry).some(v => !v)\n    if (allIdle && isActive) {\n      allIdle = false\n      if (isLeader()) {\n        callbacks.onActive()\n        if (emitOnAllTabs) send('emitActive')\n      } else {\n        send('active')\n      }\n    }\n  }\n\n  /* istanbul ignore next */\n  elector.onDuplicate = async () => await elector.die()\n  elector.onBeforeDie = async () => await send('deregister')\n\n  const send = async message => channel.postMessage([message, elector.token])\n\n  const close = async () => {\n    await elector.die()\n    await channel.close()\n  }\n\n  // Register self with remote tabs\n  send('register')\n\n  return { close, send, isLeader, idle, active, isAllIdle, setAllIdle }\n}\n","/**\n *  ___    _ _     _____ _\n * |_ _|__| | | __|_   _(_)_ __ ___   ___ _ __\n *  | |/ _` | |/ _ \\| | | | '_ ` _ \\ / _ \\ '__|\n *  | | (_| | |  __/| | | | | | | | |  __/ |\n * |___\\__,_|_|\\___||_| |_|_| |_| |_|\\___|_|\n *\n * @name IdleTimer\n * @author Randy Lebeau\n * @private\n */\n\nimport { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { TabManager } from './TabManager'\nimport { IS_BROWSER, DEFAULT_ELEMENT, DEFAULT_EVENTS, debounced, throttled } from './utils'\n\n/**\n * Detects when your user is idle\n * @class IdleTimer\n * @private\n */\nclass IdleTimer extends Component {\n  /**\n   * Creates an instance of IdleTimer\n   * bind all of our internal events here\n   * for best performance\n   * @param {Object} props\n   * @return {IdleTimer}\n   * @private\n   */\n  constructor (props) {\n    super(props)\n\n    /**\n     * Sets initial component state\n     * @type {Object}\n     * @private\n     */\n    this.state = {\n      idle: false,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      lastIdle: null,\n      idleTime: 0,\n      remaining: null,\n      pageX: null,\n      pageY: null\n    }\n\n    /**\n     * The timer instance\n     * @type {Timeout}\n     * @private\n     */\n    this.tId = null\n\n    /**\n     * Wether or not events are bound\n     * @type {boolean}\n     * @private\n     */\n    this.eventsBound = false\n\n    this.callbackRefs = {}\n\n    // Debounce and throttle can't both be set\n    if (props.debounce > 0 && props.throttle > 0) {\n      throw new Error('onAction can either be throttled or debounced (not both)')\n    }\n\n    // Create debounced action if applicable\n    if (props.debounce > 0) {\n      this._onAction = debounced(props.onAction, props.debounce)\n\n    // Create throttled action if applicable\n    } else if (props.throttle > 0) {\n      this._onAction = throttled(props.onAction, props.throttle)\n\n    // Set custom onAction\n    } else {\n      this._onAction = props.onAction\n    }\n\n    // Create a throttle event handler if applicable\n    if (props.eventsThrottle > 0) {\n      this.handleEvent = throttled(this._handleEvent.bind(this), props.eventsThrottle)\n    } else {\n      this.handleEvent = this._handleEvent.bind(this)\n    }\n\n    // If startOnMount is set, idle state defaults to true\n    if (!props.startOnMount || props.startManually) {\n      this.state.idle = true\n    }\n\n    // Bind all events to component scope, built for speed 🚀\n    this._toggleIdleState = this._toggleIdleState.bind(this)\n    this.start = this.start.bind(this)\n    this.reset = this.reset.bind(this)\n    this.pause = this.pause.bind(this)\n    this.resume = this.resume.bind(this)\n    this.isIdle = this.isIdle.bind(this)\n    this.getRemainingTime = this.getRemainingTime.bind(this)\n    this.getElapsedTime = this.getElapsedTime.bind(this)\n    this.getLastActiveTime = this.getLastActiveTime.bind(this)\n    this.getLastIdleTime = this.getLastIdleTime.bind(this)\n    this.getTotalIdleTime = this.getTotalIdleTime.bind(this)\n    this.getTotalActiveTime = this.getTotalActiveTime.bind(this)\n  }\n\n  /**\n   * Runs once the component has mounted\n   * here we handle automatically starting\n   * the idletimer\n   * @private\n   */\n  componentDidMount () {\n    const { startOnMount, startManually } = this.props\n\n    // Set up cross tab\n    this._setupTabManager()\n\n    if (startManually) return\n    if (startOnMount) {\n      this.start()\n    } else {\n      this._bindEvents()\n    }\n  }\n\n  componentDidUpdate (prevProps) {\n    // Update debounce function\n    if ((prevProps.debounce !== this.props.debounce) && this.props.debounce > 0) {\n      if (this._onAction.cancel) this._onAction.cancel()\n      this._onAction = debounced(this.props.onAction, this.props.debounce)\n    } else\n    // Update throttle function\n    if ((prevProps.throttle !== this.props.throttle) && this.props.throttle > 0) {\n      if (this._onAction.cancel) this._onAction.cancel()\n      this._onAction = throttled(this.props.onAction, this.props.throttle)\n    } else\n    // Remove throttle or debounce\n    if (\n      (prevProps.throttle && this.props.throttle === 0) ||\n      (prevProps.debounce && this.props.debounce === 0)\n    ) {\n      if (this._onAction.cancel) this._onAction.cancel()\n      this._onAction = this.props.onAction\n    }\n\n    // Update event throttle function\n    if (prevProps.eventsThrottle !== this.props.eventsThrottle) {\n      this._unbindEvents()\n      this.handleEvent = throttled(this._handleEvent.bind(this), this.props.eventsThrottle)\n      this._bindEvents()\n    }\n    // Update timeout value\n    if (prevProps.timeout !== this.props.timeout) {\n      if (this.state.idle) this.reset()\n    }\n\n    // Update callback refs\n    if (prevProps.onActive !== this.props.onActive) this.callbackRefs.onActive = this.props.onActive\n    if (prevProps.onIdle !== this.props.onIdle) this.callbackRefs.onIdle = this.props.onIdle\n  }\n\n  /**\n   * Called before the component un-mounts\n   * here we clear the timer and remove\n   * all the event listeners\n   * @private\n   */\n  componentWillUnmount () {\n    // Clear timeout to prevent delayed state changes\n    clearTimeout(this.tId)\n    this._unbindEvents(true)\n    // Cancel any debounced onAction handlers\n    if (this._onAction.cancel) this._onAction.cancel()\n    /* istanbul ignore next */\n    if (this.manager) {\n      this.manager.close().catch(console.error)\n    }\n  }\n\n  /**\n   * Render children if IdleTimer is used as a wrapper\n   * @return {Component} children\n   * @private\n   */\n  render () {\n    const { children } = this.props\n    return children || null\n  }\n\n  /**\n   * Setup the Tab Manager.\n   * @private\n   */\n  _setupTabManager () {\n    const { crossTab, onIdle, onActive } = this.props\n    this.callbackRefs = { onIdle, onActive }\n\n    /* istanbul ignore next */\n    if (crossTab) {\n      const {\n        type,\n        channelName,\n        fallbackInterval,\n        responseTime,\n        emitOnAllTabs\n      } = Object.assign({\n        channelName: 'idle-timer',\n        fallbackInterval: 2000,\n        responseTime: 100,\n        removeTimeout: 1000 * 60,\n        emitOnAllTabs: false\n      }, crossTab === true ? {} : crossTab)\n\n      this.manager = TabManager({\n        type,\n        channelName,\n        fallbackInterval,\n        responseTime,\n        emitOnAllTabs,\n        callbacks: this.callbackRefs,\n        start: this.start,\n        reset: this.reset,\n        pause: this.pause,\n        resume: this.resume\n      })\n    }\n  }\n\n  /**\n   * Binds the specified events\n   * @private\n   */\n  _bindEvents () {\n    // Don't bind events if\n    // we are not in a browser\n    if (!IS_BROWSER) return\n    // Otherwise we bind all the events\n    // to the supplied element\n    const { element, events, passive, capture } = this.props\n    if (!this.eventsBound) {\n      events.forEach(e => {\n        element.addEventListener(e, this.handleEvent, {\n          capture,\n          passive\n        })\n      })\n      this.eventsBound = true\n    }\n  }\n\n  /**\n   * Unbinds all the bound events\n   * @private\n   */\n  _unbindEvents (force = false) {\n    // If we are not in a browser\n    // we don't need to unbind events\n    if (!IS_BROWSER) return\n    // Unbind all events\n    const { element, events, passive, capture } = this.props\n    if (this.eventsBound || force) {\n      events.forEach(e => {\n        element.removeEventListener(e, this.handleEvent, {\n          capture,\n          passive\n        })\n      })\n      this.eventsBound = false\n    }\n  }\n\n  /**\n   * Toggles the idle state and calls\n   * the correct action function\n   * @private\n   */\n  _toggleIdleState (e) {\n    // Fire the appropriate action\n    // and pass the event through\n    // Toggle the idle state\n    this.setState((prevState) => ({\n      idle: !prevState.idle,\n      lastIdle: !prevState.idle ? (+new Date()) - this.props.timeout : prevState.lastIdle,\n      idleTime: prevState.idle ? prevState.idleTime + (+new Date()) - prevState.lastIdle : prevState.idleTime\n    }), () => {\n      const { onActive, onIdle, stopOnIdle } = this.props\n      const { idle } = this.state\n      if (idle) {\n        if (stopOnIdle) {\n          // Clear any existing timeout\n          clearTimeout(this.tId)\n          this.tId = null\n          // Unbind events\n          this._unbindEvents()\n        }\n\n        if (this.manager) {\n          /* istanbul ignore next */\n          this.manager.idle()\n        } else {\n          onIdle(e)\n        }\n      } else {\n        this._bindEvents()\n        if (this.manager) {\n          /* istanbul ignore next */\n          this.manager.active()\n        } else {\n          onActive(e)\n        }\n      }\n    })\n  }\n\n  /**\n   * Event handler for supported event types\n   * @param  {Object} e event object\n   * @private\n   */\n  _handleEvent (e) {\n    const { remaining, pageX, pageY, idle } = this.state\n    const { timeout, stopOnIdle } = this.props\n\n    // Fire onAction event\n    this._onAction(e)\n\n    // Already active, ignore events\n    if (remaining) return\n\n    // Mousemove event\n    if (e.type === 'mousemove') {\n      // If coords are same, it didn't move\n      /* istanbul ignore next */\n      if (e.pageX === pageX && e.pageY === pageY) {\n        return\n      }\n      // If coords don't exist how could it move\n      if (typeof e.pageX === 'undefined' && typeof e.pageY === 'undefined') {\n        return\n      }\n      // Under 200 ms is hard to do\n      // continuous activity will bypass this\n      /* istanbul ignore next */\n      const elapsed = this.getElapsedTime()\n      /* istanbul ignore next */\n      if (elapsed < 200) {\n        return\n      }\n    }\n\n    // Clear any existing timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Determine last time User was active, as can't rely on setTimeout ticking at the correct interval\n    const elapsedTimeSinceLastActive = +new Date() - this.getLastActiveTime()\n\n    // If the user is idle or last active time is more than timeout, flip the idle state\n    if ((idle && !stopOnIdle) || (!idle && elapsedTimeSinceLastActive > timeout)) {\n      this._toggleIdleState(e)\n    }\n\n    // Store when the user was last active\n    // and update the mouse coordinates\n    this.setState({\n      lastActive: +new Date(),\n      pageX: e.pageX,\n      pageY: e.pageY\n    })\n\n    // If the user is idle and stopOnIdle flag is not set\n    // set a new timeout\n    if (idle) {\n      if (!stopOnIdle) {\n        this.tId = setTimeout(this._toggleIdleState, timeout)\n      }\n    } else {\n      this.tId = setTimeout(this._toggleIdleState, timeout)\n    }\n  }\n\n  /**\n   * Set initial state and start timer\n   * @name start\n   */\n  start (remote = true) {\n    // Clear timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Bind the events\n    this._bindEvents()\n\n    // Reset state\n    this.setState({\n      idle: false,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      remaining: null\n    })\n\n    if (this.manager) {\n      /* istanbul ignore next */\n      this.manager.setAllIdle(false)\n      /* istanbul ignore next */\n      if (!remote && this.props.crossTab.emitOnAllTabs) {\n        this.manager.send('start')\n      }\n    }\n\n    // Set new timeout\n    const { timeout } = this.props\n    this.tId = setTimeout(this._toggleIdleState, timeout)\n  }\n\n  /**\n   * Restore initial state and restart timer, calling onActive\n   * @name reset\n   */\n  reset (remote = false) {\n    // Clear timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Bind the events\n    this._bindEvents()\n\n    if (this.state.idle) {\n      if (this.manager) {\n        /* istanbul ignore next */\n        this.manager.active()\n      } else {\n        this.props.onActive()\n      }\n    }\n\n    if (this.manager) {\n      /* istanbul ignore next */\n      this.manager.setAllIdle(false)\n      /* istanbul ignore next */\n      if (!remote && this.props.crossTab.emitOnAllTabs) {\n        this.manager.send('reset')\n      }\n    }\n\n    // Reset state\n    this.setState({\n      idle: false,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      remaining: null\n    })\n\n    // Set new timeout\n    const { timeout } = this.props\n    this.tId = setTimeout(this._toggleIdleState, timeout)\n  }\n\n  /**\n   * Store remaining time and stop timer\n   * @name pause\n   */\n  pause (remote = false) {\n    // Timer is already paused\n    const { remaining } = this.state\n    if (remaining !== null) return\n\n    // Unbind events\n    this._unbindEvents()\n\n    // Clear existing timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Send event to other tabs\n    if (this.manager) {\n      /* istanbul ignore next */\n      if (!remote && this.props.crossTab.emitOnAllTabs) {\n        this.manager.send('pause')\n      }\n    }\n\n    // Define how much is left on the timer\n    this.setState({\n      remaining: this.getRemainingTime()\n    })\n  }\n\n  /**\n   * Resumes a paused timer\n   * @name resume\n   */\n  resume (remote = false) {\n    // Timer is not paused\n    const { remaining, idle } = this.state\n    if (remaining === null) return\n\n    // Bind events\n    this._bindEvents()\n\n    // Send event to other tabs\n    if (this.manager) {\n      /* istanbul ignore next */\n      if (!remote && this.props.crossTab.emitOnAllTabs) {\n        this.manager.send('resume')\n      }\n    }\n\n    // Start timer and clear remaining\n    // if we are in the active state\n    if (!idle) {\n      // Set a new timeout\n      this.tId = setTimeout(this._toggleIdleState, remaining)\n      // Set new state\n      this.setState({ remaining: null, lastActive: +new Date() })\n    }\n  }\n\n  /**\n   * Time remaining before idle\n   * @name getRemainingTime\n   * @return {number} Milliseconds remaining\n   */\n  getRemainingTime () {\n    const { remaining, lastActive } = this.state\n    const { timeout } = this.props\n\n    // If idle there is no time remaining\n    if (remaining !== null) {\n      return remaining < 0 ? 0 : remaining\n    }\n\n    // Determine remaining, if negative idle didn't finish flipping, just return 0\n    const timeLeft = timeout - ((+new Date()) - lastActive)\n    return timeLeft < 0 ? 0 : timeLeft\n  }\n\n  /**\n   * How much time has elapsed\n   * @name getElapsedTime\n   * @return {Timestamp}\n   */\n  getElapsedTime () {\n    const { oldDate } = this.state\n    return (+new Date()) - oldDate\n  }\n\n  /**\n   * Last time the user was idle\n   * @name getLastIdleTime\n   * @return {Timestamp}\n   */\n  getLastIdleTime () {\n    const { lastIdle } = this.state\n    return lastIdle\n  }\n\n  /**\n   * Total time the user was idle\n   * @name getTotalIdleTime\n   * @return {number}\n   */\n  getTotalIdleTime () {\n    const { idle, lastIdle, idleTime } = this.state\n    if (idle) {\n      return ((+new Date()) - lastIdle) + idleTime\n    } else {\n      return idleTime\n    }\n  }\n\n  /**\n   * Last time the user was active\n   * @name getLastActiveTime\n   * @return {Timestamp}\n   */\n  getLastActiveTime () {\n    const { lastActive } = this.state\n    return lastActive\n  }\n\n  /**\n   * Total time the user was active\n   * @name getTotalActiveTime\n   * @return {number}\n   */\n  getTotalActiveTime () {\n    return this.getElapsedTime() - this.getTotalIdleTime()\n  }\n\n  /**\n   * Returns wether or not the user is idle\n   * @name isIdle\n   * @return {boolean}\n   */\n  isIdle () {\n    const { idle } = this.state\n    return idle\n  }\n\n  /**\n   * Returns wether or not this is the leader tab\n   * @name isLeader\n   * @return {boolean}\n   */\n  isLeader () {\n    return this.manager ? this.manager.isLeader() : true\n  }\n}\n\n/**\n * Type checks for every property\n * @type {Object}\n * @private\n */\nIdleTimer.propTypes = {\n  /**\n   * Activity Timeout in milliseconds\n   * default: 1200000\n   * @type {Number}\n   */\n  timeout: PropTypes.number,\n  /**\n   * DOM events to listen to\n   * default: see [default events](https://github.com/SupremeTechnopriest/react-idle-timer#default-events)\n   * @type {Array}\n   */\n  events: PropTypes.arrayOf(PropTypes.string),\n  /**\n   * Function to call when user is idle\n   * default: () => {}\n   * @type {Function}\n   */\n  onIdle: PropTypes.func,\n  /**\n   * Function to call when user becomes active\n   * default: () => {}\n   * @type {Function}\n   */\n  onActive: PropTypes.func,\n  /**\n   * Function to call on user actions\n   * default: () => {}\n   * @type {Function}\n   */\n  onAction: PropTypes.func,\n  /**\n   * Debounce the onAction function by setting delay in milliseconds\n   * default: 0\n   * @type {Number}\n   */\n  debounce: PropTypes.number,\n  /**\n   * Throttle the onAction function by setting delay in milliseconds\n   * default: 0\n   * @type {Number}\n   */\n  throttle: PropTypes.number,\n  /**\n   * Throttle the event handler function by setting delay in milliseconds\n   * default: 200\n   * @type {Number}\n   */\n  eventsThrottle: PropTypes.number,\n  /**\n   * Element reference to bind activity listeners to\n   * default: document\n   * @type {Object}\n   */\n  element: PropTypes.oneOfType([PropTypes.object, PropTypes.element]),\n  /**\n   * Start the timer on mount\n   * default: true\n   * @type {Boolean}\n   */\n  startOnMount: PropTypes.bool,\n  /**\n   * Require the timer to be started manually.\n   * default: false\n   * @type {Boolean}\n   */\n  startManually: PropTypes.bool,\n  /**\n   * Once the user goes idle the IdleTimer will not\n   * reset on user input instead, reset() must be\n   * called manually to restart the timer\n   * default: false\n   * @type {Boolean}\n   */\n  stopOnIdle: PropTypes.bool,\n  /**\n   * Bind events passively\n   * default: true\n   * @type {Boolean}\n   */\n  passive: PropTypes.bool,\n  /**\n   * Capture events\n   * default: true\n   * @type {Boolean}\n   */\n  capture: PropTypes.bool,\n  /**\n   * Cross Tab functionality.\n   * default: false\n   * @type {Boolean|Object}\n   */\n  crossTab: PropTypes.oneOfType([\n    PropTypes.bool,\n    PropTypes.shape({\n      type: PropTypes.oneOf(['broadcastChannel', 'localStorage', 'simulate']),\n      channelName: PropTypes.string,\n      fallbackInterval: PropTypes.number,\n      responseTime: PropTypes.number,\n      removeTimeout: PropTypes.number,\n      emitOnAllTabs: PropTypes.bool\n    })\n  ])\n}\n\n/**\n * Sets default property values\n * @type {Object}\n * @private\n */\nIdleTimer.defaultProps = {\n  timeout: 1000 * 60 * 20,\n  element: DEFAULT_ELEMENT,\n  events: DEFAULT_EVENTS,\n  onIdle: () => { },\n  onActive: () => { },\n  onAction: () => { },\n  debounce: 0,\n  throttle: 0,\n  eventsThrottle: 200,\n  startOnMount: true,\n  startManually: false,\n  stopOnIdle: false,\n  capture: true,\n  passive: true,\n  crossTab: false\n}\n\nexport default IdleTimer\n","/**\n *  ___    _ _     _____ _\n * |_ _|__| | | __|_   _(_)_ __ ___   ___ _ __\n *  | |/ _` | |/ _ \\| | | | '_ ` _ \\ / _ \\ '__|\n *  | | (_| | |  __/| | | | | | | | |  __/ |\n * |___\\__,_|_|\\___||_| |_|_| |_| |_|\\___|_|\n *\n * @name useIdleTimer\n * @author Randy Lebeau\n * @private\n */\n\nimport { useEffect, useRef, useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport { TabManager } from './TabManager'\nimport { IS_BROWSER, DEFAULT_ELEMENT, DEFAULT_EVENTS, debounced, throttled } from './utils'\n\n/**\n * Detects when your user is idle\n * @function useIdleTimer\n * @private\n */\nfunction useIdleTimer ({\n  timeout = 1000 * 60 * 20,\n  element = DEFAULT_ELEMENT,\n  events = DEFAULT_EVENTS,\n  onIdle = () => { },\n  onActive = () => { },\n  onAction = () => { },\n  debounce = 0,\n  throttle = 0,\n  eventsThrottle = 200,\n  startOnMount = true,\n  startManually = false,\n  stopOnIdle = false,\n  capture = true,\n  passive = true,\n  crossTab = false\n} = {}) {\n  const eventsBound = useRef(false)\n  const idle = useRef(true)\n  const oldDate = useRef(+new Date())\n  const remaining = useRef(null)\n  const pageX = useRef(null)\n  const pageY = useRef(null)\n  const tId = useRef(null)\n  const lastActive = useRef(null)\n  const lastIdle = useRef(null)\n  const idleTime = useRef(0)\n  const firstLoad = useRef(true)\n  const _timeout = useRef(timeout)\n  const manager = useRef(null)\n\n  /* istanbul ignore next */\n  if (crossTab) {\n    if (crossTab === true) crossTab = {}\n    crossTab = Object.assign({\n      channelName: 'idle-timer',\n      fallbackInterval: 2000,\n      responseTime: 100,\n      removeTimeout: 1000 * 60,\n      emitOnAllTabs: false\n    }, crossTab)\n  }\n\n  // Event emitters\n  const emitOnIdle = useRef(onIdle)\n  const emitOnActive = useRef(onActive)\n  const emitOnAction = useRef(onAction)\n\n  useEffect(() => {\n    emitOnIdle.current = onIdle\n  }, [onIdle])\n\n  useEffect(() => {\n    emitOnActive.current = onActive\n  }, [onActive])\n\n  useEffect(() => {\n    emitOnAction.current = onAction\n  }, [onAction])\n\n  const intermediateOnAction = useMemo(() => {\n    function callOnAction (e) {\n      emitOnAction.current(e)\n    }\n\n    // Cancel any existing debounce timeouts\n    if (callOnAction.cancel) callOnAction.cancel()\n\n    // Create debounced action if applicable\n    if (debounce > 0) {\n      return debounced(callOnAction, debounce)\n\n      // Create throttled action if applicable\n    } else if (throttle > 0) {\n      return throttled(callOnAction, throttle)\n\n      // No throttle or debounce\n    } else {\n      return callOnAction\n    }\n  }, [throttle, debounce])\n\n  /**\n   * Toggles the idle state and calls\n   * the correct action function\n   * @private\n   */\n  const _toggleIdleState = e => {\n    const nextIdle = !idle.current\n    idle.current = nextIdle\n    if (nextIdle) {\n      if (stopOnIdle) {\n        // Clear any existing timeout\n        clearTimeout(tId.current)\n        tId.current = null\n        // Unbind events\n        _unbindEvents()\n      }\n      lastIdle.current = (+new Date()) - _timeout.current\n      if (manager.current) {\n        /* istanbul ignore next */\n        manager.current.idle()\n      } else {\n        emitOnIdle.current(e)\n      }\n    } else {\n      idleTime.current += (+new Date()) - lastIdle.current\n      _bindEvents()\n      if (manager.current) {\n        /* istanbul ignore next */\n        manager.current.active()\n      } else {\n        emitOnActive.current(e)\n      }\n    }\n  }\n\n  /**\n   * Event handler\n   * @param {Event} e\n   */\n  const _handleEvent = e => {\n    // Fire onAction event\n    intermediateOnAction(e)\n\n    // Already active, ignore events\n    if (remaining.current) return\n\n    // Mousemove event\n    /* istanbul ignore next */\n    if (e.type === 'mousemove') {\n      // If coords are same, it didn't move\n      if (e.pageX === pageX && e.pageY === pageY) {\n        return\n      }\n      // If coords don't exist how could it move\n      if (typeof e.pageX === 'undefined' && typeof e.pageY === 'undefined') {\n        return\n      }\n      // Under 200 ms is hard to do\n      // continuous activity will bypass this\n      const elapsed = getElapsedTime()\n      if (elapsed < 200) {\n        return\n      }\n    }\n\n    // Clear any existing timeout\n    clearTimeout(tId.current)\n    tId.current = null\n\n    // Determine last time User was active, as can't rely on setTimeout ticking at the correct interval\n    const elapsedTimeSinceLastActive = +new Date() - getLastActiveTime()\n\n    // If the user is idle or last active time is more than timeout, flip the idle state\n    if (\n      (idle.current && !stopOnIdle) ||\n      (!idle.current && elapsedTimeSinceLastActive > _timeout.current)\n    ) {\n      _toggleIdleState(e)\n    }\n\n    // Store when the user was last active\n    // and update the mouse coordinates\n    lastActive.current = +new Date()\n    pageX.current = e.pageX\n    pageY.current = e.pageY\n\n    // If the user is active, set a new timeout\n    if (!idle.current) {\n      tId.current = setTimeout(_toggleIdleState, _timeout.current)\n    }\n  }\n\n  /**\n   * Reference to current handleEvent function.\n   * @private\n   */\n  const handleEvent = useRef(_handleEvent)\n\n  /**\n   * Binds the specified events\n   * @private\n   */\n  const _bindEvents = () => {\n    // Don't bind events if\n    // we are not in a browser\n    if (!IS_BROWSER) return\n    // Otherwise we bind all the events\n    // to the supplied element\n    if (!eventsBound.current) {\n      events.forEach(e => {\n        element.addEventListener(e, handleEvent.current, {\n          capture,\n          passive\n        })\n      })\n      eventsBound.current = true\n    }\n  }\n\n  /**\n   * Unbinds all the bound events\n   * @private\n   */\n  const _unbindEvents = (force = false) => {\n    // If we are not in a browser\n    // we don't need to unbind events\n    if (!IS_BROWSER) return\n    // Unbind all events\n    if (eventsBound.current || force) {\n      events.forEach(e => {\n        element.removeEventListener(e, handleEvent.current, {\n          capture,\n          passive\n        })\n      })\n      eventsBound.current = false\n    }\n  }\n\n  /**\n   * Time remaining before idle\n   * @name getRemainingTime\n   * @return {number} Milliseconds remaining\n   */\n  const getRemainingTime = () => {\n    // If idle there is no time remaining\n    if (remaining.current !== null) {\n      return remaining.current < 0 ? 0 : remaining.current\n    }\n\n    // Determine remaining, if negative idle didn't finish flipping, just return 0\n    const timeLeft = _timeout.current - ((+new Date()) - lastActive.current)\n    return timeLeft < 0 ? 0 : timeLeft\n  }\n\n  /**\n   * How much time has elapsed\n   * @name getElapsedTime\n   * @return {Timestamp}\n   */\n  const getElapsedTime = () => (+new Date()) - oldDate.current\n\n  /**\n   * Last time the user was idle\n   * @name getLastIdleTime\n   * @return {Timestamp}\n   */\n  const getLastIdleTime = () => lastIdle.current\n\n  /**\n   * Get the total time user is idle\n   * @name getTotalIdleTime\n   * @return {number} Milliseconds idle\n   */\n  const getTotalIdleTime = () => {\n    if (idle.current) {\n      return ((+new Date()) - lastIdle.current) + idleTime.current\n    } else {\n      return idleTime.current\n    }\n  }\n\n  /**\n   * Last time the user was active\n   * @name getLastActiveTime\n   * @return {Timestamp}\n   */\n  const getLastActiveTime = () => lastActive.current\n\n  /**\n   * Get the total time user is active\n   * @name getTotalActiveTime\n   * @return {number} Milliseconds active\n   */\n  const getTotalActiveTime = () => getElapsedTime() - getTotalIdleTime()\n\n  /**\n   * Returns wether or not the user is idle\n   * @name isIdle\n   * @return {Boolean}\n   */\n  const isIdle = () => idle.current\n\n  /**\n   * Returns wether or not this is the leader tab\n   * @returns {Boolean}\n   */\n  const isLeader = () => manager.current ? manager.current.isLeader() : true\n\n  /**\n  * Set initial state and start timer\n  * @name reset\n  */\n  const start = (remote = false) => {\n    // Clear timeout\n    clearTimeout(tId.current)\n    tId.current = null\n\n    // Bind the events\n    _bindEvents()\n\n    // Set state\n    idle.current = false\n    oldDate.current = +new Date()\n    lastActive.current = +new Date()\n    remaining.current = null\n\n    if (manager.current) {\n      /* istanbul ignore next */\n      manager.current.setAllIdle(false)\n      /* istanbul ignore next */\n      if (!remote && crossTab.emitOnAllTabs) {\n        manager.current.send('start')\n      }\n    }\n\n    // Set new timeout\n    tId.current = setTimeout(_toggleIdleState, _timeout.current)\n  }\n\n  /**\n  * Restore initial state and restart timer, calling onActive\n  * @name reset\n  */\n  const reset = (remote = false) => {\n    // Clear timeout\n    clearTimeout(tId.current)\n    tId.current = null\n\n    // Bind the events\n    _bindEvents()\n\n    // Emit active\n    if (idle.current) {\n      if (manager.current) {\n        /* istanbul ignore next */\n        manager.current.active()\n      } else {\n        emitOnActive.current()\n      }\n    }\n\n    // Reset state\n    idle.current = false\n    oldDate.current = +new Date()\n    lastActive.current = +new Date()\n    remaining.current = null\n\n    if (manager.current) {\n      /* istanbul ignore next */\n      manager.current.setAllIdle(false)\n      /* istanbul ignore next */\n      if (!remote && crossTab.emitOnAllTabs) {\n        manager.current.send('reset')\n      }\n    }\n\n    // Set new timeout\n    tId.current = setTimeout(_toggleIdleState, _timeout.current)\n  }\n\n  /**\n   * Store remaining time and stop timer\n   * @name pause\n   */\n  const pause = (remote = false) => {\n    // Timer is already paused\n    if (remaining.current !== null) return\n\n    // Unbind events\n    _unbindEvents()\n\n    // Clear existing timeout\n    clearTimeout(tId.current)\n    tId.current = null\n\n    // Define how much is left on the timer\n    remaining.current = getRemainingTime()\n\n    if (manager.current) {\n      /* istanbul ignore next */\n      if (!remote && crossTab.emitOnAllTabs) {\n        manager.current.send('pause')\n      }\n    }\n  }\n\n  /**\n   * Resumes a paused timer\n   * @name resume\n   */\n  const resume = (remote = false) => {\n    // Timer is not paused\n    if (remaining.current === null) return\n\n    // Bind events\n    _bindEvents()\n\n    // Start timer and clear remaining\n    // if we are in the idle state\n    if (!idle.current) {\n      // Set a new timeout\n      tId.current = setTimeout(_toggleIdleState, remaining.current)\n      // Set states\n      remaining.current = null\n      lastActive.current = +new Date()\n    }\n\n    if (manager.current) {\n      /* istanbul ignore next */\n      if (!remote && crossTab.emitOnAllTabs) {\n        manager.current.send('resume')\n      }\n    }\n  }\n\n  /**\n   * Hook lifecycle\n   */\n  useEffect(() => {\n    // Debounce and throttle can't both be set\n    if (debounce > 0 && throttle > 0) {\n      throw new Error('onAction can either be throttled or debounced (not both)')\n    }\n\n    // Set up cross tab\n    /* istanbul ignore next */\n    if (crossTab) {\n      manager.current = TabManager({\n        type: crossTab.type,\n        channelName: crossTab.channelName,\n        fallbackInterval: crossTab.fallbackInterval,\n        responseTime: crossTab.responseTime,\n        emitOnAllTabs: crossTab.emitOnAllTabs,\n        callbacks: {\n          onIdle: emitOnIdle.current,\n          onActive: emitOnActive.current\n        },\n        start,\n        reset,\n        pause,\n        resume\n      })\n    }\n\n    // If startOnMount is enabled, start the timer\n    if (startManually) {\n      return async () => {\n        clearTimeout(tId.current)\n        _unbindEvents(true)\n        if (crossTab) await manager.current.close()\n      }\n    }\n\n    if (startOnMount) {\n      start()\n    } else {\n      _bindEvents()\n    }\n\n    // Clear and unbind on unmount\n    return async () => {\n      clearTimeout(tId.current)\n      _unbindEvents(true)\n      if (intermediateOnAction.cancel) intermediateOnAction.cancel()\n      if (crossTab) await manager.current.close()\n    }\n  }, [])\n\n  useEffect(() => {\n    const eventsWereBound = eventsBound.current\n    if (eventsWereBound) _unbindEvents()\n    if (eventsThrottle > 0) {\n      handleEvent.current = throttled(_handleEvent, eventsThrottle)\n    } else {\n      handleEvent.current = _handleEvent\n    }\n    if (eventsWereBound) _bindEvents()\n  }, [eventsThrottle])\n\n  useEffect(() => {\n    _timeout.current = timeout\n    if (!firstLoad.current && idle.current) {\n      reset()\n    }\n    firstLoad.current = false\n  }, [timeout])\n\n  return {\n    isIdle,\n    isLeader,\n    start,\n    pause,\n    reset,\n    resume,\n    getLastIdleTime,\n    getTotalIdleTime,\n    getLastActiveTime,\n    getTotalActiveTime,\n    getElapsedTime,\n    getRemainingTime\n  }\n}\n\n/**\n * Type checks for every property\n * @type {Object}\n * @private\n */\nuseIdleTimer.propTypes = {\n  /**\n   * Activity Timeout in milliseconds\n   * default: 1200000\n   * @type {number}\n   */\n  timeout: PropTypes.number,\n  /**\n   * DOM events to listen to\n   * default: see [default events](https://github.com/SupremeTechnopriest/react-idle-timer#default-events)\n   * @type {Array}\n   */\n  events: PropTypes.arrayOf(PropTypes.string),\n  /**\n   * Function to call when user is idle.\n   * default: () => {}\n   * @type {Function}\n   */\n  onIdle: PropTypes.func,\n  /**\n   * Function to call when user becomes active.\n   * default: () => {}\n   * @type {Function}\n   */\n  onActive: PropTypes.func,\n  /**\n   * Function to call on user actions.\n   * default: () => {}\n   * @type {Function}\n   */\n  onAction: PropTypes.func,\n  /**\n   * Debounce the onAction function by setting delay in milliseconds.\n   * default: 0\n   * @type {number}\n   */\n  debounce: PropTypes.number,\n  /**\n   * Throttle the onAction function by setting delay in milliseconds.\n   * default: 0\n   * @type {number}\n   */\n  throttle: PropTypes.number,\n  /**\n   * Throttle the event handler function by setting delay in milliseconds.\n   * default: 200\n   * @type {number}\n   */\n  eventsThrottle: PropTypes.number,\n  /**\n   * Element reference to bind activity listeners to.\n   * default: document\n   * @type {Object}\n   */\n  element: PropTypes.oneOfType([PropTypes.object, PropTypes.element]),\n  /**\n   * Start the timer on mount.\n   * default: true\n   * @type {Boolean}\n   */\n  startOnMount: PropTypes.bool,\n  /**\n   * Require the timer to be started manually.\n   * default: false\n   * @type {Boolean}\n   */\n  startManually: PropTypes.bool,\n  /**\n   * Once the user goes idle the IdleTimer will not\n   * reset on user input instead, start() or reset() must be\n   * called manually to restart the timer.\n   * default: false\n   * @type {Boolean}\n   */\n  stopOnIdle: PropTypes.bool,\n  /**\n   * Bind events passively.\n   * default: true\n   * @type {Boolean}\n   */\n  passive: PropTypes.bool,\n  /**\n   * Capture events.\n   * default: true\n   * @type {Boolean}\n   */\n  capture: PropTypes.bool,\n  /**\n   * Cross Tab functionality.\n   * default: false\n   * @type {Boolean|Object}\n   */\n  crossTab: PropTypes.oneOfType([\n    PropTypes.bool,\n    PropTypes.shape({\n      type: PropTypes.oneOf(['broadcastChannel', 'localStorage', 'simulate']),\n      channelName: PropTypes.string,\n      fallbackInterval: PropTypes.number,\n      responseTime: PropTypes.number,\n      removeTimeout: PropTypes.number,\n      emitOnAllTabs: PropTypes.bool\n    })\n  ])\n}\n\n/**\n * Sets default property values\n * @type {Object}\n * @private\n */\nuseIdleTimer.defaultProps = {\n  timeout: 1000 * 60 * 20,\n  element: DEFAULT_ELEMENT,\n  events: DEFAULT_EVENTS,\n  onIdle: () => { },\n  onActive: () => { },\n  onAction: () => { },\n  debounce: 0,\n  throttle: 0,\n  eventsThrottle: 200,\n  startOnMount: true,\n  startManually: false,\n  stopOnIdle: false,\n  capture: true,\n  passive: true,\n  crossTab: false\n}\n\nexport default useIdleTimer\n"],"names":["IS_BROWSER","window","DEFAULT_ELEMENT","document","DEFAULT_EVENTS","debounced","fn","delay","timerId","result","args","clearTimeout","setTimeout","cancel","throttled","lastCall","now","Date","getTime","lastMs","additional","microSeconds","ms","randomToken","Math","random","toString","substring","sleep","time","Promise","resolve","create","channelName","state","messagesCallback","bc","BroadcastChannel","onmessage","msg","data","close","channelState","onMessage","postMessage","messageJson","err","reject","canBeUsed","type","averageResponseTime","ObliviousSet","ttl","set","Set","timeMap","Map","value","this","has","add","_removeTooOldValues","clear","olderThen","iterator","Symbol","next","get","getLocalStorage","localStorage","e","addStorageEventListener","key","listener","ev","JSON","parse","newValue","addEventListener","ls","setItem","removeItem","options","Error","uuid","eMIs","removeTimeout","msgObj","token","messagesCallbackTime","removeEventListener","writeObj","stringify","createEvent","initEvent","dispatchEvent","userAgent","navigator","toLowerCase","includes","defaultTime","SIMULATE_CHANNELS","name","Array","from","filter","channel","forEach","METHODS","BroadcastChannelMethod","LocalStorageMethod","chooseMethod","SimulateMethod","method","find","m","useMethod","map","MessageChannel","closed","_isListening","_onMessageListener","_addEventListeners","message","internal","_unSendMessagePromises","_beforeClose","_preparePromises","_prepareChannel","_post","listenObj","_removeListenerObject","_addListenerObject","obj","awaitPrepare","then","all","_this","_state","messageChannel","sendPromise","maybePromise","s","_hasMessageListeners","length","push","listenerFn","_startListening","o","_stopListening","LeaderElection","_channel","_options","isLeader","isDead","_isApplying","_reApply","_unloadFns","_listeners","_intervals","_duplicateListeners","_duplicateCalled","_onBeforeDie","unloadFn","die","stopCriteria","handleMessage","context","_this2","action","_sendMessage","responseTime","leaderElector","isLeaderListener","beLeader","success","applyOnce","_awaitLeadershipPromise","resolved","finish","clearInterval","interval","whenDeathListener","setInterval","fallbackInterval","onBeforeDie","_this3","uFn","msgJson","postInternal","TabManager","emitOnAllTabs","callbacks","start","reset","pause","resume","elector","_leaderElector","createLeaderElection","registry","leader","allIdle","awaitLeadership","id","idle","active","onIdle","onActive","isIdle","Object","values","every","v","send","isActive","some","onDuplicate","isAllIdle","setAllIdle","bool","IdleTimer","props","oldDate","lastActive","lastIdle","idleTime","remaining","pageX","pageY","tId","eventsBound","callbackRefs","debounce","throttle","_onAction","onAction","eventsThrottle","handleEvent","_handleEvent","bind","startOnMount","startManually","_toggleIdleState","getRemainingTime","getElapsedTime","getLastActiveTime","getLastIdleTime","getTotalIdleTime","getTotalActiveTime","_setupTabManager","_bindEvents","prevProps","_unbindEvents","timeout","manager","console","error","children","crossTab","assign","element","events","passive","capture","force","setState","prevState","_this4","stopOnIdle","elapsedTimeSinceLastActive","remote","timeLeft","Component","useIdleTimer","useRef","firstLoad","_timeout","emitOnIdle","emitOnActive","emitOnAction","useEffect","current","intermediateOnAction","useMemo","callOnAction","nextIdle","eventsWereBound","propTypes","PropTypes","number","arrayOf","string","func","oneOfType","object","shape","oneOf","defaultProps"],"mappings":"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"}