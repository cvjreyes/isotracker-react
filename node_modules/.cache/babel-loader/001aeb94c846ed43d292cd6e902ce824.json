{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { getWindowScrollLeft, getWindowScrollTop } from \"../../helpers/dom/element.mjs\";\n/**\r\n * Helper class for checking if element will fit at the desired side of cursor.\r\n *\r\n * @class Cursor\r\n * @plugin ContextMenu\r\n */\n\nvar Cursor = /*#__PURE__*/function () {\n  function Cursor(object, rootWindow) {\n    _classCallCheck(this, Cursor);\n\n    var windowScrollTop = getWindowScrollTop(rootWindow);\n    var windowScrollLeft = getWindowScrollLeft(rootWindow);\n    var top;\n    var topRelative;\n    var left;\n    var leftRelative;\n    var cellHeight;\n    var cellWidth;\n    this.rootWindow = rootWindow;\n    this.type = this.getSourceType(object);\n\n    if (this.type === 'literal') {\n      top = parseInt(object.top, 10);\n      left = parseInt(object.left, 10);\n      cellHeight = object.height || 0;\n      cellWidth = object.width || 0;\n      topRelative = top;\n      leftRelative = left;\n      top += windowScrollTop;\n      left += windowScrollLeft;\n    } else if (this.type === 'event') {\n      top = parseInt(object.pageY, 10);\n      left = parseInt(object.pageX, 10);\n      cellHeight = object.target.clientHeight;\n      cellWidth = object.target.clientWidth;\n      topRelative = top - windowScrollTop;\n      leftRelative = left - windowScrollLeft;\n    }\n\n    this.top = top;\n    this.topRelative = topRelative;\n    this.left = left;\n    this.leftRelative = leftRelative;\n    this.scrollTop = windowScrollTop;\n    this.scrollLeft = windowScrollLeft;\n    this.cellHeight = cellHeight;\n    this.cellWidth = cellWidth;\n  }\n  /**\r\n   * Get source type name.\r\n   *\r\n   * @param {*} object Event or Object with coordinates.\r\n   * @returns {string} Returns one of this values: `'literal'`, `'event'`.\r\n   */\n\n\n  _createClass(Cursor, [{\n    key: \"getSourceType\",\n    value: function getSourceType(object) {\n      var type = 'literal';\n\n      if (object instanceof Event) {\n        type = 'event';\n      }\n\n      return type;\n    }\n    /**\r\n     * Checks if element can be placed above the cursor.\r\n     *\r\n     * @param {HTMLElement} element Element to check if it's size will fit above the cursor.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"fitsAbove\",\n    value: function fitsAbove(element) {\n      return this.topRelative >= element.offsetHeight;\n    }\n    /**\r\n     * Checks if element can be placed below the cursor.\r\n     *\r\n     * @param {HTMLElement} element Element to check if it's size will fit below the cursor.\r\n     * @param {number} [viewportHeight] The viewport height.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"fitsBelow\",\n    value: function fitsBelow(element) {\n      var viewportHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.rootWindow.innerHeight;\n      return this.topRelative + element.offsetHeight <= viewportHeight;\n    }\n    /**\r\n     * Checks if element can be placed on the right of the cursor.\r\n     *\r\n     * @param {HTMLElement} element Element to check if it's size will fit on the right of the cursor.\r\n     * @param {number} [viewportWidth] The viewport width.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"fitsOnRight\",\n    value: function fitsOnRight(element) {\n      var viewportWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.rootWindow.innerWidth;\n      return this.leftRelative + this.cellWidth + element.offsetWidth <= viewportWidth;\n    }\n    /**\r\n     * Checks if element can be placed on the left on the cursor.\r\n     *\r\n     * @param {HTMLElement} element Element to check if it's size will fit on the left of the cursor.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"fitsOnLeft\",\n    value: function fitsOnLeft(element) {\n      return this.leftRelative >= element.offsetWidth;\n    }\n  }]);\n\n  return Cursor;\n}();\n\nexport default Cursor;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/plugins/contextMenu/cursor.mjs"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","getWindowScrollLeft","getWindowScrollTop","Cursor","object","rootWindow","windowScrollTop","windowScrollLeft","top","topRelative","left","leftRelative","cellHeight","cellWidth","type","getSourceType","parseInt","height","width","pageY","pageX","clientHeight","clientWidth","scrollTop","scrollLeft","value","Event","fitsAbove","element","offsetHeight","fitsBelow","viewportHeight","arguments","undefined","innerHeight","fitsOnRight","viewportWidth","innerWidth","offsetWidth","fitsOnLeft"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport { getWindowScrollLeft, getWindowScrollTop } from \"../../helpers/dom/element.mjs\";\r\n/**\r\n * Helper class for checking if element will fit at the desired side of cursor.\r\n *\r\n * @class Cursor\r\n * @plugin ContextMenu\r\n */\r\n\r\nvar Cursor = /*#__PURE__*/function () {\r\n  function Cursor(object, rootWindow) {\r\n    _classCallCheck(this, Cursor);\r\n\r\n    var windowScrollTop = getWindowScrollTop(rootWindow);\r\n    var windowScrollLeft = getWindowScrollLeft(rootWindow);\r\n    var top;\r\n    var topRelative;\r\n    var left;\r\n    var leftRelative;\r\n    var cellHeight;\r\n    var cellWidth;\r\n    this.rootWindow = rootWindow;\r\n    this.type = this.getSourceType(object);\r\n\r\n    if (this.type === 'literal') {\r\n      top = parseInt(object.top, 10);\r\n      left = parseInt(object.left, 10);\r\n      cellHeight = object.height || 0;\r\n      cellWidth = object.width || 0;\r\n      topRelative = top;\r\n      leftRelative = left;\r\n      top += windowScrollTop;\r\n      left += windowScrollLeft;\r\n    } else if (this.type === 'event') {\r\n      top = parseInt(object.pageY, 10);\r\n      left = parseInt(object.pageX, 10);\r\n      cellHeight = object.target.clientHeight;\r\n      cellWidth = object.target.clientWidth;\r\n      topRelative = top - windowScrollTop;\r\n      leftRelative = left - windowScrollLeft;\r\n    }\r\n\r\n    this.top = top;\r\n    this.topRelative = topRelative;\r\n    this.left = left;\r\n    this.leftRelative = leftRelative;\r\n    this.scrollTop = windowScrollTop;\r\n    this.scrollLeft = windowScrollLeft;\r\n    this.cellHeight = cellHeight;\r\n    this.cellWidth = cellWidth;\r\n  }\r\n  /**\r\n   * Get source type name.\r\n   *\r\n   * @param {*} object Event or Object with coordinates.\r\n   * @returns {string} Returns one of this values: `'literal'`, `'event'`.\r\n   */\r\n\r\n\r\n  _createClass(Cursor, [{\r\n    key: \"getSourceType\",\r\n    value: function getSourceType(object) {\r\n      var type = 'literal';\r\n\r\n      if (object instanceof Event) {\r\n        type = 'event';\r\n      }\r\n\r\n      return type;\r\n    }\r\n    /**\r\n     * Checks if element can be placed above the cursor.\r\n     *\r\n     * @param {HTMLElement} element Element to check if it's size will fit above the cursor.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"fitsAbove\",\r\n    value: function fitsAbove(element) {\r\n      return this.topRelative >= element.offsetHeight;\r\n    }\r\n    /**\r\n     * Checks if element can be placed below the cursor.\r\n     *\r\n     * @param {HTMLElement} element Element to check if it's size will fit below the cursor.\r\n     * @param {number} [viewportHeight] The viewport height.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"fitsBelow\",\r\n    value: function fitsBelow(element) {\r\n      var viewportHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.rootWindow.innerHeight;\r\n      return this.topRelative + element.offsetHeight <= viewportHeight;\r\n    }\r\n    /**\r\n     * Checks if element can be placed on the right of the cursor.\r\n     *\r\n     * @param {HTMLElement} element Element to check if it's size will fit on the right of the cursor.\r\n     * @param {number} [viewportWidth] The viewport width.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"fitsOnRight\",\r\n    value: function fitsOnRight(element) {\r\n      var viewportWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.rootWindow.innerWidth;\r\n      return this.leftRelative + this.cellWidth + element.offsetWidth <= viewportWidth;\r\n    }\r\n    /**\r\n     * Checks if element can be placed on the left on the cursor.\r\n     *\r\n     * @param {HTMLElement} element Element to check if it's size will fit on the left of the cursor.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"fitsOnLeft\",\r\n    value: function fitsOnLeft(element) {\r\n      return this.leftRelative >= element.offsetWidth;\r\n    }\r\n  }]);\r\n\r\n  return Cursor;\r\n}();\r\n\r\nexport default Cursor;"]},"metadata":{},"sourceType":"module"}