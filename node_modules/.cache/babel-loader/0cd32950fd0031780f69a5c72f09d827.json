{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport GlobalMeta from \"./metaLayers/globalMeta.mjs\";\nimport TableMeta from \"./metaLayers/tableMeta.mjs\";\nimport ColumnMeta from \"./metaLayers/columnMeta.mjs\";\nimport CellMeta from \"./metaLayers/cellMeta.mjs\";\n/**\n * With the Meta Manager class, it can be possible to manage with meta objects for different layers in\n * one place. All coordinates used to fetch, updating, removing, or creating rows or columns have to\n * be passed as physical values.\n *\n * The diagram of the meta layers:\n * +-------------+.\n * │ GlobalMeta  │\n * │ (prototype) │\n * +-------------+\\\n *       │         \\\n *       │          \\\n *      \\│/         _\\|\n * +-------------+    +-------------+.\n * │ TableMeta   │    │ ColumnMeta  │\n * │ (instance)  │    │ (prototype) │\n * +-------------+    +-------------+.\n *                         │\n *                         │\n *                        \\│/\n *                    +-------------+.\n *                    │  CellMeta   │\n *                    │ (instance)  │\n *                    +-------------+.\n *\n * A more detailed description of the specific layers can be found in the \"metaLayers/\" modules description.\n */\n\nvar MetaManager = /*#__PURE__*/function () {\n  function MetaManager() {\n    var customSettings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, MetaManager);\n    /**\n     * @type {GlobalMeta}\n     */\n\n\n    this.globalMeta = new GlobalMeta();\n    this.globalMeta.updateMeta(customSettings);\n    /**\n     * @type {TableMeta}\n     */\n\n    this.tableMeta = new TableMeta(this.globalMeta);\n    /**\n     * @type {ColumnMeta}\n     */\n\n    this.columnMeta = new ColumnMeta(this.globalMeta);\n    /**\n     * @type {CellMeta}\n     */\n\n    this.cellMeta = new CellMeta(this.columnMeta);\n  }\n  /**\n   * Gets the global meta object that is a root of all default settings, which are recognizable by Handsontable.\n   * Other layers inherites all properties from this. Adding, removing, or changing property in that\n   * object has a direct reflection to all layers.\n   *\n   * @returns {object}\n   */\n\n\n  _createClass(MetaManager, [{\n    key: \"getGlobalMeta\",\n    value: function getGlobalMeta() {\n      return this.globalMeta.getMeta();\n    }\n    /**\n     * Updates global settings object by merging settings with the current state.\n     *\n     * @param {object} settings An object to merge with.\n     */\n\n  }, {\n    key: \"updateGlobalMeta\",\n    value: function updateGlobalMeta(settings) {\n      this.globalMeta.updateMeta(settings);\n    }\n    /**\n     * Gets settings object that was passed in the Handsontable constructor. That layer contains all\n     * default settings inherited from the GlobalMeta layer merged with settings passed by the developer.\n     * Adding, removing, or changing property in that object has no direct reflection on any other layers.\n     *\n     * @returns {object}\n     */\n\n  }, {\n    key: \"getTableMeta\",\n    value: function getTableMeta() {\n      return this.tableMeta.getMeta();\n    }\n    /**\n     * Updates table settings object by merging settings with the current state.\n     *\n     * @param {object} settings An object to merge with.\n     */\n\n  }, {\n    key: \"updateTableMeta\",\n    value: function updateTableMeta(settings) {\n      this.tableMeta.updateMeta(settings);\n    }\n    /**\n     * Gets column meta object that is a root of all settings defined in the column property of the Handsontable\n     * settings. Each column in the Handsontable is associated with a unique meta object which identified by\n     * the physical column index. Adding, removing, or changing property in that object has a direct reflection\n     * only for the CellMeta layer. The reflection will be visible only if the property doesn't exist in the lower\n     * layers (prototype lookup).\n     *\n     * @param {number} physicalColumn The physical column index.\n     * @returns {object}\n     */\n\n  }, {\n    key: \"getColumnMeta\",\n    value: function getColumnMeta(physicalColumn) {\n      return this.columnMeta.getMeta(physicalColumn);\n    }\n    /**\n     * Updates column meta object by merging settings with the current state.\n     *\n     * @param {number} physicalColumn The physical column index which points what column meta object is updated.\n     * @param {object} settings An object to merge with.\n     */\n\n  }, {\n    key: \"updateColumnMeta\",\n    value: function updateColumnMeta(physicalColumn, settings) {\n      this.columnMeta.updateMeta(physicalColumn, settings);\n    }\n    /**\n     * Gets the cell meta object that is a root of all settings defined for the specific cell rendered by\n     * the Handsontable. Each cell meta inherits settings from higher layers. When a property doesn't\n     * exist in that layer, it is looked up through a prototype to the highest layer. Starting\n     * from CellMeta -> ColumnMeta and ending to GlobalMeta, which stores default settings. Adding,\n     * removing, or changing property in that object has no direct reflection on any other layers.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {string} [key] If the key exists its value will be returned, otherwise the whole cell meta object.\n     * @returns {object}\n     */\n\n  }, {\n    key: \"getCellMeta\",\n    value: function getCellMeta(physicalRow, physicalColumn, key) {\n      return this.cellMeta.getMeta(physicalRow, physicalColumn, key);\n    }\n    /**\n     * Sets settings object for cell meta object defined by \"key\" property.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {string} key The property name to set.\n     * @param {*} value Value to save.\n     */\n\n  }, {\n    key: \"setCellMeta\",\n    value: function setCellMeta(physicalRow, physicalColumn, key, value) {\n      this.cellMeta.setMeta(physicalRow, physicalColumn, key, value);\n    }\n    /**\n     * Updates cell meta object by merging settings with the current state.\n     *\n     * @param {number} physicalRow The physical row index which points what cell meta object is updated.\n     * @param {number} physicalColumn The physical column index which points what cell meta object is updated.\n     * @param {object} settings An object to merge with.\n     */\n\n  }, {\n    key: \"updateCellMeta\",\n    value: function updateCellMeta(physicalRow, physicalColumn, settings) {\n      this.cellMeta.updateMeta(physicalRow, physicalColumn, settings);\n    }\n    /**\n     * Removes a property defined by the \"key\" argument from the cell meta object.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {string} key The property name to remove.\n     */\n\n  }, {\n    key: \"removeCellMeta\",\n    value: function removeCellMeta(physicalRow, physicalColumn, key) {\n      this.cellMeta.removeMeta(physicalRow, physicalColumn, key);\n    }\n    /**\n     * Returns all cell meta objects that were created during the Handsontable operation. As cell meta\n     * objects are created lazy, the length of the returned collection depends on how and when the\n     * table has asked for access to that meta objects.\n     *\n     * @returns {object[]}\n     */\n\n  }, {\n    key: \"getCellsMeta\",\n    value: function getCellsMeta() {\n      return this.cellMeta.getMetas();\n    }\n    /**\n     * Returns all cell meta objects that were created during the Handsontable operation but for\n     * specyfic row index.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @returns {object[]}\n     */\n\n  }, {\n    key: \"getCellsMetaAtRow\",\n    value: function getCellsMetaAtRow(physicalRow) {\n      return this.cellMeta.getMetasAtRow(physicalRow);\n    }\n    /**\n     * Creates one or more rows at specific position.\n     *\n     * @param {number} physicalRow The physical row index which points from what position the row is added.\n     * @param {number} [amount=1] An amount of rows to add.\n     */\n\n  }, {\n    key: \"createRow\",\n    value: function createRow(physicalRow) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.createRow(physicalRow, amount);\n    }\n    /**\n     * Removes one or more rows from the collection.\n     *\n     * @param {number} physicalRow The physical row index which points from what position the row is removed.\n     * @param {number} [amount=1] An amount rows to remove.\n     */\n\n  }, {\n    key: \"removeRow\",\n    value: function removeRow(physicalRow) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.removeRow(physicalRow, amount);\n    }\n    /**\n     * Creates one or more columns at specific position.\n     *\n     * @param {number} physicalColumn The physical column index which points from what position the column is added.\n     * @param {number} [amount=1] An amount of columns to add.\n     */\n\n  }, {\n    key: \"createColumn\",\n    value: function createColumn(physicalColumn) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.createColumn(physicalColumn, amount);\n      this.columnMeta.createColumn(physicalColumn, amount);\n    }\n    /**\n     * Removes one or more columns from the collection.\n     *\n     * @param {number} physicalColumn The physical column index which points from what position the column is removed.\n     * @param {number} [amount=1] An amount of columns to remove.\n     */\n\n  }, {\n    key: \"removeColumn\",\n    value: function removeColumn(physicalColumn) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.removeColumn(physicalColumn, amount);\n      this.columnMeta.removeColumn(physicalColumn, amount);\n    }\n    /**\n     * Clears all saved cell meta objects. It keeps column meta, table meta, and global meta intact.\n     */\n\n  }, {\n    key: \"clearCellsCache\",\n    value: function clearCellsCache() {\n      this.cellMeta.clearCache();\n    }\n    /**\n     * Clears all saved cell and columns meta objects.\n     */\n\n  }, {\n    key: \"clearCache\",\n    value: function clearCache() {\n      this.cellMeta.clearCache();\n      this.columnMeta.clearCache();\n    }\n  }]);\n\n  return MetaManager;\n}();\n\nexport { MetaManager as default };","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/dataMap/metaManager/index.mjs"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","GlobalMeta","TableMeta","ColumnMeta","CellMeta","MetaManager","customSettings","arguments","undefined","globalMeta","updateMeta","tableMeta","columnMeta","cellMeta","value","getGlobalMeta","getMeta","updateGlobalMeta","settings","getTableMeta","updateTableMeta","getColumnMeta","physicalColumn","updateColumnMeta","getCellMeta","physicalRow","setCellMeta","setMeta","updateCellMeta","removeCellMeta","removeMeta","getCellsMeta","getMetas","getCellsMetaAtRow","getMetasAtRow","createRow","amount","removeRow","createColumn","removeColumn","clearCellsCache","clearCache","default"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport GlobalMeta from \"./metaLayers/globalMeta.mjs\";\nimport TableMeta from \"./metaLayers/tableMeta.mjs\";\nimport ColumnMeta from \"./metaLayers/columnMeta.mjs\";\nimport CellMeta from \"./metaLayers/cellMeta.mjs\";\n/**\n * With the Meta Manager class, it can be possible to manage with meta objects for different layers in\n * one place. All coordinates used to fetch, updating, removing, or creating rows or columns have to\n * be passed as physical values.\n *\n * The diagram of the meta layers:\n * +-------------+.\n * │ GlobalMeta  │\n * │ (prototype) │\n * +-------------+\\\n *       │         \\\n *       │          \\\n *      \\│/         _\\|\n * +-------------+    +-------------+.\n * │ TableMeta   │    │ ColumnMeta  │\n * │ (instance)  │    │ (prototype) │\n * +-------------+    +-------------+.\n *                         │\n *                         │\n *                        \\│/\n *                    +-------------+.\n *                    │  CellMeta   │\n *                    │ (instance)  │\n *                    +-------------+.\n *\n * A more detailed description of the specific layers can be found in the \"metaLayers/\" modules description.\n */\n\nvar MetaManager = /*#__PURE__*/function () {\n  function MetaManager() {\n    var customSettings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, MetaManager);\n\n    /**\n     * @type {GlobalMeta}\n     */\n    this.globalMeta = new GlobalMeta();\n    this.globalMeta.updateMeta(customSettings);\n    /**\n     * @type {TableMeta}\n     */\n\n    this.tableMeta = new TableMeta(this.globalMeta);\n    /**\n     * @type {ColumnMeta}\n     */\n\n    this.columnMeta = new ColumnMeta(this.globalMeta);\n    /**\n     * @type {CellMeta}\n     */\n\n    this.cellMeta = new CellMeta(this.columnMeta);\n  }\n  /**\n   * Gets the global meta object that is a root of all default settings, which are recognizable by Handsontable.\n   * Other layers inherites all properties from this. Adding, removing, or changing property in that\n   * object has a direct reflection to all layers.\n   *\n   * @returns {object}\n   */\n\n\n  _createClass(MetaManager, [{\n    key: \"getGlobalMeta\",\n    value: function getGlobalMeta() {\n      return this.globalMeta.getMeta();\n    }\n    /**\n     * Updates global settings object by merging settings with the current state.\n     *\n     * @param {object} settings An object to merge with.\n     */\n\n  }, {\n    key: \"updateGlobalMeta\",\n    value: function updateGlobalMeta(settings) {\n      this.globalMeta.updateMeta(settings);\n    }\n    /**\n     * Gets settings object that was passed in the Handsontable constructor. That layer contains all\n     * default settings inherited from the GlobalMeta layer merged with settings passed by the developer.\n     * Adding, removing, or changing property in that object has no direct reflection on any other layers.\n     *\n     * @returns {object}\n     */\n\n  }, {\n    key: \"getTableMeta\",\n    value: function getTableMeta() {\n      return this.tableMeta.getMeta();\n    }\n    /**\n     * Updates table settings object by merging settings with the current state.\n     *\n     * @param {object} settings An object to merge with.\n     */\n\n  }, {\n    key: \"updateTableMeta\",\n    value: function updateTableMeta(settings) {\n      this.tableMeta.updateMeta(settings);\n    }\n    /**\n     * Gets column meta object that is a root of all settings defined in the column property of the Handsontable\n     * settings. Each column in the Handsontable is associated with a unique meta object which identified by\n     * the physical column index. Adding, removing, or changing property in that object has a direct reflection\n     * only for the CellMeta layer. The reflection will be visible only if the property doesn't exist in the lower\n     * layers (prototype lookup).\n     *\n     * @param {number} physicalColumn The physical column index.\n     * @returns {object}\n     */\n\n  }, {\n    key: \"getColumnMeta\",\n    value: function getColumnMeta(physicalColumn) {\n      return this.columnMeta.getMeta(physicalColumn);\n    }\n    /**\n     * Updates column meta object by merging settings with the current state.\n     *\n     * @param {number} physicalColumn The physical column index which points what column meta object is updated.\n     * @param {object} settings An object to merge with.\n     */\n\n  }, {\n    key: \"updateColumnMeta\",\n    value: function updateColumnMeta(physicalColumn, settings) {\n      this.columnMeta.updateMeta(physicalColumn, settings);\n    }\n    /**\n     * Gets the cell meta object that is a root of all settings defined for the specific cell rendered by\n     * the Handsontable. Each cell meta inherits settings from higher layers. When a property doesn't\n     * exist in that layer, it is looked up through a prototype to the highest layer. Starting\n     * from CellMeta -> ColumnMeta and ending to GlobalMeta, which stores default settings. Adding,\n     * removing, or changing property in that object has no direct reflection on any other layers.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {string} [key] If the key exists its value will be returned, otherwise the whole cell meta object.\n     * @returns {object}\n     */\n\n  }, {\n    key: \"getCellMeta\",\n    value: function getCellMeta(physicalRow, physicalColumn, key) {\n      return this.cellMeta.getMeta(physicalRow, physicalColumn, key);\n    }\n    /**\n     * Sets settings object for cell meta object defined by \"key\" property.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {string} key The property name to set.\n     * @param {*} value Value to save.\n     */\n\n  }, {\n    key: \"setCellMeta\",\n    value: function setCellMeta(physicalRow, physicalColumn, key, value) {\n      this.cellMeta.setMeta(physicalRow, physicalColumn, key, value);\n    }\n    /**\n     * Updates cell meta object by merging settings with the current state.\n     *\n     * @param {number} physicalRow The physical row index which points what cell meta object is updated.\n     * @param {number} physicalColumn The physical column index which points what cell meta object is updated.\n     * @param {object} settings An object to merge with.\n     */\n\n  }, {\n    key: \"updateCellMeta\",\n    value: function updateCellMeta(physicalRow, physicalColumn, settings) {\n      this.cellMeta.updateMeta(physicalRow, physicalColumn, settings);\n    }\n    /**\n     * Removes a property defined by the \"key\" argument from the cell meta object.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {string} key The property name to remove.\n     */\n\n  }, {\n    key: \"removeCellMeta\",\n    value: function removeCellMeta(physicalRow, physicalColumn, key) {\n      this.cellMeta.removeMeta(physicalRow, physicalColumn, key);\n    }\n    /**\n     * Returns all cell meta objects that were created during the Handsontable operation. As cell meta\n     * objects are created lazy, the length of the returned collection depends on how and when the\n     * table has asked for access to that meta objects.\n     *\n     * @returns {object[]}\n     */\n\n  }, {\n    key: \"getCellsMeta\",\n    value: function getCellsMeta() {\n      return this.cellMeta.getMetas();\n    }\n    /**\n     * Returns all cell meta objects that were created during the Handsontable operation but for\n     * specyfic row index.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @returns {object[]}\n     */\n\n  }, {\n    key: \"getCellsMetaAtRow\",\n    value: function getCellsMetaAtRow(physicalRow) {\n      return this.cellMeta.getMetasAtRow(physicalRow);\n    }\n    /**\n     * Creates one or more rows at specific position.\n     *\n     * @param {number} physicalRow The physical row index which points from what position the row is added.\n     * @param {number} [amount=1] An amount of rows to add.\n     */\n\n  }, {\n    key: \"createRow\",\n    value: function createRow(physicalRow) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.createRow(physicalRow, amount);\n    }\n    /**\n     * Removes one or more rows from the collection.\n     *\n     * @param {number} physicalRow The physical row index which points from what position the row is removed.\n     * @param {number} [amount=1] An amount rows to remove.\n     */\n\n  }, {\n    key: \"removeRow\",\n    value: function removeRow(physicalRow) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.removeRow(physicalRow, amount);\n    }\n    /**\n     * Creates one or more columns at specific position.\n     *\n     * @param {number} physicalColumn The physical column index which points from what position the column is added.\n     * @param {number} [amount=1] An amount of columns to add.\n     */\n\n  }, {\n    key: \"createColumn\",\n    value: function createColumn(physicalColumn) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.createColumn(physicalColumn, amount);\n      this.columnMeta.createColumn(physicalColumn, amount);\n    }\n    /**\n     * Removes one or more columns from the collection.\n     *\n     * @param {number} physicalColumn The physical column index which points from what position the column is removed.\n     * @param {number} [amount=1] An amount of columns to remove.\n     */\n\n  }, {\n    key: \"removeColumn\",\n    value: function removeColumn(physicalColumn) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.removeColumn(physicalColumn, amount);\n      this.columnMeta.removeColumn(physicalColumn, amount);\n    }\n    /**\n     * Clears all saved cell meta objects. It keeps column meta, table meta, and global meta intact.\n     */\n\n  }, {\n    key: \"clearCellsCache\",\n    value: function clearCellsCache() {\n      this.cellMeta.clearCache();\n    }\n    /**\n     * Clears all saved cell and columns meta objects.\n     */\n\n  }, {\n    key: \"clearCache\",\n    value: function clearCache() {\n      this.cellMeta.clearCache();\n      this.columnMeta.clearCache();\n    }\n  }]);\n\n  return MetaManager;\n}();\n\nexport { MetaManager as default };"]},"metadata":{},"sourceType":"module"}