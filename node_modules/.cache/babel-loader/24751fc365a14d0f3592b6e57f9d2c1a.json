{"ast":null,"code":"import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.object.get-prototype-of\";\nimport \"core-js/modules/es.object.keys\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.for-each\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nimport { getCellType } from \"./../cellTypes/registry.mjs\";\nimport { deepObjectSize, hasOwnProperty, isObject } from \"./object.mjs\";\nvar COLUMN_LABEL_BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\nvar COLUMN_LABEL_BASE_LENGTH = COLUMN_LABEL_BASE.length;\n/**\r\n * Generates spreadsheet-like column names: A, B, C, ..., Z, AA, AB, etc.\r\n *\r\n * @param {number} index Column index.\r\n * @returns {string}\r\n */\n\nexport function spreadsheetColumnLabel(index) {\n  var dividend = index + 1;\n  var columnLabel = '';\n  var modulo;\n\n  while (dividend > 0) {\n    modulo = (dividend - 1) % COLUMN_LABEL_BASE_LENGTH;\n    columnLabel = String.fromCharCode(65 + modulo) + columnLabel;\n    dividend = parseInt((dividend - modulo) / COLUMN_LABEL_BASE_LENGTH, 10);\n  }\n\n  return columnLabel;\n}\n/**\r\n * Generates spreadsheet-like column index from theirs labels: A, B, C ...., Z, AA, AB, etc.\r\n *\r\n * @param {string} label Column label.\r\n * @returns {number}\r\n */\n\nexport function spreadsheetColumnIndex(label) {\n  var result = 0;\n\n  if (label) {\n    for (var i = 0, j = label.length - 1; i < label.length; i += 1, j -= 1) {\n      result += Math.pow(COLUMN_LABEL_BASE_LENGTH, j) * (COLUMN_LABEL_BASE.indexOf(label[i]) + 1);\n    }\n  }\n\n  result -= 1;\n  return result;\n}\n/**\r\n * Creates 2D array of Excel-like values \"A1\", \"A2\", ...\r\n *\r\n * @param {number} rows Number of rows to generate.\r\n * @param {number} columns Number of columns to generate.\r\n * @returns {Array}\r\n */\n\nexport function createSpreadsheetData() {\n  var rows = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n  var columns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n  var _rows = [];\n  var i;\n  var j;\n\n  for (i = 0; i < rows; i++) {\n    var row = [];\n\n    for (j = 0; j < columns; j++) {\n      row.push(spreadsheetColumnLabel(j) + (i + 1));\n    }\n\n    _rows.push(row);\n  }\n\n  return _rows;\n}\n/**\r\n * Creates 2D array of Excel-like values \"A1\", \"A2\", as an array of objects.\r\n *\r\n * @param {number} rows Number of rows to generate.\r\n * @param {number} colCount Number of columns to generate.\r\n * @returns {Array}\r\n */\n\nexport function createSpreadsheetObjectData() {\n  var rows = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n  var colCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n  var _rows = [];\n  var i;\n  var j;\n\n  for (i = 0; i < rows; i++) {\n    var row = {};\n\n    for (j = 0; j < colCount; j++) {\n      row[\"prop\".concat(j)] = spreadsheetColumnLabel(j) + (i + 1);\n    }\n\n    _rows.push(row);\n  }\n\n  return _rows;\n}\n/**\r\n * Generates an empty data object.\r\n *\r\n * @param {number} rows Number of rows to generate.\r\n * @param {number} columns Number of columns to generate.\r\n * @returns {Array}\r\n */\n\nexport function createEmptySpreadsheetData(rows, columns) {\n  var data = [];\n  var row;\n\n  for (var i = 0; i < rows; i++) {\n    row = [];\n\n    for (var j = 0; j < columns; j++) {\n      row.push('');\n    }\n\n    data.push(row);\n  }\n\n  return data;\n}\n/**\r\n * @param {Array} input The data to translate.\r\n * @returns {Array}\r\n */\n\nexport function translateRowsToColumns(input) {\n  var output = [];\n  var i;\n  var ilen;\n  var j;\n  var jlen;\n  var olen = 0;\n\n  for (i = 0, ilen = input.length; i < ilen; i++) {\n    for (j = 0, jlen = input[i].length; j < jlen; j++) {\n      if (j === olen) {\n        output.push([]);\n        olen += 1;\n      }\n\n      output[j].push(input[i][j]);\n    }\n  }\n\n  return output;\n}\n/**\r\n * Factory that produces a function for searching methods (or any properties) which could be defined directly in\r\n * table configuration or implicitly, within cell type definition.\r\n *\r\n * For example: renderer can be defined explicitly using \"renderer\" property in column configuration or it can be\r\n * defined implicitly using \"type\" property.\r\n *\r\n * Methods/properties defined explicitly always takes precedence over those defined through \"type\".\r\n *\r\n * If the method/property is not found in an object, searching is continued recursively through prototype chain, until\r\n * it reaches the Object.prototype.\r\n *\r\n * @param {string} methodName Name of the method/property to search (i.e. 'renderer', 'validator', 'copyable').\r\n * @param {boolean} [allowUndefined] If `false`, the search is continued if methodName has not been found in cell\r\n *   \"type\".\r\n * @returns {Function}\r\n */\n\nexport function cellMethodLookupFactory(methodName, allowUndefined) {\n  var isUndefinedAllowed = typeof allowUndefined === 'undefined' ? true : allowUndefined;\n  return function cellMethodLookup(row, col) {\n    return function getMethodFromProperties(properties) {\n      if (!properties) {\n        return; // method or property not found\n      }\n\n      if (hasOwnProperty(properties, methodName) && properties[methodName] !== void 0) {\n        // check if it is own and is not empty\n        return properties[methodName]; // method defined directly\n      } else if (hasOwnProperty(properties, 'type') && properties.type) {\n        // check if it is own and is not empty\n        if (typeof properties.type !== 'string') {\n          throw new Error('Cell \"type\" must be a string');\n        }\n\n        var type = getCellType(properties.type);\n\n        if (hasOwnProperty(type, methodName)) {\n          return type[methodName]; // method defined in type.\n        } else if (isUndefinedAllowed) {\n          return; // method does not defined in type (eg. validator), returns undefined\n        }\n      }\n\n      return getMethodFromProperties(Object.getPrototypeOf(properties));\n    }(typeof row === 'number' ? this.getCellMeta(row, col) : row);\n  };\n}\n/**\r\n * Transform a data row (either an array or an object) or an array of data rows to array of changes in a form of `[row,\r\n * prop/col, value]`. Convenient to use with `setDataAtRowProp` and `setSourceDataAtCell` methods.\r\n *\r\n * @param {Array|object} dataRow Object of row data, array of row data or an array of either.\r\n * @param {number} rowOffset Row offset to be passed to the resulting change list. Defaults to `0`.\r\n * @returns {Array} Array of changes (in a form of an array).\r\n */\n\nexport function dataRowToChangesArray(dataRow) {\n  var rowOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var dataRows = dataRow;\n  var changesArray = [];\n\n  if (!Array.isArray(dataRow) || !Array.isArray(dataRow[0])) {\n    dataRows = [dataRow];\n  }\n\n  dataRows.forEach(function (row, rowIndex) {\n    if (Array.isArray(row)) {\n      row.forEach(function (value, column) {\n        changesArray.push([rowIndex + rowOffset, column, value]);\n      });\n    } else {\n      Object.keys(row).forEach(function (propName) {\n        changesArray.push([rowIndex + rowOffset, propName, row[propName]]);\n      });\n    }\n  });\n  return changesArray;\n}\n/**\r\n * Count the number of keys (or, basically, columns when the data is an array or arrays) in the first row of the\r\n * provided dataset.\r\n *\r\n * @param {Array} data The dataset.\r\n * @returns {number} Number of keys in the first row of the dataset.\r\n */\n\nexport function countFirstRowKeys(data) {\n  var result = 0;\n\n  if (Array.isArray(data)) {\n    if (data[0] && Array.isArray(data[0])) {\n      result = data[0].length;\n    } else if (data[0] && isObject(data[0])) {\n      result = deepObjectSize(data[0]);\n    }\n  }\n\n  return result;\n}\n/**\r\n * Check whether the provided dataset is a *non-empty* array of arrays.\r\n *\r\n * @param {Array} data Dataset to be checked.\r\n * @returns {boolean} `true` if data is an array of arrays, `false` otherwise.\r\n */\n\nexport function isArrayOfArrays(data) {\n  return !!(Array.isArray(data) && data.length && data.every(function (el) {\n    return Array.isArray(el);\n  }));\n}\n/**\r\n * Check whether the provided dataset is a *non-empty* array of objects.\r\n *\r\n * @param {Array} data Dataset to be checked.\r\n * @returns {boolean} `true` if data is an array of objects, `false` otherwise.\r\n */\n\nexport function isArrayOfObjects(data) {\n  return !!(Array.isArray(data) && data.length && data.every(function (el) {\n    return _typeof(el) === 'object' && !Array.isArray(el) && el !== null;\n  }));\n}","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/helpers/data.mjs"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","getCellType","deepObjectSize","hasOwnProperty","isObject","COLUMN_LABEL_BASE","COLUMN_LABEL_BASE_LENGTH","length","spreadsheetColumnLabel","index","dividend","columnLabel","modulo","String","fromCharCode","parseInt","spreadsheetColumnIndex","label","result","i","j","Math","pow","indexOf","createSpreadsheetData","rows","arguments","undefined","columns","_rows","row","push","createSpreadsheetObjectData","colCount","concat","createEmptySpreadsheetData","data","translateRowsToColumns","input","output","ilen","jlen","olen","cellMethodLookupFactory","methodName","allowUndefined","isUndefinedAllowed","cellMethodLookup","col","getMethodFromProperties","properties","type","Error","Object","getPrototypeOf","getCellMeta","dataRowToChangesArray","dataRow","rowOffset","dataRows","changesArray","Array","isArray","forEach","rowIndex","value","column","keys","propName","countFirstRowKeys","isArrayOfArrays","every","el","isArrayOfObjects"],"mappings":";;;;;;;;;;;AAAA,SAASA,OAAT,CAAiBC,GAAjB,EAAsB;AAAE;;AAA2B,MAAI,OAAOC,MAAP,KAAkB,UAAlB,IAAgC,OAAOA,MAAM,CAACC,QAAd,KAA2B,QAA/D,EAAyE;AAAEH,IAAAA,OAAO,GAAG,SAASA,OAAT,CAAiBC,GAAjB,EAAsB;AAAE,aAAO,OAAOA,GAAd;AAAoB,KAAtD;AAAyD,GAApI,MAA0I;AAAED,IAAAA,OAAO,GAAG,SAASA,OAAT,CAAiBC,GAAjB,EAAsB;AAAE,aAAOA,GAAG,IAAI,OAAOC,MAAP,KAAkB,UAAzB,IAAuCD,GAAG,CAACG,WAAJ,KAAoBF,MAA3D,IAAqED,GAAG,KAAKC,MAAM,CAACG,SAApF,GAAgG,QAAhG,GAA2G,OAAOJ,GAAzH;AAA+H,KAAjK;AAAoK;;AAAC,SAAOD,OAAO,CAACC,GAAD,CAAd;AAAsB;;AAY1X,SAASK,WAAT,QAA4B,6BAA5B;AACA,SAASC,cAAT,EAAyBC,cAAzB,EAAyCC,QAAzC,QAAyD,cAAzD;AACA,IAAIC,iBAAiB,GAAG,4BAAxB;AACA,IAAIC,wBAAwB,GAAGD,iBAAiB,CAACE,MAAjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,sBAAT,CAAgCC,KAAhC,EAAuC;AAC5C,MAAIC,QAAQ,GAAGD,KAAK,GAAG,CAAvB;AACA,MAAIE,WAAW,GAAG,EAAlB;AACA,MAAIC,MAAJ;;AAEA,SAAOF,QAAQ,GAAG,CAAlB,EAAqB;AACnBE,IAAAA,MAAM,GAAG,CAACF,QAAQ,GAAG,CAAZ,IAAiBJ,wBAA1B;AACAK,IAAAA,WAAW,GAAGE,MAAM,CAACC,YAAP,CAAoB,KAAKF,MAAzB,IAAmCD,WAAjD;AACAD,IAAAA,QAAQ,GAAGK,QAAQ,CAAC,CAACL,QAAQ,GAAGE,MAAZ,IAAsBN,wBAAvB,EAAiD,EAAjD,CAAnB;AACD;;AAED,SAAOK,WAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASK,sBAAT,CAAgCC,KAAhC,EAAuC;AAC5C,MAAIC,MAAM,GAAG,CAAb;;AAEA,MAAID,KAAJ,EAAW;AACT,SAAK,IAAIE,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGH,KAAK,CAACV,MAAN,GAAe,CAAnC,EAAsCY,CAAC,GAAGF,KAAK,CAACV,MAAhD,EAAwDY,CAAC,IAAI,CAAL,EAAQC,CAAC,IAAI,CAArE,EAAwE;AACtEF,MAAAA,MAAM,IAAIG,IAAI,CAACC,GAAL,CAAShB,wBAAT,EAAmCc,CAAnC,KAAyCf,iBAAiB,CAACkB,OAAlB,CAA0BN,KAAK,CAACE,CAAD,CAA/B,IAAsC,CAA/E,CAAV;AACD;AACF;;AAEDD,EAAAA,MAAM,IAAI,CAAV;AACA,SAAOA,MAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASM,qBAAT,GAAiC;AACtC,MAAIC,IAAI,GAAGC,SAAS,CAACnB,MAAV,GAAmB,CAAnB,IAAwBmB,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,GAA/E;AACA,MAAIE,OAAO,GAAGF,SAAS,CAACnB,MAAV,GAAmB,CAAnB,IAAwBmB,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAAlF;AACA,MAAIG,KAAK,GAAG,EAAZ;AACA,MAAIV,CAAJ;AACA,MAAIC,CAAJ;;AAEA,OAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGM,IAAhB,EAAsBN,CAAC,EAAvB,EAA2B;AACzB,QAAIW,GAAG,GAAG,EAAV;;AAEA,SAAKV,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGQ,OAAhB,EAAyBR,CAAC,EAA1B,EAA8B;AAC5BU,MAAAA,GAAG,CAACC,IAAJ,CAASvB,sBAAsB,CAACY,CAAD,CAAtB,IAA6BD,CAAC,GAAG,CAAjC,CAAT;AACD;;AAEDU,IAAAA,KAAK,CAACE,IAAN,CAAWD,GAAX;AACD;;AAED,SAAOD,KAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASG,2BAAT,GAAuC;AAC5C,MAAIP,IAAI,GAAGC,SAAS,CAACnB,MAAV,GAAmB,CAAnB,IAAwBmB,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,GAA/E;AACA,MAAIO,QAAQ,GAAGP,SAAS,CAACnB,MAAV,GAAmB,CAAnB,IAAwBmB,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAAnF;AACA,MAAIG,KAAK,GAAG,EAAZ;AACA,MAAIV,CAAJ;AACA,MAAIC,CAAJ;;AAEA,OAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGM,IAAhB,EAAsBN,CAAC,EAAvB,EAA2B;AACzB,QAAIW,GAAG,GAAG,EAAV;;AAEA,SAAKV,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGa,QAAhB,EAA0Bb,CAAC,EAA3B,EAA+B;AAC7BU,MAAAA,GAAG,CAAC,OAAOI,MAAP,CAAcd,CAAd,CAAD,CAAH,GAAwBZ,sBAAsB,CAACY,CAAD,CAAtB,IAA6BD,CAAC,GAAG,CAAjC,CAAxB;AACD;;AAEDU,IAAAA,KAAK,CAACE,IAAN,CAAWD,GAAX;AACD;;AAED,SAAOD,KAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASM,0BAAT,CAAoCV,IAApC,EAA0CG,OAA1C,EAAmD;AACxD,MAAIQ,IAAI,GAAG,EAAX;AACA,MAAIN,GAAJ;;AAEA,OAAK,IAAIX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,IAApB,EAA0BN,CAAC,EAA3B,EAA+B;AAC7BW,IAAAA,GAAG,GAAG,EAAN;;AAEA,SAAK,IAAIV,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGQ,OAApB,EAA6BR,CAAC,EAA9B,EAAkC;AAChCU,MAAAA,GAAG,CAACC,IAAJ,CAAS,EAAT;AACD;;AAEDK,IAAAA,IAAI,CAACL,IAAL,CAAUD,GAAV;AACD;;AAED,SAAOM,IAAP;AACD;AACD;AACA;AACA;AACA;;AAEA,OAAO,SAASC,sBAAT,CAAgCC,KAAhC,EAAuC;AAC5C,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIpB,CAAJ;AACA,MAAIqB,IAAJ;AACA,MAAIpB,CAAJ;AACA,MAAIqB,IAAJ;AACA,MAAIC,IAAI,GAAG,CAAX;;AAEA,OAAKvB,CAAC,GAAG,CAAJ,EAAOqB,IAAI,GAAGF,KAAK,CAAC/B,MAAzB,EAAiCY,CAAC,GAAGqB,IAArC,EAA2CrB,CAAC,EAA5C,EAAgD;AAC9C,SAAKC,CAAC,GAAG,CAAJ,EAAOqB,IAAI,GAAGH,KAAK,CAACnB,CAAD,CAAL,CAASZ,MAA5B,EAAoCa,CAAC,GAAGqB,IAAxC,EAA8CrB,CAAC,EAA/C,EAAmD;AACjD,UAAIA,CAAC,KAAKsB,IAAV,EAAgB;AACdH,QAAAA,MAAM,CAACR,IAAP,CAAY,EAAZ;AACAW,QAAAA,IAAI,IAAI,CAAR;AACD;;AAEDH,MAAAA,MAAM,CAACnB,CAAD,CAAN,CAAUW,IAAV,CAAeO,KAAK,CAACnB,CAAD,CAAL,CAASC,CAAT,CAAf;AACD;AACF;;AAED,SAAOmB,MAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASI,uBAAT,CAAiCC,UAAjC,EAA6CC,cAA7C,EAA6D;AAClE,MAAIC,kBAAkB,GAAG,OAAOD,cAAP,KAA0B,WAA1B,GAAwC,IAAxC,GAA+CA,cAAxE;AACA,SAAO,SAASE,gBAAT,CAA0BjB,GAA1B,EAA+BkB,GAA/B,EAAoC;AACzC,WAAO,SAASC,uBAAT,CAAiCC,UAAjC,EAA6C;AAClD,UAAI,CAACA,UAAL,EAAiB;AACf,eADe,CACP;AACT;;AAED,UAAI/C,cAAc,CAAC+C,UAAD,EAAaN,UAAb,CAAd,IAA0CM,UAAU,CAACN,UAAD,CAAV,KAA2B,KAAK,CAA9E,EAAiF;AAC/E;AACA,eAAOM,UAAU,CAACN,UAAD,CAAjB,CAF+E,CAEhD;AAChC,OAHD,MAGO,IAAIzC,cAAc,CAAC+C,UAAD,EAAa,MAAb,CAAd,IAAsCA,UAAU,CAACC,IAArD,EAA2D;AAChE;AACA,YAAI,OAAOD,UAAU,CAACC,IAAlB,KAA2B,QAA/B,EAAyC;AACvC,gBAAM,IAAIC,KAAJ,CAAU,8BAAV,CAAN;AACD;;AAED,YAAID,IAAI,GAAGlD,WAAW,CAACiD,UAAU,CAACC,IAAZ,CAAtB;;AAEA,YAAIhD,cAAc,CAACgD,IAAD,EAAOP,UAAP,CAAlB,EAAsC;AACpC,iBAAOO,IAAI,CAACP,UAAD,CAAX,CADoC,CACX;AAC1B,SAFD,MAEO,IAAIE,kBAAJ,EAAwB;AAC7B,iBAD6B,CACrB;AACT;AACF;;AAED,aAAOG,uBAAuB,CAACI,MAAM,CAACC,cAAP,CAAsBJ,UAAtB,CAAD,CAA9B;AACD,KAxBM,CAwBL,OAAOpB,GAAP,KAAe,QAAf,GAA0B,KAAKyB,WAAL,CAAiBzB,GAAjB,EAAsBkB,GAAtB,CAA1B,GAAuDlB,GAxBlD,CAAP;AAyBD,GA1BD;AA2BD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAAS0B,qBAAT,CAA+BC,OAA/B,EAAwC;AAC7C,MAAIC,SAAS,GAAGhC,SAAS,CAACnB,MAAV,GAAmB,CAAnB,IAAwBmB,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAApF;AACA,MAAIiC,QAAQ,GAAGF,OAAf;AACA,MAAIG,YAAY,GAAG,EAAnB;;AAEA,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcL,OAAd,CAAD,IAA2B,CAACI,KAAK,CAACC,OAAN,CAAcL,OAAO,CAAC,CAAD,CAArB,CAAhC,EAA2D;AACzDE,IAAAA,QAAQ,GAAG,CAACF,OAAD,CAAX;AACD;;AAEDE,EAAAA,QAAQ,CAACI,OAAT,CAAiB,UAAUjC,GAAV,EAAekC,QAAf,EAAyB;AACxC,QAAIH,KAAK,CAACC,OAAN,CAAchC,GAAd,CAAJ,EAAwB;AACtBA,MAAAA,GAAG,CAACiC,OAAJ,CAAY,UAAUE,KAAV,EAAiBC,MAAjB,EAAyB;AACnCN,QAAAA,YAAY,CAAC7B,IAAb,CAAkB,CAACiC,QAAQ,GAAGN,SAAZ,EAAuBQ,MAAvB,EAA+BD,KAA/B,CAAlB;AACD,OAFD;AAGD,KAJD,MAIO;AACLZ,MAAAA,MAAM,CAACc,IAAP,CAAYrC,GAAZ,EAAiBiC,OAAjB,CAAyB,UAAUK,QAAV,EAAoB;AAC3CR,QAAAA,YAAY,CAAC7B,IAAb,CAAkB,CAACiC,QAAQ,GAAGN,SAAZ,EAAuBU,QAAvB,EAAiCtC,GAAG,CAACsC,QAAD,CAApC,CAAlB;AACD,OAFD;AAGD;AACF,GAVD;AAWA,SAAOR,YAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASS,iBAAT,CAA2BjC,IAA3B,EAAiC;AACtC,MAAIlB,MAAM,GAAG,CAAb;;AAEA,MAAI2C,KAAK,CAACC,OAAN,CAAc1B,IAAd,CAAJ,EAAyB;AACvB,QAAIA,IAAI,CAAC,CAAD,CAAJ,IAAWyB,KAAK,CAACC,OAAN,CAAc1B,IAAI,CAAC,CAAD,CAAlB,CAAf,EAAuC;AACrClB,MAAAA,MAAM,GAAGkB,IAAI,CAAC,CAAD,CAAJ,CAAQ7B,MAAjB;AACD,KAFD,MAEO,IAAI6B,IAAI,CAAC,CAAD,CAAJ,IAAWhC,QAAQ,CAACgC,IAAI,CAAC,CAAD,CAAL,CAAvB,EAAkC;AACvClB,MAAAA,MAAM,GAAGhB,cAAc,CAACkC,IAAI,CAAC,CAAD,CAAL,CAAvB;AACD;AACF;;AAED,SAAOlB,MAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASoD,eAAT,CAAyBlC,IAAzB,EAA+B;AACpC,SAAO,CAAC,EAAEyB,KAAK,CAACC,OAAN,CAAc1B,IAAd,KAAuBA,IAAI,CAAC7B,MAA5B,IAAsC6B,IAAI,CAACmC,KAAL,CAAW,UAAUC,EAAV,EAAc;AACvE,WAAOX,KAAK,CAACC,OAAN,CAAcU,EAAd,CAAP;AACD,GAF+C,CAAxC,CAAR;AAGD;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,gBAAT,CAA0BrC,IAA1B,EAAgC;AACrC,SAAO,CAAC,EAAEyB,KAAK,CAACC,OAAN,CAAc1B,IAAd,KAAuBA,IAAI,CAAC7B,MAA5B,IAAsC6B,IAAI,CAACmC,KAAL,CAAW,UAAUC,EAAV,EAAc;AACvE,WAAO7E,OAAO,CAAC6E,EAAD,CAAP,KAAgB,QAAhB,IAA4B,CAACX,KAAK,CAACC,OAAN,CAAcU,EAAd,CAA7B,IAAkDA,EAAE,KAAK,IAAhE;AACD,GAF+C,CAAxC,CAAR;AAGD","sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\r\n\r\nimport \"core-js/modules/es.object.get-prototype-of.js\";\r\nimport \"core-js/modules/web.dom-collections.for-each.js\";\r\nimport \"core-js/modules/es.object.keys.js\";\r\nimport \"core-js/modules/es.symbol.js\";\r\nimport \"core-js/modules/es.symbol.description.js\";\r\nimport \"core-js/modules/es.object.to-string.js\";\r\nimport \"core-js/modules/es.symbol.iterator.js\";\r\nimport \"core-js/modules/es.array.iterator.js\";\r\nimport \"core-js/modules/es.string.iterator.js\";\r\nimport \"core-js/modules/web.dom-collections.iterator.js\";\r\nimport { getCellType } from \"./../cellTypes/registry.mjs\";\r\nimport { deepObjectSize, hasOwnProperty, isObject } from \"./object.mjs\";\r\nvar COLUMN_LABEL_BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\nvar COLUMN_LABEL_BASE_LENGTH = COLUMN_LABEL_BASE.length;\r\n/**\r\n * Generates spreadsheet-like column names: A, B, C, ..., Z, AA, AB, etc.\r\n *\r\n * @param {number} index Column index.\r\n * @returns {string}\r\n */\r\n\r\nexport function spreadsheetColumnLabel(index) {\r\n  var dividend = index + 1;\r\n  var columnLabel = '';\r\n  var modulo;\r\n\r\n  while (dividend > 0) {\r\n    modulo = (dividend - 1) % COLUMN_LABEL_BASE_LENGTH;\r\n    columnLabel = String.fromCharCode(65 + modulo) + columnLabel;\r\n    dividend = parseInt((dividend - modulo) / COLUMN_LABEL_BASE_LENGTH, 10);\r\n  }\r\n\r\n  return columnLabel;\r\n}\r\n/**\r\n * Generates spreadsheet-like column index from theirs labels: A, B, C ...., Z, AA, AB, etc.\r\n *\r\n * @param {string} label Column label.\r\n * @returns {number}\r\n */\r\n\r\nexport function spreadsheetColumnIndex(label) {\r\n  var result = 0;\r\n\r\n  if (label) {\r\n    for (var i = 0, j = label.length - 1; i < label.length; i += 1, j -= 1) {\r\n      result += Math.pow(COLUMN_LABEL_BASE_LENGTH, j) * (COLUMN_LABEL_BASE.indexOf(label[i]) + 1);\r\n    }\r\n  }\r\n\r\n  result -= 1;\r\n  return result;\r\n}\r\n/**\r\n * Creates 2D array of Excel-like values \"A1\", \"A2\", ...\r\n *\r\n * @param {number} rows Number of rows to generate.\r\n * @param {number} columns Number of columns to generate.\r\n * @returns {Array}\r\n */\r\n\r\nexport function createSpreadsheetData() {\r\n  var rows = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\r\n  var columns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\r\n  var _rows = [];\r\n  var i;\r\n  var j;\r\n\r\n  for (i = 0; i < rows; i++) {\r\n    var row = [];\r\n\r\n    for (j = 0; j < columns; j++) {\r\n      row.push(spreadsheetColumnLabel(j) + (i + 1));\r\n    }\r\n\r\n    _rows.push(row);\r\n  }\r\n\r\n  return _rows;\r\n}\r\n/**\r\n * Creates 2D array of Excel-like values \"A1\", \"A2\", as an array of objects.\r\n *\r\n * @param {number} rows Number of rows to generate.\r\n * @param {number} colCount Number of columns to generate.\r\n * @returns {Array}\r\n */\r\n\r\nexport function createSpreadsheetObjectData() {\r\n  var rows = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\r\n  var colCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\r\n  var _rows = [];\r\n  var i;\r\n  var j;\r\n\r\n  for (i = 0; i < rows; i++) {\r\n    var row = {};\r\n\r\n    for (j = 0; j < colCount; j++) {\r\n      row[\"prop\".concat(j)] = spreadsheetColumnLabel(j) + (i + 1);\r\n    }\r\n\r\n    _rows.push(row);\r\n  }\r\n\r\n  return _rows;\r\n}\r\n/**\r\n * Generates an empty data object.\r\n *\r\n * @param {number} rows Number of rows to generate.\r\n * @param {number} columns Number of columns to generate.\r\n * @returns {Array}\r\n */\r\n\r\nexport function createEmptySpreadsheetData(rows, columns) {\r\n  var data = [];\r\n  var row;\r\n\r\n  for (var i = 0; i < rows; i++) {\r\n    row = [];\r\n\r\n    for (var j = 0; j < columns; j++) {\r\n      row.push('');\r\n    }\r\n\r\n    data.push(row);\r\n  }\r\n\r\n  return data;\r\n}\r\n/**\r\n * @param {Array} input The data to translate.\r\n * @returns {Array}\r\n */\r\n\r\nexport function translateRowsToColumns(input) {\r\n  var output = [];\r\n  var i;\r\n  var ilen;\r\n  var j;\r\n  var jlen;\r\n  var olen = 0;\r\n\r\n  for (i = 0, ilen = input.length; i < ilen; i++) {\r\n    for (j = 0, jlen = input[i].length; j < jlen; j++) {\r\n      if (j === olen) {\r\n        output.push([]);\r\n        olen += 1;\r\n      }\r\n\r\n      output[j].push(input[i][j]);\r\n    }\r\n  }\r\n\r\n  return output;\r\n}\r\n/**\r\n * Factory that produces a function for searching methods (or any properties) which could be defined directly in\r\n * table configuration or implicitly, within cell type definition.\r\n *\r\n * For example: renderer can be defined explicitly using \"renderer\" property in column configuration or it can be\r\n * defined implicitly using \"type\" property.\r\n *\r\n * Methods/properties defined explicitly always takes precedence over those defined through \"type\".\r\n *\r\n * If the method/property is not found in an object, searching is continued recursively through prototype chain, until\r\n * it reaches the Object.prototype.\r\n *\r\n * @param {string} methodName Name of the method/property to search (i.e. 'renderer', 'validator', 'copyable').\r\n * @param {boolean} [allowUndefined] If `false`, the search is continued if methodName has not been found in cell\r\n *   \"type\".\r\n * @returns {Function}\r\n */\r\n\r\nexport function cellMethodLookupFactory(methodName, allowUndefined) {\r\n  var isUndefinedAllowed = typeof allowUndefined === 'undefined' ? true : allowUndefined;\r\n  return function cellMethodLookup(row, col) {\r\n    return function getMethodFromProperties(properties) {\r\n      if (!properties) {\r\n        return; // method or property not found\r\n      }\r\n\r\n      if (hasOwnProperty(properties, methodName) && properties[methodName] !== void 0) {\r\n        // check if it is own and is not empty\r\n        return properties[methodName]; // method defined directly\r\n      } else if (hasOwnProperty(properties, 'type') && properties.type) {\r\n        // check if it is own and is not empty\r\n        if (typeof properties.type !== 'string') {\r\n          throw new Error('Cell \"type\" must be a string');\r\n        }\r\n\r\n        var type = getCellType(properties.type);\r\n\r\n        if (hasOwnProperty(type, methodName)) {\r\n          return type[methodName]; // method defined in type.\r\n        } else if (isUndefinedAllowed) {\r\n          return; // method does not defined in type (eg. validator), returns undefined\r\n        }\r\n      }\r\n\r\n      return getMethodFromProperties(Object.getPrototypeOf(properties));\r\n    }(typeof row === 'number' ? this.getCellMeta(row, col) : row);\r\n  };\r\n}\r\n/**\r\n * Transform a data row (either an array or an object) or an array of data rows to array of changes in a form of `[row,\r\n * prop/col, value]`. Convenient to use with `setDataAtRowProp` and `setSourceDataAtCell` methods.\r\n *\r\n * @param {Array|object} dataRow Object of row data, array of row data or an array of either.\r\n * @param {number} rowOffset Row offset to be passed to the resulting change list. Defaults to `0`.\r\n * @returns {Array} Array of changes (in a form of an array).\r\n */\r\n\r\nexport function dataRowToChangesArray(dataRow) {\r\n  var rowOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\r\n  var dataRows = dataRow;\r\n  var changesArray = [];\r\n\r\n  if (!Array.isArray(dataRow) || !Array.isArray(dataRow[0])) {\r\n    dataRows = [dataRow];\r\n  }\r\n\r\n  dataRows.forEach(function (row, rowIndex) {\r\n    if (Array.isArray(row)) {\r\n      row.forEach(function (value, column) {\r\n        changesArray.push([rowIndex + rowOffset, column, value]);\r\n      });\r\n    } else {\r\n      Object.keys(row).forEach(function (propName) {\r\n        changesArray.push([rowIndex + rowOffset, propName, row[propName]]);\r\n      });\r\n    }\r\n  });\r\n  return changesArray;\r\n}\r\n/**\r\n * Count the number of keys (or, basically, columns when the data is an array or arrays) in the first row of the\r\n * provided dataset.\r\n *\r\n * @param {Array} data The dataset.\r\n * @returns {number} Number of keys in the first row of the dataset.\r\n */\r\n\r\nexport function countFirstRowKeys(data) {\r\n  var result = 0;\r\n\r\n  if (Array.isArray(data)) {\r\n    if (data[0] && Array.isArray(data[0])) {\r\n      result = data[0].length;\r\n    } else if (data[0] && isObject(data[0])) {\r\n      result = deepObjectSize(data[0]);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n/**\r\n * Check whether the provided dataset is a *non-empty* array of arrays.\r\n *\r\n * @param {Array} data Dataset to be checked.\r\n * @returns {boolean} `true` if data is an array of arrays, `false` otherwise.\r\n */\r\n\r\nexport function isArrayOfArrays(data) {\r\n  return !!(Array.isArray(data) && data.length && data.every(function (el) {\r\n    return Array.isArray(el);\r\n  }));\r\n}\r\n/**\r\n * Check whether the provided dataset is a *non-empty* array of objects.\r\n *\r\n * @param {Array} data Dataset to be checked.\r\n * @returns {boolean} `true` if data is an array of objects, `false` otherwise.\r\n */\r\n\r\nexport function isArrayOfObjects(data) {\r\n  return !!(Array.isArray(data) && data.length && data.every(function (el) {\r\n    return _typeof(el) === 'object' && !Array.isArray(el) && el !== null;\r\n  }));\r\n}"]},"metadata":{},"sourceType":"module"}