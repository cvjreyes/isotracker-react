{"ast":null,"code":"import CanvasJSObject from './canvasjs';\nimport { extend, getProperty } from '../helpers/utils';\n\nfunction DataSeries(chart, options, theme, index, id) {\n  DataSeries.base.constructor.call(this, \"DataSeries\", options, theme);\n  this.chart = chart;\n  this.canvas = chart.canvas;\n  this._ctx = chart.canvas.ctx;\n  this.index = index;\n  this.noDataPointsInPlotArea = 0; //this.maxWidthInX = 0;\n\n  this.id = id;\n  this.chart._eventManager.objectMap[id] = {\n    id: id,\n    objectType: \"dataSeries\",\n    dataSeriesIndex: index\n  };\n  this.dataPointIds = [];\n  this.plotUnit = [];\n  this.axisX = null;\n  this.axisY = null;\n\n  if (this.fillOpacity === null) {\n    if (this.type.match(/area/i)) this.fillOpacity = .7;else this.fillOpacity = 1;\n  }\n\n  this.axisPlacement = this.getDefaultAxisPlacement();\n\n  if (typeof this._options.indexLabelFontSize === \"undefined\") {\n    this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize);\n  }\n}\n\nextend(DataSeries, CanvasJSObject); //Static Method that returns the axisPlacement for a given ChartType. Returns one of \"normal\", \"xySwapped\", \"none\"\n\nDataSeries.prototype.getDefaultAxisPlacement = function () {\n  //if (!this.visible)\n  //\treturn \"none\";\n  //type = this.type.toLowerCase();\n  var type = this.type;\n\n  if (type === \"column\" || type === \"line\" || type === \"stepLine\" || type === \"spline\" || type === \"area\" || type === \"stepArea\" || type === \"splineArea\" || type === \"stackedColumn\" || type === \"stackedLine\" || type === \"bubble\" || type === \"scatter\" || type === \"stackedArea\" || type === \"stackedColumn100\" || type === \"stackedLine100\" || type === \"stackedArea100\" || type === \"candlestick\" || type === \"ohlc\" || type === \"rangeColumn\" || type === \"rangeArea\" || type === \"rangeSplineArea\") {\n    return \"normal\";\n  } else if (type === \"bar\" || type === \"stackedBar\" || type === \"stackedBar100\" || type === \"rangeBar\") {\n    return \"xySwapped\";\n  } else if (type === \"pie\" || type === \"doughnut\" || type === \"funnel\") {\n    return \"none\";\n  } else {\n    window.console.log(\"Unknown Chart Type: \" + type);\n    return null;\n  }\n};\n\nDataSeries.getDefaultLegendMarker = function (type) {\n  //type = type.toLowerCase();\n  if (type === \"column\" || type === \"stackedColumn\" || type === \"stackedLine\" || type === \"bar\" || type === \"stackedBar\" || type === \"stackedBar100\" || type === \"bubble\" || type === \"scatter\" || type === \"stackedColumn100\" || type === \"stackedLine100\" || type === \"stepArea\" || type === \"candlestick\" || type === \"ohlc\" || type === \"rangeColumn\" || type === \"rangeBar\" || type === \"rangeArea\" || type === \"rangeSplineArea\") {\n    return \"square\";\n  } else if (type === \"line\" || type === \"stepLine\" || type === \"spline\" || type === \"pie\" || type === \"doughnut\" || type === \"funnel\") {\n    return \"circle\";\n  } else if (type === \"area\" || type === \"splineArea\" || type === \"stackedArea\" || type === \"stackedArea100\") {\n    return \"triangle\";\n  } else {\n    window.console.log(\"Unknown Chart Type: \" + type);\n    return null;\n  }\n}; //Finds dataPoint with the given x value. If findClosest is set, finds dataPoint with closest x value.\n//Returns searchResult object if found, else returns null\n\n\nDataSeries.prototype.getDataPointAtX = function (x, findClosest) {\n  if (!this.dataPoints || this.dataPoints.length === 0) return null;\n  var searchResult = {\n    dataPoint: null,\n    distance: Infinity,\n    index: NaN\n  };\n  var dataPoint = null;\n  var j = 0;\n  var i = 0;\n  var direction = 1; // +1 for foward and -1 for backward.\n\n  var minimumXDistance = Infinity;\n  var forwardMissCount = 0,\n      backwardMissCount = 0;\n  var maxMissCount = 1000;\n  var searchStartIndex = 0;\n\n  if (this.chart.plotInfo.axisPlacement !== \"none\") {\n    //var xRange = (this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x);\n    //if (xRange > 0)\n    //\tsearchStartIndex = ((this.dataPoints.length - 1) / xRange * (x - this.dataPoints[0].x)) >> 0;\n    //else\n    //\tsearchStartIndex = 0;\n    var xRange = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x;\n    if (xRange > 0) searchStartIndex = Math.min(Math.max((this.dataPoints.length - 1) / xRange * (x - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length);else searchStartIndex = 0; //searchStartIndex = ((this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x) / this.dataPoints.length * (x - this.dataPoints[0].x)) >> 0;\n  }\n\n  while (true) {\n    i = direction > 0 ? searchStartIndex + j : searchStartIndex - j;\n\n    if (i >= 0 && i < this.dataPoints.length) {\n      dataPoint = this.dataPoints[i];\n      var distance = Math.abs(dataPoint.x - x);\n\n      if (distance < searchResult.distance) {\n        searchResult.dataPoint = dataPoint;\n        searchResult.distance = distance;\n        searchResult.index = i;\n      }\n\n      var xDistance = Math.abs(dataPoint.x - x);\n      if (xDistance <= minimumXDistance) minimumXDistance = xDistance;else {\n        if (direction > 0) forwardMissCount++;else backwardMissCount++;\n      }\n      if (forwardMissCount > maxMissCount && backwardMissCount > maxMissCount) break;\n    } else if (searchStartIndex - j < 0 && searchStartIndex + j >= this.dataPoints.length) break;\n\n    if (direction === -1) {\n      j++;\n      direction = 1;\n    } else direction = -1;\n  }\n\n  if (!findClosest && searchResult.dataPoint.x === x) return searchResult;else if (findClosest && searchResult.dataPoint !== null) return searchResult;else return null;\n}; // x & y should be in pixels. Can be used only after rendering the chart.\n\n\nDataSeries.prototype.getDataPointAtXY = function (x, y, getClosest) {\n  if (!this.dataPoints || this.dataPoints.length === 0) return null;\n  getClosest = getClosest || false;\n  var results = [];\n  var j = 0,\n      i = 0;\n  var direction = 1; // +1 for foward and -1 for backward.\n\n  var foundDataPoint = false;\n  var minimumXDistance = Infinity;\n  var forwardMissCount = 0,\n      backwardMissCount = 0;\n  var maxMissCount = 1000;\n  var searchStartIndex = 0;\n\n  if (this.chart.plotInfo.axisPlacement !== \"none\") {\n    var xval = this.chart.axisX.getXValueAt({\n      x: x,\n      y: y\n    });\n    var xRange = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x;\n    if (xRange > 0) searchStartIndex = Math.min(Math.max((this.dataPoints.length - 1) / xRange * (xval - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length);else searchStartIndex = 0; //var xRange = (this.axisX._absoluteMaximum - this.axisX._absoluteMinimum);\n    //if (xRange > 0)\n    //\tsearchStartIndex = Math.min(Math.max(((this.dataPoints.length - 1) / xRange * (xval - this.axisX._absoluteMinimum)) >> 0, 0), this.dataPoints.length);\n    //else\n    //\tsearchStartIndex = 0;\n  }\n\n  while (true) {\n    //i = searchStartIndex + (j * direction);\n    i = direction > 0 ? searchStartIndex + j : searchStartIndex - j;\n\n    if (i >= 0 && i < this.dataPoints.length) {\n      var id = this.dataPointIds[i];\n      var visualInfo = this.chart._eventManager.objectMap[id];\n      var dataPoint = this.dataPoints[i];\n      var distance = null;\n\n      if (visualInfo) {\n        switch (this.type) {\n          case \"column\":\n          case \"stackedColumn\":\n          case \"stackedColumn100\":\n          case \"bar\":\n          case \"stackedBar\":\n          case \"stackedBar100\":\n          case \"rangeColumn\":\n          case \"rangeBar\":\n            if (x >= visualInfo.x1 && x <= visualInfo.x2 && y >= visualInfo.y1 && y <= visualInfo.y2) {\n              results.push({\n                dataPoint: dataPoint,\n                dataPointIndex: i,\n                dataSeries: this,\n                distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y1 - y), Math.abs(visualInfo.y2 - y)) //distance:0\n\n              });\n              foundDataPoint = true;\n            }\n\n            break;\n\n          case \"line\":\n          case \"stepLine\":\n          case \"spline\":\n          case \"area\":\n          case \"stepArea\":\n          case \"stackedArea\":\n          case \"stackedArea100\":\n          case \"splineArea\":\n          case \"scatter\":\n            var markerSize = getProperty(\"markerSize\", dataPoint, this) || 4;\n            var snapDistance = getClosest ? 20 : markerSize;\n            distance = Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2));\n\n            if (distance <= snapDistance) {\n              results.push({\n                dataPoint: dataPoint,\n                dataPointIndex: i,\n                dataSeries: this,\n                distance: distance\n              });\n            }\n\n            var xDistance = Math.abs(visualInfo.x1 - x);\n            if (xDistance <= minimumXDistance) minimumXDistance = xDistance;else {\n              if (direction > 0) forwardMissCount++;else backwardMissCount++;\n            }\n\n            if (distance <= markerSize / 2) {\n              foundDataPoint = true;\n            }\n\n            break;\n\n          case \"rangeArea\":\n          case \"rangeSplineArea\":\n            var markerSize = getProperty(\"markerSize\", dataPoint, this) || 4;\n            var snapDistance = getClosest ? 20 : markerSize;\n            distance = Math.min(Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2)), Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y2 - y, 2)));\n\n            if (distance <= snapDistance) {\n              results.push({\n                dataPoint: dataPoint,\n                dataPointIndex: i,\n                dataSeries: this,\n                distance: distance\n              });\n            }\n\n            var xDistance = Math.abs(visualInfo.x1 - x);\n            if (xDistance <= minimumXDistance) minimumXDistance = xDistance;else {\n              if (direction > 0) forwardMissCount++;else backwardMissCount++;\n            }\n\n            if (distance <= markerSize / 2) {\n              foundDataPoint = true;\n            }\n\n            break;\n\n          case \"bubble\":\n            var markerSize = visualInfo.size;\n            distance = Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2));\n\n            if (distance <= markerSize / 2) {\n              results.push({\n                dataPoint: dataPoint,\n                dataPointIndex: i,\n                dataSeries: this,\n                distance: distance\n              });\n              foundDataPoint = true;\n            }\n\n            break;\n\n          case \"pie\":\n          case \"doughnut\":\n            var center = visualInfo.center;\n            var innerRadius = this.type === \"doughnut\" ? visualInfo.percentInnerRadius * visualInfo.radius : 0;\n            distance = Math.sqrt(Math.pow(center.x - x, 2) + Math.pow(center.y - y, 2));\n\n            if (distance < visualInfo.radius && distance > innerRadius) {\n              var deltaY = y - center.y;\n              var deltaX = x - center.x;\n              var angle = Math.atan2(deltaY, deltaX);\n              if (angle < 0) angle += Math.PI * 2;\n              angle = Number(((angle / Math.PI * 180 % 360 + 360) % 360).toFixed(12)); //console.log(angle);\n\n              var startAngle = Number(((visualInfo.startAngle / Math.PI * 180 % 360 + 360) % 360).toFixed(12));\n              var endAngle = Number(((visualInfo.endAngle / Math.PI * 180 % 360 + 360) % 360).toFixed(12)); //So that data point is detected when there is only one dataPoint\n\n              if (endAngle === 0 && visualInfo.endAngle > 1) {\n                endAngle = 360;\n              }\n\n              if (startAngle >= endAngle && dataPoint.y !== 0) {\n                endAngle += 360;\n                if (angle < startAngle) angle += 360;\n              }\n\n              if (angle > startAngle && angle < endAngle) {\n                results.push({\n                  dataPoint: dataPoint,\n                  dataPointIndex: i,\n                  dataSeries: this,\n                  distance: 0\n                });\n                foundDataPoint = true;\n              }\n            }\n\n            break;\n\n          case \"candlestick\":\n            if (x >= visualInfo.x1 - visualInfo.borderThickness / 2 && x <= visualInfo.x2 + visualInfo.borderThickness / 2 && y >= visualInfo.y2 - visualInfo.borderThickness / 2 && y <= visualInfo.y3 + visualInfo.borderThickness / 2 || Math.abs(visualInfo.x2 - x + visualInfo.x1 - x) < visualInfo.borderThickness && y >= visualInfo.y1 && y <= visualInfo.y4) {\n              results.push({\n                dataPoint: dataPoint,\n                dataPointIndex: i,\n                dataSeries: this,\n                distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y2 - y), Math.abs(visualInfo.y3 - y)) //distance:0\n\n              });\n              foundDataPoint = true;\n            }\n\n            break;\n\n          case \"ohlc\":\n            if (Math.abs(visualInfo.x2 - x + visualInfo.x1 - x) < visualInfo.borderThickness && y >= visualInfo.y2 && y <= visualInfo.y3 || x >= visualInfo.x1 && x <= (visualInfo.x2 + visualInfo.x1) / 2 && y >= visualInfo.y1 - visualInfo.borderThickness / 2 && y <= visualInfo.y1 + visualInfo.borderThickness / 2 || x >= (visualInfo.x1 + visualInfo.x2) / 2 && x <= visualInfo.x2 && y >= visualInfo.y4 - visualInfo.borderThickness / 2 && y <= visualInfo.y4 + visualInfo.borderThickness / 2) {\n              results.push({\n                dataPoint: dataPoint,\n                dataPointIndex: i,\n                dataSeries: this,\n                distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y2 - y), Math.abs(visualInfo.y3 - y)) //distance:0\n\n              });\n              foundDataPoint = true;\n            }\n\n            break;\n        }\n\n        if (foundDataPoint || forwardMissCount > maxMissCount && backwardMissCount > maxMissCount) break;\n      }\n    } else if (searchStartIndex - j < 0 && searchStartIndex + j >= this.dataPoints.length) break;\n\n    if (direction === -1) {\n      j++;\n      direction = 1;\n    } else direction = -1;\n  }\n\n  var closestResult = null;\n\n  for (var m = 0; m < results.length; m++) {\n    if (!closestResult) {\n      closestResult = results[m];\n    } else if (results[m].distance <= closestResult.distance) {\n      closestResult = results[m];\n    }\n  } //if (window.console)\n  //\twindow.console.log(\"forwardMissCount: \" + forwardMissCount + \"; backwardMissCount: \" + backwardMissCount + \"; getClosest: \" + getClosest);\n  //if (window.console && closestResult)\n  //    window.console.log(j + \": distance = \" + closestResult.distance);\n\n\n  return closestResult;\n};\n\nDataSeries.prototype.getMarkerProperties = function (index, x, y, ctx) {\n  var dataPoints = this.dataPoints;\n  var dataSeries = this;\n  var markerColor = dataPoints[index].markerColor ? dataPoints[index].markerColor : dataSeries.markerColor ? dataSeries.markerColor : dataPoints[index].color ? dataPoints[index].color : dataSeries.color ? dataSeries.color : dataSeries._colorSet[index % dataSeries._colorSet.length];\n  var markerBorderColor = dataPoints[index].markerBorderColor ? dataPoints[index].markerBorderColor : dataSeries.markerBorderColor ? dataSeries.markerBorderColor : null;\n  var markerBorderThickness = dataPoints[index].markerBorderThickness ? dataPoints[index].markerBorderThickness : dataSeries.markerBorderThickness ? dataSeries.markerBorderThickness : null;\n  var markerType = dataPoints[index].markerType ? dataPoints[index].markerType : dataSeries.markerType;\n  var markerSize = dataPoints[index].markerSize ? dataPoints[index].markerSize : dataSeries.markerSize;\n  return {\n    x: x,\n    y: y,\n    ctx: ctx,\n    type: markerType,\n    size: markerSize,\n    color: markerColor,\n    borderColor: markerBorderColor,\n    borderThickness: markerBorderThickness\n  };\n};\n\nexport default DataSeries;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/canvasjs/src/core/data_series.js"],"names":["CanvasJSObject","extend","getProperty","DataSeries","chart","options","theme","index","id","base","constructor","call","canvas","_ctx","ctx","noDataPointsInPlotArea","_eventManager","objectMap","objectType","dataSeriesIndex","dataPointIds","plotUnit","axisX","axisY","fillOpacity","type","match","axisPlacement","getDefaultAxisPlacement","_options","indexLabelFontSize","getAutoFontSize","prototype","window","console","log","getDefaultLegendMarker","getDataPointAtX","x","findClosest","dataPoints","length","searchResult","dataPoint","distance","Infinity","NaN","j","i","direction","minimumXDistance","forwardMissCount","backwardMissCount","maxMissCount","searchStartIndex","plotInfo","xRange","Math","min","max","abs","xDistance","getDataPointAtXY","y","getClosest","results","foundDataPoint","xval","getXValueAt","visualInfo","x1","x2","y1","y2","push","dataPointIndex","dataSeries","markerSize","snapDistance","sqrt","pow","size","center","innerRadius","percentInnerRadius","radius","deltaY","deltaX","angle","atan2","PI","Number","toFixed","startAngle","endAngle","borderThickness","y3","y4","closestResult","m","getMarkerProperties","markerColor","color","_colorSet","markerBorderColor","markerBorderThickness","markerType","borderColor"],"mappings":"AACA,OAAOA,cAAP,MAA2B,YAA3B;AACA,SAAQC,MAAR,EAAgBC,WAAhB,QAAkC,kBAAlC;;AAEA,SAASC,UAAT,CAAoBC,KAApB,EAA2BC,OAA3B,EAAoCC,KAApC,EAA2CC,KAA3C,EAAkDC,EAAlD,EAAsD;AACpDL,EAAAA,UAAU,CAACM,IAAX,CAAgBC,WAAhB,CAA4BC,IAA5B,CAAiC,IAAjC,EAAuC,YAAvC,EAAqDN,OAArD,EAA8DC,KAA9D;AAEA,OAAKF,KAAL,GAAaA,KAAb;AACA,OAAKQ,MAAL,GAAcR,KAAK,CAACQ,MAApB;AACA,OAAKC,IAAL,GAAYT,KAAK,CAACQ,MAAN,CAAaE,GAAzB;AACA,OAAKP,KAAL,GAAaA,KAAb;AACA,OAAKQ,sBAAL,GAA8B,CAA9B,CAPoD,CAQpD;;AACA,OAAKP,EAAL,GAAUA,EAAV;AACA,OAAKJ,KAAL,CAAWY,aAAX,CAAyBC,SAAzB,CAAmCT,EAAnC,IAAyC;AACvCA,IAAAA,EAAE,EAAEA,EADmC;AAC/BU,IAAAA,UAAU,EAAE,YADmB;AACLC,IAAAA,eAAe,EAAEZ;AADZ,GAAzC;AAGA,OAAKa,YAAL,GAAoB,EAApB;AACA,OAAKC,QAAL,GAAgB,EAAhB;AAEA,OAAKC,KAAL,GAAa,IAAb;AACA,OAAKC,KAAL,GAAa,IAAb;;AAEA,MAAI,KAAKC,WAAL,KAAqB,IAAzB,EAA+B;AAC7B,QAAI,KAAKC,IAAL,CAAUC,KAAV,CAAgB,OAAhB,CAAJ,EACE,KAAKF,WAAL,GAAmB,EAAnB,CADF,KAGE,KAAKA,WAAL,GAAmB,CAAnB;AACH;;AAGD,OAAKG,aAAL,GAAqB,KAAKC,uBAAL,EAArB;;AAEA,MAAI,OAAQ,KAAKC,QAAL,CAAcC,kBAAtB,KAA8C,WAAlD,EAA+D;AAE7D,SAAKA,kBAAL,GAA0B,KAAK1B,KAAL,CAAW2B,eAAX,CAA2B,KAAKD,kBAAhC,CAA1B;AACD;AACF;;AAED7B,MAAM,CAACE,UAAD,EAAaH,cAAb,CAAN,C,CAEA;;AACAG,UAAU,CAAC6B,SAAX,CAAqBJ,uBAArB,GAA+C,YAAY;AAEzD;AACA;AAEA;AACA,MAAIH,IAAI,GAAG,KAAKA,IAAhB;;AAEA,MAAIA,IAAI,KAAK,QAAT,IAAqBA,IAAI,KAAK,MAA9B,IAAwCA,IAAI,KAAK,UAAjD,IAA+DA,IAAI,KAAK,QAAxE,IAAoFA,IAAI,KAAK,MAA7F,IAAuGA,IAAI,KAAK,UAAhH,IAA8HA,IAAI,KAAK,YAAvI,IAAuJA,IAAI,KAAK,eAAhK,IAAmLA,IAAI,KAAK,aAA5L,IAA6MA,IAAI,KAAK,QAAtN,IAAkOA,IAAI,KAAK,SAA3O,IACCA,IAAI,KAAK,aADV,IAC2BA,IAAI,KAAK,kBADpC,IAC0DA,IAAI,KAAK,gBADnE,IACuFA,IAAI,KAAK,gBADhG,IAECA,IAAI,KAAK,aAFV,IAE2BA,IAAI,KAAK,MAFpC,IAE8CA,IAAI,KAAK,aAFvD,IAEwEA,IAAI,KAAK,WAFjF,IAEgGA,IAAI,KAAK,iBAF7G,EAEgI;AAC9H,WAAO,QAAP;AACD,GAJD,MAKK,IAAIA,IAAI,KAAK,KAAT,IAAkBA,IAAI,KAAK,YAA3B,IAA2CA,IAAI,KAAK,eAApD,IAAuEA,IAAI,KAAK,UAApF,EAAgG;AAEnG,WAAO,WAAP;AACD,GAHI,MAIA,IAAIA,IAAI,KAAK,KAAT,IAAkBA,IAAI,KAAK,UAA3B,IAAyCA,IAAI,KAAK,QAAtD,EAAgE;AACnE,WAAO,MAAP;AACD,GAFI,MAEE;AACLQ,IAAAA,MAAM,CAACC,OAAP,CAAeC,GAAf,CAAmB,yBAAyBV,IAA5C;AACA,WAAO,IAAP;AACD;AACF,CAvBD;;AAyBAtB,UAAU,CAACiC,sBAAX,GAAoC,UAAUX,IAAV,EAAgB;AAElD;AAEA,MAAIA,IAAI,KAAK,QAAT,IAAqBA,IAAI,KAAK,eAA9B,IAAiDA,IAAI,KAAK,aAA1D,IAA2EA,IAAI,KAAK,KAApF,IAA6FA,IAAI,KAAK,YAAtG,IAAsHA,IAAI,KAAK,eAA/H,IACCA,IAAI,KAAK,QADV,IACsBA,IAAI,KAAK,SAD/B,IAECA,IAAI,KAAK,kBAFV,IAEgCA,IAAI,KAAK,gBAFzC,IAE6DA,IAAI,KAAK,UAFtE,IAGCA,IAAI,KAAK,aAHV,IAG2BA,IAAI,KAAK,MAHpC,IAG8CA,IAAI,KAAK,aAHvD,IAGwEA,IAAI,KAAK,UAHjF,IAG+FA,IAAI,KAAK,WAHxG,IAGuHA,IAAI,KAAK,iBAHpI,EAGuJ;AACrJ,WAAO,QAAP;AACD,GALD,MAMK,IAAIA,IAAI,KAAK,MAAT,IAAmBA,IAAI,KAAK,UAA5B,IAA0CA,IAAI,KAAK,QAAnD,IAA+DA,IAAI,KAAK,KAAxE,IAAiFA,IAAI,KAAK,UAA1F,IAAwGA,IAAI,KAAK,QAArH,EAA+H;AAClI,WAAO,QAAP;AACD,GAFI,MAEE,IAAIA,IAAI,KAAK,MAAT,IAAmBA,IAAI,KAAK,YAA5B,IAA4CA,IAAI,KAAK,aAArD,IAAsEA,IAAI,KAAK,gBAAnF,EAAqG;AAC1G,WAAO,UAAP;AACD,GAFM,MAEA;AACLQ,IAAAA,MAAM,CAACC,OAAP,CAAeC,GAAf,CAAmB,yBAAyBV,IAA5C;AACA,WAAO,IAAP;AACD;AACF,CAlBD,C,CAoBA;AACA;;;AACAtB,UAAU,CAAC6B,SAAX,CAAqBK,eAArB,GAAuC,UAAUC,CAAV,EAAaC,WAAb,EAA0B;AAE/D,MAAI,CAAC,KAAKC,UAAN,IAAoB,KAAKA,UAAL,CAAgBC,MAAhB,KAA2B,CAAnD,EAAsD,OAAO,IAAP;AAEtD,MAAIC,YAAY,GAAG;AACjBC,IAAAA,SAAS,EAAE,IADM;AACAC,IAAAA,QAAQ,EAAEC,QADV;AACoBtC,IAAAA,KAAK,EAAEuC;AAD3B,GAAnB;AAGA,MAAIH,SAAS,GAAG,IAAhB;AAEA,MAAII,CAAC,GAAG,CAAR;AACA,MAAIC,CAAC,GAAG,CAAR;AACA,MAAIC,SAAS,GAAG,CAAhB,CAX+D,CAW5C;;AAEnB,MAAIC,gBAAgB,GAAGL,QAAvB;AACA,MAAIM,gBAAgB,GAAG,CAAvB;AAAA,MAA0BC,iBAAiB,GAAG,CAA9C;AACA,MAAIC,YAAY,GAAG,IAAnB;AACA,MAAIC,gBAAgB,GAAG,CAAvB;;AAEA,MAAI,KAAKlD,KAAL,CAAWmD,QAAX,CAAoB5B,aAApB,KAAsC,MAA1C,EAAkD;AAEhD;AAEA;AACA;AACA;AACA;AAEA,QAAI6B,MAAM,GAAI,KAAKhB,UAAL,CAAgB,KAAKA,UAAL,CAAgBC,MAAhB,GAAyB,CAAzC,EAA4CH,CAA5C,GAAgD,KAAKE,UAAL,CAAgB,CAAhB,EAAmBF,CAAjF;AAEA,QAAIkB,MAAM,GAAG,CAAb,EACEF,gBAAgB,GAAGG,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,GAAL,CAAU,CAAC,KAAKnB,UAAL,CAAgBC,MAAhB,GAAyB,CAA1B,IAA+Be,MAA/B,IAAyClB,CAAC,GAAG,KAAKE,UAAL,CAAgB,CAAhB,EAAmBF,CAAhE,CAAD,IAAwE,CAAjF,EAAoF,CAApF,CAAT,EAAiG,KAAKE,UAAL,CAAgBC,MAAjH,CAAnB,CADF,KAGEa,gBAAgB,GAAG,CAAnB,CAd8C,CAgBhD;AACD;;AAED,SAAO,IAAP,EAAa;AAEXN,IAAAA,CAAC,GAAIC,SAAS,GAAG,CAAb,GAAkBK,gBAAgB,GAAGP,CAArC,GAAyCO,gBAAgB,GAAGP,CAAhE;;AAEA,QAAIC,CAAC,IAAI,CAAL,IAAUA,CAAC,GAAG,KAAKR,UAAL,CAAgBC,MAAlC,EAA0C;AAExCE,MAAAA,SAAS,GAAG,KAAKH,UAAL,CAAgBQ,CAAhB,CAAZ;AAEA,UAAIJ,QAAQ,GAAGa,IAAI,CAACG,GAAL,CAASjB,SAAS,CAACL,CAAV,GAAcA,CAAvB,CAAf;;AAEA,UAAIM,QAAQ,GAAGF,YAAY,CAACE,QAA5B,EAAsC;AACpCF,QAAAA,YAAY,CAACC,SAAb,GAAyBA,SAAzB;AACAD,QAAAA,YAAY,CAACE,QAAb,GAAwBA,QAAxB;AACAF,QAAAA,YAAY,CAACnC,KAAb,GAAqByC,CAArB;AACD;;AAED,UAAIa,SAAS,GAAGJ,IAAI,CAACG,GAAL,CAASjB,SAAS,CAACL,CAAV,GAAcA,CAAvB,CAAhB;AACA,UAAIuB,SAAS,IAAIX,gBAAjB,EACEA,gBAAgB,GAAGW,SAAnB,CADF,KAEK;AACH,YAAIZ,SAAS,GAAG,CAAhB,EACEE,gBAAgB,GADlB,KAGEC,iBAAiB;AACpB;AAED,UAAID,gBAAgB,GAAGE,YAAnB,IAAmCD,iBAAiB,GAAGC,YAA3D,EACE;AAGH,KA1BD,MA0BO,IAAIC,gBAAgB,GAAGP,CAAnB,GAAuB,CAAvB,IAA4BO,gBAAgB,GAAGP,CAAnB,IAAwB,KAAKP,UAAL,CAAgBC,MAAxE,EACL;;AAEF,QAAIQ,SAAS,KAAK,CAAC,CAAnB,EAAsB;AACpBF,MAAAA,CAAC;AACDE,MAAAA,SAAS,GAAG,CAAZ;AACD,KAHD,MAIEA,SAAS,GAAG,CAAC,CAAb;AACH;;AAGD,MAAI,CAACV,WAAD,IAAgBG,YAAY,CAACC,SAAb,CAAuBL,CAAvB,KAA6BA,CAAjD,EACE,OAAOI,YAAP,CADF,KAEK,IAAIH,WAAW,IAAIG,YAAY,CAACC,SAAb,KAA2B,IAA9C,EACH,OAAOD,YAAP,CADG,KAGH,OAAO,IAAP;AACH,CApFD,C,CAsFA;;;AACAvC,UAAU,CAAC6B,SAAX,CAAqB8B,gBAArB,GAAwC,UAAUxB,CAAV,EAAayB,CAAb,EAAgBC,UAAhB,EAA4B;AAElE,MAAI,CAAC,KAAKxB,UAAN,IAAoB,KAAKA,UAAL,CAAgBC,MAAhB,KAA2B,CAAnD,EAAsD,OAAO,IAAP;AAEtDuB,EAAAA,UAAU,GAAGA,UAAU,IAAI,KAA3B;AACA,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIlB,CAAC,GAAG,CAAR;AAAA,MAAWC,CAAC,GAAG,CAAf;AACA,MAAIC,SAAS,GAAG,CAAhB,CAPkE,CAO/C;;AACnB,MAAIiB,cAAc,GAAG,KAArB;AACA,MAAIhB,gBAAgB,GAAGL,QAAvB;AACA,MAAIM,gBAAgB,GAAG,CAAvB;AAAA,MAA0BC,iBAAiB,GAAG,CAA9C;AACA,MAAIC,YAAY,GAAG,IAAnB;AACA,MAAIC,gBAAgB,GAAG,CAAvB;;AAEA,MAAI,KAAKlD,KAAL,CAAWmD,QAAX,CAAoB5B,aAApB,KAAsC,MAA1C,EAAkD;AAChD,QAAIwC,IAAI,GAAG,KAAK/D,KAAL,CAAWkB,KAAX,CAAiB8C,WAAjB,CAA6B;AAAE9B,MAAAA,CAAC,EAAEA,CAAL;AAAQyB,MAAAA,CAAC,EAAEA;AAAX,KAA7B,CAAX;AAEA,QAAIP,MAAM,GAAI,KAAKhB,UAAL,CAAgB,KAAKA,UAAL,CAAgBC,MAAhB,GAAyB,CAAzC,EAA4CH,CAA5C,GAAgD,KAAKE,UAAL,CAAgB,CAAhB,EAAmBF,CAAjF;AAEA,QAAIkB,MAAM,GAAG,CAAb,EACEF,gBAAgB,GAAGG,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,GAAL,CAAU,CAAC,KAAKnB,UAAL,CAAgBC,MAAhB,GAAyB,CAA1B,IAA+Be,MAA/B,IAAyCW,IAAI,GAAG,KAAK3B,UAAL,CAAgB,CAAhB,EAAmBF,CAAnE,CAAD,IAA2E,CAApF,EAAuF,CAAvF,CAAT,EAAoG,KAAKE,UAAL,CAAgBC,MAApH,CAAnB,CADF,KAGEa,gBAAgB,GAAG,CAAnB,CAR8C,CAUhD;AAEA;AACA;AACA;AACA;AACD;;AAED,SAAO,IAAP,EAAa;AAEX;AACAN,IAAAA,CAAC,GAAIC,SAAS,GAAG,CAAb,GAAkBK,gBAAgB,GAAGP,CAArC,GAAyCO,gBAAgB,GAAGP,CAAhE;;AAEA,QAAIC,CAAC,IAAI,CAAL,IAAUA,CAAC,GAAG,KAAKR,UAAL,CAAgBC,MAAlC,EAA0C;AAExC,UAAIjC,EAAE,GAAG,KAAKY,YAAL,CAAkB4B,CAAlB,CAAT;AACA,UAAIqB,UAAU,GAAG,KAAKjE,KAAL,CAAWY,aAAX,CAAyBC,SAAzB,CAAmCT,EAAnC,CAAjB;AACA,UAAImC,SAAS,GAAG,KAAKH,UAAL,CAAgBQ,CAAhB,CAAhB;AACA,UAAIJ,QAAQ,GAAG,IAAf;;AAEA,UAAIyB,UAAJ,EAAgB;AAEd,gBAAQ,KAAK5C,IAAb;AAEE,eAAK,QAAL;AACA,eAAK,eAAL;AACA,eAAK,kBAAL;AACA,eAAK,KAAL;AACA,eAAK,YAAL;AACA,eAAK,eAAL;AACA,eAAK,aAAL;AACA,eAAK,UAAL;AAEE,gBAAIa,CAAC,IAAI+B,UAAU,CAACC,EAAhB,IAAsBhC,CAAC,IAAI+B,UAAU,CAACE,EAAtC,IAA4CR,CAAC,IAAIM,UAAU,CAACG,EAA5D,IAAkET,CAAC,IAAIM,UAAU,CAACI,EAAtF,EAA0F;AACxFR,cAAAA,OAAO,CAACS,IAAR,CAAa;AACX/B,gBAAAA,SAAS,EAAEA,SADA;AAEXgC,gBAAAA,cAAc,EAAE3B,CAFL;AAGX4B,gBAAAA,UAAU,EAAE,IAHD;AAIXhC,gBAAAA,QAAQ,EAAEa,IAAI,CAACC,GAAL,CAASD,IAAI,CAACG,GAAL,CAASS,UAAU,CAACC,EAAX,GAAgBhC,CAAzB,CAAT,EAAsCmB,IAAI,CAACG,GAAL,CAASS,UAAU,CAACE,EAAX,GAAgBjC,CAAzB,CAAtC,EAAmEmB,IAAI,CAACG,GAAL,CAASS,UAAU,CAACG,EAAX,GAAgBT,CAAzB,CAAnE,EAAgGN,IAAI,CAACG,GAAL,CAASS,UAAU,CAACI,EAAX,GAAgBV,CAAzB,CAAhG,CAJC,CAKX;;AALW,eAAb;AAQAG,cAAAA,cAAc,GAAG,IAAjB;AACD;;AACD;;AAEF,eAAK,MAAL;AACA,eAAK,UAAL;AACA,eAAK,QAAL;AACA,eAAK,MAAL;AACA,eAAK,UAAL;AACA,eAAK,aAAL;AACA,eAAK,gBAAL;AACA,eAAK,YAAL;AACA,eAAK,SAAL;AACE,gBAAIW,UAAU,GAAG3E,WAAW,CAAC,YAAD,EAAeyC,SAAf,EAA0B,IAA1B,CAAX,IAA8C,CAA/D;AACA,gBAAImC,YAAY,GAAGd,UAAU,GAAG,EAAH,GAAQa,UAArC;AAEAjC,YAAAA,QAAQ,GAAGa,IAAI,CAACsB,IAAL,CAAUtB,IAAI,CAACuB,GAAL,CAASX,UAAU,CAACC,EAAX,GAAgBhC,CAAzB,EAA4B,CAA5B,IAAiCmB,IAAI,CAACuB,GAAL,CAASX,UAAU,CAACG,EAAX,GAAgBT,CAAzB,EAA4B,CAA5B,CAA3C,CAAX;;AACA,gBAAInB,QAAQ,IAAIkC,YAAhB,EAA8B;AAC5Bb,cAAAA,OAAO,CAACS,IAAR,CAAa;AACX/B,gBAAAA,SAAS,EAAEA,SADA;AAEXgC,gBAAAA,cAAc,EAAE3B,CAFL;AAGX4B,gBAAAA,UAAU,EAAE,IAHD;AAIXhC,gBAAAA,QAAQ,EAAEA;AAJC,eAAb;AAMD;;AAED,gBAAIiB,SAAS,GAAGJ,IAAI,CAACG,GAAL,CAASS,UAAU,CAACC,EAAX,GAAgBhC,CAAzB,CAAhB;AACA,gBAAIuB,SAAS,IAAIX,gBAAjB,EACEA,gBAAgB,GAAGW,SAAnB,CADF,KAEK;AACH,kBAAIZ,SAAS,GAAG,CAAhB,EACEE,gBAAgB,GADlB,KAGEC,iBAAiB;AACpB;;AAED,gBAAIR,QAAQ,IAAIiC,UAAU,GAAG,CAA7B,EAAgC;AAC9BX,cAAAA,cAAc,GAAG,IAAjB;AACD;;AAED;;AAEF,eAAK,WAAL;AACA,eAAK,iBAAL;AAEE,gBAAIW,UAAU,GAAG3E,WAAW,CAAC,YAAD,EAAeyC,SAAf,EAA0B,IAA1B,CAAX,IAA8C,CAA/D;AACA,gBAAImC,YAAY,GAAGd,UAAU,GAAG,EAAH,GAAQa,UAArC;AAEAjC,YAAAA,QAAQ,GAAGa,IAAI,CAACC,GAAL,CAASD,IAAI,CAACsB,IAAL,CAAUtB,IAAI,CAACuB,GAAL,CAASX,UAAU,CAACC,EAAX,GAAgBhC,CAAzB,EAA4B,CAA5B,IAAiCmB,IAAI,CAACuB,GAAL,CAASX,UAAU,CAACG,EAAX,GAAgBT,CAAzB,EAA4B,CAA5B,CAA3C,CAAT,EAAqFN,IAAI,CAACsB,IAAL,CAAUtB,IAAI,CAACuB,GAAL,CAASX,UAAU,CAACC,EAAX,GAAgBhC,CAAzB,EAA4B,CAA5B,IAAiCmB,IAAI,CAACuB,GAAL,CAASX,UAAU,CAACI,EAAX,GAAgBV,CAAzB,EAA4B,CAA5B,CAA3C,CAArF,CAAX;;AACA,gBAAInB,QAAQ,IAAIkC,YAAhB,EAA8B;AAC5Bb,cAAAA,OAAO,CAACS,IAAR,CAAa;AACX/B,gBAAAA,SAAS,EAAEA,SADA;AAEXgC,gBAAAA,cAAc,EAAE3B,CAFL;AAGX4B,gBAAAA,UAAU,EAAE,IAHD;AAIXhC,gBAAAA,QAAQ,EAAEA;AAJC,eAAb;AAMD;;AAED,gBAAIiB,SAAS,GAAGJ,IAAI,CAACG,GAAL,CAASS,UAAU,CAACC,EAAX,GAAgBhC,CAAzB,CAAhB;AACA,gBAAIuB,SAAS,IAAIX,gBAAjB,EACEA,gBAAgB,GAAGW,SAAnB,CADF,KAEK;AACH,kBAAIZ,SAAS,GAAG,CAAhB,EACEE,gBAAgB,GADlB,KAGEC,iBAAiB;AACpB;;AAED,gBAAIR,QAAQ,IAAIiC,UAAU,GAAG,CAA7B,EAAgC;AAC9BX,cAAAA,cAAc,GAAG,IAAjB;AACD;;AAED;;AAEF,eAAK,QAAL;AACE,gBAAIW,UAAU,GAAGR,UAAU,CAACY,IAA5B;AACArC,YAAAA,QAAQ,GAAGa,IAAI,CAACsB,IAAL,CAAUtB,IAAI,CAACuB,GAAL,CAASX,UAAU,CAACC,EAAX,GAAgBhC,CAAzB,EAA4B,CAA5B,IAAiCmB,IAAI,CAACuB,GAAL,CAASX,UAAU,CAACG,EAAX,GAAgBT,CAAzB,EAA4B,CAA5B,CAA3C,CAAX;;AACA,gBAAInB,QAAQ,IAAIiC,UAAU,GAAG,CAA7B,EAAgC;AAC9BZ,cAAAA,OAAO,CAACS,IAAR,CAAa;AACX/B,gBAAAA,SAAS,EAAEA,SADA;AAEXgC,gBAAAA,cAAc,EAAE3B,CAFL;AAGX4B,gBAAAA,UAAU,EAAE,IAHD;AAIXhC,gBAAAA,QAAQ,EAAEA;AAJC,eAAb;AAOAsB,cAAAA,cAAc,GAAG,IAAjB;AACD;;AACD;;AAEF,eAAK,KAAL;AACA,eAAK,UAAL;AACE,gBAAIgB,MAAM,GAAGb,UAAU,CAACa,MAAxB;AACA,gBAAIC,WAAW,GAAG,KAAK1D,IAAL,KAAc,UAAd,GAA2B4C,UAAU,CAACe,kBAAX,GAAgCf,UAAU,CAACgB,MAAtE,GAA+E,CAAjG;AAEAzC,YAAAA,QAAQ,GAAGa,IAAI,CAACsB,IAAL,CAAUtB,IAAI,CAACuB,GAAL,CAASE,MAAM,CAAC5C,CAAP,GAAWA,CAApB,EAAuB,CAAvB,IAA4BmB,IAAI,CAACuB,GAAL,CAASE,MAAM,CAACnB,CAAP,GAAWA,CAApB,EAAuB,CAAvB,CAAtC,CAAX;;AACA,gBAAInB,QAAQ,GAAGyB,UAAU,CAACgB,MAAtB,IAAgCzC,QAAQ,GAAGuC,WAA/C,EAA4D;AAE1D,kBAAIG,MAAM,GAAGvB,CAAC,GAAGmB,MAAM,CAACnB,CAAxB;AACA,kBAAIwB,MAAM,GAAGjD,CAAC,GAAG4C,MAAM,CAAC5C,CAAxB;AACA,kBAAIkD,KAAK,GAAG/B,IAAI,CAACgC,KAAL,CAAWH,MAAX,EAAmBC,MAAnB,CAAZ;AAEA,kBAAIC,KAAK,GAAG,CAAZ,EACEA,KAAK,IAAI/B,IAAI,CAACiC,EAAL,GAAU,CAAnB;AAEFF,cAAAA,KAAK,GAAGG,MAAM,CAAC,CAAC,CAAEH,KAAK,GAAG/B,IAAI,CAACiC,EAAb,GAAkB,GAAlB,GAAwB,GAAzB,GAAgC,GAAjC,IAAwC,GAAzC,EAA8CE,OAA9C,CAAsD,EAAtD,CAAD,CAAd,CAT0D,CAU1D;;AAGA,kBAAIC,UAAU,GAAGF,MAAM,CAAC,CAAC,CAAEtB,UAAU,CAACwB,UAAX,GAAwBpC,IAAI,CAACiC,EAA7B,GAAkC,GAAlC,GAAwC,GAAzC,GAAgD,GAAjD,IAAwD,GAAzD,EAA8DE,OAA9D,CAAsE,EAAtE,CAAD,CAAvB;AACA,kBAAIE,QAAQ,GAAGH,MAAM,CAAC,CAAC,CAAEtB,UAAU,CAACyB,QAAX,GAAsBrC,IAAI,CAACiC,EAA3B,GAAgC,GAAhC,GAAsC,GAAvC,GAA8C,GAA/C,IAAsD,GAAvD,EAA4DE,OAA5D,CAAoE,EAApE,CAAD,CAArB,CAd0D,CAgB1D;;AACA,kBAAIE,QAAQ,KAAK,CAAb,IAAkBzB,UAAU,CAACyB,QAAX,GAAsB,CAA5C,EAA+C;AAC7CA,gBAAAA,QAAQ,GAAG,GAAX;AACD;;AAED,kBAAID,UAAU,IAAIC,QAAd,IAA0BnD,SAAS,CAACoB,CAAV,KAAgB,CAA9C,EAAiD;AAC/C+B,gBAAAA,QAAQ,IAAI,GAAZ;AAEA,oBAAIN,KAAK,GAAGK,UAAZ,EACEL,KAAK,IAAI,GAAT;AACH;;AAGD,kBAAIA,KAAK,GAAGK,UAAR,IAAsBL,KAAK,GAAGM,QAAlC,EAA4C;AAC1C7B,gBAAAA,OAAO,CAACS,IAAR,CAAa;AACX/B,kBAAAA,SAAS,EAAEA,SADA;AAEXgC,kBAAAA,cAAc,EAAE3B,CAFL;AAGX4B,kBAAAA,UAAU,EAAE,IAHD;AAIXhC,kBAAAA,QAAQ,EAAE;AAJC,iBAAb;AAOAsB,gBAAAA,cAAc,GAAG,IAAjB;AACD;AAEF;;AAED;;AAEF,eAAK,aAAL;AACE,gBAAM5B,CAAC,IAAK+B,UAAU,CAACC,EAAX,GAAgBD,UAAU,CAAC0B,eAAX,GAA6B,CAApD,IAA4DzD,CAAC,IAAK+B,UAAU,CAACE,EAAX,GAAgBF,UAAU,CAAC0B,eAAX,GAA6B,CAA/G,IACChC,CAAC,IAAIM,UAAU,CAACI,EAAX,GAAgBJ,UAAU,CAAC0B,eAAX,GAA6B,CADnD,IAC0DhC,CAAC,IAAIM,UAAU,CAAC2B,EAAX,GAAgB3B,UAAU,CAAC0B,eAAX,GAA6B,CAD7G,IAEEtC,IAAI,CAACG,GAAL,CAASS,UAAU,CAACE,EAAX,GAAgBjC,CAAhB,GAAoB+B,UAAU,CAACC,EAA/B,GAAoChC,CAA7C,IAAkD+B,UAAU,CAAC0B,eAA7D,IAAiFhC,CAAC,IAAIM,UAAU,CAACG,EAAhB,IAAsBT,CAAC,IAAIM,UAAU,CAAC4B,EAF7H,EAEmI;AACjIhC,cAAAA,OAAO,CAACS,IAAR,CAAa;AACX/B,gBAAAA,SAAS,EAAEA,SADA;AAEXgC,gBAAAA,cAAc,EAAE3B,CAFL;AAGX4B,gBAAAA,UAAU,EAAE,IAHD;AAIXhC,gBAAAA,QAAQ,EAAEa,IAAI,CAACC,GAAL,CAASD,IAAI,CAACG,GAAL,CAASS,UAAU,CAACC,EAAX,GAAgBhC,CAAzB,CAAT,EAAsCmB,IAAI,CAACG,GAAL,CAASS,UAAU,CAACE,EAAX,GAAgBjC,CAAzB,CAAtC,EAAmEmB,IAAI,CAACG,GAAL,CAASS,UAAU,CAACI,EAAX,GAAgBV,CAAzB,CAAnE,EAAgGN,IAAI,CAACG,GAAL,CAASS,UAAU,CAAC2B,EAAX,GAAgBjC,CAAzB,CAAhG,CAJC,CAKX;;AALW,eAAb;AAQAG,cAAAA,cAAc,GAAG,IAAjB;AACD;;AACD;;AAEF,eAAK,MAAL;AAEE,gBAAKT,IAAI,CAACG,GAAL,CAASS,UAAU,CAACE,EAAX,GAAgBjC,CAAhB,GAAoB+B,UAAU,CAACC,EAA/B,GAAoChC,CAA7C,IAAkD+B,UAAU,CAAC0B,eAA7D,IAAiFhC,CAAC,IAAIM,UAAU,CAACI,EAAhB,IAAsBV,CAAC,IAAIM,UAAU,CAAC2B,EAAxH,IAEE1D,CAAC,IAAI+B,UAAU,CAACC,EAAhB,IAAuBhC,CAAC,IAAI,CAAC+B,UAAU,CAACE,EAAX,GAAgBF,UAAU,CAACC,EAA5B,IAAkC,CAA9D,IACEP,CAAC,IAAIM,UAAU,CAACG,EAAX,GAAgBH,UAAU,CAAC0B,eAAX,GAA6B,CADpD,IAC2DhC,CAAC,IAAIM,UAAU,CAACG,EAAX,GAAgBH,UAAU,CAAC0B,eAAX,GAA6B,CAH/G,IAKGzD,CAAC,IAAI,CAAC+B,UAAU,CAACC,EAAX,GAAgBD,UAAU,CAACE,EAA5B,IAAkC,CAAxC,IAA+CjC,CAAC,IAAI+B,UAAU,CAACE,EAA/D,IACER,CAAC,IAAIM,UAAU,CAAC4B,EAAX,GAAgB5B,UAAU,CAAC0B,eAAX,GAA6B,CADpD,IAC2DhC,CAAC,IAAIM,UAAU,CAAC4B,EAAX,GAAgB5B,UAAU,CAAC0B,eAAX,GAA6B,CANnH,EAMwH;AAEtH9B,cAAAA,OAAO,CAACS,IAAR,CAAa;AACX/B,gBAAAA,SAAS,EAAEA,SADA;AAEXgC,gBAAAA,cAAc,EAAE3B,CAFL;AAGX4B,gBAAAA,UAAU,EAAE,IAHD;AAIXhC,gBAAAA,QAAQ,EAAEa,IAAI,CAACC,GAAL,CAASD,IAAI,CAACG,GAAL,CAASS,UAAU,CAACC,EAAX,GAAgBhC,CAAzB,CAAT,EAAsCmB,IAAI,CAACG,GAAL,CAASS,UAAU,CAACE,EAAX,GAAgBjC,CAAzB,CAAtC,EAAmEmB,IAAI,CAACG,GAAL,CAASS,UAAU,CAACI,EAAX,GAAgBV,CAAzB,CAAnE,EAAgGN,IAAI,CAACG,GAAL,CAASS,UAAU,CAAC2B,EAAX,GAAgBjC,CAAzB,CAAhG,CAJC,CAKX;;AALW,eAAb;AAQAG,cAAAA,cAAc,GAAG,IAAjB;AACD;;AACD;AAnMJ;;AAuMA,YAAIA,cAAc,IAAKf,gBAAgB,GAAGE,YAAnB,IAAmCD,iBAAiB,GAAGC,YAA9E,EACE;AACH;AAEF,KApND,MAoNO,IAAIC,gBAAgB,GAAGP,CAAnB,GAAuB,CAAvB,IAA4BO,gBAAgB,GAAGP,CAAnB,IAAwB,KAAKP,UAAL,CAAgBC,MAAxE,EACL;;AAEF,QAAIQ,SAAS,KAAK,CAAC,CAAnB,EAAsB;AACpBF,MAAAA,CAAC;AACDE,MAAAA,SAAS,GAAG,CAAZ;AACD,KAHD,MAIEA,SAAS,GAAG,CAAC,CAAb;AAEH;;AAID,MAAIiD,aAAa,GAAG,IAApB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlC,OAAO,CAACxB,MAA5B,EAAoC0D,CAAC,EAArC,EAAyC;AACvC,QAAI,CAACD,aAAL,EAAoB;AAClBA,MAAAA,aAAa,GAAGjC,OAAO,CAACkC,CAAD,CAAvB;AACD,KAFD,MAEO,IAAIlC,OAAO,CAACkC,CAAD,CAAP,CAAWvD,QAAX,IAAuBsD,aAAa,CAACtD,QAAzC,EAAmD;AACxDsD,MAAAA,aAAa,GAAGjC,OAAO,CAACkC,CAAD,CAAvB;AACD;AACF,GA9QiE,CAgRlE;AACA;AAEA;AACA;;;AAEA,SAAOD,aAAP;AACD,CAvRD;;AAyRA/F,UAAU,CAAC6B,SAAX,CAAqBoE,mBAArB,GAA2C,UAAU7F,KAAV,EAAiB+B,CAAjB,EAAoByB,CAApB,EAAuBjD,GAAvB,EAA4B;AACrE,MAAI0B,UAAU,GAAG,KAAKA,UAAtB;AACA,MAAIoC,UAAU,GAAG,IAAjB;AAEA,MAAIyB,WAAW,GAAG7D,UAAU,CAACjC,KAAD,CAAV,CAAkB8F,WAAlB,GAAgC7D,UAAU,CAACjC,KAAD,CAAV,CAAkB8F,WAAlD,GAAgEzB,UAAU,CAACyB,WAAX,GAAyBzB,UAAU,CAACyB,WAApC,GAAkD7D,UAAU,CAACjC,KAAD,CAAV,CAAkB+F,KAAlB,GAA0B9D,UAAU,CAACjC,KAAD,CAAV,CAAkB+F,KAA5C,GAAoD1B,UAAU,CAAC0B,KAAX,GAAmB1B,UAAU,CAAC0B,KAA9B,GAAsC1B,UAAU,CAAC2B,SAAX,CAAqBhG,KAAK,GAAGqE,UAAU,CAAC2B,SAAX,CAAqB9D,MAAlD,CAA9N;AACA,MAAI+D,iBAAiB,GAAGhE,UAAU,CAACjC,KAAD,CAAV,CAAkBiG,iBAAlB,GAAsChE,UAAU,CAACjC,KAAD,CAAV,CAAkBiG,iBAAxD,GAA4E5B,UAAU,CAAC4B,iBAAX,GAA+B5B,UAAU,CAAC4B,iBAA1C,GAA8D,IAAlK;AACA,MAAIC,qBAAqB,GAAGjE,UAAU,CAACjC,KAAD,CAAV,CAAkBkG,qBAAlB,GAA0CjE,UAAU,CAACjC,KAAD,CAAV,CAAkBkG,qBAA5D,GAAoF7B,UAAU,CAAC6B,qBAAX,GAAmC7B,UAAU,CAAC6B,qBAA9C,GAAsE,IAAtL;AACA,MAAIC,UAAU,GAAGlE,UAAU,CAACjC,KAAD,CAAV,CAAkBmG,UAAlB,GAA+BlE,UAAU,CAACjC,KAAD,CAAV,CAAkBmG,UAAjD,GAA8D9B,UAAU,CAAC8B,UAA1F;AACA,MAAI7B,UAAU,GAAGrC,UAAU,CAACjC,KAAD,CAAV,CAAkBsE,UAAlB,GAA+BrC,UAAU,CAACjC,KAAD,CAAV,CAAkBsE,UAAjD,GAA8DD,UAAU,CAACC,UAA1F;AAGA,SAAO;AACLvC,IAAAA,CAAC,EAAEA,CADE;AACCyB,IAAAA,CAAC,EAAEA,CADJ;AACOjD,IAAAA,GAAG,EAAEA,GADZ;AAELW,IAAAA,IAAI,EAAEiF,UAFD;AAGLzB,IAAAA,IAAI,EAAEJ,UAHD;AAILyB,IAAAA,KAAK,EAAED,WAJF;AAKLM,IAAAA,WAAW,EAAEH,iBALR;AAMLT,IAAAA,eAAe,EAAEU;AANZ,GAAP;AAQD,CAnBD;;AAqBA,eAAetG,UAAf","sourcesContent":["\r\nimport CanvasJSObject from './canvasjs';\r\nimport {extend, getProperty} from '../helpers/utils';\r\n\r\nfunction DataSeries(chart, options, theme, index, id) {\r\n  DataSeries.base.constructor.call(this, \"DataSeries\", options, theme);\r\n\r\n  this.chart = chart;\r\n  this.canvas = chart.canvas;\r\n  this._ctx = chart.canvas.ctx;\r\n  this.index = index;\r\n  this.noDataPointsInPlotArea = 0;\r\n  //this.maxWidthInX = 0;\r\n  this.id = id;\r\n  this.chart._eventManager.objectMap[id] = {\r\n    id: id, objectType: \"dataSeries\", dataSeriesIndex: index\r\n  }\r\n  this.dataPointIds = [];\r\n  this.plotUnit = [];\r\n\r\n  this.axisX = null;\r\n  this.axisY = null;\r\n\r\n  if (this.fillOpacity === null) {\r\n    if (this.type.match(/area/i))\r\n      this.fillOpacity = .7;\r\n    else\r\n      this.fillOpacity = 1;\r\n  }\r\n\r\n\r\n  this.axisPlacement = this.getDefaultAxisPlacement();\r\n\r\n  if (typeof (this._options.indexLabelFontSize) === \"undefined\") {\r\n\r\n    this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize);\r\n  }\r\n}\r\n\r\nextend(DataSeries, CanvasJSObject);\r\n\r\n//Static Method that returns the axisPlacement for a given ChartType. Returns one of \"normal\", \"xySwapped\", \"none\"\r\nDataSeries.prototype.getDefaultAxisPlacement = function () {\r\n\r\n  //if (!this.visible)\r\n  //\treturn \"none\";\r\n\r\n  //type = this.type.toLowerCase();\r\n  var type = this.type;\r\n\r\n  if (type === \"column\" || type === \"line\" || type === \"stepLine\" || type === \"spline\" || type === \"area\" || type === \"stepArea\" || type === \"splineArea\" || type === \"stackedColumn\" || type === \"stackedLine\" || type === \"bubble\" || type === \"scatter\"\r\n    || type === \"stackedArea\" || type === \"stackedColumn100\" || type === \"stackedLine100\" || type === \"stackedArea100\"\r\n    || type === \"candlestick\" || type === \"ohlc\" || type === \"rangeColumn\" || type === \"rangeArea\" || type === \"rangeSplineArea\") {\r\n    return \"normal\";\r\n  }\r\n  else if (type === \"bar\" || type === \"stackedBar\" || type === \"stackedBar100\" || type === \"rangeBar\") {\r\n\r\n    return \"xySwapped\";\r\n  }\r\n  else if (type === \"pie\" || type === \"doughnut\" || type === \"funnel\") {\r\n    return \"none\";\r\n  } else {\r\n    window.console.log(\"Unknown Chart Type: \" + type);\r\n    return null;\r\n  }\r\n}\r\n\r\nDataSeries.getDefaultLegendMarker = function (type) {\r\n\r\n  //type = type.toLowerCase();\r\n\r\n  if (type === \"column\" || type === \"stackedColumn\" || type === \"stackedLine\" || type === \"bar\" || type === \"stackedBar\" || type === \"stackedBar100\"\r\n    || type === \"bubble\" || type === \"scatter\"\r\n    || type === \"stackedColumn100\" || type === \"stackedLine100\" || type === \"stepArea\"\r\n    || type === \"candlestick\" || type === \"ohlc\" || type === \"rangeColumn\" || type === \"rangeBar\" || type === \"rangeArea\" || type === \"rangeSplineArea\") {\r\n    return \"square\";\r\n  }\r\n  else if (type === \"line\" || type === \"stepLine\" || type === \"spline\" || type === \"pie\" || type === \"doughnut\" || type === \"funnel\") {\r\n    return \"circle\";\r\n  } else if (type === \"area\" || type === \"splineArea\" || type === \"stackedArea\" || type === \"stackedArea100\") {\r\n    return \"triangle\"\r\n  } else {\r\n    window.console.log(\"Unknown Chart Type: \" + type);\r\n    return null;\r\n  }\r\n}\r\n\r\n//Finds dataPoint with the given x value. If findClosest is set, finds dataPoint with closest x value.\r\n//Returns searchResult object if found, else returns null\r\nDataSeries.prototype.getDataPointAtX = function (x, findClosest) {\r\n\r\n  if (!this.dataPoints || this.dataPoints.length === 0) return null;\r\n\r\n  var searchResult = {\r\n    dataPoint: null, distance: Infinity, index: NaN\r\n  };\r\n  var dataPoint = null;\r\n\r\n  var j = 0;\r\n  var i = 0;\r\n  var direction = 1; // +1 for foward and -1 for backward.\r\n\r\n  var minimumXDistance = Infinity;\r\n  var forwardMissCount = 0, backwardMissCount = 0;\r\n  var maxMissCount = 1000;\r\n  var searchStartIndex = 0;\r\n\r\n  if (this.chart.plotInfo.axisPlacement !== \"none\") {\r\n\r\n    //var xRange = (this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x);\r\n\r\n    //if (xRange > 0)\r\n    //\tsearchStartIndex = ((this.dataPoints.length - 1) / xRange * (x - this.dataPoints[0].x)) >> 0;\r\n    //else\r\n    //\tsearchStartIndex = 0;\r\n\r\n    var xRange = (this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x);\r\n\r\n    if (xRange > 0)\r\n      searchStartIndex = Math.min(Math.max(((this.dataPoints.length - 1) / xRange * (x - this.dataPoints[0].x)) >> 0, 0), this.dataPoints.length);\r\n    else\r\n      searchStartIndex = 0;\r\n\r\n    //searchStartIndex = ((this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x) / this.dataPoints.length * (x - this.dataPoints[0].x)) >> 0;\r\n  }\r\n\r\n  while (true) {\r\n\r\n    i = (direction > 0) ? searchStartIndex + j : searchStartIndex - j;\r\n\r\n    if (i >= 0 && i < this.dataPoints.length) {\r\n\r\n      dataPoint = this.dataPoints[i];\r\n\r\n      var distance = Math.abs(dataPoint.x - x);\r\n\r\n      if (distance < searchResult.distance) {\r\n        searchResult.dataPoint = dataPoint;\r\n        searchResult.distance = distance;\r\n        searchResult.index = i;\r\n      }\r\n\r\n      var xDistance = Math.abs(dataPoint.x - x);\r\n      if (xDistance <= minimumXDistance)\r\n        minimumXDistance = xDistance;\r\n      else {\r\n        if (direction > 0)\r\n          forwardMissCount++;\r\n        else\r\n          backwardMissCount++;\r\n      }\r\n\r\n      if (forwardMissCount > maxMissCount && backwardMissCount > maxMissCount)\r\n        break;\r\n\r\n\r\n    } else if (searchStartIndex - j < 0 && searchStartIndex + j >= this.dataPoints.length)\r\n      break;\r\n\r\n    if (direction === -1) {\r\n      j++;\r\n      direction = 1;\r\n    } else\r\n      direction = -1;\r\n  }\r\n\r\n\r\n  if (!findClosest && searchResult.dataPoint.x === x)\r\n    return searchResult;\r\n  else if (findClosest && searchResult.dataPoint !== null)\r\n    return searchResult;\r\n  else\r\n    return null;\r\n}\r\n\r\n// x & y should be in pixels. Can be used only after rendering the chart.\r\nDataSeries.prototype.getDataPointAtXY = function (x, y, getClosest) {\r\n\r\n  if (!this.dataPoints || this.dataPoints.length === 0) return null;\r\n\r\n  getClosest = getClosest || false;\r\n  var results = [];\r\n  var j = 0, i = 0;\r\n  var direction = 1; // +1 for foward and -1 for backward.\r\n  var foundDataPoint = false;\r\n  var minimumXDistance = Infinity;\r\n  var forwardMissCount = 0, backwardMissCount = 0;\r\n  var maxMissCount = 1000;\r\n  var searchStartIndex = 0;\r\n\r\n  if (this.chart.plotInfo.axisPlacement !== \"none\") {\r\n    var xval = this.chart.axisX.getXValueAt({ x: x, y: y });\r\n\r\n    var xRange = (this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x);\r\n\r\n    if (xRange > 0)\r\n      searchStartIndex = Math.min(Math.max(((this.dataPoints.length - 1) / xRange * (xval - this.dataPoints[0].x)) >> 0, 0), this.dataPoints.length);\r\n    else\r\n      searchStartIndex = 0;\r\n\r\n    //var xRange = (this.axisX._absoluteMaximum - this.axisX._absoluteMinimum);\r\n\r\n    //if (xRange > 0)\r\n    //\tsearchStartIndex = Math.min(Math.max(((this.dataPoints.length - 1) / xRange * (xval - this.axisX._absoluteMinimum)) >> 0, 0), this.dataPoints.length);\r\n    //else\r\n    //\tsearchStartIndex = 0;\r\n  }\r\n\r\n  while (true) {\r\n\r\n    //i = searchStartIndex + (j * direction);\r\n    i = (direction > 0) ? searchStartIndex + j : searchStartIndex - j;\r\n\r\n    if (i >= 0 && i < this.dataPoints.length) {\r\n\r\n      var id = this.dataPointIds[i];\r\n      var visualInfo = this.chart._eventManager.objectMap[id];\r\n      var dataPoint = this.dataPoints[i];\r\n      var distance = null;\r\n\r\n      if (visualInfo) {\r\n\r\n        switch (this.type) {\r\n\r\n          case \"column\":\r\n          case \"stackedColumn\":\r\n          case \"stackedColumn100\":\r\n          case \"bar\":\r\n          case \"stackedBar\":\r\n          case \"stackedBar100\":\r\n          case \"rangeColumn\":\r\n          case \"rangeBar\":\r\n\r\n            if (x >= visualInfo.x1 && x <= visualInfo.x2 && y >= visualInfo.y1 && y <= visualInfo.y2) {\r\n              results.push({\r\n                dataPoint: dataPoint,\r\n                dataPointIndex: i,\r\n                dataSeries: this,\r\n                distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y1 - y), Math.abs(visualInfo.y2 - y))\r\n                //distance:0\r\n              });\r\n\r\n              foundDataPoint = true;\r\n            }\r\n            break;\r\n\r\n          case \"line\":\r\n          case \"stepLine\":\r\n          case \"spline\":\r\n          case \"area\":\r\n          case \"stepArea\":\r\n          case \"stackedArea\":\r\n          case \"stackedArea100\":\r\n          case \"splineArea\":\r\n          case \"scatter\":\r\n            var markerSize = getProperty(\"markerSize\", dataPoint, this) || 4;\r\n            var snapDistance = getClosest ? 20 : markerSize;\r\n\r\n            distance = Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2));\r\n            if (distance <= snapDistance) {\r\n              results.push({\r\n                dataPoint: dataPoint,\r\n                dataPointIndex: i,\r\n                dataSeries: this,\r\n                distance: distance\r\n              });\r\n            }\r\n\r\n            var xDistance = Math.abs(visualInfo.x1 - x);\r\n            if (xDistance <= minimumXDistance)\r\n              minimumXDistance = xDistance;\r\n            else {\r\n              if (direction > 0)\r\n                forwardMissCount++;\r\n              else\r\n                backwardMissCount++;\r\n            }\r\n\r\n            if (distance <= markerSize / 2) {\r\n              foundDataPoint = true;\r\n            }\r\n\r\n            break;\r\n\r\n          case \"rangeArea\":\r\n          case \"rangeSplineArea\":\r\n\r\n            var markerSize = getProperty(\"markerSize\", dataPoint, this) || 4;\r\n            var snapDistance = getClosest ? 20 : markerSize;\r\n\r\n            distance = Math.min(Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2)), Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y2 - y, 2)));\r\n            if (distance <= snapDistance) {\r\n              results.push({\r\n                dataPoint: dataPoint,\r\n                dataPointIndex: i,\r\n                dataSeries: this,\r\n                distance: distance\r\n              });\r\n            }\r\n\r\n            var xDistance = Math.abs(visualInfo.x1 - x);\r\n            if (xDistance <= minimumXDistance)\r\n              minimumXDistance = xDistance;\r\n            else {\r\n              if (direction > 0)\r\n                forwardMissCount++;\r\n              else\r\n                backwardMissCount++;\r\n            }\r\n\r\n            if (distance <= markerSize / 2) {\r\n              foundDataPoint = true;\r\n            }\r\n\r\n            break;\r\n\r\n          case \"bubble\":\r\n            var markerSize = visualInfo.size;\r\n            distance = Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2));\r\n            if (distance <= markerSize / 2) {\r\n              results.push({\r\n                dataPoint: dataPoint,\r\n                dataPointIndex: i,\r\n                dataSeries: this,\r\n                distance: distance\r\n              });\r\n\r\n              foundDataPoint = true;\r\n            }\r\n            break;\r\n\r\n          case \"pie\":\r\n          case \"doughnut\":\r\n            var center = visualInfo.center;\r\n            var innerRadius = this.type === \"doughnut\" ? visualInfo.percentInnerRadius * visualInfo.radius : 0;\r\n\r\n            distance = Math.sqrt(Math.pow(center.x - x, 2) + Math.pow(center.y - y, 2));\r\n            if (distance < visualInfo.radius && distance > innerRadius) {\r\n\r\n              var deltaY = y - center.y;\r\n              var deltaX = x - center.x;\r\n              var angle = Math.atan2(deltaY, deltaX);\r\n\r\n              if (angle < 0)\r\n                angle += Math.PI * 2;\r\n\r\n              angle = Number((((angle / Math.PI * 180 % 360) + 360) % 360).toFixed(12));\r\n              //console.log(angle);\r\n\r\n\r\n              var startAngle = Number((((visualInfo.startAngle / Math.PI * 180 % 360) + 360) % 360).toFixed(12));\r\n              var endAngle = Number((((visualInfo.endAngle / Math.PI * 180 % 360) + 360) % 360).toFixed(12));\r\n\r\n              //So that data point is detected when there is only one dataPoint\r\n              if (endAngle === 0 && visualInfo.endAngle > 1) {\r\n                endAngle = 360;\r\n              }\r\n\r\n              if (startAngle >= endAngle && dataPoint.y !== 0) {\r\n                endAngle += 360;\r\n\r\n                if (angle < startAngle)\r\n                  angle += 360;\r\n              }\r\n\r\n\r\n              if (angle > startAngle && angle < endAngle) {\r\n                results.push({\r\n                  dataPoint: dataPoint,\r\n                  dataPointIndex: i,\r\n                  dataSeries: this,\r\n                  distance: 0\r\n                });\r\n\r\n                foundDataPoint = true;\r\n              }\r\n\r\n            }\r\n\r\n            break;\r\n\r\n          case \"candlestick\":\r\n            if (((x >= (visualInfo.x1 - visualInfo.borderThickness / 2)) && (x <= (visualInfo.x2 + visualInfo.borderThickness / 2))\r\n              && (y >= visualInfo.y2 - visualInfo.borderThickness / 2) && (y <= visualInfo.y3 + visualInfo.borderThickness / 2))\r\n              || (Math.abs(visualInfo.x2 - x + visualInfo.x1 - x) < visualInfo.borderThickness && (y >= visualInfo.y1 && y <= visualInfo.y4))) {\r\n              results.push({\r\n                dataPoint: dataPoint,\r\n                dataPointIndex: i,\r\n                dataSeries: this,\r\n                distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y2 - y), Math.abs(visualInfo.y3 - y))\r\n                //distance:0\r\n              });\r\n\r\n              foundDataPoint = true;\r\n            }\r\n            break;\r\n\r\n          case \"ohlc\":\r\n\r\n            if ((Math.abs(visualInfo.x2 - x + visualInfo.x1 - x) < visualInfo.borderThickness && (y >= visualInfo.y2 && y <= visualInfo.y3))\r\n\r\n              || (x >= visualInfo.x1 && (x <= (visualInfo.x2 + visualInfo.x1) / 2)\r\n                && (y >= visualInfo.y1 - visualInfo.borderThickness / 2) && (y <= visualInfo.y1 + visualInfo.borderThickness / 2))\r\n\r\n              || ((x >= (visualInfo.x1 + visualInfo.x2) / 2) && (x <= visualInfo.x2)\r\n                && (y >= visualInfo.y4 - visualInfo.borderThickness / 2) && (y <= visualInfo.y4 + visualInfo.borderThickness / 2))) {\r\n\r\n              results.push({\r\n                dataPoint: dataPoint,\r\n                dataPointIndex: i,\r\n                dataSeries: this,\r\n                distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y2 - y), Math.abs(visualInfo.y3 - y))\r\n                //distance:0\r\n              });\r\n\r\n              foundDataPoint = true;\r\n            }\r\n            break;\r\n\r\n        }\r\n\r\n        if (foundDataPoint || (forwardMissCount > maxMissCount && backwardMissCount > maxMissCount))\r\n          break;\r\n      }\r\n\r\n    } else if (searchStartIndex - j < 0 && searchStartIndex + j >= this.dataPoints.length)\r\n      break;\r\n\r\n    if (direction === -1) {\r\n      j++;\r\n      direction = 1;\r\n    } else\r\n      direction = -1;\r\n\r\n  }\r\n\r\n\r\n\r\n  var closestResult = null;\r\n\r\n  for (var m = 0; m < results.length; m++) {\r\n    if (!closestResult) {\r\n      closestResult = results[m];\r\n    } else if (results[m].distance <= closestResult.distance) {\r\n      closestResult = results[m];\r\n    }\r\n  }\r\n\r\n  //if (window.console)\r\n  //\twindow.console.log(\"forwardMissCount: \" + forwardMissCount + \"; backwardMissCount: \" + backwardMissCount + \"; getClosest: \" + getClosest);\r\n\r\n  //if (window.console && closestResult)\r\n  //    window.console.log(j + \": distance = \" + closestResult.distance);\r\n\r\n  return closestResult;\r\n}\r\n\r\nDataSeries.prototype.getMarkerProperties = function (index, x, y, ctx) {\r\n  var dataPoints = this.dataPoints;\r\n  var dataSeries = this;\r\n\r\n  var markerColor = dataPoints[index].markerColor ? dataPoints[index].markerColor : dataSeries.markerColor ? dataSeries.markerColor : dataPoints[index].color ? dataPoints[index].color : dataSeries.color ? dataSeries.color : dataSeries._colorSet[index % dataSeries._colorSet.length];\r\n  var markerBorderColor = dataPoints[index].markerBorderColor ? dataPoints[index].markerBorderColor : dataSeries.markerBorderColor ? dataSeries.markerBorderColor : null;\r\n  var markerBorderThickness = dataPoints[index].markerBorderThickness ? dataPoints[index].markerBorderThickness : dataSeries.markerBorderThickness ? dataSeries.markerBorderThickness : null;\r\n  var markerType = dataPoints[index].markerType ? dataPoints[index].markerType : dataSeries.markerType;\r\n  var markerSize = dataPoints[index].markerSize ? dataPoints[index].markerSize : dataSeries.markerSize;\r\n\r\n\r\n  return {\r\n    x: x, y: y, ctx: ctx,\r\n    type: markerType,\r\n    size: markerSize,\r\n    color: markerColor,\r\n    borderColor: markerBorderColor,\r\n    borderThickness: markerBorderThickness\r\n  }\r\n}\r\n\r\nexport default DataSeries;\r\n"]},"metadata":{},"sourceType":"module"}