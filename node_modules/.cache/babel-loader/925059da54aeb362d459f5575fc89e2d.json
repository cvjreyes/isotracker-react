{"ast":null,"code":"var _templateObject;\n\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\n\nimport { toSingleLine } from \"../../../../helpers/templateLiteralTag.mjs\";\n/**\r\n * @param {TreeNode} nodeToProcess A tree node to process.\r\n * @param {number} gridColumnIndex The visual column index that triggers the node modification.\r\n *                                 The index can be between the root node column index and\r\n *                                 column index plus node colspan length.\r\n */\n\nexport function hideColumn(nodeToProcess, gridColumnIndex) {\n  if (!Number.isInteger(gridColumnIndex)) {\n    throw new Error('The passed gridColumnIndex argument has invalid type.');\n  }\n\n  if (nodeToProcess.childs.length > 0) {\n    throw new Error(toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"The passed node is not the last node on the tree. Only for \\nthe last node, the hide column modification can be applied.\"], [\"The passed node is not the last node on the tree. Only for\\\\x20\\nthe last node, the hide column modification can be applied.\"]))));\n  }\n\n  var crossHiddenColumns = nodeToProcess.data.crossHiddenColumns;\n\n  if (crossHiddenColumns.includes(gridColumnIndex)) {\n    return;\n  }\n\n  var isCollapsibleNode = false;\n  nodeToProcess.walkUp(function (node) {\n    var collapsible = node.data.collapsible;\n\n    if (collapsible) {\n      isCollapsibleNode = true;\n      return false; // Cancel tree traversing\n    }\n  }); // TODO: When the node is collapsible do not hide the column. Currently collapsible headers\n  // does not work with hidden columns (hidden index map types).\n\n  if (isCollapsibleNode) {\n    return;\n  }\n\n  nodeToProcess.walkUp(function (node) {\n    var data = node.data;\n    data.crossHiddenColumns.push(gridColumnIndex);\n\n    if (data.colspan > 1) {\n      data.colspan -= 1;\n    } else {\n      data.isHidden = true;\n    }\n  });\n}","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/hideColumn.mjs"],"names":["_templateObject","_taggedTemplateLiteral","strings","raw","slice","Object","freeze","defineProperties","value","toSingleLine","hideColumn","nodeToProcess","gridColumnIndex","Number","isInteger","Error","childs","length","crossHiddenColumns","data","includes","isCollapsibleNode","walkUp","node","collapsible","push","colspan","isHidden"],"mappings":"AAGA,IAAIA,eAAJ;;AAEA,SAASC,sBAAT,CAAgCC,OAAhC,EAAyCC,GAAzC,EAA8C;AAAE,MAAI,CAACA,GAAL,EAAU;AAAEA,IAAAA,GAAG,GAAGD,OAAO,CAACE,KAAR,CAAc,CAAd,CAAN;AAAyB;;AAAC,SAAOC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACE,gBAAP,CAAwBL,OAAxB,EAAiC;AAAEC,IAAAA,GAAG,EAAE;AAAEK,MAAAA,KAAK,EAAEH,MAAM,CAACC,MAAP,CAAcH,GAAd;AAAT;AAAP,GAAjC,CAAd,CAAP;AAAiG;;AAMvL,SAASM,YAAT,QAA6B,4CAA7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,UAAT,CAAoBC,aAApB,EAAmCC,eAAnC,EAAoD;AACzD,MAAI,CAACC,MAAM,CAACC,SAAP,CAAiBF,eAAjB,CAAL,EAAwC;AACtC,UAAM,IAAIG,KAAJ,CAAU,uDAAV,CAAN;AACD;;AAED,MAAIJ,aAAa,CAACK,MAAd,CAAqBC,MAArB,GAA8B,CAAlC,EAAqC;AACnC,UAAM,IAAIF,KAAJ,CAAUN,YAAY,CAACT,eAAe,KAAKA,eAAe,GAAGC,sBAAsB,CAAC,CAAC,0HAAD,CAAD,EAA+H,CAAC,8HAAD,CAA/H,CAA7C,CAAhB,CAAtB,CAAN;AACD;;AAED,MAAIiB,kBAAkB,GAAGP,aAAa,CAACQ,IAAd,CAAmBD,kBAA5C;;AAEA,MAAIA,kBAAkB,CAACE,QAAnB,CAA4BR,eAA5B,CAAJ,EAAkD;AAChD;AACD;;AAED,MAAIS,iBAAiB,GAAG,KAAxB;AACAV,EAAAA,aAAa,CAACW,MAAd,CAAqB,UAAUC,IAAV,EAAgB;AACnC,QAAIC,WAAW,GAAGD,IAAI,CAACJ,IAAL,CAAUK,WAA5B;;AAEA,QAAIA,WAAJ,EAAiB;AACfH,MAAAA,iBAAiB,GAAG,IAApB;AACA,aAAO,KAAP,CAFe,CAED;AACf;AACF,GAPD,EAhByD,CAuBrD;AACJ;;AAEA,MAAIA,iBAAJ,EAAuB;AACrB;AACD;;AAEDV,EAAAA,aAAa,CAACW,MAAd,CAAqB,UAAUC,IAAV,EAAgB;AACnC,QAAIJ,IAAI,GAAGI,IAAI,CAACJ,IAAhB;AACAA,IAAAA,IAAI,CAACD,kBAAL,CAAwBO,IAAxB,CAA6Bb,eAA7B;;AAEA,QAAIO,IAAI,CAACO,OAAL,GAAe,CAAnB,EAAsB;AACpBP,MAAAA,IAAI,CAACO,OAAL,IAAgB,CAAhB;AACD,KAFD,MAEO;AACLP,MAAAA,IAAI,CAACQ,QAAL,GAAgB,IAAhB;AACD;AACF,GATD;AAUD","sourcesContent":["import \"core-js/modules/es.array.slice.js\";\r\nimport \"core-js/modules/es.object.freeze.js\";\r\n\r\nvar _templateObject;\r\n\r\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\r\n\r\nimport \"core-js/modules/es.number.is-integer.js\";\r\nimport \"core-js/modules/es.number.constructor.js\";\r\nimport \"core-js/modules/es.array.includes.js\";\r\nimport \"core-js/modules/es.string.includes.js\";\r\nimport { toSingleLine } from \"../../../../helpers/templateLiteralTag.mjs\";\r\n/**\r\n * @param {TreeNode} nodeToProcess A tree node to process.\r\n * @param {number} gridColumnIndex The visual column index that triggers the node modification.\r\n *                                 The index can be between the root node column index and\r\n *                                 column index plus node colspan length.\r\n */\r\n\r\nexport function hideColumn(nodeToProcess, gridColumnIndex) {\r\n  if (!Number.isInteger(gridColumnIndex)) {\r\n    throw new Error('The passed gridColumnIndex argument has invalid type.');\r\n  }\r\n\r\n  if (nodeToProcess.childs.length > 0) {\r\n    throw new Error(toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"The passed node is not the last node on the tree. Only for \\nthe last node, the hide column modification can be applied.\"], [\"The passed node is not the last node on the tree. Only for\\\\x20\\nthe last node, the hide column modification can be applied.\"]))));\r\n  }\r\n\r\n  var crossHiddenColumns = nodeToProcess.data.crossHiddenColumns;\r\n\r\n  if (crossHiddenColumns.includes(gridColumnIndex)) {\r\n    return;\r\n  }\r\n\r\n  var isCollapsibleNode = false;\r\n  nodeToProcess.walkUp(function (node) {\r\n    var collapsible = node.data.collapsible;\r\n\r\n    if (collapsible) {\r\n      isCollapsibleNode = true;\r\n      return false; // Cancel tree traversing\r\n    }\r\n  }); // TODO: When the node is collapsible do not hide the column. Currently collapsible headers\r\n  // does not work with hidden columns (hidden index map types).\r\n\r\n  if (isCollapsibleNode) {\r\n    return;\r\n  }\r\n\r\n  nodeToProcess.walkUp(function (node) {\r\n    var data = node.data;\r\n    data.crossHiddenColumns.push(gridColumnIndex);\r\n\r\n    if (data.colspan > 1) {\r\n      data.colspan -= 1;\r\n    } else {\r\n      data.isHidden = true;\r\n    }\r\n  });\r\n}"]},"metadata":{},"sourceType":"module"}