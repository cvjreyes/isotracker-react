{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { innerHeight, innerWidth, getScrollLeft, getScrollTop, offset } from \"./../../../helpers/dom/element.mjs\";\n/**\r\n * @class Scroll\r\n */\n\nvar Scroll = /*#__PURE__*/function () {\n  /**\r\n   * @param {Walkontable} wotInstance The Walkontable instance.\r\n   */\n  function Scroll(wotInstance) {\n    _classCallCheck(this, Scroll);\n\n    this.wot = wotInstance;\n  }\n  /**\r\n   * Scrolls viewport to a cell.\r\n   *\r\n   * @param {CellCoords} coords The cell coordinates.\r\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\r\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\r\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\r\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\r\n   * @returns {boolean}\r\n   */\n\n\n  _createClass(Scroll, [{\n    key: \"scrollViewport\",\n    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n      if (coords.col < 0 || coords.row < 0) {\n        return false;\n      }\n\n      var scrolledHorizontally = this.scrollViewportHorizontally(coords.col, snapToRight, snapToLeft);\n      var scrolledVertically = this.scrollViewportVertically(coords.row, snapToTop, snapToBottom);\n      return scrolledHorizontally || scrolledVertically;\n    }\n    /**\r\n     * Scrolls viewport to a column.\r\n     *\r\n     * @param {number} column Visual column index.\r\n     * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\r\n     * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"scrollViewportHorizontally\",\n    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n      if (!this.wot.drawn) {\n        return false;\n      }\n\n      var _this$_getVariables = this._getVariables(),\n          fixedColumnsLeft = _this$_getVariables.fixedColumnsLeft,\n          leftOverlay = _this$_getVariables.leftOverlay,\n          totalColumns = _this$_getVariables.totalColumns;\n\n      var result = false;\n\n      if (column >= 0 && column <= Math.max(totalColumns - 1, 0)) {\n        var firstVisibleColumn = this.getFirstVisibleColumn();\n        var lastVisibleColumn = this.getLastVisibleColumn();\n\n        if (column >= fixedColumnsLeft && firstVisibleColumn > -1 && (column < firstVisibleColumn || snapToLeft)) {\n          result = leftOverlay.scrollTo(column);\n        } else if (lastVisibleColumn === -1 || lastVisibleColumn > -1 && (column > lastVisibleColumn || snapToRight)) {\n          result = leftOverlay.scrollTo(column, true);\n        }\n      }\n\n      return result;\n    }\n    /**\r\n     * Scrolls viewport to a row.\r\n     *\r\n     * @param {number} row Visual row index.\r\n     * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\r\n     * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"scrollViewportVertically\",\n    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {\n      if (!this.wot.drawn) {\n        return false;\n      }\n\n      var _this$_getVariables2 = this._getVariables(),\n          fixedRowsBottom = _this$_getVariables2.fixedRowsBottom,\n          fixedRowsTop = _this$_getVariables2.fixedRowsTop,\n          topOverlay = _this$_getVariables2.topOverlay,\n          totalRows = _this$_getVariables2.totalRows;\n\n      var result = false;\n\n      if (row >= 0 && row <= Math.max(totalRows - 1, 0)) {\n        var firstVisibleRow = this.getFirstVisibleRow();\n        var lastVisibleRow = this.getLastVisibleRow();\n\n        if (row >= fixedRowsTop && firstVisibleRow > -1 && (row < firstVisibleRow || snapToTop)) {\n          result = topOverlay.scrollTo(row);\n        } else if (lastVisibleRow === -1 || lastVisibleRow > -1 && (row > lastVisibleRow && row < totalRows - fixedRowsBottom || snapToBottom)) {\n          result = topOverlay.scrollTo(row, true);\n        }\n      }\n\n      return result;\n    }\n    /**\r\n     * Get first visible row based on virtual dom and how table is visible in browser window viewport.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getFirstVisibleRow\",\n    value: function getFirstVisibleRow() {\n      var _this$_getVariables3 = this._getVariables(),\n          topOverlay = _this$_getVariables3.topOverlay,\n          wtTable = _this$_getVariables3.wtTable,\n          wtViewport = _this$_getVariables3.wtViewport,\n          totalRows = _this$_getVariables3.totalRows,\n          fixedRowsTop = _this$_getVariables3.fixedRowsTop;\n\n      var rootWindow = this.wot.rootWindow;\n      var firstVisibleRow = wtTable.getFirstVisibleRow();\n\n      if (topOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = offset(wtTable.wtRootElement);\n        var totalTableHeight = innerHeight(wtTable.hider);\n        var windowHeight = innerHeight(rootWindow);\n        var windowScrollTop = getScrollTop(rootWindow, rootWindow); // Only calculate firstVisibleRow when table didn't filled (from up) whole viewport space\n\n        if (rootElementOffset.top + totalTableHeight - windowHeight <= windowScrollTop) {\n          var rowsHeight = wtViewport.getColumnHeaderHeight();\n          rowsHeight += topOverlay.sumCellSizes(0, fixedRowsTop);\n\n          for (var row = totalRows; row > 0; row--) {\n            rowsHeight += topOverlay.sumCellSizes(row - 1, row);\n\n            if (rootElementOffset.top + totalTableHeight - rowsHeight <= windowScrollTop) {\n              // Return physical row + 1\n              firstVisibleRow = row;\n              break;\n            }\n          }\n        }\n      }\n\n      return firstVisibleRow;\n    }\n    /**\r\n     * Get last visible row based on virtual dom and how table is visible in browser window viewport.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getLastVisibleRow\",\n    value: function getLastVisibleRow() {\n      var _this$_getVariables4 = this._getVariables(),\n          topOverlay = _this$_getVariables4.topOverlay,\n          wtTable = _this$_getVariables4.wtTable,\n          wtViewport = _this$_getVariables4.wtViewport,\n          totalRows = _this$_getVariables4.totalRows;\n\n      var rootWindow = this.wot.rootWindow;\n      var lastVisibleRow = wtTable.getLastVisibleRow();\n\n      if (topOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = offset(wtTable.wtRootElement);\n        var windowScrollTop = getScrollTop(rootWindow, rootWindow); // Only calculate lastVisibleRow when table didn't filled (from bottom) whole viewport space\n\n        if (rootElementOffset.top > windowScrollTop) {\n          var windowHeight = innerHeight(rootWindow);\n          var rowsHeight = wtViewport.getColumnHeaderHeight();\n\n          for (var row = 1; row <= totalRows; row++) {\n            rowsHeight += topOverlay.sumCellSizes(row - 1, row);\n\n            if (rootElementOffset.top + rowsHeight - windowScrollTop >= windowHeight) {\n              // Return physical row - 1 (-2 because rangeEach gives row index + 1 - sumCellSizes requirements)\n              lastVisibleRow = row - 2;\n              break;\n            }\n          }\n        }\n      }\n\n      return lastVisibleRow;\n    }\n    /**\r\n     * Get first visible column based on virtual dom and how table is visible in browser window viewport.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getFirstVisibleColumn\",\n    value: function getFirstVisibleColumn() {\n      var _this$_getVariables5 = this._getVariables(),\n          leftOverlay = _this$_getVariables5.leftOverlay,\n          wtTable = _this$_getVariables5.wtTable,\n          wtViewport = _this$_getVariables5.wtViewport,\n          totalColumns = _this$_getVariables5.totalColumns;\n\n      var rootWindow = this.wot.rootWindow;\n      var firstVisibleColumn = wtTable.getFirstVisibleColumn();\n\n      if (leftOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = offset(wtTable.wtRootElement);\n        var totalTableWidth = innerWidth(wtTable.hider);\n        var windowWidth = innerWidth(rootWindow);\n        var windowScrollLeft = getScrollLeft(rootWindow, rootWindow); // Only calculate firstVisibleColumn when table didn't filled (from left) whole viewport space\n\n        if (rootElementOffset.left + totalTableWidth - windowWidth <= windowScrollLeft) {\n          var columnsWidth = wtViewport.getRowHeaderWidth();\n\n          for (var column = totalColumns; column > 0; column--) {\n            columnsWidth += leftOverlay.sumCellSizes(column - 1, column);\n\n            if (rootElementOffset.left + totalTableWidth - columnsWidth <= windowScrollLeft) {\n              // Return physical column + 1\n              firstVisibleColumn = column;\n              break;\n            }\n          }\n        }\n      }\n\n      return firstVisibleColumn;\n    }\n    /**\r\n     * Get last visible column based on virtual dom and how table is visible in browser window viewport.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getLastVisibleColumn\",\n    value: function getLastVisibleColumn() {\n      var _this$_getVariables6 = this._getVariables(),\n          leftOverlay = _this$_getVariables6.leftOverlay,\n          wtTable = _this$_getVariables6.wtTable,\n          wtViewport = _this$_getVariables6.wtViewport,\n          totalColumns = _this$_getVariables6.totalColumns;\n\n      var rootWindow = this.wot.rootWindow;\n      var lastVisibleColumn = wtTable.getLastVisibleColumn();\n\n      if (leftOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = offset(wtTable.wtRootElement);\n        var windowScrollLeft = getScrollLeft(rootWindow, rootWindow); // Only calculate lastVisibleColumn when table didn't filled (from right) whole viewport space\n\n        if (rootElementOffset.left > windowScrollLeft) {\n          var windowWidth = innerWidth(rootWindow);\n          var columnsWidth = wtViewport.getRowHeaderWidth();\n\n          for (var column = 1; column <= totalColumns; column++) {\n            columnsWidth += leftOverlay.sumCellSizes(column - 1, column);\n\n            if (rootElementOffset.left + columnsWidth - windowScrollLeft >= windowWidth) {\n              // Return physical column - 1 (-2 because rangeEach gives column index + 1 - sumCellSizes requirements)\n              lastVisibleColumn = column - 2;\n              break;\n            }\n          }\n        }\n      }\n\n      return lastVisibleColumn;\n    }\n    /**\r\n     * Returns collection of variables used to rows and columns visibility calculations.\r\n     *\r\n     * @returns {object}\r\n     * @private\r\n     */\n\n  }, {\n    key: \"_getVariables\",\n    value: function _getVariables() {\n      var wot = this.wot;\n      var topOverlay = wot.wtOverlays.topOverlay;\n      var leftOverlay = wot.wtOverlays.leftOverlay;\n      var wtTable = wot.wtTable;\n      var wtViewport = wot.wtViewport;\n      var totalRows = wot.getSetting('totalRows');\n      var totalColumns = wot.getSetting('totalColumns');\n      var fixedRowsTop = wot.getSetting('fixedRowsTop');\n      var fixedRowsBottom = wot.getSetting('fixedRowsBottom');\n      var fixedColumnsLeft = wot.getSetting('fixedColumnsLeft');\n      return {\n        topOverlay: topOverlay,\n        leftOverlay: leftOverlay,\n        wtTable: wtTable,\n        wtViewport: wtViewport,\n        totalRows: totalRows,\n        totalColumns: totalColumns,\n        fixedRowsTop: fixedRowsTop,\n        fixedRowsBottom: fixedRowsBottom,\n        fixedColumnsLeft: fixedColumnsLeft\n      };\n    }\n  }]);\n\n  return Scroll;\n}();\n\nexport default Scroll;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/3rdparty/walkontable/src/scroll.mjs"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","innerHeight","innerWidth","getScrollLeft","getScrollTop","offset","Scroll","wotInstance","wot","value","scrollViewport","coords","snapToTop","snapToRight","snapToBottom","snapToLeft","col","row","scrolledHorizontally","scrollViewportHorizontally","scrolledVertically","scrollViewportVertically","column","drawn","_this$_getVariables","_getVariables","fixedColumnsLeft","leftOverlay","totalColumns","result","Math","max","firstVisibleColumn","getFirstVisibleColumn","lastVisibleColumn","getLastVisibleColumn","scrollTo","_this$_getVariables2","fixedRowsBottom","fixedRowsTop","topOverlay","totalRows","firstVisibleRow","getFirstVisibleRow","lastVisibleRow","getLastVisibleRow","_this$_getVariables3","wtTable","wtViewport","rootWindow","mainTableScrollableElement","rootElementOffset","wtRootElement","totalTableHeight","hider","windowHeight","windowScrollTop","top","rowsHeight","getColumnHeaderHeight","sumCellSizes","_this$_getVariables4","_this$_getVariables5","totalTableWidth","windowWidth","windowScrollLeft","left","columnsWidth","getRowHeaderWidth","_this$_getVariables6","wtOverlays","getSetting"],"mappings":"AAAA,SAASA,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;AAAE,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;;AAEzJ,SAASC,iBAAT,CAA2BC,MAA3B,EAAmCC,KAAnC,EAA0C;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AAAE,QAAIE,UAAU,GAAGH,KAAK,CAACC,CAAD,CAAtB;AAA2BE,IAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,IAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,QAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4BC,IAAAA,MAAM,CAACC,cAAP,CAAsBT,MAAtB,EAA8BI,UAAU,CAACM,GAAzC,EAA8CN,UAA9C;AAA4D;AAAE;;AAE7T,SAASO,YAAT,CAAsBd,WAAtB,EAAmCe,UAAnC,EAA+CC,WAA/C,EAA4D;AAAE,MAAID,UAAJ,EAAgBb,iBAAiB,CAACF,WAAW,CAACiB,SAAb,EAAwBF,UAAxB,CAAjB;AAAsD,MAAIC,WAAJ,EAAiBd,iBAAiB,CAACF,WAAD,EAAcgB,WAAd,CAAjB;AAA6C,SAAOhB,WAAP;AAAqB;;AAEvN,SAASkB,WAAT,EAAsBC,UAAtB,EAAkCC,aAAlC,EAAiDC,YAAjD,EAA+DC,MAA/D,QAA6E,oCAA7E;AACA;AACA;AACA;;AAEA,IAAIC,MAAM,GAAG,aAAa,YAAY;AACpC;AACF;AACA;AACE,WAASA,MAAT,CAAgBC,WAAhB,EAA6B;AAC3B1B,IAAAA,eAAe,CAAC,IAAD,EAAOyB,MAAP,CAAf;;AAEA,SAAKE,GAAL,GAAWD,WAAX;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGEV,EAAAA,YAAY,CAACS,MAAD,EAAS,CAAC;AACpBV,IAAAA,GAAG,EAAE,gBADe;AAEpBa,IAAAA,KAAK,EAAE,SAASC,cAAT,CAAwBC,MAAxB,EAAgCC,SAAhC,EAA2CC,WAA3C,EAAwDC,YAAxD,EAAsEC,UAAtE,EAAkF;AACvF,UAAIJ,MAAM,CAACK,GAAP,GAAa,CAAb,IAAkBL,MAAM,CAACM,GAAP,GAAa,CAAnC,EAAsC;AACpC,eAAO,KAAP;AACD;;AAED,UAAIC,oBAAoB,GAAG,KAAKC,0BAAL,CAAgCR,MAAM,CAACK,GAAvC,EAA4CH,WAA5C,EAAyDE,UAAzD,CAA3B;AACA,UAAIK,kBAAkB,GAAG,KAAKC,wBAAL,CAA8BV,MAAM,CAACM,GAArC,EAA0CL,SAA1C,EAAqDE,YAArD,CAAzB;AACA,aAAOI,oBAAoB,IAAIE,kBAA/B;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAlBwB,GAAD,EAoBlB;AACDxB,IAAAA,GAAG,EAAE,4BADJ;AAEDa,IAAAA,KAAK,EAAE,SAASU,0BAAT,CAAoCG,MAApC,EAA4CT,WAA5C,EAAyDE,UAAzD,EAAqE;AAC1E,UAAI,CAAC,KAAKP,GAAL,CAASe,KAAd,EAAqB;AACnB,eAAO,KAAP;AACD;;AAED,UAAIC,mBAAmB,GAAG,KAAKC,aAAL,EAA1B;AAAA,UACIC,gBAAgB,GAAGF,mBAAmB,CAACE,gBAD3C;AAAA,UAEIC,WAAW,GAAGH,mBAAmB,CAACG,WAFtC;AAAA,UAGIC,YAAY,GAAGJ,mBAAmB,CAACI,YAHvC;;AAKA,UAAIC,MAAM,GAAG,KAAb;;AAEA,UAAIP,MAAM,IAAI,CAAV,IAAeA,MAAM,IAAIQ,IAAI,CAACC,GAAL,CAASH,YAAY,GAAG,CAAxB,EAA2B,CAA3B,CAA7B,EAA4D;AAC1D,YAAII,kBAAkB,GAAG,KAAKC,qBAAL,EAAzB;AACA,YAAIC,iBAAiB,GAAG,KAAKC,oBAAL,EAAxB;;AAEA,YAAIb,MAAM,IAAII,gBAAV,IAA8BM,kBAAkB,GAAG,CAAC,CAApD,KAA0DV,MAAM,GAAGU,kBAAT,IAA+BjB,UAAzF,CAAJ,EAA0G;AACxGc,UAAAA,MAAM,GAAGF,WAAW,CAACS,QAAZ,CAAqBd,MAArB,CAAT;AACD,SAFD,MAEO,IAAIY,iBAAiB,KAAK,CAAC,CAAvB,IAA4BA,iBAAiB,GAAG,CAAC,CAArB,KAA2BZ,MAAM,GAAGY,iBAAT,IAA8BrB,WAAzD,CAAhC,EAAuG;AAC5GgB,UAAAA,MAAM,GAAGF,WAAW,CAACS,QAAZ,CAAqBd,MAArB,EAA6B,IAA7B,CAAT;AACD;AACF;;AAED,aAAOO,MAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAlCK,GApBkB,EAwDlB;AACDjC,IAAAA,GAAG,EAAE,0BADJ;AAEDa,IAAAA,KAAK,EAAE,SAASY,wBAAT,CAAkCJ,GAAlC,EAAuCL,SAAvC,EAAkDE,YAAlD,EAAgE;AACrE,UAAI,CAAC,KAAKN,GAAL,CAASe,KAAd,EAAqB;AACnB,eAAO,KAAP;AACD;;AAED,UAAIc,oBAAoB,GAAG,KAAKZ,aAAL,EAA3B;AAAA,UACIa,eAAe,GAAGD,oBAAoB,CAACC,eAD3C;AAAA,UAEIC,YAAY,GAAGF,oBAAoB,CAACE,YAFxC;AAAA,UAGIC,UAAU,GAAGH,oBAAoB,CAACG,UAHtC;AAAA,UAIIC,SAAS,GAAGJ,oBAAoB,CAACI,SAJrC;;AAMA,UAAIZ,MAAM,GAAG,KAAb;;AAEA,UAAIZ,GAAG,IAAI,CAAP,IAAYA,GAAG,IAAIa,IAAI,CAACC,GAAL,CAASU,SAAS,GAAG,CAArB,EAAwB,CAAxB,CAAvB,EAAmD;AACjD,YAAIC,eAAe,GAAG,KAAKC,kBAAL,EAAtB;AACA,YAAIC,cAAc,GAAG,KAAKC,iBAAL,EAArB;;AAEA,YAAI5B,GAAG,IAAIsB,YAAP,IAAuBG,eAAe,GAAG,CAAC,CAA1C,KAAgDzB,GAAG,GAAGyB,eAAN,IAAyB9B,SAAzE,CAAJ,EAAyF;AACvFiB,UAAAA,MAAM,GAAGW,UAAU,CAACJ,QAAX,CAAoBnB,GAApB,CAAT;AACD,SAFD,MAEO,IAAI2B,cAAc,KAAK,CAAC,CAApB,IAAyBA,cAAc,GAAG,CAAC,CAAlB,KAAwB3B,GAAG,GAAG2B,cAAN,IAAwB3B,GAAG,GAAGwB,SAAS,GAAGH,eAA1C,IAA6DxB,YAArF,CAA7B,EAAiI;AACtIe,UAAAA,MAAM,GAAGW,UAAU,CAACJ,QAAX,CAAoBnB,GAApB,EAAyB,IAAzB,CAAT;AACD;AACF;;AAED,aAAOY,MAAP;AACD;AACD;AACJ;AACA;AACA;AACA;;AAhCK,GAxDkB,EA0FlB;AACDjC,IAAAA,GAAG,EAAE,oBADJ;AAEDa,IAAAA,KAAK,EAAE,SAASkC,kBAAT,GAA8B;AACnC,UAAIG,oBAAoB,GAAG,KAAKrB,aAAL,EAA3B;AAAA,UACIe,UAAU,GAAGM,oBAAoB,CAACN,UADtC;AAAA,UAEIO,OAAO,GAAGD,oBAAoB,CAACC,OAFnC;AAAA,UAGIC,UAAU,GAAGF,oBAAoB,CAACE,UAHtC;AAAA,UAIIP,SAAS,GAAGK,oBAAoB,CAACL,SAJrC;AAAA,UAKIF,YAAY,GAAGO,oBAAoB,CAACP,YALxC;;AAOA,UAAIU,UAAU,GAAG,KAAKzC,GAAL,CAASyC,UAA1B;AACA,UAAIP,eAAe,GAAGK,OAAO,CAACJ,kBAAR,EAAtB;;AAEA,UAAIH,UAAU,CAACU,0BAAX,KAA0CD,UAA9C,EAA0D;AACxD,YAAIE,iBAAiB,GAAG9C,MAAM,CAAC0C,OAAO,CAACK,aAAT,CAA9B;AACA,YAAIC,gBAAgB,GAAGpD,WAAW,CAAC8C,OAAO,CAACO,KAAT,CAAlC;AACA,YAAIC,YAAY,GAAGtD,WAAW,CAACgD,UAAD,CAA9B;AACA,YAAIO,eAAe,GAAGpD,YAAY,CAAC6C,UAAD,EAAaA,UAAb,CAAlC,CAJwD,CAII;;AAE5D,YAAIE,iBAAiB,CAACM,GAAlB,GAAwBJ,gBAAxB,GAA2CE,YAA3C,IAA2DC,eAA/D,EAAgF;AAC9E,cAAIE,UAAU,GAAGV,UAAU,CAACW,qBAAX,EAAjB;AACAD,UAAAA,UAAU,IAAIlB,UAAU,CAACoB,YAAX,CAAwB,CAAxB,EAA2BrB,YAA3B,CAAd;;AAEA,eAAK,IAAItB,GAAG,GAAGwB,SAAf,EAA0BxB,GAAG,GAAG,CAAhC,EAAmCA,GAAG,EAAtC,EAA0C;AACxCyC,YAAAA,UAAU,IAAIlB,UAAU,CAACoB,YAAX,CAAwB3C,GAAG,GAAG,CAA9B,EAAiCA,GAAjC,CAAd;;AAEA,gBAAIkC,iBAAiB,CAACM,GAAlB,GAAwBJ,gBAAxB,GAA2CK,UAA3C,IAAyDF,eAA7D,EAA8E;AAC5E;AACAd,cAAAA,eAAe,GAAGzB,GAAlB;AACA;AACD;AACF;AACF;AACF;;AAED,aAAOyB,eAAP;AACD;AACD;AACJ;AACA;AACA;AACA;;AAzCK,GA1FkB,EAqIlB;AACD9C,IAAAA,GAAG,EAAE,mBADJ;AAEDa,IAAAA,KAAK,EAAE,SAASoC,iBAAT,GAA6B;AAClC,UAAIgB,oBAAoB,GAAG,KAAKpC,aAAL,EAA3B;AAAA,UACIe,UAAU,GAAGqB,oBAAoB,CAACrB,UADtC;AAAA,UAEIO,OAAO,GAAGc,oBAAoB,CAACd,OAFnC;AAAA,UAGIC,UAAU,GAAGa,oBAAoB,CAACb,UAHtC;AAAA,UAIIP,SAAS,GAAGoB,oBAAoB,CAACpB,SAJrC;;AAMA,UAAIQ,UAAU,GAAG,KAAKzC,GAAL,CAASyC,UAA1B;AACA,UAAIL,cAAc,GAAGG,OAAO,CAACF,iBAAR,EAArB;;AAEA,UAAIL,UAAU,CAACU,0BAAX,KAA0CD,UAA9C,EAA0D;AACxD,YAAIE,iBAAiB,GAAG9C,MAAM,CAAC0C,OAAO,CAACK,aAAT,CAA9B;AACA,YAAII,eAAe,GAAGpD,YAAY,CAAC6C,UAAD,EAAaA,UAAb,CAAlC,CAFwD,CAEI;;AAE5D,YAAIE,iBAAiB,CAACM,GAAlB,GAAwBD,eAA5B,EAA6C;AAC3C,cAAID,YAAY,GAAGtD,WAAW,CAACgD,UAAD,CAA9B;AACA,cAAIS,UAAU,GAAGV,UAAU,CAACW,qBAAX,EAAjB;;AAEA,eAAK,IAAI1C,GAAG,GAAG,CAAf,EAAkBA,GAAG,IAAIwB,SAAzB,EAAoCxB,GAAG,EAAvC,EAA2C;AACzCyC,YAAAA,UAAU,IAAIlB,UAAU,CAACoB,YAAX,CAAwB3C,GAAG,GAAG,CAA9B,EAAiCA,GAAjC,CAAd;;AAEA,gBAAIkC,iBAAiB,CAACM,GAAlB,GAAwBC,UAAxB,GAAqCF,eAArC,IAAwDD,YAA5D,EAA0E;AACxE;AACAX,cAAAA,cAAc,GAAG3B,GAAG,GAAG,CAAvB;AACA;AACD;AACF;AACF;AACF;;AAED,aAAO2B,cAAP;AACD;AACD;AACJ;AACA;AACA;AACA;;AAtCK,GArIkB,EA6KlB;AACDhD,IAAAA,GAAG,EAAE,uBADJ;AAEDa,IAAAA,KAAK,EAAE,SAASwB,qBAAT,GAAiC;AACtC,UAAI6B,oBAAoB,GAAG,KAAKrC,aAAL,EAA3B;AAAA,UACIE,WAAW,GAAGmC,oBAAoB,CAACnC,WADvC;AAAA,UAEIoB,OAAO,GAAGe,oBAAoB,CAACf,OAFnC;AAAA,UAGIC,UAAU,GAAGc,oBAAoB,CAACd,UAHtC;AAAA,UAIIpB,YAAY,GAAGkC,oBAAoB,CAAClC,YAJxC;;AAMA,UAAIqB,UAAU,GAAG,KAAKzC,GAAL,CAASyC,UAA1B;AACA,UAAIjB,kBAAkB,GAAGe,OAAO,CAACd,qBAAR,EAAzB;;AAEA,UAAIN,WAAW,CAACuB,0BAAZ,KAA2CD,UAA/C,EAA2D;AACzD,YAAIE,iBAAiB,GAAG9C,MAAM,CAAC0C,OAAO,CAACK,aAAT,CAA9B;AACA,YAAIW,eAAe,GAAG7D,UAAU,CAAC6C,OAAO,CAACO,KAAT,CAAhC;AACA,YAAIU,WAAW,GAAG9D,UAAU,CAAC+C,UAAD,CAA5B;AACA,YAAIgB,gBAAgB,GAAG9D,aAAa,CAAC8C,UAAD,EAAaA,UAAb,CAApC,CAJyD,CAIK;;AAE9D,YAAIE,iBAAiB,CAACe,IAAlB,GAAyBH,eAAzB,GAA2CC,WAA3C,IAA0DC,gBAA9D,EAAgF;AAC9E,cAAIE,YAAY,GAAGnB,UAAU,CAACoB,iBAAX,EAAnB;;AAEA,eAAK,IAAI9C,MAAM,GAAGM,YAAlB,EAAgCN,MAAM,GAAG,CAAzC,EAA4CA,MAAM,EAAlD,EAAsD;AACpD6C,YAAAA,YAAY,IAAIxC,WAAW,CAACiC,YAAZ,CAAyBtC,MAAM,GAAG,CAAlC,EAAqCA,MAArC,CAAhB;;AAEA,gBAAI6B,iBAAiB,CAACe,IAAlB,GAAyBH,eAAzB,GAA2CI,YAA3C,IAA2DF,gBAA/D,EAAiF;AAC/E;AACAjC,cAAAA,kBAAkB,GAAGV,MAArB;AACA;AACD;AACF;AACF;AACF;;AAED,aAAOU,kBAAP;AACD;AACD;AACJ;AACA;AACA;AACA;;AAvCK,GA7KkB,EAsNlB;AACDpC,IAAAA,GAAG,EAAE,sBADJ;AAEDa,IAAAA,KAAK,EAAE,SAAS0B,oBAAT,GAAgC;AACrC,UAAIkC,oBAAoB,GAAG,KAAK5C,aAAL,EAA3B;AAAA,UACIE,WAAW,GAAG0C,oBAAoB,CAAC1C,WADvC;AAAA,UAEIoB,OAAO,GAAGsB,oBAAoB,CAACtB,OAFnC;AAAA,UAGIC,UAAU,GAAGqB,oBAAoB,CAACrB,UAHtC;AAAA,UAIIpB,YAAY,GAAGyC,oBAAoB,CAACzC,YAJxC;;AAMA,UAAIqB,UAAU,GAAG,KAAKzC,GAAL,CAASyC,UAA1B;AACA,UAAIf,iBAAiB,GAAGa,OAAO,CAACZ,oBAAR,EAAxB;;AAEA,UAAIR,WAAW,CAACuB,0BAAZ,KAA2CD,UAA/C,EAA2D;AACzD,YAAIE,iBAAiB,GAAG9C,MAAM,CAAC0C,OAAO,CAACK,aAAT,CAA9B;AACA,YAAIa,gBAAgB,GAAG9D,aAAa,CAAC8C,UAAD,EAAaA,UAAb,CAApC,CAFyD,CAEK;;AAE9D,YAAIE,iBAAiB,CAACe,IAAlB,GAAyBD,gBAA7B,EAA+C;AAC7C,cAAID,WAAW,GAAG9D,UAAU,CAAC+C,UAAD,CAA5B;AACA,cAAIkB,YAAY,GAAGnB,UAAU,CAACoB,iBAAX,EAAnB;;AAEA,eAAK,IAAI9C,MAAM,GAAG,CAAlB,EAAqBA,MAAM,IAAIM,YAA/B,EAA6CN,MAAM,EAAnD,EAAuD;AACrD6C,YAAAA,YAAY,IAAIxC,WAAW,CAACiC,YAAZ,CAAyBtC,MAAM,GAAG,CAAlC,EAAqCA,MAArC,CAAhB;;AAEA,gBAAI6B,iBAAiB,CAACe,IAAlB,GAAyBC,YAAzB,GAAwCF,gBAAxC,IAA4DD,WAAhE,EAA6E;AAC3E;AACA9B,cAAAA,iBAAiB,GAAGZ,MAAM,GAAG,CAA7B;AACA;AACD;AACF;AACF;AACF;;AAED,aAAOY,iBAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;;AAvCK,GAtNkB,EA+PlB;AACDtC,IAAAA,GAAG,EAAE,eADJ;AAEDa,IAAAA,KAAK,EAAE,SAASgB,aAAT,GAAyB;AAC9B,UAAIjB,GAAG,GAAG,KAAKA,GAAf;AACA,UAAIgC,UAAU,GAAGhC,GAAG,CAAC8D,UAAJ,CAAe9B,UAAhC;AACA,UAAIb,WAAW,GAAGnB,GAAG,CAAC8D,UAAJ,CAAe3C,WAAjC;AACA,UAAIoB,OAAO,GAAGvC,GAAG,CAACuC,OAAlB;AACA,UAAIC,UAAU,GAAGxC,GAAG,CAACwC,UAArB;AACA,UAAIP,SAAS,GAAGjC,GAAG,CAAC+D,UAAJ,CAAe,WAAf,CAAhB;AACA,UAAI3C,YAAY,GAAGpB,GAAG,CAAC+D,UAAJ,CAAe,cAAf,CAAnB;AACA,UAAIhC,YAAY,GAAG/B,GAAG,CAAC+D,UAAJ,CAAe,cAAf,CAAnB;AACA,UAAIjC,eAAe,GAAG9B,GAAG,CAAC+D,UAAJ,CAAe,iBAAf,CAAtB;AACA,UAAI7C,gBAAgB,GAAGlB,GAAG,CAAC+D,UAAJ,CAAe,kBAAf,CAAvB;AACA,aAAO;AACL/B,QAAAA,UAAU,EAAEA,UADP;AAELb,QAAAA,WAAW,EAAEA,WAFR;AAGLoB,QAAAA,OAAO,EAAEA,OAHJ;AAILC,QAAAA,UAAU,EAAEA,UAJP;AAKLP,QAAAA,SAAS,EAAEA,SALN;AAMLb,QAAAA,YAAY,EAAEA,YANT;AAOLW,QAAAA,YAAY,EAAEA,YAPT;AAQLD,QAAAA,eAAe,EAAEA,eARZ;AASLZ,QAAAA,gBAAgB,EAAEA;AATb,OAAP;AAWD;AAxBA,GA/PkB,CAAT,CAAZ;;AA0RA,SAAOpB,MAAP;AACD,CAhTyB,EAA1B;;AAkTA,eAAeA,MAAf","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport { innerHeight, innerWidth, getScrollLeft, getScrollTop, offset } from \"./../../../helpers/dom/element.mjs\";\r\n/**\r\n * @class Scroll\r\n */\r\n\r\nvar Scroll = /*#__PURE__*/function () {\r\n  /**\r\n   * @param {Walkontable} wotInstance The Walkontable instance.\r\n   */\r\n  function Scroll(wotInstance) {\r\n    _classCallCheck(this, Scroll);\r\n\r\n    this.wot = wotInstance;\r\n  }\r\n  /**\r\n   * Scrolls viewport to a cell.\r\n   *\r\n   * @param {CellCoords} coords The cell coordinates.\r\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\r\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\r\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\r\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\r\n   * @returns {boolean}\r\n   */\r\n\r\n\r\n  _createClass(Scroll, [{\r\n    key: \"scrollViewport\",\r\n    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\r\n      if (coords.col < 0 || coords.row < 0) {\r\n        return false;\r\n      }\r\n\r\n      var scrolledHorizontally = this.scrollViewportHorizontally(coords.col, snapToRight, snapToLeft);\r\n      var scrolledVertically = this.scrollViewportVertically(coords.row, snapToTop, snapToBottom);\r\n      return scrolledHorizontally || scrolledVertically;\r\n    }\r\n    /**\r\n     * Scrolls viewport to a column.\r\n     *\r\n     * @param {number} column Visual column index.\r\n     * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\r\n     * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"scrollViewportHorizontally\",\r\n    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {\r\n      if (!this.wot.drawn) {\r\n        return false;\r\n      }\r\n\r\n      var _this$_getVariables = this._getVariables(),\r\n          fixedColumnsLeft = _this$_getVariables.fixedColumnsLeft,\r\n          leftOverlay = _this$_getVariables.leftOverlay,\r\n          totalColumns = _this$_getVariables.totalColumns;\r\n\r\n      var result = false;\r\n\r\n      if (column >= 0 && column <= Math.max(totalColumns - 1, 0)) {\r\n        var firstVisibleColumn = this.getFirstVisibleColumn();\r\n        var lastVisibleColumn = this.getLastVisibleColumn();\r\n\r\n        if (column >= fixedColumnsLeft && firstVisibleColumn > -1 && (column < firstVisibleColumn || snapToLeft)) {\r\n          result = leftOverlay.scrollTo(column);\r\n        } else if (lastVisibleColumn === -1 || lastVisibleColumn > -1 && (column > lastVisibleColumn || snapToRight)) {\r\n          result = leftOverlay.scrollTo(column, true);\r\n        }\r\n      }\r\n\r\n      return result;\r\n    }\r\n    /**\r\n     * Scrolls viewport to a row.\r\n     *\r\n     * @param {number} row Visual row index.\r\n     * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\r\n     * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"scrollViewportVertically\",\r\n    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {\r\n      if (!this.wot.drawn) {\r\n        return false;\r\n      }\r\n\r\n      var _this$_getVariables2 = this._getVariables(),\r\n          fixedRowsBottom = _this$_getVariables2.fixedRowsBottom,\r\n          fixedRowsTop = _this$_getVariables2.fixedRowsTop,\r\n          topOverlay = _this$_getVariables2.topOverlay,\r\n          totalRows = _this$_getVariables2.totalRows;\r\n\r\n      var result = false;\r\n\r\n      if (row >= 0 && row <= Math.max(totalRows - 1, 0)) {\r\n        var firstVisibleRow = this.getFirstVisibleRow();\r\n        var lastVisibleRow = this.getLastVisibleRow();\r\n\r\n        if (row >= fixedRowsTop && firstVisibleRow > -1 && (row < firstVisibleRow || snapToTop)) {\r\n          result = topOverlay.scrollTo(row);\r\n        } else if (lastVisibleRow === -1 || lastVisibleRow > -1 && (row > lastVisibleRow && row < totalRows - fixedRowsBottom || snapToBottom)) {\r\n          result = topOverlay.scrollTo(row, true);\r\n        }\r\n      }\r\n\r\n      return result;\r\n    }\r\n    /**\r\n     * Get first visible row based on virtual dom and how table is visible in browser window viewport.\r\n     *\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getFirstVisibleRow\",\r\n    value: function getFirstVisibleRow() {\r\n      var _this$_getVariables3 = this._getVariables(),\r\n          topOverlay = _this$_getVariables3.topOverlay,\r\n          wtTable = _this$_getVariables3.wtTable,\r\n          wtViewport = _this$_getVariables3.wtViewport,\r\n          totalRows = _this$_getVariables3.totalRows,\r\n          fixedRowsTop = _this$_getVariables3.fixedRowsTop;\r\n\r\n      var rootWindow = this.wot.rootWindow;\r\n      var firstVisibleRow = wtTable.getFirstVisibleRow();\r\n\r\n      if (topOverlay.mainTableScrollableElement === rootWindow) {\r\n        var rootElementOffset = offset(wtTable.wtRootElement);\r\n        var totalTableHeight = innerHeight(wtTable.hider);\r\n        var windowHeight = innerHeight(rootWindow);\r\n        var windowScrollTop = getScrollTop(rootWindow, rootWindow); // Only calculate firstVisibleRow when table didn't filled (from up) whole viewport space\r\n\r\n        if (rootElementOffset.top + totalTableHeight - windowHeight <= windowScrollTop) {\r\n          var rowsHeight = wtViewport.getColumnHeaderHeight();\r\n          rowsHeight += topOverlay.sumCellSizes(0, fixedRowsTop);\r\n\r\n          for (var row = totalRows; row > 0; row--) {\r\n            rowsHeight += topOverlay.sumCellSizes(row - 1, row);\r\n\r\n            if (rootElementOffset.top + totalTableHeight - rowsHeight <= windowScrollTop) {\r\n              // Return physical row + 1\r\n              firstVisibleRow = row;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return firstVisibleRow;\r\n    }\r\n    /**\r\n     * Get last visible row based on virtual dom and how table is visible in browser window viewport.\r\n     *\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getLastVisibleRow\",\r\n    value: function getLastVisibleRow() {\r\n      var _this$_getVariables4 = this._getVariables(),\r\n          topOverlay = _this$_getVariables4.topOverlay,\r\n          wtTable = _this$_getVariables4.wtTable,\r\n          wtViewport = _this$_getVariables4.wtViewport,\r\n          totalRows = _this$_getVariables4.totalRows;\r\n\r\n      var rootWindow = this.wot.rootWindow;\r\n      var lastVisibleRow = wtTable.getLastVisibleRow();\r\n\r\n      if (topOverlay.mainTableScrollableElement === rootWindow) {\r\n        var rootElementOffset = offset(wtTable.wtRootElement);\r\n        var windowScrollTop = getScrollTop(rootWindow, rootWindow); // Only calculate lastVisibleRow when table didn't filled (from bottom) whole viewport space\r\n\r\n        if (rootElementOffset.top > windowScrollTop) {\r\n          var windowHeight = innerHeight(rootWindow);\r\n          var rowsHeight = wtViewport.getColumnHeaderHeight();\r\n\r\n          for (var row = 1; row <= totalRows; row++) {\r\n            rowsHeight += topOverlay.sumCellSizes(row - 1, row);\r\n\r\n            if (rootElementOffset.top + rowsHeight - windowScrollTop >= windowHeight) {\r\n              // Return physical row - 1 (-2 because rangeEach gives row index + 1 - sumCellSizes requirements)\r\n              lastVisibleRow = row - 2;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return lastVisibleRow;\r\n    }\r\n    /**\r\n     * Get first visible column based on virtual dom and how table is visible in browser window viewport.\r\n     *\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getFirstVisibleColumn\",\r\n    value: function getFirstVisibleColumn() {\r\n      var _this$_getVariables5 = this._getVariables(),\r\n          leftOverlay = _this$_getVariables5.leftOverlay,\r\n          wtTable = _this$_getVariables5.wtTable,\r\n          wtViewport = _this$_getVariables5.wtViewport,\r\n          totalColumns = _this$_getVariables5.totalColumns;\r\n\r\n      var rootWindow = this.wot.rootWindow;\r\n      var firstVisibleColumn = wtTable.getFirstVisibleColumn();\r\n\r\n      if (leftOverlay.mainTableScrollableElement === rootWindow) {\r\n        var rootElementOffset = offset(wtTable.wtRootElement);\r\n        var totalTableWidth = innerWidth(wtTable.hider);\r\n        var windowWidth = innerWidth(rootWindow);\r\n        var windowScrollLeft = getScrollLeft(rootWindow, rootWindow); // Only calculate firstVisibleColumn when table didn't filled (from left) whole viewport space\r\n\r\n        if (rootElementOffset.left + totalTableWidth - windowWidth <= windowScrollLeft) {\r\n          var columnsWidth = wtViewport.getRowHeaderWidth();\r\n\r\n          for (var column = totalColumns; column > 0; column--) {\r\n            columnsWidth += leftOverlay.sumCellSizes(column - 1, column);\r\n\r\n            if (rootElementOffset.left + totalTableWidth - columnsWidth <= windowScrollLeft) {\r\n              // Return physical column + 1\r\n              firstVisibleColumn = column;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return firstVisibleColumn;\r\n    }\r\n    /**\r\n     * Get last visible column based on virtual dom and how table is visible in browser window viewport.\r\n     *\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getLastVisibleColumn\",\r\n    value: function getLastVisibleColumn() {\r\n      var _this$_getVariables6 = this._getVariables(),\r\n          leftOverlay = _this$_getVariables6.leftOverlay,\r\n          wtTable = _this$_getVariables6.wtTable,\r\n          wtViewport = _this$_getVariables6.wtViewport,\r\n          totalColumns = _this$_getVariables6.totalColumns;\r\n\r\n      var rootWindow = this.wot.rootWindow;\r\n      var lastVisibleColumn = wtTable.getLastVisibleColumn();\r\n\r\n      if (leftOverlay.mainTableScrollableElement === rootWindow) {\r\n        var rootElementOffset = offset(wtTable.wtRootElement);\r\n        var windowScrollLeft = getScrollLeft(rootWindow, rootWindow); // Only calculate lastVisibleColumn when table didn't filled (from right) whole viewport space\r\n\r\n        if (rootElementOffset.left > windowScrollLeft) {\r\n          var windowWidth = innerWidth(rootWindow);\r\n          var columnsWidth = wtViewport.getRowHeaderWidth();\r\n\r\n          for (var column = 1; column <= totalColumns; column++) {\r\n            columnsWidth += leftOverlay.sumCellSizes(column - 1, column);\r\n\r\n            if (rootElementOffset.left + columnsWidth - windowScrollLeft >= windowWidth) {\r\n              // Return physical column - 1 (-2 because rangeEach gives column index + 1 - sumCellSizes requirements)\r\n              lastVisibleColumn = column - 2;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return lastVisibleColumn;\r\n    }\r\n    /**\r\n     * Returns collection of variables used to rows and columns visibility calculations.\r\n     *\r\n     * @returns {object}\r\n     * @private\r\n     */\r\n\r\n  }, {\r\n    key: \"_getVariables\",\r\n    value: function _getVariables() {\r\n      var wot = this.wot;\r\n      var topOverlay = wot.wtOverlays.topOverlay;\r\n      var leftOverlay = wot.wtOverlays.leftOverlay;\r\n      var wtTable = wot.wtTable;\r\n      var wtViewport = wot.wtViewport;\r\n      var totalRows = wot.getSetting('totalRows');\r\n      var totalColumns = wot.getSetting('totalColumns');\r\n      var fixedRowsTop = wot.getSetting('fixedRowsTop');\r\n      var fixedRowsBottom = wot.getSetting('fixedRowsBottom');\r\n      var fixedColumnsLeft = wot.getSetting('fixedColumnsLeft');\r\n      return {\r\n        topOverlay: topOverlay,\r\n        leftOverlay: leftOverlay,\r\n        wtTable: wtTable,\r\n        wtViewport: wtViewport,\r\n        totalRows: totalRows,\r\n        totalColumns: totalColumns,\r\n        fixedRowsTop: fixedRowsTop,\r\n        fixedRowsBottom: fixedRowsBottom,\r\n        fixedColumnsLeft: fixedColumnsLeft\r\n      };\r\n    }\r\n  }]);\r\n\r\n  return Scroll;\r\n}();\r\n\r\nexport default Scroll;"]},"metadata":{},"sourceType":"module"}