{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { createObjectPropListener, getProperty, isObject, objectEach, setProperty } from \"./helpers/object.mjs\";\nimport { countFirstRowKeys as _countFirstRowKeys } from \"./helpers/data.mjs\";\nimport { arrayEach } from \"./helpers/array.mjs\";\nimport { rangeEach } from \"./helpers/number.mjs\";\nimport { isFunction } from \"./helpers/function.mjs\";\n/**\n * @class DataSource\n * @private\n */\n\nvar DataSource = /*#__PURE__*/function () {\n  function DataSource(hotInstance) {\n    var dataSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    _classCallCheck(this, DataSource);\n    /**\n     * Instance of Handsontable.\n     *\n     * @type {Handsontable}\n     */\n\n\n    this.hot = hotInstance;\n    /**\n     * Data source.\n     *\n     * @type {Array}\n     */\n\n    this.data = dataSource;\n    /**\n     * Type of data source.\n     *\n     * @type {string}\n     * @default 'array'\n     */\n\n    this.dataType = 'array';\n\n    this.colToProp = function () {};\n\n    this.propToCol = function () {};\n  }\n  /**\n   * Run the `modifyRowData` hook and return either the modified or the source data for the provided row.\n   *\n   * @private\n   * @param {number} rowIndex Row index.\n   * @returns {Array|object} Source or modified row of data.\n   */\n\n\n  _createClass(DataSource, [{\n    key: \"modifyRowData\",\n    value: function modifyRowData(rowIndex) {\n      var modifyRowData;\n\n      if (this.hot.hasHook('modifyRowData')) {\n        modifyRowData = this.hot.runHooks('modifyRowData', rowIndex);\n      }\n\n      return modifyRowData !== void 0 && !Number.isInteger(modifyRowData) ? modifyRowData : this.data[rowIndex];\n    }\n    /**\n     * Get all data.\n     *\n     * @param {boolean} [toArray=false] If `true` return source data as an array of arrays even when source data was provided\n     *                                  in another format.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      var toArray = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (!this.data || this.data.length === 0) {\n        return this.data;\n      }\n\n      return this.getByRange(null, null, toArray);\n    }\n    /**\n     * Set new data source.\n     *\n     * @param {Array} data The new data.\n     */\n\n  }, {\n    key: \"setData\",\n    value: function setData(data) {\n      this.data = data;\n    }\n    /**\n     * Returns array of column values from the data source. `column` is the index of the row in the data source.\n     *\n     * @param {number} column Visual column index.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getAtColumn\",\n    value: function getAtColumn(column) {\n      var _this = this;\n\n      var result = [];\n      arrayEach(this.data, function (row, rowIndex) {\n        var value = _this.getAtCell(rowIndex, column);\n\n        result.push(value);\n      });\n      return result;\n    }\n    /**\n     * Returns a single row of the data or a subset of its columns. If a column range or `toArray` arguments are provided, it\n     * operates only on the columns declared by the `columns` setting or the data schema.\n     *\n     * @param {number} row Physical row index.\n     * @param {number} [startColumn] Starting index for the column range (optional).\n     * @param {number} [endColumn] Ending index for the column range (optional).\n     * @param {boolean} [toArray=false] `true` if the returned value should be forced to be presented as an array.\n     * @returns {Array|object}\n     */\n\n  }, {\n    key: \"getAtRow\",\n    value: function getAtRow(row, startColumn, endColumn) {\n      var _this2 = this;\n\n      var toArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var getAllProps = startColumn === void 0 && endColumn === void 0;\n      var dataRow = null;\n      var newDataRow = null;\n      dataRow = this.modifyRowData(row);\n\n      if (Array.isArray(dataRow)) {\n        newDataRow = [];\n\n        if (getAllProps) {\n          dataRow.forEach(function (cell, column) {\n            newDataRow[column] = _this2.getAtPhysicalCell(row, column, dataRow);\n          });\n        } else {\n          // Only the columns from the provided range\n          rangeEach(startColumn, endColumn, function (column) {\n            newDataRow[column - startColumn] = _this2.getAtPhysicalCell(row, column, dataRow);\n          });\n        }\n      } else if (isObject(dataRow) || isFunction(dataRow)) {\n        if (toArray) {\n          newDataRow = [];\n        } else {\n          newDataRow = {};\n        }\n\n        if (!getAllProps || toArray) {\n          var rangeStart = 0;\n          var rangeEnd = this.countFirstRowKeys() - 1;\n          rangeEach(rangeStart, rangeEnd, function (column) {\n            var prop = _this2.colToProp(column);\n\n            if (column >= (startColumn || rangeStart) && column <= (endColumn || rangeEnd) && !Number.isInteger(prop)) {\n              var cellValue = _this2.getAtPhysicalCell(row, prop, dataRow);\n\n              if (toArray) {\n                newDataRow.push(cellValue);\n              } else {\n                setProperty(newDataRow, prop, cellValue);\n              }\n            }\n          });\n        } else {\n          objectEach(dataRow, function (value, prop) {\n            setProperty(newDataRow, prop, _this2.getAtPhysicalCell(row, prop, dataRow));\n          });\n        }\n      }\n\n      return newDataRow;\n    }\n    /**\n     * Set the provided value in the source data set at the provided coordinates.\n     *\n     * @param {number} row Physical row index.\n     * @param {number|string} column Property name / physical column index.\n     * @param {*} value The value to be set at the provided coordinates.\n     */\n\n  }, {\n    key: \"setAtCell\",\n    value: function setAtCell(row, column, value) {\n      if (row >= this.countRows() || column >= this.countFirstRowKeys()) {\n        // Not enough rows and/or columns.\n        return;\n      }\n\n      if (this.hot.hasHook('modifySourceData')) {\n        var valueHolder = createObjectPropListener(value);\n        this.hot.runHooks('modifySourceData', row, this.propToCol(column), valueHolder, 'set');\n\n        if (valueHolder.isTouched()) {\n          value = valueHolder.value;\n        }\n      }\n\n      if (!Number.isInteger(column)) {\n        // column argument is the prop name\n        setProperty(this.data[row], column, value);\n      } else {\n        this.data[row][column] = value;\n      }\n    }\n    /**\n     * Get data from the source data set using the physical indexes.\n     *\n     * @private\n     * @param {number} row Physical row index.\n     * @param {string|number|Function} column Physical column index / property / function.\n     * @param {Array|object} dataRow A representation of a data row.\n     * @returns {*} Value at the provided coordinates.\n     */\n\n  }, {\n    key: \"getAtPhysicalCell\",\n    value: function getAtPhysicalCell(row, column, dataRow) {\n      var result = null;\n\n      if (dataRow) {\n        if (typeof column === 'string') {\n          result = getProperty(dataRow, column);\n        } else if (typeof column === 'function') {\n          result = column(dataRow);\n        } else {\n          result = dataRow[column];\n        }\n      }\n\n      if (this.hot.hasHook('modifySourceData')) {\n        var valueHolder = createObjectPropListener(result);\n        this.hot.runHooks('modifySourceData', row, this.colToProp(column), valueHolder, 'get');\n\n        if (valueHolder.isTouched()) {\n          result = valueHolder.value;\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Returns a single value from the data.\n     *\n     * @param {number} row Physical row index.\n     * @param {number} column Visual column index.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getAtCell\",\n    value: function getAtCell(row, column) {\n      var dataRow = this.modifyRowData(row);\n      return this.getAtPhysicalCell(row, this.colToProp(column), dataRow);\n    }\n    /**\n     * Returns source data by passed range.\n     *\n     * @param {object} [start] Object with physical `row` and `col` keys (or visual column index, if data type is an array of objects).\n     * @param {object} [end] Object with physical `row` and `col` keys (or visual column index, if data type is an array of objects).\n     * @param {boolean} [toArray=false] If `true` return source data as an array of arrays even when source data was provided\n     *                                  in another format.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getByRange\",\n    value: function getByRange() {\n      var _this3 = this;\n\n      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var toArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var getAllProps = false;\n      var startRow = null;\n      var startCol = null;\n      var endRow = null;\n      var endCol = null;\n\n      if (start === null || end === null) {\n        getAllProps = true;\n        startRow = 0;\n        endRow = this.countRows() - 1;\n      } else {\n        startRow = Math.min(start.row, end.row);\n        startCol = Math.min(start.col, end.col);\n        endRow = Math.max(start.row, end.row);\n        endCol = Math.max(start.col, end.col);\n      }\n\n      var result = [];\n      rangeEach(startRow, endRow, function (currentRow) {\n        result.push(getAllProps ? _this3.getAtRow(currentRow, void 0, void 0, toArray) : _this3.getAtRow(currentRow, startCol, endCol, toArray));\n      });\n      return result;\n    }\n    /**\n     * Count number of rows.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"countRows\",\n    value: function countRows() {\n      if (this.hot.hasHook('modifySourceLength')) {\n        var modifiedSourceLength = this.hot.runHooks('modifySourceLength');\n\n        if (Number.isInteger(modifiedSourceLength)) {\n          return modifiedSourceLength;\n        }\n      }\n\n      return this.data.length;\n    }\n    /**\n     * Count number of columns.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"countFirstRowKeys\",\n    value: function countFirstRowKeys() {\n      return _countFirstRowKeys(this.data);\n    }\n    /**\n     * Destroy instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.data = null;\n      this.hot = null;\n    }\n  }]);\n\n  return DataSource;\n}();\n\nexport default DataSource;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/dataSource.mjs"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","createObjectPropListener","getProperty","isObject","objectEach","setProperty","countFirstRowKeys","_countFirstRowKeys","arrayEach","rangeEach","isFunction","DataSource","hotInstance","dataSource","arguments","undefined","hot","data","dataType","colToProp","propToCol","value","modifyRowData","rowIndex","hasHook","runHooks","Number","isInteger","getData","toArray","getByRange","setData","getAtColumn","column","_this","result","row","getAtCell","push","getAtRow","startColumn","endColumn","_this2","getAllProps","dataRow","newDataRow","Array","isArray","forEach","cell","getAtPhysicalCell","rangeStart","rangeEnd","prop","cellValue","setAtCell","countRows","valueHolder","isTouched","_this3","start","end","startRow","startCol","endRow","endCol","Math","min","col","max","currentRow","modifiedSourceLength","destroy"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.number.is-integer.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { createObjectPropListener, getProperty, isObject, objectEach, setProperty } from \"./helpers/object.mjs\";\nimport { countFirstRowKeys as _countFirstRowKeys } from \"./helpers/data.mjs\";\nimport { arrayEach } from \"./helpers/array.mjs\";\nimport { rangeEach } from \"./helpers/number.mjs\";\nimport { isFunction } from \"./helpers/function.mjs\";\n/**\n * @class DataSource\n * @private\n */\n\nvar DataSource = /*#__PURE__*/function () {\n  function DataSource(hotInstance) {\n    var dataSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    _classCallCheck(this, DataSource);\n\n    /**\n     * Instance of Handsontable.\n     *\n     * @type {Handsontable}\n     */\n    this.hot = hotInstance;\n    /**\n     * Data source.\n     *\n     * @type {Array}\n     */\n\n    this.data = dataSource;\n    /**\n     * Type of data source.\n     *\n     * @type {string}\n     * @default 'array'\n     */\n\n    this.dataType = 'array';\n\n    this.colToProp = function () {};\n\n    this.propToCol = function () {};\n  }\n  /**\n   * Run the `modifyRowData` hook and return either the modified or the source data for the provided row.\n   *\n   * @private\n   * @param {number} rowIndex Row index.\n   * @returns {Array|object} Source or modified row of data.\n   */\n\n\n  _createClass(DataSource, [{\n    key: \"modifyRowData\",\n    value: function modifyRowData(rowIndex) {\n      var modifyRowData;\n\n      if (this.hot.hasHook('modifyRowData')) {\n        modifyRowData = this.hot.runHooks('modifyRowData', rowIndex);\n      }\n\n      return modifyRowData !== void 0 && !Number.isInteger(modifyRowData) ? modifyRowData : this.data[rowIndex];\n    }\n    /**\n     * Get all data.\n     *\n     * @param {boolean} [toArray=false] If `true` return source data as an array of arrays even when source data was provided\n     *                                  in another format.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      var toArray = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (!this.data || this.data.length === 0) {\n        return this.data;\n      }\n\n      return this.getByRange(null, null, toArray);\n    }\n    /**\n     * Set new data source.\n     *\n     * @param {Array} data The new data.\n     */\n\n  }, {\n    key: \"setData\",\n    value: function setData(data) {\n      this.data = data;\n    }\n    /**\n     * Returns array of column values from the data source. `column` is the index of the row in the data source.\n     *\n     * @param {number} column Visual column index.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getAtColumn\",\n    value: function getAtColumn(column) {\n      var _this = this;\n\n      var result = [];\n      arrayEach(this.data, function (row, rowIndex) {\n        var value = _this.getAtCell(rowIndex, column);\n\n        result.push(value);\n      });\n      return result;\n    }\n    /**\n     * Returns a single row of the data or a subset of its columns. If a column range or `toArray` arguments are provided, it\n     * operates only on the columns declared by the `columns` setting or the data schema.\n     *\n     * @param {number} row Physical row index.\n     * @param {number} [startColumn] Starting index for the column range (optional).\n     * @param {number} [endColumn] Ending index for the column range (optional).\n     * @param {boolean} [toArray=false] `true` if the returned value should be forced to be presented as an array.\n     * @returns {Array|object}\n     */\n\n  }, {\n    key: \"getAtRow\",\n    value: function getAtRow(row, startColumn, endColumn) {\n      var _this2 = this;\n\n      var toArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var getAllProps = startColumn === void 0 && endColumn === void 0;\n      var dataRow = null;\n      var newDataRow = null;\n      dataRow = this.modifyRowData(row);\n\n      if (Array.isArray(dataRow)) {\n        newDataRow = [];\n\n        if (getAllProps) {\n          dataRow.forEach(function (cell, column) {\n            newDataRow[column] = _this2.getAtPhysicalCell(row, column, dataRow);\n          });\n        } else {\n          // Only the columns from the provided range\n          rangeEach(startColumn, endColumn, function (column) {\n            newDataRow[column - startColumn] = _this2.getAtPhysicalCell(row, column, dataRow);\n          });\n        }\n      } else if (isObject(dataRow) || isFunction(dataRow)) {\n        if (toArray) {\n          newDataRow = [];\n        } else {\n          newDataRow = {};\n        }\n\n        if (!getAllProps || toArray) {\n          var rangeStart = 0;\n          var rangeEnd = this.countFirstRowKeys() - 1;\n          rangeEach(rangeStart, rangeEnd, function (column) {\n            var prop = _this2.colToProp(column);\n\n            if (column >= (startColumn || rangeStart) && column <= (endColumn || rangeEnd) && !Number.isInteger(prop)) {\n              var cellValue = _this2.getAtPhysicalCell(row, prop, dataRow);\n\n              if (toArray) {\n                newDataRow.push(cellValue);\n              } else {\n                setProperty(newDataRow, prop, cellValue);\n              }\n            }\n          });\n        } else {\n          objectEach(dataRow, function (value, prop) {\n            setProperty(newDataRow, prop, _this2.getAtPhysicalCell(row, prop, dataRow));\n          });\n        }\n      }\n\n      return newDataRow;\n    }\n    /**\n     * Set the provided value in the source data set at the provided coordinates.\n     *\n     * @param {number} row Physical row index.\n     * @param {number|string} column Property name / physical column index.\n     * @param {*} value The value to be set at the provided coordinates.\n     */\n\n  }, {\n    key: \"setAtCell\",\n    value: function setAtCell(row, column, value) {\n      if (row >= this.countRows() || column >= this.countFirstRowKeys()) {\n        // Not enough rows and/or columns.\n        return;\n      }\n\n      if (this.hot.hasHook('modifySourceData')) {\n        var valueHolder = createObjectPropListener(value);\n        this.hot.runHooks('modifySourceData', row, this.propToCol(column), valueHolder, 'set');\n\n        if (valueHolder.isTouched()) {\n          value = valueHolder.value;\n        }\n      }\n\n      if (!Number.isInteger(column)) {\n        // column argument is the prop name\n        setProperty(this.data[row], column, value);\n      } else {\n        this.data[row][column] = value;\n      }\n    }\n    /**\n     * Get data from the source data set using the physical indexes.\n     *\n     * @private\n     * @param {number} row Physical row index.\n     * @param {string|number|Function} column Physical column index / property / function.\n     * @param {Array|object} dataRow A representation of a data row.\n     * @returns {*} Value at the provided coordinates.\n     */\n\n  }, {\n    key: \"getAtPhysicalCell\",\n    value: function getAtPhysicalCell(row, column, dataRow) {\n      var result = null;\n\n      if (dataRow) {\n        if (typeof column === 'string') {\n          result = getProperty(dataRow, column);\n        } else if (typeof column === 'function') {\n          result = column(dataRow);\n        } else {\n          result = dataRow[column];\n        }\n      }\n\n      if (this.hot.hasHook('modifySourceData')) {\n        var valueHolder = createObjectPropListener(result);\n        this.hot.runHooks('modifySourceData', row, this.colToProp(column), valueHolder, 'get');\n\n        if (valueHolder.isTouched()) {\n          result = valueHolder.value;\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Returns a single value from the data.\n     *\n     * @param {number} row Physical row index.\n     * @param {number} column Visual column index.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getAtCell\",\n    value: function getAtCell(row, column) {\n      var dataRow = this.modifyRowData(row);\n      return this.getAtPhysicalCell(row, this.colToProp(column), dataRow);\n    }\n    /**\n     * Returns source data by passed range.\n     *\n     * @param {object} [start] Object with physical `row` and `col` keys (or visual column index, if data type is an array of objects).\n     * @param {object} [end] Object with physical `row` and `col` keys (or visual column index, if data type is an array of objects).\n     * @param {boolean} [toArray=false] If `true` return source data as an array of arrays even when source data was provided\n     *                                  in another format.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getByRange\",\n    value: function getByRange() {\n      var _this3 = this;\n\n      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var toArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var getAllProps = false;\n      var startRow = null;\n      var startCol = null;\n      var endRow = null;\n      var endCol = null;\n\n      if (start === null || end === null) {\n        getAllProps = true;\n        startRow = 0;\n        endRow = this.countRows() - 1;\n      } else {\n        startRow = Math.min(start.row, end.row);\n        startCol = Math.min(start.col, end.col);\n        endRow = Math.max(start.row, end.row);\n        endCol = Math.max(start.col, end.col);\n      }\n\n      var result = [];\n      rangeEach(startRow, endRow, function (currentRow) {\n        result.push(getAllProps ? _this3.getAtRow(currentRow, void 0, void 0, toArray) : _this3.getAtRow(currentRow, startCol, endCol, toArray));\n      });\n      return result;\n    }\n    /**\n     * Count number of rows.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"countRows\",\n    value: function countRows() {\n      if (this.hot.hasHook('modifySourceLength')) {\n        var modifiedSourceLength = this.hot.runHooks('modifySourceLength');\n\n        if (Number.isInteger(modifiedSourceLength)) {\n          return modifiedSourceLength;\n        }\n      }\n\n      return this.data.length;\n    }\n    /**\n     * Count number of columns.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"countFirstRowKeys\",\n    value: function countFirstRowKeys() {\n      return _countFirstRowKeys(this.data);\n    }\n    /**\n     * Destroy instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.data = null;\n      this.hot = null;\n    }\n  }]);\n\n  return DataSource;\n}();\n\nexport default DataSource;"]},"metadata":{},"sourceType":"module"}