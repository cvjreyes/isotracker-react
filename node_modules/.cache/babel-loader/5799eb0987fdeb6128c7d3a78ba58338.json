{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { isObject } from \"./../helpers/object.mjs\";\nimport { rangeEach } from \"./../helpers/number.mjs\";\nimport { stringify } from \"./../helpers/mixed.mjs\";\n/**\r\n * @class SamplesGenerator\r\n * @util\r\n */\n\nvar SamplesGenerator = /*#__PURE__*/function () {\n  function SamplesGenerator(dataFactory) {\n    _classCallCheck(this, SamplesGenerator);\n    /**\r\n     * Samples prepared for calculations.\r\n     *\r\n     * @type {Map}\r\n     * @default {null}\r\n     */\n\n\n    this.samples = null;\n    /**\r\n     * Function which give the data to collect samples.\r\n     *\r\n     * @type {Function}\r\n     */\n\n    this.dataFactory = dataFactory;\n    /**\r\n     * Custom number of samples to take of each value length.\r\n     *\r\n     * @type {number}\r\n     * @default {null}\r\n     */\n\n    this.customSampleCount = null;\n    /**\r\n     * `true` if duplicate samples collection should be allowed, `false` otherwise.\r\n     *\r\n     * @type {boolean}\r\n     * @default {false}\r\n     */\n\n    this.allowDuplicates = false;\n  }\n  /**\r\n   * Get the sample count for this instance.\r\n   *\r\n   * @returns {number}\r\n   */\n\n\n  _createClass(SamplesGenerator, [{\n    key: \"getSampleCount\",\n    value: function getSampleCount() {\n      if (this.customSampleCount) {\n        return this.customSampleCount;\n      }\n\n      return SamplesGenerator.SAMPLE_COUNT;\n    }\n    /**\r\n     * Set the sample count.\r\n     *\r\n     * @param {number} sampleCount Number of samples to be collected.\r\n     */\n\n  }, {\n    key: \"setSampleCount\",\n    value: function setSampleCount(sampleCount) {\n      this.customSampleCount = sampleCount;\n    }\n    /**\r\n     * Set if the generator should accept duplicate values.\r\n     *\r\n     * @param {boolean} allowDuplicates `true` to allow duplicate values.\r\n     */\n\n  }, {\n    key: \"setAllowDuplicates\",\n    value: function setAllowDuplicates(allowDuplicates) {\n      this.allowDuplicates = allowDuplicates;\n    }\n    /**\r\n     * Generate samples for row. You can control which area should be sampled by passing `rowRange` object and `colRange` object.\r\n     *\r\n     * @param {object|number} rowRange The rows range to generate the samples.\r\n     * @param {object} colRange The column range to generate the samples.\r\n     * @returns {object}\r\n     */\n\n  }, {\n    key: \"generateRowSamples\",\n    value: function generateRowSamples(rowRange, colRange) {\n      return this.generateSamples('row', colRange, rowRange);\n    }\n    /**\r\n     * Generate samples for column. You can control which area should be sampled by passing `colRange` object and `rowRange` object.\r\n     *\r\n     * @param {object} colRange Column index.\r\n     * @param {object} rowRange Column index.\r\n     * @returns {object}\r\n     */\n\n  }, {\n    key: \"generateColumnSamples\",\n    value: function generateColumnSamples(colRange, rowRange) {\n      return this.generateSamples('col', rowRange, colRange);\n    }\n    /**\r\n     * Generate collection of samples.\r\n     *\r\n     * @param {string} type Type to generate. Can be `col` or `row`.\r\n     * @param {object} range The range to generate the samples.\r\n     * @param {object|number} specifierRange The range to generate the samples.\r\n     * @returns {Map}\r\n     */\n\n  }, {\n    key: \"generateSamples\",\n    value: function generateSamples(type, range, specifierRange) {\n      var _this = this;\n\n      var samples = new Map();\n\n      var _ref = typeof specifierRange === 'number' ? {\n        from: specifierRange,\n        to: specifierRange\n      } : specifierRange,\n          from = _ref.from,\n          to = _ref.to;\n\n      rangeEach(from, to, function (index) {\n        var sample = _this.generateSample(type, range, index);\n\n        samples.set(index, sample);\n      });\n      return samples;\n    }\n    /**\r\n     * Generate sample for specified type (`row` or `col`).\r\n     *\r\n     * @param {string} type Samples type `row` or `col`.\r\n     * @param {object} range The range to generate the samples.\r\n     * @param {number} specifierValue The range to generate the samples.\r\n     * @returns {Map}\r\n     */\n\n  }, {\n    key: \"generateSample\",\n    value: function generateSample(type, range, specifierValue) {\n      var _this2 = this;\n\n      if (type !== 'row' && type !== 'col') {\n        throw new Error('Unsupported sample type');\n      }\n\n      var samples = new Map();\n      var computedKey = type === 'row' ? 'col' : 'row';\n      var sampledValues = [];\n      rangeEach(range.from, range.to, function (index) {\n        var _ref2 = type === 'row' ? _this2.dataFactory(specifierValue, index) : _this2.dataFactory(index, specifierValue),\n            value = _ref2.value,\n            bundleSeed = _ref2.bundleSeed;\n\n        var hasCustomBundleSeed = typeof bundleSeed === 'string' && bundleSeed.length > 0;\n        var seed;\n\n        if (hasCustomBundleSeed) {\n          seed = bundleSeed;\n        } else if (isObject(value)) {\n          seed = \"\".concat(Object.keys(value).length);\n        } else if (Array.isArray(value)) {\n          seed = \"\".concat(value.length);\n        } else {\n          seed = \"\".concat(stringify(value).length);\n        }\n\n        if (!samples.has(seed)) {\n          samples.set(seed, {\n            needed: _this2.getSampleCount(),\n            strings: []\n          });\n        }\n\n        var sample = samples.get(seed);\n\n        if (sample.needed) {\n          var duplicate = sampledValues.indexOf(value) > -1;\n\n          if (!duplicate || _this2.allowDuplicates || hasCustomBundleSeed) {\n            sample.strings.push(_defineProperty({\n              value: value\n            }, computedKey, index));\n            sampledValues.push(value);\n            sample.needed -= 1;\n          }\n        }\n      });\n      return samples;\n    }\n  }], [{\n    key: \"SAMPLE_COUNT\",\n    get:\n    /**\r\n     * Number of samples to take of each value length.\r\n     *\r\n     * @type {number}\r\n     */\n    function get() {\n      return 3;\n    }\n  }]);\n\n  return SamplesGenerator;\n}();\n\nexport default SamplesGenerator;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/utils/samplesGenerator.mjs"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","_createClass","protoProps","staticProps","prototype","isObject","rangeEach","stringify","SamplesGenerator","dataFactory","samples","customSampleCount","allowDuplicates","getSampleCount","SAMPLE_COUNT","setSampleCount","sampleCount","setAllowDuplicates","generateRowSamples","rowRange","colRange","generateSamples","generateColumnSamples","type","range","specifierRange","_this","Map","_ref","from","to","index","sample","generateSample","set","specifierValue","_this2","Error","computedKey","sampledValues","_ref2","bundleSeed","hasCustomBundleSeed","seed","concat","keys","Array","isArray","has","needed","strings","get","duplicate","indexOf","push"],"mappings":"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","sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\r\n\r\nimport \"core-js/modules/es.array.iterator.js\";\r\nimport \"core-js/modules/es.map.js\";\r\nimport \"core-js/modules/es.object.to-string.js\";\r\nimport \"core-js/modules/es.string.iterator.js\";\r\nimport \"core-js/modules/web.dom-collections.iterator.js\";\r\nimport \"core-js/modules/es.object.keys.js\";\r\nimport \"core-js/modules/es.array.index-of.js\";\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport { isObject } from \"./../helpers/object.mjs\";\r\nimport { rangeEach } from \"./../helpers/number.mjs\";\r\nimport { stringify } from \"./../helpers/mixed.mjs\";\r\n/**\r\n * @class SamplesGenerator\r\n * @util\r\n */\r\n\r\nvar SamplesGenerator = /*#__PURE__*/function () {\r\n  function SamplesGenerator(dataFactory) {\r\n    _classCallCheck(this, SamplesGenerator);\r\n\r\n    /**\r\n     * Samples prepared for calculations.\r\n     *\r\n     * @type {Map}\r\n     * @default {null}\r\n     */\r\n    this.samples = null;\r\n    /**\r\n     * Function which give the data to collect samples.\r\n     *\r\n     * @type {Function}\r\n     */\r\n\r\n    this.dataFactory = dataFactory;\r\n    /**\r\n     * Custom number of samples to take of each value length.\r\n     *\r\n     * @type {number}\r\n     * @default {null}\r\n     */\r\n\r\n    this.customSampleCount = null;\r\n    /**\r\n     * `true` if duplicate samples collection should be allowed, `false` otherwise.\r\n     *\r\n     * @type {boolean}\r\n     * @default {false}\r\n     */\r\n\r\n    this.allowDuplicates = false;\r\n  }\r\n  /**\r\n   * Get the sample count for this instance.\r\n   *\r\n   * @returns {number}\r\n   */\r\n\r\n\r\n  _createClass(SamplesGenerator, [{\r\n    key: \"getSampleCount\",\r\n    value: function getSampleCount() {\r\n      if (this.customSampleCount) {\r\n        return this.customSampleCount;\r\n      }\r\n\r\n      return SamplesGenerator.SAMPLE_COUNT;\r\n    }\r\n    /**\r\n     * Set the sample count.\r\n     *\r\n     * @param {number} sampleCount Number of samples to be collected.\r\n     */\r\n\r\n  }, {\r\n    key: \"setSampleCount\",\r\n    value: function setSampleCount(sampleCount) {\r\n      this.customSampleCount = sampleCount;\r\n    }\r\n    /**\r\n     * Set if the generator should accept duplicate values.\r\n     *\r\n     * @param {boolean} allowDuplicates `true` to allow duplicate values.\r\n     */\r\n\r\n  }, {\r\n    key: \"setAllowDuplicates\",\r\n    value: function setAllowDuplicates(allowDuplicates) {\r\n      this.allowDuplicates = allowDuplicates;\r\n    }\r\n    /**\r\n     * Generate samples for row. You can control which area should be sampled by passing `rowRange` object and `colRange` object.\r\n     *\r\n     * @param {object|number} rowRange The rows range to generate the samples.\r\n     * @param {object} colRange The column range to generate the samples.\r\n     * @returns {object}\r\n     */\r\n\r\n  }, {\r\n    key: \"generateRowSamples\",\r\n    value: function generateRowSamples(rowRange, colRange) {\r\n      return this.generateSamples('row', colRange, rowRange);\r\n    }\r\n    /**\r\n     * Generate samples for column. You can control which area should be sampled by passing `colRange` object and `rowRange` object.\r\n     *\r\n     * @param {object} colRange Column index.\r\n     * @param {object} rowRange Column index.\r\n     * @returns {object}\r\n     */\r\n\r\n  }, {\r\n    key: \"generateColumnSamples\",\r\n    value: function generateColumnSamples(colRange, rowRange) {\r\n      return this.generateSamples('col', rowRange, colRange);\r\n    }\r\n    /**\r\n     * Generate collection of samples.\r\n     *\r\n     * @param {string} type Type to generate. Can be `col` or `row`.\r\n     * @param {object} range The range to generate the samples.\r\n     * @param {object|number} specifierRange The range to generate the samples.\r\n     * @returns {Map}\r\n     */\r\n\r\n  }, {\r\n    key: \"generateSamples\",\r\n    value: function generateSamples(type, range, specifierRange) {\r\n      var _this = this;\r\n\r\n      var samples = new Map();\r\n\r\n      var _ref = typeof specifierRange === 'number' ? {\r\n        from: specifierRange,\r\n        to: specifierRange\r\n      } : specifierRange,\r\n          from = _ref.from,\r\n          to = _ref.to;\r\n\r\n      rangeEach(from, to, function (index) {\r\n        var sample = _this.generateSample(type, range, index);\r\n\r\n        samples.set(index, sample);\r\n      });\r\n      return samples;\r\n    }\r\n    /**\r\n     * Generate sample for specified type (`row` or `col`).\r\n     *\r\n     * @param {string} type Samples type `row` or `col`.\r\n     * @param {object} range The range to generate the samples.\r\n     * @param {number} specifierValue The range to generate the samples.\r\n     * @returns {Map}\r\n     */\r\n\r\n  }, {\r\n    key: \"generateSample\",\r\n    value: function generateSample(type, range, specifierValue) {\r\n      var _this2 = this;\r\n\r\n      if (type !== 'row' && type !== 'col') {\r\n        throw new Error('Unsupported sample type');\r\n      }\r\n\r\n      var samples = new Map();\r\n      var computedKey = type === 'row' ? 'col' : 'row';\r\n      var sampledValues = [];\r\n      rangeEach(range.from, range.to, function (index) {\r\n        var _ref2 = type === 'row' ? _this2.dataFactory(specifierValue, index) : _this2.dataFactory(index, specifierValue),\r\n            value = _ref2.value,\r\n            bundleSeed = _ref2.bundleSeed;\r\n\r\n        var hasCustomBundleSeed = typeof bundleSeed === 'string' && bundleSeed.length > 0;\r\n        var seed;\r\n\r\n        if (hasCustomBundleSeed) {\r\n          seed = bundleSeed;\r\n        } else if (isObject(value)) {\r\n          seed = \"\".concat(Object.keys(value).length);\r\n        } else if (Array.isArray(value)) {\r\n          seed = \"\".concat(value.length);\r\n        } else {\r\n          seed = \"\".concat(stringify(value).length);\r\n        }\r\n\r\n        if (!samples.has(seed)) {\r\n          samples.set(seed, {\r\n            needed: _this2.getSampleCount(),\r\n            strings: []\r\n          });\r\n        }\r\n\r\n        var sample = samples.get(seed);\r\n\r\n        if (sample.needed) {\r\n          var duplicate = sampledValues.indexOf(value) > -1;\r\n\r\n          if (!duplicate || _this2.allowDuplicates || hasCustomBundleSeed) {\r\n            sample.strings.push(_defineProperty({\r\n              value: value\r\n            }, computedKey, index));\r\n            sampledValues.push(value);\r\n            sample.needed -= 1;\r\n          }\r\n        }\r\n      });\r\n      return samples;\r\n    }\r\n  }], [{\r\n    key: \"SAMPLE_COUNT\",\r\n    get:\r\n    /**\r\n     * Number of samples to take of each value length.\r\n     *\r\n     * @type {number}\r\n     */\r\n    function get() {\r\n      return 3;\r\n    }\r\n  }]);\r\n\r\n  return SamplesGenerator;\r\n}();\r\n\r\nexport default SamplesGenerator;"]},"metadata":{},"sourceType":"module"}