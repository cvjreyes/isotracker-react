{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport NodesPool from \"./../utils/nodesPool.mjs\";\n/**\n * Base renderer class, abstract logic for specialized renderers.\n *\n * @class BaseRenderer\n */\n\nvar BaseRenderer = /*#__PURE__*/function () {\n  function BaseRenderer(nodeType, rootNode) {\n    _classCallCheck(this, BaseRenderer);\n    /**\n     * Factory for newly created DOM elements.\n     *\n     * NodePool should be used for each renderer. For the first stage of the refactoring\n     * process, only some of the renderers are implemented a new approach.\n     *\n     * @type {NodesPool|null}\n     */\n\n\n    this.nodesPool = typeof nodeType === 'string' ? new NodesPool(nodeType) : null;\n    /**\n     * Node type which the renderer will manage while building the table (eg. 'TD', 'TR', 'TH').\n     *\n     * @type {string}\n     */\n\n    this.nodeType = nodeType;\n    /**\n     * The root node to which newly created elements will be inserted.\n     *\n     * @type {HTMLElement}\n     */\n\n    this.rootNode = rootNode;\n    /**\n     * The instance of the Table class, a wrapper for all renderers and holder for properties describe table state.\n     *\n     * @type {TableRenderer}\n     */\n\n    this.table = null;\n    /**\n     * Counter of nodes already added.\n     *\n     * @type {number}\n     */\n\n    this.renderedNodes = 0;\n  }\n  /**\n   * Sets the table renderer instance to the current renderer.\n   *\n   * @param {TableRenderer} table The TableRenderer instance.\n   */\n\n\n  _createClass(BaseRenderer, [{\n    key: \"setTable\",\n    value: function setTable(table) {\n      if (this.nodesPool) {\n        this.nodesPool.setRootDocument(table.rootDocument);\n      }\n\n      this.table = table;\n    }\n    /**\n     * Adjusts the number of rendered nodes.\n     */\n\n  }, {\n    key: \"adjust\",\n    value: function adjust() {}\n    /**\n     * Renders the contents to the elements.\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {}\n  }]);\n\n  return BaseRenderer;\n}();\n\nexport { BaseRenderer as default };","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/3rdparty/walkontable/src/renderer/_base.mjs"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","NodesPool","BaseRenderer","nodeType","rootNode","nodesPool","table","renderedNodes","value","setTable","setRootDocument","rootDocument","adjust","render","default"],"mappings":"AAAA,SAASA,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;AAAE,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;;AAEzJ,SAASC,iBAAT,CAA2BC,MAA3B,EAAmCC,KAAnC,EAA0C;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AAAE,QAAIE,UAAU,GAAGH,KAAK,CAACC,CAAD,CAAtB;AAA2BE,IAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,IAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,QAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4BC,IAAAA,MAAM,CAACC,cAAP,CAAsBT,MAAtB,EAA8BI,UAAU,CAACM,GAAzC,EAA8CN,UAA9C;AAA4D;AAAE;;AAE7T,SAASO,YAAT,CAAsBd,WAAtB,EAAmCe,UAAnC,EAA+CC,WAA/C,EAA4D;AAAE,MAAID,UAAJ,EAAgBb,iBAAiB,CAACF,WAAW,CAACiB,SAAb,EAAwBF,UAAxB,CAAjB;AAAsD,MAAIC,WAAJ,EAAiBd,iBAAiB,CAACF,WAAD,EAAcgB,WAAd,CAAjB;AAA6C,SAAOhB,WAAP;AAAqB;;AAEvN,OAAOkB,SAAP,MAAsB,0BAAtB;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,YAAY,GAAG,aAAa,YAAY;AAC1C,WAASA,YAAT,CAAsBC,QAAtB,EAAgCC,QAAhC,EAA0C;AACxCvB,IAAAA,eAAe,CAAC,IAAD,EAAOqB,YAAP,CAAf;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,SAAKG,SAAL,GAAiB,OAAOF,QAAP,KAAoB,QAApB,GAA+B,IAAIF,SAAJ,CAAcE,QAAd,CAA/B,GAAyD,IAA1E;AACA;AACJ;AACA;AACA;AACA;;AAEI,SAAKA,QAAL,GAAgBA,QAAhB;AACA;AACJ;AACA;AACA;AACA;;AAEI,SAAKC,QAAL,GAAgBA,QAAhB;AACA;AACJ;AACA;AACA;AACA;;AAEI,SAAKE,KAAL,GAAa,IAAb;AACA;AACJ;AACA;AACA;AACA;;AAEI,SAAKC,aAAL,GAAqB,CAArB;AACD;AACD;AACF;AACA;AACA;AACA;;;AAGEV,EAAAA,YAAY,CAACK,YAAD,EAAe,CAAC;AAC1BN,IAAAA,GAAG,EAAE,UADqB;AAE1BY,IAAAA,KAAK,EAAE,SAASC,QAAT,CAAkBH,KAAlB,EAAyB;AAC9B,UAAI,KAAKD,SAAT,EAAoB;AAClB,aAAKA,SAAL,CAAeK,eAAf,CAA+BJ,KAAK,CAACK,YAArC;AACD;;AAED,WAAKL,KAAL,GAAaA,KAAb;AACD;AACD;AACJ;AACA;;AAX8B,GAAD,EAaxB;AACDV,IAAAA,GAAG,EAAE,QADJ;AAEDY,IAAAA,KAAK,EAAE,SAASI,MAAT,GAAkB,CAAE;AAC3B;AACJ;AACA;;AALK,GAbwB,EAoBxB;AACDhB,IAAAA,GAAG,EAAE,QADJ;AAEDY,IAAAA,KAAK,EAAE,SAASK,MAAT,GAAkB,CAAE;AAF1B,GApBwB,CAAf,CAAZ;;AAyBA,SAAOX,YAAP;AACD,CA3E+B,EAAhC;;AA6EA,SAASA,YAAY,IAAIY,OAAzB","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport NodesPool from \"./../utils/nodesPool.mjs\";\n/**\n * Base renderer class, abstract logic for specialized renderers.\n *\n * @class BaseRenderer\n */\n\nvar BaseRenderer = /*#__PURE__*/function () {\n  function BaseRenderer(nodeType, rootNode) {\n    _classCallCheck(this, BaseRenderer);\n\n    /**\n     * Factory for newly created DOM elements.\n     *\n     * NodePool should be used for each renderer. For the first stage of the refactoring\n     * process, only some of the renderers are implemented a new approach.\n     *\n     * @type {NodesPool|null}\n     */\n    this.nodesPool = typeof nodeType === 'string' ? new NodesPool(nodeType) : null;\n    /**\n     * Node type which the renderer will manage while building the table (eg. 'TD', 'TR', 'TH').\n     *\n     * @type {string}\n     */\n\n    this.nodeType = nodeType;\n    /**\n     * The root node to which newly created elements will be inserted.\n     *\n     * @type {HTMLElement}\n     */\n\n    this.rootNode = rootNode;\n    /**\n     * The instance of the Table class, a wrapper for all renderers and holder for properties describe table state.\n     *\n     * @type {TableRenderer}\n     */\n\n    this.table = null;\n    /**\n     * Counter of nodes already added.\n     *\n     * @type {number}\n     */\n\n    this.renderedNodes = 0;\n  }\n  /**\n   * Sets the table renderer instance to the current renderer.\n   *\n   * @param {TableRenderer} table The TableRenderer instance.\n   */\n\n\n  _createClass(BaseRenderer, [{\n    key: \"setTable\",\n    value: function setTable(table) {\n      if (this.nodesPool) {\n        this.nodesPool.setRootDocument(table.rootDocument);\n      }\n\n      this.table = table;\n    }\n    /**\n     * Adjusts the number of rendered nodes.\n     */\n\n  }, {\n    key: \"adjust\",\n    value: function adjust() {}\n    /**\n     * Renders the contents to the elements.\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {}\n  }]);\n\n  return BaseRenderer;\n}();\n\nexport { BaseRenderer as default };"]},"metadata":{},"sourceType":"module"}