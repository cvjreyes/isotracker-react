{"ast":null,"code":"import _slicedToArray from \"C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nvar _excluded = [\"element\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { unstable_useEnhancedEffect as useEnhancedEffect } from '@mui/material/utils';\n/** Credit: https://github.com/reach/reach-ui/blob/86a046f54d53b6420e392b3fa56dd991d9d4e458/packages/descendants/README.md\r\n *  Modified slightly to suit our purposes.\r\n */\n// To replace with .findIndex() once we stop IE11 support.\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nfunction findIndex(array, comp) {\n  for (var i = 0; i < array.length; i += 1) {\n    if (comp(array[i])) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction binaryFindElement(array, element) {\n  var start = 0;\n  var end = array.length - 1;\n\n  while (start <= end) {\n    var middle = Math.floor((start + end) / 2);\n\n    if (array[middle].element === element) {\n      return middle;\n    } // eslint-disable-next-line no-bitwise\n\n\n    if (array[middle].element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING) {\n      end = middle - 1;\n    } else {\n      start = middle + 1;\n    }\n  }\n\n  return start;\n}\n\nvar DescendantContext = /*#__PURE__*/React.createContext({});\n\nif (process.env.NODE_ENV !== 'production') {\n  DescendantContext.displayName = 'DescendantContext';\n}\n\nfunction usePrevious(value) {\n  var ref = React.useRef(null);\n  React.useEffect(function () {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n\nvar noop = function noop() {};\n/**\r\n * This hook registers our descendant by passing it into an array. We can then\r\n * search that array by to find its index when registering it in the component.\r\n * We use this for focus management, keyboard navigation, and typeahead\r\n * functionality for some components.\r\n *\r\n * The hook accepts the element node\r\n *\r\n * Our main goals with this are:\r\n *   1) maximum composability,\r\n *   2) minimal API friction\r\n *   3) SSR compatibility*\r\n *   4) concurrent safe\r\n *   5) index always up-to-date with the tree despite changes\r\n *   6) works with memoization of any component in the tree (hopefully)\r\n *\r\n * * As for SSR, the good news is that we don't actually need the index on the\r\n * server for most use-cases, as we are only using it to determine the order of\r\n * composed descendants for keyboard navigation.\r\n */\n\n\nexport function useDescendant(descendant) {\n  var _React$useState = React.useState(),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      forceUpdate = _React$useState2[1];\n\n  var _React$useContext = React.useContext(DescendantContext),\n      _React$useContext$reg = _React$useContext.registerDescendant,\n      registerDescendant = _React$useContext$reg === void 0 ? noop : _React$useContext$reg,\n      _React$useContext$unr = _React$useContext.unregisterDescendant,\n      unregisterDescendant = _React$useContext$unr === void 0 ? noop : _React$useContext$unr,\n      _React$useContext$des = _React$useContext.descendants,\n      descendants = _React$useContext$des === void 0 ? [] : _React$useContext$des,\n      _React$useContext$par = _React$useContext.parentId,\n      parentId = _React$useContext$par === void 0 ? null : _React$useContext$par; // This will initially return -1 because we haven't registered the descendant\n  // on the first render. After we register, this will then return the correct\n  // index on the following render and we will re-register descendants\n  // so that everything is up-to-date before the user interacts with a\n  // collection.\n\n\n  var index = findIndex(descendants, function (item) {\n    return item.element === descendant.element;\n  });\n  var previousDescendants = usePrevious(descendants); // We also need to re-register descendants any time ANY of the other\n  // descendants have changed. My brain was melting when I wrote this and it\n  // feels a little off, but checking in render and using the result in the\n  // effect's dependency array works well enough.\n\n  var someDescendantsHaveChanged = descendants.some(function (newDescendant, position) {\n    return previousDescendants && previousDescendants[position] && previousDescendants[position].element !== newDescendant.element;\n  }); // Prevent any flashing\n\n  useEnhancedEffect(function () {\n    if (descendant.element) {\n      registerDescendant(_extends({}, descendant, {\n        index: index\n      }));\n      return function () {\n        unregisterDescendant(descendant.element);\n      };\n    }\n\n    forceUpdate({});\n    return undefined;\n  }, [registerDescendant, unregisterDescendant, index, someDescendantsHaveChanged, descendant]);\n  return {\n    parentId: parentId,\n    index: index\n  };\n}\nexport function DescendantProvider(props) {\n  var children = props.children,\n      id = props.id;\n\n  var _React$useState3 = React.useState([]),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      items = _React$useState4[0],\n      set = _React$useState4[1];\n\n  var registerDescendant = React.useCallback(function (_ref) {\n    var element = _ref.element,\n        other = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n    set(function (oldItems) {\n      var newItems;\n\n      if (oldItems.length === 0) {\n        // If there are no items, register at index 0 and bail.\n        return [_extends({}, other, {\n          element: element,\n          index: 0\n        })];\n      }\n\n      var index = binaryFindElement(oldItems, element);\n\n      if (oldItems[index] && oldItems[index].element === element) {\n        // If the element is already registered, just use the same array\n        newItems = oldItems;\n      } else {\n        // When registering a descendant, we need to make sure we insert in\n        // into the array in the same order that it appears in the DOM. So as\n        // new descendants are added or maybe some are removed, we always know\n        // that the array is up-to-date and correct.\n        //\n        // So here we look at our registered descendants and see if the new\n        // element we are adding appears earlier than an existing descendant's\n        // DOM node via `node.compareDocumentPosition`. If it does, we insert\n        // the new element at this index. Because `registerDescendant` will be\n        // called in an effect every time the descendants state value changes,\n        // we should be sure that this index is accurate when descendent\n        // elements come or go from our component.\n        var newItem = _extends({}, other, {\n          element: element,\n          index: index\n        }); // If an index is not found we will push the element to the end.\n\n\n        newItems = oldItems.slice();\n        newItems.splice(index, 0, newItem);\n      }\n\n      newItems.forEach(function (item, position) {\n        item.index = position;\n      });\n      return newItems;\n    });\n  }, []);\n  var unregisterDescendant = React.useCallback(function (element) {\n    set(function (oldItems) {\n      return oldItems.filter(function (item) {\n        return element !== item.element;\n      });\n    });\n  }, []);\n  var value = React.useMemo(function () {\n    return {\n      descendants: items,\n      registerDescendant: registerDescendant,\n      unregisterDescendant: unregisterDescendant,\n      parentId: id\n    };\n  }, [items, registerDescendant, unregisterDescendant, id]);\n  return /*#__PURE__*/_jsx(DescendantContext.Provider, {\n    value: value,\n    children: children\n  });\n}\nprocess.env.NODE_ENV !== \"production\" ? DescendantProvider.propTypes = {\n  children: PropTypes.node,\n  id: PropTypes.string\n} : void 0;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/@mui/lab/TreeView/descendants.js"],"names":["_objectWithoutPropertiesLoose","_extends","_excluded","React","PropTypes","unstable_useEnhancedEffect","useEnhancedEffect","jsx","_jsx","findIndex","array","comp","i","length","binaryFindElement","element","start","end","middle","Math","floor","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","DescendantContext","createContext","process","env","NODE_ENV","displayName","usePrevious","value","ref","useRef","useEffect","current","noop","useDescendant","descendant","useState","forceUpdate","useContext","registerDescendant","unregisterDescendant","descendants","parentId","index","item","previousDescendants","someDescendantsHaveChanged","some","newDescendant","position","undefined","DescendantProvider","props","children","id","items","set","useCallback","_ref","other","oldItems","newItems","newItem","slice","splice","forEach","filter","useMemo","Provider","propTypes","node","string"],"mappings":"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","sourcesContent":["import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\r\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\r\nconst _excluded = [\"element\"];\r\nimport * as React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { unstable_useEnhancedEffect as useEnhancedEffect } from '@mui/material/utils';\r\n/** Credit: https://github.com/reach/reach-ui/blob/86a046f54d53b6420e392b3fa56dd991d9d4e458/packages/descendants/README.md\r\n *  Modified slightly to suit our purposes.\r\n */\r\n// To replace with .findIndex() once we stop IE11 support.\r\n\r\nimport { jsx as _jsx } from \"react/jsx-runtime\";\r\n\r\nfunction findIndex(array, comp) {\r\n  for (let i = 0; i < array.length; i += 1) {\r\n    if (comp(array[i])) {\r\n      return i;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\nfunction binaryFindElement(array, element) {\r\n  let start = 0;\r\n  let end = array.length - 1;\r\n\r\n  while (start <= end) {\r\n    const middle = Math.floor((start + end) / 2);\r\n\r\n    if (array[middle].element === element) {\r\n      return middle;\r\n    } // eslint-disable-next-line no-bitwise\r\n\r\n\r\n    if (array[middle].element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING) {\r\n      end = middle - 1;\r\n    } else {\r\n      start = middle + 1;\r\n    }\r\n  }\r\n\r\n  return start;\r\n}\r\n\r\nconst DescendantContext = /*#__PURE__*/React.createContext({});\r\n\r\nif (process.env.NODE_ENV !== 'production') {\r\n  DescendantContext.displayName = 'DescendantContext';\r\n}\r\n\r\nfunction usePrevious(value) {\r\n  const ref = React.useRef(null);\r\n  React.useEffect(() => {\r\n    ref.current = value;\r\n  }, [value]);\r\n  return ref.current;\r\n}\r\n\r\nconst noop = () => {};\r\n/**\r\n * This hook registers our descendant by passing it into an array. We can then\r\n * search that array by to find its index when registering it in the component.\r\n * We use this for focus management, keyboard navigation, and typeahead\r\n * functionality for some components.\r\n *\r\n * The hook accepts the element node\r\n *\r\n * Our main goals with this are:\r\n *   1) maximum composability,\r\n *   2) minimal API friction\r\n *   3) SSR compatibility*\r\n *   4) concurrent safe\r\n *   5) index always up-to-date with the tree despite changes\r\n *   6) works with memoization of any component in the tree (hopefully)\r\n *\r\n * * As for SSR, the good news is that we don't actually need the index on the\r\n * server for most use-cases, as we are only using it to determine the order of\r\n * composed descendants for keyboard navigation.\r\n */\r\n\r\n\r\nexport function useDescendant(descendant) {\r\n  const [, forceUpdate] = React.useState();\r\n  const {\r\n    registerDescendant = noop,\r\n    unregisterDescendant = noop,\r\n    descendants = [],\r\n    parentId = null\r\n  } = React.useContext(DescendantContext); // This will initially return -1 because we haven't registered the descendant\r\n  // on the first render. After we register, this will then return the correct\r\n  // index on the following render and we will re-register descendants\r\n  // so that everything is up-to-date before the user interacts with a\r\n  // collection.\r\n\r\n  const index = findIndex(descendants, item => item.element === descendant.element);\r\n  const previousDescendants = usePrevious(descendants); // We also need to re-register descendants any time ANY of the other\r\n  // descendants have changed. My brain was melting when I wrote this and it\r\n  // feels a little off, but checking in render and using the result in the\r\n  // effect's dependency array works well enough.\r\n\r\n  const someDescendantsHaveChanged = descendants.some((newDescendant, position) => {\r\n    return previousDescendants && previousDescendants[position] && previousDescendants[position].element !== newDescendant.element;\r\n  }); // Prevent any flashing\r\n\r\n  useEnhancedEffect(() => {\r\n    if (descendant.element) {\r\n      registerDescendant(_extends({}, descendant, {\r\n        index\r\n      }));\r\n      return () => {\r\n        unregisterDescendant(descendant.element);\r\n      };\r\n    }\r\n\r\n    forceUpdate({});\r\n    return undefined;\r\n  }, [registerDescendant, unregisterDescendant, index, someDescendantsHaveChanged, descendant]);\r\n  return {\r\n    parentId,\r\n    index\r\n  };\r\n}\r\nexport function DescendantProvider(props) {\r\n  const {\r\n    children,\r\n    id\r\n  } = props;\r\n  const [items, set] = React.useState([]);\r\n  const registerDescendant = React.useCallback(_ref => {\r\n    let {\r\n      element\r\n    } = _ref,\r\n        other = _objectWithoutPropertiesLoose(_ref, _excluded);\r\n\r\n    set(oldItems => {\r\n      let newItems;\r\n\r\n      if (oldItems.length === 0) {\r\n        // If there are no items, register at index 0 and bail.\r\n        return [_extends({}, other, {\r\n          element,\r\n          index: 0\r\n        })];\r\n      }\r\n\r\n      const index = binaryFindElement(oldItems, element);\r\n\r\n      if (oldItems[index] && oldItems[index].element === element) {\r\n        // If the element is already registered, just use the same array\r\n        newItems = oldItems;\r\n      } else {\r\n        // When registering a descendant, we need to make sure we insert in\r\n        // into the array in the same order that it appears in the DOM. So as\r\n        // new descendants are added or maybe some are removed, we always know\r\n        // that the array is up-to-date and correct.\r\n        //\r\n        // So here we look at our registered descendants and see if the new\r\n        // element we are adding appears earlier than an existing descendant's\r\n        // DOM node via `node.compareDocumentPosition`. If it does, we insert\r\n        // the new element at this index. Because `registerDescendant` will be\r\n        // called in an effect every time the descendants state value changes,\r\n        // we should be sure that this index is accurate when descendent\r\n        // elements come or go from our component.\r\n        const newItem = _extends({}, other, {\r\n          element,\r\n          index\r\n        }); // If an index is not found we will push the element to the end.\r\n\r\n\r\n        newItems = oldItems.slice();\r\n        newItems.splice(index, 0, newItem);\r\n      }\r\n\r\n      newItems.forEach((item, position) => {\r\n        item.index = position;\r\n      });\r\n      return newItems;\r\n    });\r\n  }, []);\r\n  const unregisterDescendant = React.useCallback(element => {\r\n    set(oldItems => oldItems.filter(item => element !== item.element));\r\n  }, []);\r\n  const value = React.useMemo(() => ({\r\n    descendants: items,\r\n    registerDescendant,\r\n    unregisterDescendant,\r\n    parentId: id\r\n  }), [items, registerDescendant, unregisterDescendant, id]);\r\n  return /*#__PURE__*/_jsx(DescendantContext.Provider, {\r\n    value: value,\r\n    children: children\r\n  });\r\n}\r\nprocess.env.NODE_ENV !== \"production\" ? DescendantProvider.propTypes = {\r\n  children: PropTypes.node,\r\n  id: PropTypes.string\r\n} : void 0;"]},"metadata":{},"sourceType":"module"}