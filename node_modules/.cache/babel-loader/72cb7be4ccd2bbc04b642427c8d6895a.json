{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n\n  _classApplyDescriptorSet(receiver, descriptor, value);\n\n  return value;\n}\n\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n\n    descriptor.value = value;\n  }\n}\n\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\n\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n\n  return privateMap.get(receiver);\n}\n\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n\n  return descriptor.value;\n}\n\nimport { BasePlugin } from \"../base/index.mjs\";\nimport { createAutofillHooks } from \"./autofill.mjs\";\nimport staticRegister from \"../../utils/staticRegister.mjs\";\nimport { error, warn } from \"../../helpers/console.mjs\";\nimport { isDefined, isUndefined } from \"../../helpers/mixed.mjs\";\nimport { setupEngine, setupSheet, unregisterEngine, getRegisteredHotInstances } from \"./engine/register.mjs\";\nimport { isEscapedFormulaExpression, unescapeFormulaExpression } from \"./utils.mjs\";\nimport { getEngineSettingsWithOverrides } from \"./engine/settings.mjs\";\nimport { isArrayOfArrays } from \"../../helpers/data.mjs\";\nimport { toUpperCaseFirst } from \"../../helpers/string.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nexport var PLUGIN_KEY = 'formulas';\nexport var PLUGIN_PRIORITY = 260;\nHooks.getSingleton().register('afterNamedExpressionAdded');\nHooks.getSingleton().register('afterNamedExpressionRemoved');\nHooks.getSingleton().register('afterSheetAdded');\nHooks.getSingleton().register('afterSheetRemoved');\nHooks.getSingleton().register('afterSheetRenamed');\nHooks.getSingleton().register('afterFormulasValuesUpdate');\n/**\n * This plugin allows you to perform Excel-like calculations in your business applications. It does it by an\n * integration with our other product, [HyperFormula](https://github.com/handsontable/hyperformula/), which is a\n * powerful calculation engine with an extensive number of features.\n *\n * @plugin Formulas\n */\n\nvar _internalOperationPending = /*#__PURE__*/new WeakMap();\n\nvar _hotWasInitializedWithEmptyData = /*#__PURE__*/new WeakMap();\n\nvar _engineListeners = /*#__PURE__*/new WeakMap();\n\nexport var Formulas = /*#__PURE__*/function (_BasePlugin) {\n  _inherits(Formulas, _BasePlugin);\n\n  var _super = _createSuper(Formulas);\n\n  function Formulas() {\n    var _this;\n\n    _classCallCheck(this, Formulas);\n\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(_args));\n\n    _internalOperationPending.set(_assertThisInitialized(_this), {\n      writable: true,\n      value: false\n    });\n\n    _hotWasInitializedWithEmptyData.set(_assertThisInitialized(_this), {\n      writable: true,\n      value: false\n    });\n\n    _engineListeners.set(_assertThisInitialized(_this), {\n      writable: true,\n      value: [['valuesUpdated', function () {\n        var _this2;\n\n        return (_this2 = _this).onEngineValuesUpdated.apply(_this2, arguments);\n      }], ['namedExpressionAdded', function () {\n        var _this3;\n\n        return (_this3 = _this).onEngineNamedExpressionsAdded.apply(_this3, arguments);\n      }], ['namedExpressionRemoved', function () {\n        var _this4;\n\n        return (_this4 = _this).onEngineNamedExpressionsRemoved.apply(_this4, arguments);\n      }], ['sheetAdded', function () {\n        var _this5;\n\n        return (_this5 = _this).onEngineSheetAdded.apply(_this5, arguments);\n      }], ['sheetRenamed', function () {\n        var _this6;\n\n        return (_this6 = _this).onEngineSheetRenamed.apply(_this6, arguments);\n      }], ['sheetRemoved', function () {\n        var _this7;\n\n        return (_this7 = _this).onEngineSheetRemoved.apply(_this7, arguments);\n      }]]\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"staticRegister\", staticRegister('formulas'));\n\n    _defineProperty(_assertThisInitialized(_this), \"engine\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"sheetName\", null);\n\n    return _this;\n  }\n\n  _createClass(Formulas, [{\n    key: \"sheetId\",\n    get:\n    /**\n     * HyperFormula's sheet id.\n     *\n     * @type {number|null}\n     */\n    function get() {\n      return this.sheetName === null ? null : this.engine.getSheetId(this.sheetName);\n    }\n    /**\n     * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n     * hook and if it returns `true` than the {@link Formulas#enablePlugin} method is called.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      /* eslint-disable no-unneeded-ternary */\n      return this.hot.getSettings()[PLUGIN_KEY] ? true : false;\n    }\n    /**\n     * Enables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"enablePlugin\",\n    value: function enablePlugin() {\n      var _setupEngine,\n          _this8 = this;\n\n      if (this.enabled) {\n        return;\n      }\n\n      this.engine = (_setupEngine = setupEngine(this.hot)) !== null && _setupEngine !== void 0 ? _setupEngine : this.engine;\n\n      if (!this.engine) {\n        warn('Missing the required `engine` key in the Formulas settings. Please fill it with either an' + ' engine class or an engine instance.');\n        return;\n      } // Useful for disabling -> enabling the plugin using `updateSettings` or the API.\n\n\n      if (this.sheetName !== null && !this.engine.doesSheetExist(this.sheetName)) {\n        this.sheetName = this.addSheet(this.sheetName, this.hot.getSourceDataArray());\n      }\n\n      this.addHook('beforeLoadData', function () {\n        return _this8.onBeforeLoadData.apply(_this8, arguments);\n      });\n      this.addHook('afterLoadData', function () {\n        return _this8.onAfterLoadData.apply(_this8, arguments);\n      });\n      this.addHook('modifyData', function () {\n        return _this8.onModifyData.apply(_this8, arguments);\n      });\n      this.addHook('modifySourceData', function () {\n        return _this8.onModifySourceData.apply(_this8, arguments);\n      });\n      this.addHook('beforeValidate', function () {\n        return _this8.onBeforeValidate.apply(_this8, arguments);\n      });\n      this.addHook('afterSetSourceDataAtCell', function () {\n        return _this8.onAfterSetSourceDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('afterSetDataAtCell', function () {\n        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('afterSetDataAtRowProp', function () {\n        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('beforeCreateRow', function () {\n        return _this8.onBeforeCreateRow.apply(_this8, arguments);\n      });\n      this.addHook('beforeCreateCol', function () {\n        return _this8.onBeforeCreateCol.apply(_this8, arguments);\n      });\n      this.addHook('afterCreateRow', function () {\n        return _this8.onAfterCreateRow.apply(_this8, arguments);\n      });\n      this.addHook('afterCreateCol', function () {\n        return _this8.onAfterCreateCol.apply(_this8, arguments);\n      });\n      this.addHook('beforeRemoveRow', function () {\n        return _this8.onBeforeRemoveRow.apply(_this8, arguments);\n      });\n      this.addHook('beforeRemoveCol', function () {\n        return _this8.onBeforeRemoveCol.apply(_this8, arguments);\n      });\n      this.addHook('afterRemoveRow', function () {\n        return _this8.onAfterRemoveRow.apply(_this8, arguments);\n      });\n      this.addHook('afterRemoveCol', function () {\n        return _this8.onAfterRemoveCol.apply(_this8, arguments);\n      });\n      var autofillHooks = createAutofillHooks(this);\n      this.addHook('beforeAutofill', autofillHooks.beforeAutofill);\n      this.addHook('afterAutofill', autofillHooks.afterAutofill);\n\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            eventName = _ref2[0],\n            listener = _ref2[1];\n\n        return _this8.engine.on(eventName, listener);\n      });\n\n      _get(_getPrototypeOf(Formulas.prototype), \"enablePlugin\", this).call(this);\n    }\n    /**\n     * Disables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"disablePlugin\",\n    value: function disablePlugin() {\n      var _this9 = this;\n\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            eventName = _ref4[0],\n            listener = _ref4[1];\n\n        return _this9.engine.off(eventName, listener);\n      });\n\n      unregisterEngine(this.engine, this.hot);\n\n      _get(_getPrototypeOf(Formulas.prototype), \"disablePlugin\", this).call(this);\n    }\n    /**\n     * Triggered on `updateSettings`.\n     *\n     * @private\n     * @param {object} newSettings New set of settings passed to the `updateSettings` method.\n     */\n\n  }, {\n    key: \"updatePlugin\",\n    value: function updatePlugin(newSettings) {\n      this.engine.updateConfig(getEngineSettingsWithOverrides(this.hot.getSettings()));\n      var pluginSettings = this.hot.getSettings()[PLUGIN_KEY];\n\n      if (isDefined(pluginSettings) && isDefined(pluginSettings.sheetName) && pluginSettings.sheetName !== this.sheetName) {\n        this.switchSheet(pluginSettings.sheetName);\n      } // If no data was passed to the `updateSettings` method and no sheet is connected to the instance -> create a\n      // new sheet using the currently used data. Otherwise, it will be handled by the `afterLoadData` call.\n\n\n      if (!newSettings.data && this.sheetName === null) {\n        var sheetName = this.hot.getSettings()[PLUGIN_KEY].sheetName;\n\n        if (sheetName && this.engine.doesSheetExist(sheetName)) {\n          this.switchSheet(this.sheetName);\n        } else {\n          this.sheetName = this.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0, this.hot.getSourceDataArray());\n        }\n      }\n\n      _get(_getPrototypeOf(Formulas.prototype), \"updatePlugin\", this).call(this, newSettings);\n    }\n    /**\n     * Destroys the plugin instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this10 = this;\n\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref5) {\n        var _this10$engine;\n\n        var _ref6 = _slicedToArray(_ref5, 2),\n            eventName = _ref6[0],\n            listener = _ref6[1];\n\n        return (_this10$engine = _this10.engine) === null || _this10$engine === void 0 ? void 0 : _this10$engine.off(eventName, listener);\n      });\n\n      _classPrivateFieldSet(this, _engineListeners, null);\n\n      unregisterEngine(this.engine, this.hot);\n\n      _get(_getPrototypeOf(Formulas.prototype), \"destroy\", this).call(this);\n    }\n    /**\n     * Helper function for `toPhysicalRowPosition` and `toPhysicalColumnPosition`.\n     *\n     * @private\n     * @param {number} visualIndex Visual entry index.\n     * @param {number} physicalIndex Physical entry index.\n     * @param {number} entriesCount Visual entries count.\n     * @param {number} sourceEntriesCount Source entries count.\n     * @param {boolean} contained `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getPhysicalIndexPosition\",\n    value: function getPhysicalIndexPosition(visualIndex, physicalIndex, entriesCount, sourceEntriesCount, contained) {\n      if (!contained) {\n        if (visualIndex >= entriesCount) {\n          return sourceEntriesCount + (visualIndex - entriesCount);\n        }\n      }\n\n      return physicalIndex;\n    }\n    /**\n     * Returns the physical row index. The difference between this and Core's `toPhysical` is that it doesn't return\n     * `null` on rows with indexes higher than the number of rows.\n     *\n     * @private\n     * @param {number} row Visual row index.\n     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {number} The physical row index.\n     */\n\n  }, {\n    key: \"toPhysicalRowPosition\",\n    value: function toPhysicalRowPosition(row) {\n      var contained = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.getPhysicalIndexPosition(row, this.hot.toPhysicalRow(row), this.hot.countRows(), this.hot.countSourceRows(), contained);\n    }\n    /**\n     * Returns the physical column index. The difference between this and Core's `toPhysical` is that it doesn't return\n     * `null` on columns with indexes higher than the number of columns.\n     *\n     * @private\n     * @param {number} column Visual column index.\n     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {number} The physical column index.\n     */\n\n  }, {\n    key: \"toPhysicalColumnPosition\",\n    value: function toPhysicalColumnPosition(column) {\n      var contained = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.getPhysicalIndexPosition(column, this.hot.toPhysicalColumn(column), this.hot.countCols(), this.hot.countSourceCols(), contained);\n    }\n    /**\n     * Add a sheet to the shared HyperFormula instance.\n     *\n     * @param {string|null} [sheetName] The new sheet name. If not provided (or a null is passed), will be\n     * auto-generated by HyperFormula.\n     * @param {Array} [sheetData] Data passed to the shared HyperFormula instance. Has to be declared as an array of\n     * arrays - array of objects is not supported in this scenario.\n     * @returns {boolean|string} `false` if the data format is unusable or it is impossible to add a new sheet to the\n     * engine, the created sheet name otherwise.\n     */\n\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(sheetName, sheetData) {\n      if (isDefined(sheetData) && !isArrayOfArrays(sheetData)) {\n        warn('The provided data should be an array of arrays.');\n        return false;\n      }\n\n      if (sheetName !== void 0 && sheetName !== null && this.engine.doesSheetExist(sheetName)) {\n        warn('Sheet with the provided name already exists.');\n        return false;\n      }\n\n      try {\n        var actualSheetName = this.engine.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0);\n\n        if (sheetData) {\n          this.engine.setSheetContent(actualSheetName, sheetData);\n        }\n\n        return actualSheetName;\n      } catch (e) {\n        warn(e.message);\n        return false;\n      }\n    }\n    /**\n     * Switch the sheet used as data in the Handsontable instance (it loads the data from the shared HyperFormula\n     * instance).\n     *\n     * @param {string} sheetName Sheet name used in the shared HyperFormula instance.\n     */\n\n  }, {\n    key: \"switchSheet\",\n    value: function switchSheet(sheetName) {\n      if (!this.engine.doesSheetExist(sheetName)) {\n        error(\"The sheet named `\".concat(sheetName, \"` does not exist, switch aborted.\"));\n        return;\n      }\n\n      this.sheetName = sheetName;\n      var serialized = this.engine.getSheetSerialized(this.sheetId);\n\n      if (serialized.length > 0) {\n        this.hot.loadData(serialized, \"\".concat(toUpperCaseFirst(PLUGIN_KEY), \".switchSheet\"));\n      }\n    }\n    /**\n     * Get the cell type under specified visual coordinates.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n     * @returns {string} Possible values: 'FORMULA' | 'VALUE' | 'MATRIX' | 'EMPTY'.\n     */\n\n  }, {\n    key: \"getCellType\",\n    value: function getCellType(row, column) {\n      var sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n      return this.engine.getCellType({\n        sheet: sheet,\n        row: this.hot.toPhysicalRow(row),\n        col: this.hot.toPhysicalColumn(column)\n      });\n    }\n    /**\n     * Returns `true` if under specified visual coordinates is formula.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isFormulaCellType\",\n    value: function isFormulaCellType(row, column) {\n      var sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n      var cellType = this.getCellType(row, column, sheet);\n      return cellType === 'FORMULA' || cellType === 'MATRIX';\n    }\n    /**\n     * Renders dependent sheets (handsontable instances) based on the changes - list of the\n     * recalculated dependent cells.\n     *\n     * @private\n     * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n     * @param {boolean} [renderSelf] `true` if it's supposed to render itself, `false` otherwise.\n     */\n\n  }, {\n    key: \"renderDependentSheets\",\n    value: function renderDependentSheets(dependentCells) {\n      var _this11 = this;\n\n      var renderSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var affectedSheetIds = new Set();\n      dependentCells.forEach(function (change) {\n        var _change$address; // For the Named expression the address is empty, hence the `sheetId` is undefined.\n\n\n        var sheetId = change === null || change === void 0 ? void 0 : (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.sheet;\n\n        if (sheetId !== void 0) {\n          if (!affectedSheetIds.has(sheetId)) {\n            affectedSheetIds.add(sheetId);\n          }\n        }\n      });\n      getRegisteredHotInstances(this.engine).forEach(function (relatedHot, sheetId) {\n        if ((renderSelf || sheetId !== _this11.sheetId) && affectedSheetIds.has(sheetId)) {\n          var _relatedHot$view;\n\n          relatedHot.render();\n          (_relatedHot$view = relatedHot.view) === null || _relatedHot$view === void 0 ? void 0 : _relatedHot$view.adjustElementsSize();\n        }\n      });\n    }\n    /**\n     * Validates dependent cells based on the cells that are modified by the change.\n     *\n     * @private\n     * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n     * @param {object[]} [changedCells] The values and location of applied changes by developer (through API or UI).\n     */\n\n  }, {\n    key: \"validateDependentCells\",\n    value: function validateDependentCells(dependentCells) {\n      var _this12 = this;\n\n      var changedCells = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      var stringifyAddress = function stringifyAddress(change) {\n        var _change$address2;\n\n        var _ref7 = (_change$address2 = change === null || change === void 0 ? void 0 : change.address) !== null && _change$address2 !== void 0 ? _change$address2 : {},\n            row = _ref7.row,\n            col = _ref7.col,\n            sheet = _ref7.sheet;\n\n        return isDefined(sheet) ? \"\".concat(sheet, \":\").concat(row, \"x\").concat(col) : '';\n      };\n\n      var changedCellsSet = new Set(changedCells.map(function (change) {\n        return stringifyAddress(change);\n      }));\n      dependentCells.forEach(function (change) {\n        var _change$address3, _change$address4;\n\n        var _ref8 = (_change$address3 = change.address) !== null && _change$address3 !== void 0 ? _change$address3 : {},\n            row = _ref8.row,\n            col = _ref8.col;\n\n        var visualRow = isDefined(row) ? _this12.hot.toVisualRow(row) : null;\n        var visualColumn = isDefined(col) ? _this12.hot.toVisualColumn(col) : null; // Don't try to validate cells outside of the visual part of the table.\n\n        if (visualRow === null || visualColumn === null) {\n          return;\n        } // For the Named expression the address is empty, hence the `sheetId` is undefined.\n\n\n        var sheetId = change === null || change === void 0 ? void 0 : (_change$address4 = change.address) === null || _change$address4 === void 0 ? void 0 : _change$address4.sheet;\n        var addressId = stringifyAddress(change); // Validate the cells that depend on the calculated formulas. Skip that cells\n        // where the user directly changes the values - the Core triggers those validators.\n\n        if (sheetId !== void 0 && !changedCellsSet.has(addressId)) {\n          var hot = getRegisteredHotInstances(_this12.engine).get(sheetId); // It will just re-render certain cell when necessary.\n\n          hot.validateCell(hot.getDataAtCell(visualRow, visualColumn), hot.getCellMeta(visualRow, visualColumn), function () {});\n        }\n      });\n    }\n    /**\n     * Sync a change from the change-related hooks with the engine.\n     *\n     * @private\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {Handsontable.CellValue} newValue New value.\n     * @returns {Array} Array of changes exported from the engine.\n     */\n\n  }, {\n    key: \"syncChangeWithEngine\",\n    value: function syncChangeWithEngine(row, column, newValue) {\n      var address = {\n        row: this.toPhysicalRowPosition(row),\n        col: this.toPhysicalColumnPosition(column),\n        sheet: this.sheetId\n      };\n\n      if (!this.engine.isItPossibleToSetCellContents(address)) {\n        warn(\"Not possible to set cell data at \".concat(JSON.stringify(address)));\n        return;\n      }\n\n      return this.engine.setCellContents(address, newValue);\n    }\n    /**\n     * The hook allows to translate the formula value to calculated value before it goes to the\n     * validator function.\n     *\n     * @private\n     * @param {*} value The cell value to validate.\n     * @param {number} visualRow The visual row index.\n     * @param {number|string} prop The visual column index or property name of the column.\n     * @returns {*} Returns value to validate.\n     */\n\n  }, {\n    key: \"onBeforeValidate\",\n    value: function onBeforeValidate(value, visualRow, prop) {\n      var visualColumn = this.hot.propToCol(prop);\n\n      if (this.isFormulaCellType(visualRow, visualColumn)) {\n        var address = {\n          row: this.hot.toPhysicalRow(visualRow),\n          col: this.hot.toPhysicalColumn(visualColumn),\n          sheet: this.sheetId\n        };\n        var cellValue = this.engine.getCellValue(address); // If `cellValue` is an object it is expected to be an error\n\n        return _typeof(cellValue) === 'object' && cellValue !== null ? cellValue.value : cellValue;\n      }\n\n      return value;\n    }\n    /**\n     * `beforeLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     * @private\n     */\n\n  }, {\n    key: \"onBeforeLoadData\",\n    value: function onBeforeLoadData(sourceData, initialLoad) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n      if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n        return;\n      } // This flag needs to be defined, because not passing data to HOT results in HOT auto-generating a `null`-filled\n      // initial dataset.\n\n\n      _classPrivateFieldSet(this, _hotWasInitializedWithEmptyData, isUndefined(this.hot.getSettings().data));\n    }\n    /**\n     * `afterLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     * @private\n     */\n\n  }, {\n    key: \"onAfterLoadData\",\n    value: function onAfterLoadData(sourceData, initialLoad) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n      if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n        return;\n      }\n\n      this.sheetName = setupSheet(this.engine, this.hot.getSettings()[PLUGIN_KEY].sheetName);\n\n      if (!_classPrivateFieldGet(this, _hotWasInitializedWithEmptyData)) {\n        var sourceDataArray = this.hot.getSourceDataArray();\n\n        if (this.engine.isItPossibleToReplaceSheetContent(this.sheetName, sourceDataArray)) {\n          _classPrivateFieldSet(this, _internalOperationPending, true);\n\n          var dependentCells = this.engine.setSheetContent(this.sheetName, this.hot.getSourceDataArray());\n          this.renderDependentSheets(dependentCells);\n\n          _classPrivateFieldSet(this, _internalOperationPending, false);\n        }\n      } else {\n        this.switchSheet(this.sheetName);\n      }\n    }\n    /**\n     * `modifyData` hook callback.\n     *\n     * @private\n     * @param {number} row Physical row height.\n     * @param {number} column Physical column index.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n\n  }, {\n    key: \"onModifyData\",\n    value: function onModifyData(row, column, valueHolder, ioMode) {\n      if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n        return;\n      } // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n\n\n      var isFormulaCellType = this.isFormulaCellType(this.hot.toVisualRow(row), column);\n\n      if (!isFormulaCellType) {\n        if (isEscapedFormulaExpression(valueHolder.value)) {\n          valueHolder.value = unescapeFormulaExpression(valueHolder.value);\n        }\n\n        return;\n      } // `toPhysicalColumn` is here because of inconsistencies related to hook execution in `src/dataMap`.\n\n\n      var address = {\n        row: row,\n        col: this.toPhysicalColumnPosition(column),\n        sheet: this.sheetId\n      };\n      var cellValue = this.engine.getCellValue(address); // If `cellValue` is an object it is expected to be an error\n\n      var value = _typeof(cellValue) === 'object' && cellValue !== null ? cellValue.value : cellValue;\n      valueHolder.value = value;\n    }\n    /**\n     * `modifySourceData` hook callback.\n     *\n     * @private\n     * @param {number} row Physical row index.\n     * @param {number|string} columnOrProp Physical column index or prop.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n\n  }, {\n    key: \"onModifySourceData\",\n    value: function onModifySourceData(row, columnOrProp, valueHolder, ioMode) {\n      if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n        return;\n      }\n\n      var visualColumn = this.hot.propToCol(columnOrProp); // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n\n      var isFormulaCellType = this.isFormulaCellType(this.hot.toVisualRow(row), visualColumn);\n\n      if (!isFormulaCellType) {\n        return;\n      }\n\n      var dimensions = this.engine.getSheetDimensions(this.engine.getSheetId(this.sheetName)); // Don't actually change the source data if HyperFormula is not\n      // initialized yet. This is done to allow the `afterLoadData` hook to\n      // load the existing source data with `Handsontable#getSourceDataArray`\n      // properly.\n\n      if (dimensions.width === 0 && dimensions.height === 0) {\n        return;\n      }\n\n      var address = {\n        row: row,\n        // Workaround for inconsistencies in `src/dataSource.js`\n        col: this.toPhysicalColumnPosition(visualColumn),\n        sheet: this.sheetId\n      };\n      valueHolder.value = this.engine.getCellSerialized(address);\n    }\n    /**\n     * `onAfterSetDataAtCell` hook callback.\n     *\n     * @private\n     * @param {Array[]} changes An array of changes in format [[row, prop, oldValue, value], ...].\n     */\n\n  }, {\n    key: \"onAfterSetDataAtCell\",\n    value: function onAfterSetDataAtCell(changes) {\n      var _this13 = this;\n\n      var dependentCells = [];\n      var outOfBoundsChanges = [];\n      var changedCells = [];\n      changes.forEach(function (_ref9) {\n        var _ref10 = _slicedToArray(_ref9, 4),\n            row = _ref10[0],\n            prop = _ref10[1],\n            newValue = _ref10[3];\n\n        var column = _this13.hot.propToCol(prop);\n\n        var physicalRow = _this13.hot.toPhysicalRow(row);\n\n        var physicalColumn = _this13.hot.toPhysicalColumn(column);\n\n        var address = {\n          row: physicalRow,\n          col: physicalColumn,\n          sheet: _this13.sheetId\n        };\n\n        if (physicalRow !== null && physicalColumn !== null) {\n          dependentCells.push.apply(dependentCells, _toConsumableArray(_this13.syncChangeWithEngine(row, column, newValue)));\n        } else {\n          outOfBoundsChanges.push([row, column, newValue]);\n        }\n\n        changedCells.push({\n          address: address\n        });\n      });\n\n      if (outOfBoundsChanges.length) {\n        // Workaround for rows/columns being created two times (by HOT and the engine).\n        // (unfortunately, this requires an extra re-render)\n        this.hot.addHookOnce('afterChange', function () {\n          var outOfBoundsDependentCells = [];\n          outOfBoundsChanges.forEach(function (_ref11) {\n            var _ref12 = _slicedToArray(_ref11, 3),\n                row = _ref12[0],\n                column = _ref12[1],\n                newValue = _ref12[2];\n\n            outOfBoundsDependentCells.push.apply(outOfBoundsDependentCells, _toConsumableArray(_this13.syncChangeWithEngine(row, column, newValue)));\n          });\n\n          _this13.renderDependentSheets(outOfBoundsDependentCells, true);\n        });\n      }\n\n      this.renderDependentSheets(dependentCells);\n      this.validateDependentCells(dependentCells, changedCells);\n    }\n    /**\n     * `onAfterSetSourceDataAtCell` hook callback.\n     *\n     * @private\n     * @param {Array[]} changes An array of changes in format [[row, column, oldValue, value], ...].\n     */\n\n  }, {\n    key: \"onAfterSetSourceDataAtCell\",\n    value: function onAfterSetSourceDataAtCell(changes) {\n      var _this14 = this;\n\n      var dependentCells = [];\n      var changedCells = [];\n      changes.forEach(function (_ref13) {\n        var _ref14 = _slicedToArray(_ref13, 4),\n            row = _ref14[0],\n            column = _ref14[1],\n            newValue = _ref14[3];\n\n        var address = {\n          row: row,\n          col: _this14.toPhysicalColumnPosition(column),\n          sheet: _this14.sheetId\n        };\n\n        if (!_this14.engine.isItPossibleToSetCellContents(address)) {\n          warn(\"Not possible to set source cell data at \".concat(JSON.stringify(address)));\n          return;\n        }\n\n        changedCells.push({\n          address: address\n        });\n        dependentCells.push.apply(dependentCells, _toConsumableArray(_this14.engine.setCellContents(address, newValue)));\n      });\n      this.renderDependentSheets(dependentCells);\n      this.validateDependentCells(dependentCells, changedCells);\n    }\n    /**\n     * `beforeCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeCreateRow\",\n    value: function onBeforeCreateRow(row, amount) {\n      if (!this.engine.isItPossibleToAddRows(this.sheetId, [this.toPhysicalRowPosition(row), amount])) {\n        return false;\n      }\n    }\n    /**\n     * `beforeCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} col Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeCreateCol\",\n    value: function onBeforeCreateCol(col, amount) {\n      if (!this.engine.isItPossibleToAddColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount])) {\n        return false;\n      }\n    }\n    /**\n     * `beforeRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount Amount of rows to be removed.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeRemoveRow\",\n    value: function onBeforeRemoveRow(row, amount, physicalRows) {\n      var _this15 = this;\n\n      var possible = physicalRows.every(function (physicalRow) {\n        return _this15.engine.isItPossibleToRemoveRows(_this15.sheetId, [physicalRow, 1]);\n      });\n      return possible === false ? false : void 0;\n    }\n    /**\n     * `beforeRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount Amount of columns to be removed.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeRemoveCol\",\n    value: function onBeforeRemoveCol(col, amount, physicalColumns) {\n      var _this16 = this;\n\n      var possible = physicalColumns.every(function (physicalColumn) {\n        return _this16.engine.isItPossibleToRemoveColumns(_this16.sheetId, [physicalColumn, 1]);\n      });\n      return possible === false ? false : void 0;\n    }\n    /**\n     * `afterCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     */\n\n  }, {\n    key: \"onAfterCreateRow\",\n    value: function onAfterCreateRow(row, amount) {\n      var changes = this.engine.addRows(this.sheetId, [this.toPhysicalRowPosition(row), amount]);\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} col Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     */\n\n  }, {\n    key: \"onAfterCreateCol\",\n    value: function onAfterCreateCol(col, amount) {\n      var changes = this.engine.addColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount]);\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount An amount of removed rows.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     */\n\n  }, {\n    key: \"onAfterRemoveRow\",\n    value: function onAfterRemoveRow(row, amount, physicalRows) {\n      var _this17 = this;\n\n      var descendingPhysicalRows = physicalRows.sort().reverse();\n      var changes = this.engine.batch(function () {\n        descendingPhysicalRows.forEach(function (physicalRow) {\n          _this17.engine.removeRows(_this17.sheetId, [physicalRow, 1]);\n        });\n      });\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount An amount of removed columns.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     */\n\n  }, {\n    key: \"onAfterRemoveCol\",\n    value: function onAfterRemoveCol(col, amount, physicalColumns) {\n      var _this18 = this;\n\n      var descendingPhysicalColumns = physicalColumns.sort().reverse();\n      var changes = this.engine.batch(function () {\n        descendingPhysicalColumns.forEach(function (physicalColumn) {\n          _this18.engine.removeColumns(_this18.sheetId, [physicalColumn, 1]);\n        });\n      });\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * Called when a value is updated in the engine.\n     *\n     * @private\n     * @fires Hooks#afterFormulasValuesUpdate\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineValuesUpdated\",\n    value: function onEngineValuesUpdated(changes) {\n      this.hot.runHooks('afterFormulasValuesUpdate', changes);\n    }\n    /**\n     * Called when a named expression is added to the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterNamedExpressionAdded\n     * @param {string} namedExpressionName The name of the added expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineNamedExpressionsAdded\",\n    value: function onEngineNamedExpressionsAdded(namedExpressionName, changes) {\n      this.hot.runHooks('afterNamedExpressionAdded', namedExpressionName, changes);\n    }\n    /**\n     * Called when a named expression is removed from the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterNamedExpressionRemoved\n     * @param {string} namedExpressionName The name of the removed expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineNamedExpressionsRemoved\",\n    value: function onEngineNamedExpressionsRemoved(namedExpressionName, changes) {\n      this.hot.runHooks('afterNamedExpressionRemoved', namedExpressionName, changes);\n    }\n    /**\n     * Called when a new sheet is added to the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterSheetAdded\n     * @param {string} addedSheetDisplayName The name of the added sheet.\n     */\n\n  }, {\n    key: \"onEngineSheetAdded\",\n    value: function onEngineSheetAdded(addedSheetDisplayName) {\n      this.hot.runHooks('afterSheetAdded', addedSheetDisplayName);\n    }\n    /**\n     * Called when a sheet in the engine instance is renamed.\n     *\n     * @private\n     * @fires Hooks#afterSheetRenamed\n     * @param {string} oldDisplayName The old name of the sheet.\n     * @param {string} newDisplayName The new name of the sheet.\n     */\n\n  }, {\n    key: \"onEngineSheetRenamed\",\n    value: function onEngineSheetRenamed(oldDisplayName, newDisplayName) {\n      this.hot.runHooks('afterSheetRenamed', oldDisplayName, newDisplayName);\n    }\n    /**\n     * Called when a sheet is removed from the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterSheetRemoved\n     * @param {string} removedSheetDisplayName The removed sheet name.\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineSheetRemoved\",\n    value: function onEngineSheetRemoved(removedSheetDisplayName, changes) {\n      this.hot.runHooks('afterSheetRemoved', removedSheetDisplayName, changes);\n    }\n  }], [{\n    key: \"PLUGIN_KEY\",\n    get: function get() {\n      return PLUGIN_KEY;\n    }\n  }, {\n    key: \"PLUGIN_PRIORITY\",\n    get: function get() {\n      return PLUGIN_PRIORITY;\n    }\n    /**\n     * Flag used to bypass hooks in internal operations.\n     *\n     * @private\n     * @type {boolean}\n     */\n\n  }]);\n\n  return Formulas;\n}(BasePlugin);","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/plugins/formulas/formulas.mjs"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Array","from","isArray","_arrayLikeToArray","_typeof","obj","constructor","prototype","_slicedToArray","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","o","minLen","n","Object","toString","call","slice","name","test","len","length","arr2","_i","_arr","_n","_d","_s","_e","next","done","push","value","err","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","_get","property","receiver","Reflect","get","base","_superPropBase","desc","getOwnPropertyDescriptor","object","hasOwnProperty","_getPrototypeOf","_inherits","subClass","superClass","create","_setPrototypeOf","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","construct","arguments","apply","_possibleConstructorReturn","self","_assertThisInitialized","ReferenceError","sham","Proxy","Boolean","valueOf","e","getPrototypeOf","_defineProperty","_classPrivateFieldSet","privateMap","_classExtractFieldDescriptor","_classApplyDescriptorSet","set","_classPrivateFieldGet","_classApplyDescriptorGet","action","has","BasePlugin","createAutofillHooks","staticRegister","error","warn","isDefined","isUndefined","setupEngine","setupSheet","unregisterEngine","getRegisteredHotInstances","isEscapedFormulaExpression","unescapeFormulaExpression","getEngineSettingsWithOverrides","isArrayOfArrays","toUpperCaseFirst","Hooks","PLUGIN_KEY","PLUGIN_PRIORITY","getSingleton","register","_internalOperationPending","WeakMap","_hotWasInitializedWithEmptyData","_engineListeners","Formulas","_BasePlugin","_super","_this","_len","_args","_key","concat","_this2","onEngineValuesUpdated","_this3","onEngineNamedExpressionsAdded","_this4","onEngineNamedExpressionsRemoved","_this5","onEngineSheetAdded","_this6","onEngineSheetRenamed","_this7","onEngineSheetRemoved","sheetName","engine","getSheetId","isEnabled","hot","getSettings","enablePlugin","_setupEngine","_this8","enabled","doesSheetExist","addSheet","getSourceDataArray","addHook","onBeforeLoadData","onAfterLoadData","onModifyData","onModifySourceData","onBeforeValidate","onAfterSetSourceDataAtCell","onAfterSetDataAtCell","onBeforeCreateRow","onBeforeCreateCol","onAfterCreateRow","onAfterCreateCol","onBeforeRemoveRow","onBeforeRemoveCol","onAfterRemoveRow","onAfterRemoveCol","autofillHooks","beforeAutofill","afterAutofill","forEach","_ref","_ref2","eventName","listener","on","disablePlugin","_this9","_ref3","_ref4","off","updatePlugin","newSettings","updateConfig","pluginSettings","switchSheet","data","destroy","_this10","_ref5","_this10$engine","_ref6","getPhysicalIndexPosition","visualIndex","physicalIndex","entriesCount","sourceEntriesCount","contained","toPhysicalRowPosition","row","undefined","toPhysicalRow","countRows","countSourceRows","toPhysicalColumnPosition","column","toPhysicalColumn","countCols","countSourceCols","sheetData","actualSheetName","setSheetContent","message","serialized","getSheetSerialized","sheetId","loadData","getCellType","sheet","col","isFormulaCellType","cellType","renderDependentSheets","dependentCells","_this11","renderSelf","affectedSheetIds","Set","change","_change$address","address","add","relatedHot","_relatedHot$view","render","view","adjustElementsSize","validateDependentCells","_this12","changedCells","stringifyAddress","_change$address2","_ref7","changedCellsSet","map","_change$address3","_change$address4","_ref8","visualRow","toVisualRow","visualColumn","toVisualColumn","addressId","validateCell","getDataAtCell","getCellMeta","syncChangeWithEngine","newValue","isItPossibleToSetCellContents","JSON","stringify","setCellContents","prop","propToCol","cellValue","getCellValue","sourceData","initialLoad","source","includes","sourceDataArray","isItPossibleToReplaceSheetContent","valueHolder","ioMode","columnOrProp","dimensions","getSheetDimensions","width","height","getCellSerialized","changes","_this13","outOfBoundsChanges","_ref9","_ref10","physicalRow","physicalColumn","addHookOnce","outOfBoundsDependentCells","_ref11","_ref12","_this14","_ref13","_ref14","amount","isItPossibleToAddRows","isItPossibleToAddColumns","physicalRows","_this15","possible","every","isItPossibleToRemoveRows","physicalColumns","_this16","isItPossibleToRemoveColumns","addRows","addColumns","_this17","descendingPhysicalRows","sort","reverse","batch","removeRows","_this18","descendingPhysicalColumns","removeColumns","runHooks","namedExpressionName","addedSheetDisplayName","oldDisplayName","newDisplayName","removedSheetDisplayName"],"mappings":"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","sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.weak-map.js\";\nimport \"core-js/modules/es.object.set-prototype-of.js\";\nimport \"core-js/modules/es.object.get-prototype-of.js\";\nimport \"core-js/modules/es.reflect.construct.js\";\nimport \"core-js/modules/es.reflect.get.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.from.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\n\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\n\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\n\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nimport { BasePlugin } from \"../base/index.mjs\";\nimport { createAutofillHooks } from \"./autofill.mjs\";\nimport staticRegister from \"../../utils/staticRegister.mjs\";\nimport { error, warn } from \"../../helpers/console.mjs\";\nimport { isDefined, isUndefined } from \"../../helpers/mixed.mjs\";\nimport { setupEngine, setupSheet, unregisterEngine, getRegisteredHotInstances } from \"./engine/register.mjs\";\nimport { isEscapedFormulaExpression, unescapeFormulaExpression } from \"./utils.mjs\";\nimport { getEngineSettingsWithOverrides } from \"./engine/settings.mjs\";\nimport { isArrayOfArrays } from \"../../helpers/data.mjs\";\nimport { toUpperCaseFirst } from \"../../helpers/string.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nexport var PLUGIN_KEY = 'formulas';\nexport var PLUGIN_PRIORITY = 260;\nHooks.getSingleton().register('afterNamedExpressionAdded');\nHooks.getSingleton().register('afterNamedExpressionRemoved');\nHooks.getSingleton().register('afterSheetAdded');\nHooks.getSingleton().register('afterSheetRemoved');\nHooks.getSingleton().register('afterSheetRenamed');\nHooks.getSingleton().register('afterFormulasValuesUpdate');\n/**\n * This plugin allows you to perform Excel-like calculations in your business applications. It does it by an\n * integration with our other product, [HyperFormula](https://github.com/handsontable/hyperformula/), which is a\n * powerful calculation engine with an extensive number of features.\n *\n * @plugin Formulas\n */\n\nvar _internalOperationPending = /*#__PURE__*/new WeakMap();\n\nvar _hotWasInitializedWithEmptyData = /*#__PURE__*/new WeakMap();\n\nvar _engineListeners = /*#__PURE__*/new WeakMap();\n\nexport var Formulas = /*#__PURE__*/function (_BasePlugin) {\n  _inherits(Formulas, _BasePlugin);\n\n  var _super = _createSuper(Formulas);\n\n  function Formulas() {\n    var _this;\n\n    _classCallCheck(this, Formulas);\n\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(_args));\n\n    _internalOperationPending.set(_assertThisInitialized(_this), {\n      writable: true,\n      value: false\n    });\n\n    _hotWasInitializedWithEmptyData.set(_assertThisInitialized(_this), {\n      writable: true,\n      value: false\n    });\n\n    _engineListeners.set(_assertThisInitialized(_this), {\n      writable: true,\n      value: [['valuesUpdated', function () {\n        var _this2;\n\n        return (_this2 = _this).onEngineValuesUpdated.apply(_this2, arguments);\n      }], ['namedExpressionAdded', function () {\n        var _this3;\n\n        return (_this3 = _this).onEngineNamedExpressionsAdded.apply(_this3, arguments);\n      }], ['namedExpressionRemoved', function () {\n        var _this4;\n\n        return (_this4 = _this).onEngineNamedExpressionsRemoved.apply(_this4, arguments);\n      }], ['sheetAdded', function () {\n        var _this5;\n\n        return (_this5 = _this).onEngineSheetAdded.apply(_this5, arguments);\n      }], ['sheetRenamed', function () {\n        var _this6;\n\n        return (_this6 = _this).onEngineSheetRenamed.apply(_this6, arguments);\n      }], ['sheetRemoved', function () {\n        var _this7;\n\n        return (_this7 = _this).onEngineSheetRemoved.apply(_this7, arguments);\n      }]]\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"staticRegister\", staticRegister('formulas'));\n\n    _defineProperty(_assertThisInitialized(_this), \"engine\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"sheetName\", null);\n\n    return _this;\n  }\n\n  _createClass(Formulas, [{\n    key: \"sheetId\",\n    get:\n    /**\n     * HyperFormula's sheet id.\n     *\n     * @type {number|null}\n     */\n    function get() {\n      return this.sheetName === null ? null : this.engine.getSheetId(this.sheetName);\n    }\n    /**\n     * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n     * hook and if it returns `true` than the {@link Formulas#enablePlugin} method is called.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      /* eslint-disable no-unneeded-ternary */\n      return this.hot.getSettings()[PLUGIN_KEY] ? true : false;\n    }\n    /**\n     * Enables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"enablePlugin\",\n    value: function enablePlugin() {\n      var _setupEngine,\n          _this8 = this;\n\n      if (this.enabled) {\n        return;\n      }\n\n      this.engine = (_setupEngine = setupEngine(this.hot)) !== null && _setupEngine !== void 0 ? _setupEngine : this.engine;\n\n      if (!this.engine) {\n        warn('Missing the required `engine` key in the Formulas settings. Please fill it with either an' + ' engine class or an engine instance.');\n        return;\n      } // Useful for disabling -> enabling the plugin using `updateSettings` or the API.\n\n\n      if (this.sheetName !== null && !this.engine.doesSheetExist(this.sheetName)) {\n        this.sheetName = this.addSheet(this.sheetName, this.hot.getSourceDataArray());\n      }\n\n      this.addHook('beforeLoadData', function () {\n        return _this8.onBeforeLoadData.apply(_this8, arguments);\n      });\n      this.addHook('afterLoadData', function () {\n        return _this8.onAfterLoadData.apply(_this8, arguments);\n      });\n      this.addHook('modifyData', function () {\n        return _this8.onModifyData.apply(_this8, arguments);\n      });\n      this.addHook('modifySourceData', function () {\n        return _this8.onModifySourceData.apply(_this8, arguments);\n      });\n      this.addHook('beforeValidate', function () {\n        return _this8.onBeforeValidate.apply(_this8, arguments);\n      });\n      this.addHook('afterSetSourceDataAtCell', function () {\n        return _this8.onAfterSetSourceDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('afterSetDataAtCell', function () {\n        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('afterSetDataAtRowProp', function () {\n        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('beforeCreateRow', function () {\n        return _this8.onBeforeCreateRow.apply(_this8, arguments);\n      });\n      this.addHook('beforeCreateCol', function () {\n        return _this8.onBeforeCreateCol.apply(_this8, arguments);\n      });\n      this.addHook('afterCreateRow', function () {\n        return _this8.onAfterCreateRow.apply(_this8, arguments);\n      });\n      this.addHook('afterCreateCol', function () {\n        return _this8.onAfterCreateCol.apply(_this8, arguments);\n      });\n      this.addHook('beforeRemoveRow', function () {\n        return _this8.onBeforeRemoveRow.apply(_this8, arguments);\n      });\n      this.addHook('beforeRemoveCol', function () {\n        return _this8.onBeforeRemoveCol.apply(_this8, arguments);\n      });\n      this.addHook('afterRemoveRow', function () {\n        return _this8.onAfterRemoveRow.apply(_this8, arguments);\n      });\n      this.addHook('afterRemoveCol', function () {\n        return _this8.onAfterRemoveCol.apply(_this8, arguments);\n      });\n      var autofillHooks = createAutofillHooks(this);\n      this.addHook('beforeAutofill', autofillHooks.beforeAutofill);\n      this.addHook('afterAutofill', autofillHooks.afterAutofill);\n\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            eventName = _ref2[0],\n            listener = _ref2[1];\n\n        return _this8.engine.on(eventName, listener);\n      });\n\n      _get(_getPrototypeOf(Formulas.prototype), \"enablePlugin\", this).call(this);\n    }\n    /**\n     * Disables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"disablePlugin\",\n    value: function disablePlugin() {\n      var _this9 = this;\n\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            eventName = _ref4[0],\n            listener = _ref4[1];\n\n        return _this9.engine.off(eventName, listener);\n      });\n\n      unregisterEngine(this.engine, this.hot);\n\n      _get(_getPrototypeOf(Formulas.prototype), \"disablePlugin\", this).call(this);\n    }\n    /**\n     * Triggered on `updateSettings`.\n     *\n     * @private\n     * @param {object} newSettings New set of settings passed to the `updateSettings` method.\n     */\n\n  }, {\n    key: \"updatePlugin\",\n    value: function updatePlugin(newSettings) {\n      this.engine.updateConfig(getEngineSettingsWithOverrides(this.hot.getSettings()));\n      var pluginSettings = this.hot.getSettings()[PLUGIN_KEY];\n\n      if (isDefined(pluginSettings) && isDefined(pluginSettings.sheetName) && pluginSettings.sheetName !== this.sheetName) {\n        this.switchSheet(pluginSettings.sheetName);\n      } // If no data was passed to the `updateSettings` method and no sheet is connected to the instance -> create a\n      // new sheet using the currently used data. Otherwise, it will be handled by the `afterLoadData` call.\n\n\n      if (!newSettings.data && this.sheetName === null) {\n        var sheetName = this.hot.getSettings()[PLUGIN_KEY].sheetName;\n\n        if (sheetName && this.engine.doesSheetExist(sheetName)) {\n          this.switchSheet(this.sheetName);\n        } else {\n          this.sheetName = this.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0, this.hot.getSourceDataArray());\n        }\n      }\n\n      _get(_getPrototypeOf(Formulas.prototype), \"updatePlugin\", this).call(this, newSettings);\n    }\n    /**\n     * Destroys the plugin instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this10 = this;\n\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref5) {\n        var _this10$engine;\n\n        var _ref6 = _slicedToArray(_ref5, 2),\n            eventName = _ref6[0],\n            listener = _ref6[1];\n\n        return (_this10$engine = _this10.engine) === null || _this10$engine === void 0 ? void 0 : _this10$engine.off(eventName, listener);\n      });\n\n      _classPrivateFieldSet(this, _engineListeners, null);\n\n      unregisterEngine(this.engine, this.hot);\n\n      _get(_getPrototypeOf(Formulas.prototype), \"destroy\", this).call(this);\n    }\n    /**\n     * Helper function for `toPhysicalRowPosition` and `toPhysicalColumnPosition`.\n     *\n     * @private\n     * @param {number} visualIndex Visual entry index.\n     * @param {number} physicalIndex Physical entry index.\n     * @param {number} entriesCount Visual entries count.\n     * @param {number} sourceEntriesCount Source entries count.\n     * @param {boolean} contained `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getPhysicalIndexPosition\",\n    value: function getPhysicalIndexPosition(visualIndex, physicalIndex, entriesCount, sourceEntriesCount, contained) {\n      if (!contained) {\n        if (visualIndex >= entriesCount) {\n          return sourceEntriesCount + (visualIndex - entriesCount);\n        }\n      }\n\n      return physicalIndex;\n    }\n    /**\n     * Returns the physical row index. The difference between this and Core's `toPhysical` is that it doesn't return\n     * `null` on rows with indexes higher than the number of rows.\n     *\n     * @private\n     * @param {number} row Visual row index.\n     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {number} The physical row index.\n     */\n\n  }, {\n    key: \"toPhysicalRowPosition\",\n    value: function toPhysicalRowPosition(row) {\n      var contained = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.getPhysicalIndexPosition(row, this.hot.toPhysicalRow(row), this.hot.countRows(), this.hot.countSourceRows(), contained);\n    }\n    /**\n     * Returns the physical column index. The difference between this and Core's `toPhysical` is that it doesn't return\n     * `null` on columns with indexes higher than the number of columns.\n     *\n     * @private\n     * @param {number} column Visual column index.\n     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {number} The physical column index.\n     */\n\n  }, {\n    key: \"toPhysicalColumnPosition\",\n    value: function toPhysicalColumnPosition(column) {\n      var contained = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.getPhysicalIndexPosition(column, this.hot.toPhysicalColumn(column), this.hot.countCols(), this.hot.countSourceCols(), contained);\n    }\n    /**\n     * Add a sheet to the shared HyperFormula instance.\n     *\n     * @param {string|null} [sheetName] The new sheet name. If not provided (or a null is passed), will be\n     * auto-generated by HyperFormula.\n     * @param {Array} [sheetData] Data passed to the shared HyperFormula instance. Has to be declared as an array of\n     * arrays - array of objects is not supported in this scenario.\n     * @returns {boolean|string} `false` if the data format is unusable or it is impossible to add a new sheet to the\n     * engine, the created sheet name otherwise.\n     */\n\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(sheetName, sheetData) {\n      if (isDefined(sheetData) && !isArrayOfArrays(sheetData)) {\n        warn('The provided data should be an array of arrays.');\n        return false;\n      }\n\n      if (sheetName !== void 0 && sheetName !== null && this.engine.doesSheetExist(sheetName)) {\n        warn('Sheet with the provided name already exists.');\n        return false;\n      }\n\n      try {\n        var actualSheetName = this.engine.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0);\n\n        if (sheetData) {\n          this.engine.setSheetContent(actualSheetName, sheetData);\n        }\n\n        return actualSheetName;\n      } catch (e) {\n        warn(e.message);\n        return false;\n      }\n    }\n    /**\n     * Switch the sheet used as data in the Handsontable instance (it loads the data from the shared HyperFormula\n     * instance).\n     *\n     * @param {string} sheetName Sheet name used in the shared HyperFormula instance.\n     */\n\n  }, {\n    key: \"switchSheet\",\n    value: function switchSheet(sheetName) {\n      if (!this.engine.doesSheetExist(sheetName)) {\n        error(\"The sheet named `\".concat(sheetName, \"` does not exist, switch aborted.\"));\n        return;\n      }\n\n      this.sheetName = sheetName;\n      var serialized = this.engine.getSheetSerialized(this.sheetId);\n\n      if (serialized.length > 0) {\n        this.hot.loadData(serialized, \"\".concat(toUpperCaseFirst(PLUGIN_KEY), \".switchSheet\"));\n      }\n    }\n    /**\n     * Get the cell type under specified visual coordinates.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n     * @returns {string} Possible values: 'FORMULA' | 'VALUE' | 'MATRIX' | 'EMPTY'.\n     */\n\n  }, {\n    key: \"getCellType\",\n    value: function getCellType(row, column) {\n      var sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n      return this.engine.getCellType({\n        sheet: sheet,\n        row: this.hot.toPhysicalRow(row),\n        col: this.hot.toPhysicalColumn(column)\n      });\n    }\n    /**\n     * Returns `true` if under specified visual coordinates is formula.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isFormulaCellType\",\n    value: function isFormulaCellType(row, column) {\n      var sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n      var cellType = this.getCellType(row, column, sheet);\n      return cellType === 'FORMULA' || cellType === 'MATRIX';\n    }\n    /**\n     * Renders dependent sheets (handsontable instances) based on the changes - list of the\n     * recalculated dependent cells.\n     *\n     * @private\n     * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n     * @param {boolean} [renderSelf] `true` if it's supposed to render itself, `false` otherwise.\n     */\n\n  }, {\n    key: \"renderDependentSheets\",\n    value: function renderDependentSheets(dependentCells) {\n      var _this11 = this;\n\n      var renderSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var affectedSheetIds = new Set();\n      dependentCells.forEach(function (change) {\n        var _change$address;\n\n        // For the Named expression the address is empty, hence the `sheetId` is undefined.\n        var sheetId = change === null || change === void 0 ? void 0 : (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.sheet;\n\n        if (sheetId !== void 0) {\n          if (!affectedSheetIds.has(sheetId)) {\n            affectedSheetIds.add(sheetId);\n          }\n        }\n      });\n      getRegisteredHotInstances(this.engine).forEach(function (relatedHot, sheetId) {\n        if ((renderSelf || sheetId !== _this11.sheetId) && affectedSheetIds.has(sheetId)) {\n          var _relatedHot$view;\n\n          relatedHot.render();\n          (_relatedHot$view = relatedHot.view) === null || _relatedHot$view === void 0 ? void 0 : _relatedHot$view.adjustElementsSize();\n        }\n      });\n    }\n    /**\n     * Validates dependent cells based on the cells that are modified by the change.\n     *\n     * @private\n     * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n     * @param {object[]} [changedCells] The values and location of applied changes by developer (through API or UI).\n     */\n\n  }, {\n    key: \"validateDependentCells\",\n    value: function validateDependentCells(dependentCells) {\n      var _this12 = this;\n\n      var changedCells = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      var stringifyAddress = function stringifyAddress(change) {\n        var _change$address2;\n\n        var _ref7 = (_change$address2 = change === null || change === void 0 ? void 0 : change.address) !== null && _change$address2 !== void 0 ? _change$address2 : {},\n            row = _ref7.row,\n            col = _ref7.col,\n            sheet = _ref7.sheet;\n\n        return isDefined(sheet) ? \"\".concat(sheet, \":\").concat(row, \"x\").concat(col) : '';\n      };\n\n      var changedCellsSet = new Set(changedCells.map(function (change) {\n        return stringifyAddress(change);\n      }));\n      dependentCells.forEach(function (change) {\n        var _change$address3, _change$address4;\n\n        var _ref8 = (_change$address3 = change.address) !== null && _change$address3 !== void 0 ? _change$address3 : {},\n            row = _ref8.row,\n            col = _ref8.col;\n\n        var visualRow = isDefined(row) ? _this12.hot.toVisualRow(row) : null;\n        var visualColumn = isDefined(col) ? _this12.hot.toVisualColumn(col) : null; // Don't try to validate cells outside of the visual part of the table.\n\n        if (visualRow === null || visualColumn === null) {\n          return;\n        } // For the Named expression the address is empty, hence the `sheetId` is undefined.\n\n\n        var sheetId = change === null || change === void 0 ? void 0 : (_change$address4 = change.address) === null || _change$address4 === void 0 ? void 0 : _change$address4.sheet;\n        var addressId = stringifyAddress(change); // Validate the cells that depend on the calculated formulas. Skip that cells\n        // where the user directly changes the values - the Core triggers those validators.\n\n        if (sheetId !== void 0 && !changedCellsSet.has(addressId)) {\n          var hot = getRegisteredHotInstances(_this12.engine).get(sheetId); // It will just re-render certain cell when necessary.\n\n          hot.validateCell(hot.getDataAtCell(visualRow, visualColumn), hot.getCellMeta(visualRow, visualColumn), function () {});\n        }\n      });\n    }\n    /**\n     * Sync a change from the change-related hooks with the engine.\n     *\n     * @private\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {Handsontable.CellValue} newValue New value.\n     * @returns {Array} Array of changes exported from the engine.\n     */\n\n  }, {\n    key: \"syncChangeWithEngine\",\n    value: function syncChangeWithEngine(row, column, newValue) {\n      var address = {\n        row: this.toPhysicalRowPosition(row),\n        col: this.toPhysicalColumnPosition(column),\n        sheet: this.sheetId\n      };\n\n      if (!this.engine.isItPossibleToSetCellContents(address)) {\n        warn(\"Not possible to set cell data at \".concat(JSON.stringify(address)));\n        return;\n      }\n\n      return this.engine.setCellContents(address, newValue);\n    }\n    /**\n     * The hook allows to translate the formula value to calculated value before it goes to the\n     * validator function.\n     *\n     * @private\n     * @param {*} value The cell value to validate.\n     * @param {number} visualRow The visual row index.\n     * @param {number|string} prop The visual column index or property name of the column.\n     * @returns {*} Returns value to validate.\n     */\n\n  }, {\n    key: \"onBeforeValidate\",\n    value: function onBeforeValidate(value, visualRow, prop) {\n      var visualColumn = this.hot.propToCol(prop);\n\n      if (this.isFormulaCellType(visualRow, visualColumn)) {\n        var address = {\n          row: this.hot.toPhysicalRow(visualRow),\n          col: this.hot.toPhysicalColumn(visualColumn),\n          sheet: this.sheetId\n        };\n        var cellValue = this.engine.getCellValue(address); // If `cellValue` is an object it is expected to be an error\n\n        return _typeof(cellValue) === 'object' && cellValue !== null ? cellValue.value : cellValue;\n      }\n\n      return value;\n    }\n    /**\n     * `beforeLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     * @private\n     */\n\n  }, {\n    key: \"onBeforeLoadData\",\n    value: function onBeforeLoadData(sourceData, initialLoad) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n      if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n        return;\n      } // This flag needs to be defined, because not passing data to HOT results in HOT auto-generating a `null`-filled\n      // initial dataset.\n\n\n      _classPrivateFieldSet(this, _hotWasInitializedWithEmptyData, isUndefined(this.hot.getSettings().data));\n    }\n    /**\n     * `afterLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     * @private\n     */\n\n  }, {\n    key: \"onAfterLoadData\",\n    value: function onAfterLoadData(sourceData, initialLoad) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n      if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n        return;\n      }\n\n      this.sheetName = setupSheet(this.engine, this.hot.getSettings()[PLUGIN_KEY].sheetName);\n\n      if (!_classPrivateFieldGet(this, _hotWasInitializedWithEmptyData)) {\n        var sourceDataArray = this.hot.getSourceDataArray();\n\n        if (this.engine.isItPossibleToReplaceSheetContent(this.sheetName, sourceDataArray)) {\n          _classPrivateFieldSet(this, _internalOperationPending, true);\n\n          var dependentCells = this.engine.setSheetContent(this.sheetName, this.hot.getSourceDataArray());\n          this.renderDependentSheets(dependentCells);\n\n          _classPrivateFieldSet(this, _internalOperationPending, false);\n        }\n      } else {\n        this.switchSheet(this.sheetName);\n      }\n    }\n    /**\n     * `modifyData` hook callback.\n     *\n     * @private\n     * @param {number} row Physical row height.\n     * @param {number} column Physical column index.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n\n  }, {\n    key: \"onModifyData\",\n    value: function onModifyData(row, column, valueHolder, ioMode) {\n      if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n        return;\n      } // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n\n\n      var isFormulaCellType = this.isFormulaCellType(this.hot.toVisualRow(row), column);\n\n      if (!isFormulaCellType) {\n        if (isEscapedFormulaExpression(valueHolder.value)) {\n          valueHolder.value = unescapeFormulaExpression(valueHolder.value);\n        }\n\n        return;\n      } // `toPhysicalColumn` is here because of inconsistencies related to hook execution in `src/dataMap`.\n\n\n      var address = {\n        row: row,\n        col: this.toPhysicalColumnPosition(column),\n        sheet: this.sheetId\n      };\n      var cellValue = this.engine.getCellValue(address); // If `cellValue` is an object it is expected to be an error\n\n      var value = _typeof(cellValue) === 'object' && cellValue !== null ? cellValue.value : cellValue;\n      valueHolder.value = value;\n    }\n    /**\n     * `modifySourceData` hook callback.\n     *\n     * @private\n     * @param {number} row Physical row index.\n     * @param {number|string} columnOrProp Physical column index or prop.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n\n  }, {\n    key: \"onModifySourceData\",\n    value: function onModifySourceData(row, columnOrProp, valueHolder, ioMode) {\n      if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n        return;\n      }\n\n      var visualColumn = this.hot.propToCol(columnOrProp); // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n\n      var isFormulaCellType = this.isFormulaCellType(this.hot.toVisualRow(row), visualColumn);\n\n      if (!isFormulaCellType) {\n        return;\n      }\n\n      var dimensions = this.engine.getSheetDimensions(this.engine.getSheetId(this.sheetName)); // Don't actually change the source data if HyperFormula is not\n      // initialized yet. This is done to allow the `afterLoadData` hook to\n      // load the existing source data with `Handsontable#getSourceDataArray`\n      // properly.\n\n      if (dimensions.width === 0 && dimensions.height === 0) {\n        return;\n      }\n\n      var address = {\n        row: row,\n        // Workaround for inconsistencies in `src/dataSource.js`\n        col: this.toPhysicalColumnPosition(visualColumn),\n        sheet: this.sheetId\n      };\n      valueHolder.value = this.engine.getCellSerialized(address);\n    }\n    /**\n     * `onAfterSetDataAtCell` hook callback.\n     *\n     * @private\n     * @param {Array[]} changes An array of changes in format [[row, prop, oldValue, value], ...].\n     */\n\n  }, {\n    key: \"onAfterSetDataAtCell\",\n    value: function onAfterSetDataAtCell(changes) {\n      var _this13 = this;\n\n      var dependentCells = [];\n      var outOfBoundsChanges = [];\n      var changedCells = [];\n      changes.forEach(function (_ref9) {\n        var _ref10 = _slicedToArray(_ref9, 4),\n            row = _ref10[0],\n            prop = _ref10[1],\n            newValue = _ref10[3];\n\n        var column = _this13.hot.propToCol(prop);\n\n        var physicalRow = _this13.hot.toPhysicalRow(row);\n\n        var physicalColumn = _this13.hot.toPhysicalColumn(column);\n\n        var address = {\n          row: physicalRow,\n          col: physicalColumn,\n          sheet: _this13.sheetId\n        };\n\n        if (physicalRow !== null && physicalColumn !== null) {\n          dependentCells.push.apply(dependentCells, _toConsumableArray(_this13.syncChangeWithEngine(row, column, newValue)));\n        } else {\n          outOfBoundsChanges.push([row, column, newValue]);\n        }\n\n        changedCells.push({\n          address: address\n        });\n      });\n\n      if (outOfBoundsChanges.length) {\n        // Workaround for rows/columns being created two times (by HOT and the engine).\n        // (unfortunately, this requires an extra re-render)\n        this.hot.addHookOnce('afterChange', function () {\n          var outOfBoundsDependentCells = [];\n          outOfBoundsChanges.forEach(function (_ref11) {\n            var _ref12 = _slicedToArray(_ref11, 3),\n                row = _ref12[0],\n                column = _ref12[1],\n                newValue = _ref12[2];\n\n            outOfBoundsDependentCells.push.apply(outOfBoundsDependentCells, _toConsumableArray(_this13.syncChangeWithEngine(row, column, newValue)));\n          });\n\n          _this13.renderDependentSheets(outOfBoundsDependentCells, true);\n        });\n      }\n\n      this.renderDependentSheets(dependentCells);\n      this.validateDependentCells(dependentCells, changedCells);\n    }\n    /**\n     * `onAfterSetSourceDataAtCell` hook callback.\n     *\n     * @private\n     * @param {Array[]} changes An array of changes in format [[row, column, oldValue, value], ...].\n     */\n\n  }, {\n    key: \"onAfterSetSourceDataAtCell\",\n    value: function onAfterSetSourceDataAtCell(changes) {\n      var _this14 = this;\n\n      var dependentCells = [];\n      var changedCells = [];\n      changes.forEach(function (_ref13) {\n        var _ref14 = _slicedToArray(_ref13, 4),\n            row = _ref14[0],\n            column = _ref14[1],\n            newValue = _ref14[3];\n\n        var address = {\n          row: row,\n          col: _this14.toPhysicalColumnPosition(column),\n          sheet: _this14.sheetId\n        };\n\n        if (!_this14.engine.isItPossibleToSetCellContents(address)) {\n          warn(\"Not possible to set source cell data at \".concat(JSON.stringify(address)));\n          return;\n        }\n\n        changedCells.push({\n          address: address\n        });\n        dependentCells.push.apply(dependentCells, _toConsumableArray(_this14.engine.setCellContents(address, newValue)));\n      });\n      this.renderDependentSheets(dependentCells);\n      this.validateDependentCells(dependentCells, changedCells);\n    }\n    /**\n     * `beforeCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeCreateRow\",\n    value: function onBeforeCreateRow(row, amount) {\n      if (!this.engine.isItPossibleToAddRows(this.sheetId, [this.toPhysicalRowPosition(row), amount])) {\n        return false;\n      }\n    }\n    /**\n     * `beforeCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} col Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeCreateCol\",\n    value: function onBeforeCreateCol(col, amount) {\n      if (!this.engine.isItPossibleToAddColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount])) {\n        return false;\n      }\n    }\n    /**\n     * `beforeRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount Amount of rows to be removed.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeRemoveRow\",\n    value: function onBeforeRemoveRow(row, amount, physicalRows) {\n      var _this15 = this;\n\n      var possible = physicalRows.every(function (physicalRow) {\n        return _this15.engine.isItPossibleToRemoveRows(_this15.sheetId, [physicalRow, 1]);\n      });\n      return possible === false ? false : void 0;\n    }\n    /**\n     * `beforeRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount Amount of columns to be removed.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeRemoveCol\",\n    value: function onBeforeRemoveCol(col, amount, physicalColumns) {\n      var _this16 = this;\n\n      var possible = physicalColumns.every(function (physicalColumn) {\n        return _this16.engine.isItPossibleToRemoveColumns(_this16.sheetId, [physicalColumn, 1]);\n      });\n      return possible === false ? false : void 0;\n    }\n    /**\n     * `afterCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     */\n\n  }, {\n    key: \"onAfterCreateRow\",\n    value: function onAfterCreateRow(row, amount) {\n      var changes = this.engine.addRows(this.sheetId, [this.toPhysicalRowPosition(row), amount]);\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} col Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     */\n\n  }, {\n    key: \"onAfterCreateCol\",\n    value: function onAfterCreateCol(col, amount) {\n      var changes = this.engine.addColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount]);\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount An amount of removed rows.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     */\n\n  }, {\n    key: \"onAfterRemoveRow\",\n    value: function onAfterRemoveRow(row, amount, physicalRows) {\n      var _this17 = this;\n\n      var descendingPhysicalRows = physicalRows.sort().reverse();\n      var changes = this.engine.batch(function () {\n        descendingPhysicalRows.forEach(function (physicalRow) {\n          _this17.engine.removeRows(_this17.sheetId, [physicalRow, 1]);\n        });\n      });\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount An amount of removed columns.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     */\n\n  }, {\n    key: \"onAfterRemoveCol\",\n    value: function onAfterRemoveCol(col, amount, physicalColumns) {\n      var _this18 = this;\n\n      var descendingPhysicalColumns = physicalColumns.sort().reverse();\n      var changes = this.engine.batch(function () {\n        descendingPhysicalColumns.forEach(function (physicalColumn) {\n          _this18.engine.removeColumns(_this18.sheetId, [physicalColumn, 1]);\n        });\n      });\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * Called when a value is updated in the engine.\n     *\n     * @private\n     * @fires Hooks#afterFormulasValuesUpdate\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineValuesUpdated\",\n    value: function onEngineValuesUpdated(changes) {\n      this.hot.runHooks('afterFormulasValuesUpdate', changes);\n    }\n    /**\n     * Called when a named expression is added to the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterNamedExpressionAdded\n     * @param {string} namedExpressionName The name of the added expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineNamedExpressionsAdded\",\n    value: function onEngineNamedExpressionsAdded(namedExpressionName, changes) {\n      this.hot.runHooks('afterNamedExpressionAdded', namedExpressionName, changes);\n    }\n    /**\n     * Called when a named expression is removed from the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterNamedExpressionRemoved\n     * @param {string} namedExpressionName The name of the removed expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineNamedExpressionsRemoved\",\n    value: function onEngineNamedExpressionsRemoved(namedExpressionName, changes) {\n      this.hot.runHooks('afterNamedExpressionRemoved', namedExpressionName, changes);\n    }\n    /**\n     * Called when a new sheet is added to the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterSheetAdded\n     * @param {string} addedSheetDisplayName The name of the added sheet.\n     */\n\n  }, {\n    key: \"onEngineSheetAdded\",\n    value: function onEngineSheetAdded(addedSheetDisplayName) {\n      this.hot.runHooks('afterSheetAdded', addedSheetDisplayName);\n    }\n    /**\n     * Called when a sheet in the engine instance is renamed.\n     *\n     * @private\n     * @fires Hooks#afterSheetRenamed\n     * @param {string} oldDisplayName The old name of the sheet.\n     * @param {string} newDisplayName The new name of the sheet.\n     */\n\n  }, {\n    key: \"onEngineSheetRenamed\",\n    value: function onEngineSheetRenamed(oldDisplayName, newDisplayName) {\n      this.hot.runHooks('afterSheetRenamed', oldDisplayName, newDisplayName);\n    }\n    /**\n     * Called when a sheet is removed from the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterSheetRemoved\n     * @param {string} removedSheetDisplayName The removed sheet name.\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineSheetRemoved\",\n    value: function onEngineSheetRemoved(removedSheetDisplayName, changes) {\n      this.hot.runHooks('afterSheetRemoved', removedSheetDisplayName, changes);\n    }\n  }], [{\n    key: \"PLUGIN_KEY\",\n    get: function get() {\n      return PLUGIN_KEY;\n    }\n  }, {\n    key: \"PLUGIN_PRIORITY\",\n    get: function get() {\n      return PLUGIN_PRIORITY;\n    }\n    /**\n     * Flag used to bypass hooks in internal operations.\n     *\n     * @private\n     * @type {boolean}\n     */\n\n  }]);\n\n  return Formulas;\n}(BasePlugin);"]},"metadata":{},"sourceType":"module"}