{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\n\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n\n  return descriptor.value;\n}\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n\n  _classApplyDescriptorSet(receiver, descriptor, value);\n\n  return value;\n}\n\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n\n  return privateMap.get(receiver);\n}\n\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n\n    descriptor.value = value;\n  }\n}\n\nimport { ChangesObserver } from \"./observer.mjs\";\nimport { arrayDiff } from \"./utils.mjs\";\n/**\n * The ChangesObservable module is an object that represents a resource that provides\n * the ability to observe the changes that happened in the index map indexes during\n * the code running.\n *\n * @class ChangesObservable\n */\n\nvar _observers = /*#__PURE__*/new WeakMap();\n\nvar _indexMatrix = /*#__PURE__*/new WeakMap();\n\nvar _currentIndexState = /*#__PURE__*/new WeakMap();\n\nvar _isMatrixIndexesInitialized = /*#__PURE__*/new WeakMap();\n\nvar _initialIndexValue = /*#__PURE__*/new WeakMap();\n\nexport var ChangesObservable = /*#__PURE__*/function () {\n  /**\n   * The list of registered ChangesObserver instances.\n   *\n   * @type {ChangesObserver[]}\n   */\n\n  /**\n   * An array with default values that act as a base array that will be compared with\n   * the last saved index state. The changes are generated and immediately send through\n   * the newly created ChangesObserver object. Thanks to that, the observer initially has\n   * all information about what indexes are currently changed.\n   *\n   * @type {Array}\n   */\n\n  /**\n   * An array that holds the indexes state that is currently valid. The value is changed on every\n   * index mapper cache update.\n   *\n   * @type {Array}\n   */\n\n  /**\n   * The flag determines if the observable is initialized or not. Not initialized object creates\n   * index matrix once while emitting new changes.\n   *\n   * @type {boolean}\n   */\n\n  /**\n   * The initial index value allows control from what value the index matrix array will be created.\n   * Changing that value changes how the array diff generates the changes for the initial data\n   * sent to the subscribers. For example, the changes can be triggered by detecting the changes\n   * from `false` to `true` value or vice versa. Generally, it depends on which index map type\n   * the Observable will work with. For \"hiding\" or \"trimming\" index types, it will be boolean\n   * values. For various index maps, it can be anything, but I suspect that the most appropriate\n   * initial value will be \"undefined\" in that case.\n   *\n   * @type {boolean}\n   */\n  function ChangesObservable() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        initialIndexValue = _ref.initialIndexValue;\n\n    _classCallCheck(this, ChangesObservable);\n\n    _observers.set(this, {\n      writable: true,\n      value: new Set()\n    });\n\n    _indexMatrix.set(this, {\n      writable: true,\n      value: []\n    });\n\n    _currentIndexState.set(this, {\n      writable: true,\n      value: []\n    });\n\n    _isMatrixIndexesInitialized.set(this, {\n      writable: true,\n      value: false\n    });\n\n    _initialIndexValue.set(this, {\n      writable: true,\n      value: false\n    });\n\n    _classPrivateFieldSet(this, _initialIndexValue, initialIndexValue !== null && initialIndexValue !== void 0 ? initialIndexValue : false);\n  }\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n\n  /**\n   * Creates and returns a new instance of the ChangesObserver object. The resource\n   * allows subscribing to the index changes that during the code running may change.\n   * Changes are emitted as an array of the index change. Each change is represented\n   * separately as an object with `op`, `index`, `oldValue`, and `newValue` props.\n   *\n   * For example:\n   * ```\n   * [\n   *   { op: 'replace', index: 1, oldValue: false, newValue: true },\n   *   { op: 'replace', index: 3, oldValue: false, newValue: true },\n   *   { op: 'insert', index: 4, oldValue: false, newValue: true },\n   * ]\n   * // or when the new index map changes have less indexes\n   * [\n   *   { op: 'replace', index: 1, oldValue: false, newValue: true },\n   *   { op: 'remove', index: 4, oldValue: false, newValue: true },\n   * ]\n   * ```\n   *\n   * @returns {ChangesObserver}\n   */\n\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n\n\n  _createClass(ChangesObservable, [{\n    key: \"createObserver\",\n    value: function createObserver() {\n      var _this = this;\n\n      var observer = new ChangesObserver();\n\n      _classPrivateFieldGet(this, _observers).add(observer);\n\n      observer.addLocalHook('unsubscribe', function () {\n        _classPrivateFieldGet(_this, _observers).delete(observer);\n      });\n\n      observer._writeInitialChanges(arrayDiff(_classPrivateFieldGet(this, _indexMatrix), _classPrivateFieldGet(this, _currentIndexState)));\n\n      return observer;\n    }\n    /**\n     * The method is an entry point for triggering new index map changes. Emitting the\n     * changes triggers comparing algorithm which compares last saved state with a new\n     * state. When there are some differences, the changes are sent to all subscribers.\n     *\n     * @param {Array} indexesState An array with index map state.\n     */\n\n  }, {\n    key: \"emit\",\n    value: function emit(indexesState) {\n      var currentIndexState = _classPrivateFieldGet(this, _currentIndexState);\n\n      if (!_classPrivateFieldGet(this, _isMatrixIndexesInitialized) || _classPrivateFieldGet(this, _indexMatrix).length !== indexesState.length) {\n        if (indexesState.length === 0) {\n          indexesState = new Array(currentIndexState.length).fill(_classPrivateFieldGet(this, _initialIndexValue));\n        } else {\n          _classPrivateFieldSet(this, _indexMatrix, new Array(indexesState.length).fill(_classPrivateFieldGet(this, _initialIndexValue)));\n        }\n\n        if (!_classPrivateFieldGet(this, _isMatrixIndexesInitialized)) {\n          _classPrivateFieldSet(this, _isMatrixIndexesInitialized, true);\n\n          currentIndexState = _classPrivateFieldGet(this, _indexMatrix);\n        }\n      }\n\n      var changes = arrayDiff(currentIndexState, indexesState);\n\n      _classPrivateFieldGet(this, _observers).forEach(function (observer) {\n        return observer._write(changes);\n      });\n\n      _classPrivateFieldSet(this, _currentIndexState, indexesState);\n    }\n  }]);\n\n  return ChangesObservable;\n}();","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/translations/changesObservable/observable.mjs"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_classPrivateFieldGet","receiver","privateMap","_classExtractFieldDescriptor","_classApplyDescriptorGet","get","call","value","_classPrivateFieldSet","_classApplyDescriptorSet","action","has","set","ChangesObserver","arrayDiff","_observers","WeakMap","_indexMatrix","_currentIndexState","_isMatrixIndexesInitialized","_initialIndexValue","ChangesObservable","_ref","arguments","undefined","initialIndexValue","Set","createObserver","_this","observer","add","addLocalHook","delete","_writeInitialChanges","emit","indexesState","currentIndexState","Array","fill","changes","forEach","_write"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.weak-map.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\n\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\n\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\n\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\n\nimport { ChangesObserver } from \"./observer.mjs\";\nimport { arrayDiff } from \"./utils.mjs\";\n/**\n * The ChangesObservable module is an object that represents a resource that provides\n * the ability to observe the changes that happened in the index map indexes during\n * the code running.\n *\n * @class ChangesObservable\n */\n\nvar _observers = /*#__PURE__*/new WeakMap();\n\nvar _indexMatrix = /*#__PURE__*/new WeakMap();\n\nvar _currentIndexState = /*#__PURE__*/new WeakMap();\n\nvar _isMatrixIndexesInitialized = /*#__PURE__*/new WeakMap();\n\nvar _initialIndexValue = /*#__PURE__*/new WeakMap();\n\nexport var ChangesObservable = /*#__PURE__*/function () {\n  /**\n   * The list of registered ChangesObserver instances.\n   *\n   * @type {ChangesObserver[]}\n   */\n\n  /**\n   * An array with default values that act as a base array that will be compared with\n   * the last saved index state. The changes are generated and immediately send through\n   * the newly created ChangesObserver object. Thanks to that, the observer initially has\n   * all information about what indexes are currently changed.\n   *\n   * @type {Array}\n   */\n\n  /**\n   * An array that holds the indexes state that is currently valid. The value is changed on every\n   * index mapper cache update.\n   *\n   * @type {Array}\n   */\n\n  /**\n   * The flag determines if the observable is initialized or not. Not initialized object creates\n   * index matrix once while emitting new changes.\n   *\n   * @type {boolean}\n   */\n\n  /**\n   * The initial index value allows control from what value the index matrix array will be created.\n   * Changing that value changes how the array diff generates the changes for the initial data\n   * sent to the subscribers. For example, the changes can be triggered by detecting the changes\n   * from `false` to `true` value or vice versa. Generally, it depends on which index map type\n   * the Observable will work with. For \"hiding\" or \"trimming\" index types, it will be boolean\n   * values. For various index maps, it can be anything, but I suspect that the most appropriate\n   * initial value will be \"undefined\" in that case.\n   *\n   * @type {boolean}\n   */\n  function ChangesObservable() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        initialIndexValue = _ref.initialIndexValue;\n\n    _classCallCheck(this, ChangesObservable);\n\n    _observers.set(this, {\n      writable: true,\n      value: new Set()\n    });\n\n    _indexMatrix.set(this, {\n      writable: true,\n      value: []\n    });\n\n    _currentIndexState.set(this, {\n      writable: true,\n      value: []\n    });\n\n    _isMatrixIndexesInitialized.set(this, {\n      writable: true,\n      value: false\n    });\n\n    _initialIndexValue.set(this, {\n      writable: true,\n      value: false\n    });\n\n    _classPrivateFieldSet(this, _initialIndexValue, initialIndexValue !== null && initialIndexValue !== void 0 ? initialIndexValue : false);\n  }\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n\n  /**\n   * Creates and returns a new instance of the ChangesObserver object. The resource\n   * allows subscribing to the index changes that during the code running may change.\n   * Changes are emitted as an array of the index change. Each change is represented\n   * separately as an object with `op`, `index`, `oldValue`, and `newValue` props.\n   *\n   * For example:\n   * ```\n   * [\n   *   { op: 'replace', index: 1, oldValue: false, newValue: true },\n   *   { op: 'replace', index: 3, oldValue: false, newValue: true },\n   *   { op: 'insert', index: 4, oldValue: false, newValue: true },\n   * ]\n   * // or when the new index map changes have less indexes\n   * [\n   *   { op: 'replace', index: 1, oldValue: false, newValue: true },\n   *   { op: 'remove', index: 4, oldValue: false, newValue: true },\n   * ]\n   * ```\n   *\n   * @returns {ChangesObserver}\n   */\n\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n\n\n  _createClass(ChangesObservable, [{\n    key: \"createObserver\",\n    value: function createObserver() {\n      var _this = this;\n\n      var observer = new ChangesObserver();\n\n      _classPrivateFieldGet(this, _observers).add(observer);\n\n      observer.addLocalHook('unsubscribe', function () {\n        _classPrivateFieldGet(_this, _observers).delete(observer);\n      });\n\n      observer._writeInitialChanges(arrayDiff(_classPrivateFieldGet(this, _indexMatrix), _classPrivateFieldGet(this, _currentIndexState)));\n\n      return observer;\n    }\n    /**\n     * The method is an entry point for triggering new index map changes. Emitting the\n     * changes triggers comparing algorithm which compares last saved state with a new\n     * state. When there are some differences, the changes are sent to all subscribers.\n     *\n     * @param {Array} indexesState An array with index map state.\n     */\n\n  }, {\n    key: \"emit\",\n    value: function emit(indexesState) {\n      var currentIndexState = _classPrivateFieldGet(this, _currentIndexState);\n\n      if (!_classPrivateFieldGet(this, _isMatrixIndexesInitialized) || _classPrivateFieldGet(this, _indexMatrix).length !== indexesState.length) {\n        if (indexesState.length === 0) {\n          indexesState = new Array(currentIndexState.length).fill(_classPrivateFieldGet(this, _initialIndexValue));\n        } else {\n          _classPrivateFieldSet(this, _indexMatrix, new Array(indexesState.length).fill(_classPrivateFieldGet(this, _initialIndexValue)));\n        }\n\n        if (!_classPrivateFieldGet(this, _isMatrixIndexesInitialized)) {\n          _classPrivateFieldSet(this, _isMatrixIndexesInitialized, true);\n\n          currentIndexState = _classPrivateFieldGet(this, _indexMatrix);\n        }\n      }\n\n      var changes = arrayDiff(currentIndexState, indexesState);\n\n      _classPrivateFieldGet(this, _observers).forEach(function (observer) {\n        return observer._write(changes);\n      });\n\n      _classPrivateFieldSet(this, _currentIndexState, indexesState);\n    }\n  }]);\n\n  return ChangesObservable;\n}();"]},"metadata":{},"sourceType":"module"}