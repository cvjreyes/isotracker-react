{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nimport parseDate from './parseDate';\nvar namespaces = {\n  a: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',\n  // This one seems to be for `r:id` attributes on `<sheet>`s.\n  r: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',\n  // This one seems to be for `<Relationships/>` file.\n  rr: 'http://schemas.openxmlformats.org/package/2006/relationships' // Maps \"A1\"-like coordinates to `{ row, column }` numeric coordinates.\n\n};\nvar letters = [\"\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"];\n/**\r\n * Reads an (unzipped) XLSX file structure into a 2D array of cells.\r\n * @param  {object} contents - A list of XML files inside XLSX file (which is a zipped directory).\r\n * @param  {number?} options.sheet - Workbook sheet id (`1` by default).\r\n * @param  {string?} options.dateFormat - Date format, e.g. \"MM/DD/YY\". Values having this format template set will be parsed as dates.\r\n * @param  {object} contents - A list of XML files inside XLSX file (which is a zipped directory).\r\n * @return {object} An object of shape `{ data, cells, properties }`. `data: string[][]` is an array of rows, each row being an array of cell values. `cells: string[][]` is an array of rows, each row being an array of cells. `properties: object` is the spreadsheet properties (e.g. whether date epoch is 1904 instead of 1900).\r\n */\n\nexport default function readXlsx(contents, xml) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!options.sheet) {\n    options = _extends({\n      sheet: 1\n    }, options);\n  } // Some Excel editors don't want to use standard naming scheme for sheet files.\n  // https://github.com/tidyverse/readxl/issues/104\n\n\n  var fileNames = parseFileNames(contents['xl/_rels/workbook.xml.rels'], xml); // Default file path for \"shared strings\": \"xl/sharedStrings.xml\".\n\n  var values = parseValues(contents['xl/' + fileNames.sharedStrings], xml); // Default file path for \"styles\": \"xl/styles.xml\".\n\n  var styles = parseStyles(contents['xl/' + fileNames.styles], xml);\n  var properties = parseProperties(contents['xl/workbook.xml'], xml); // A feature for getting the list of sheets in an Excel file.\n  // https://github.com/catamphetamine/read-excel-file/issues/14\n\n  if (options.getSheets) {\n    return properties.sheets.map(function (_ref) {\n      var name = _ref.name;\n      return {\n        name: name\n      };\n    });\n  } // Find the sheet by name, or take the first one.\n\n\n  var sheetRelationId = void 0;\n\n  if (typeof options.sheet === 'number') {\n    var _sheet = properties.sheets[options.sheet - 1];\n    sheetRelationId = _sheet && _sheet.relationId;\n  } else {\n    for (var _iterator = properties.sheets, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref2 = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref2 = _i.value;\n      }\n\n      var _sheet2 = _ref2;\n\n      if (_sheet2.name === options.sheet) {\n        sheetRelationId = _sheet2.relationId;\n        break;\n      }\n    }\n  } // If the sheet wasn't found then throw an error.\n  // Example: \"xl/worksheets/sheet1.xml\".\n\n\n  if (!sheetRelationId || !fileNames.sheets[sheetRelationId]) {\n    throw createSheetNotFoundError(options.sheet, properties.sheets);\n  } // Parse sheet data.\n\n\n  var sheet = parseSheet(contents['xl/' + fileNames.sheets[sheetRelationId]], xml, values, styles, properties, options); // If the sheet is empty.\n\n  if (sheet.cells.length === 0) {\n    if (options.properties) {\n      return {\n        data: [],\n        properties: properties\n      };\n    }\n\n    return [];\n  }\n\n  var _sheet$dimensions = _slicedToArray(sheet.dimensions, 2),\n      leftTop = _sheet$dimensions[0],\n      rightBottom = _sheet$dimensions[1];\n\n  var colsCount = rightBottom.column - leftTop.column + 1;\n  var rowsCount = rightBottom.row - leftTop.row + 1; // `sheet.cells` seem to not necessarily be sorted by row and column.\n\n  var data = new Array(rowsCount);\n  var i = 0;\n\n  while (i < rowsCount) {\n    data[i] = new Array(colsCount);\n    var j = 0;\n\n    while (j < colsCount) {\n      data[i][j] = null;\n      j++;\n    }\n\n    i++;\n  }\n\n  for (var _iterator2 = sheet.cells, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n    var _ref3;\n\n    if (_isArray2) {\n      if (_i2 >= _iterator2.length) break;\n      _ref3 = _iterator2[_i2++];\n    } else {\n      _i2 = _iterator2.next();\n      if (_i2.done) break;\n      _ref3 = _i2.value;\n    }\n\n    var cell = _ref3;\n    var row = cell.row - leftTop.row;\n    var column = cell.column - leftTop.column;\n    data[row][column] = cell.value;\n  } // Fill in the row map.\n\n\n  var _options = options,\n      rowMap = _options.rowMap;\n\n  if (rowMap) {\n    var _i3 = 0;\n\n    while (_i3 < data.length) {\n      rowMap[_i3] = _i3;\n      _i3++;\n    }\n  }\n\n  data = dropEmptyRows(dropEmptyColumns(data, {\n    onlyTrimAtTheEnd: true\n  }), {\n    onlyTrimAtTheEnd: true,\n    rowMap: rowMap\n  });\n\n  if (options.transformData) {\n    data = options.transformData(data); // data = options.transformData(data, {\n    //   dropEmptyRowsAndColumns(data) {\n    //     return dropEmptyRows(dropEmptyColumns(data), { rowMap })\n    //   }\n    // })\n  }\n\n  if (options.properties) {\n    return {\n      data: data,\n      properties: properties\n    };\n  }\n\n  return data;\n}\n\nfunction calculateDimensions(cells) {\n  var comparator = function comparator(a, b) {\n    return a - b;\n  };\n\n  var allRows = cells.map(function (cell) {\n    return cell.row;\n  }).sort(comparator);\n  var allCols = cells.map(function (cell) {\n    return cell.column;\n  }).sort(comparator);\n  var minRow = allRows[0];\n  var maxRow = allRows[allRows.length - 1];\n  var minCol = allCols[0];\n  var maxCol = allCols[allCols.length - 1];\n  return [{\n    row: minRow,\n    column: minCol\n  }, {\n    row: maxRow,\n    column: maxCol\n  }];\n}\n\nfunction colToInt(col) {\n  // `for ... of ...` would require Babel polyfill for iterating a string.\n  var n = 0;\n  var i = 0;\n\n  while (i < col.length) {\n    n *= 26;\n    n += letters.indexOf(col[i]);\n    i++;\n  }\n\n  return n;\n}\n\nfunction CellCoords(coords) {\n  // Examples: \"AA2091\", \"R988\", \"B1\"\n  coords = coords.split(/(\\d+)/);\n  return [// Row.\n  parseInt(coords[1]), // Column.\n  colToInt(coords[0].trim())];\n}\n\nfunction Cell(cellNode, sheet, xml, values, styles, properties, options) {\n  var coords = CellCoords(cellNode.getAttribute('r'));\n  var value = xml.select(sheet, cellNode, 'a:v', namespaces)[0]; // For `xpath` `value` can be `undefined` while for native `DOMParser` it's `null`.\n  // So using `value && ...` instead of `if (value !== undefined) { ... }` here.\n\n  value = value && value.textContent; // http://webapp.docx4java.org/OnlineDemo/ecma376/SpreadsheetML/ST_CellType.html\n\n  switch (cellNode.getAttribute('t')) {\n    // If the cell contains formula string.\n    case 'str':\n      value = value.trim();\n\n      if (value === '') {\n        value = undefined;\n      }\n\n      break;\n    // If the cell contains a \"shared\" string.\n\n    case 's':\n      // If a cell has no value then there's no `<c/>` element for it.\n      // If a `<c/>` element exists then it's not empty.\n      // The `<v/>`alue is a key in the \"shared strings\" dictionary of the\n      // XLSX file, so look it up in the `values` dictionary by the numeric key.\n      value = values[parseInt(value)].trim();\n\n      if (value === '') {\n        value = undefined;\n      }\n\n      break;\n\n    case 'b':\n      value = value === '1' ? true : false;\n      break;\n\n    case 'n': // Default type is \"n\".\n    // http://www.datypic.com/sc/ooxml/t-ssml_CT_Cell.html\n\n    default:\n      if (value === undefined) {\n        break;\n      }\n\n      value = parseFloat(value); // XLSX has no specific format for dates.\n      // Sometimes a date can be heuristically detected.\n      // https://github.com/catamphetamine/read-excel-file/issues/3#issuecomment-395770777\n\n      var style = styles[parseInt(cellNode.getAttribute('s') || 0)];\n\n      if (style.numberFormat.id >= 14 && style.numberFormat.id <= 22 || style.numberFormat.id >= 45 && style.numberFormat.id <= 47 || options.dateFormat && style.numberFormat.template === options.dateFormat || options.smartDateParser !== false && style.numberFormat.template && isDateTemplate(style.numberFormat.template)) {\n        value = parseDate(value, properties);\n      }\n\n      break;\n  } // Convert empty values to `null`.\n\n\n  if (value === undefined) {\n    value = null;\n  }\n\n  return {\n    row: coords[0],\n    column: coords[1],\n    value: value\n  };\n}\n\nexport function dropEmptyRows(data) {\n  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      rowMap = _ref4.rowMap,\n      _ref4$accessor = _ref4.accessor,\n      accessor = _ref4$accessor === undefined ? function (_) {\n    return _;\n  } : _ref4$accessor,\n      onlyTrimAtTheEnd = _ref4.onlyTrimAtTheEnd; // Drop empty rows.\n\n\n  var i = data.length - 1;\n\n  while (i >= 0) {\n    // Check if the row is empty.\n    var empty = true;\n\n    for (var _iterator3 = data[i], _isArray3 = Array.isArray(_iterator3), _i4 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref5;\n\n      if (_isArray3) {\n        if (_i4 >= _iterator3.length) break;\n        _ref5 = _iterator3[_i4++];\n      } else {\n        _i4 = _iterator3.next();\n        if (_i4.done) break;\n        _ref5 = _i4.value;\n      }\n\n      var cell = _ref5;\n\n      if (accessor(cell) !== null) {\n        empty = false;\n        break;\n      }\n    } // Remove the empty row.\n\n\n    if (empty) {\n      data.splice(i, 1);\n\n      if (rowMap) {\n        rowMap.splice(i, 1);\n      }\n    } else if (onlyTrimAtTheEnd) {\n      break;\n    }\n\n    i--;\n  }\n\n  return data;\n}\nexport function dropEmptyColumns(data) {\n  var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref6$accessor = _ref6.accessor,\n      accessor = _ref6$accessor === undefined ? function (_) {\n    return _;\n  } : _ref6$accessor,\n      onlyTrimAtTheEnd = _ref6.onlyTrimAtTheEnd;\n\n  var i = data[0].length - 1;\n\n  while (i >= 0) {\n    var empty = true;\n\n    for (var _iterator4 = data, _isArray4 = Array.isArray(_iterator4), _i5 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n      var _ref7;\n\n      if (_isArray4) {\n        if (_i5 >= _iterator4.length) break;\n        _ref7 = _iterator4[_i5++];\n      } else {\n        _i5 = _iterator4.next();\n        if (_i5.done) break;\n        _ref7 = _i5.value;\n      }\n\n      var row = _ref7;\n\n      if (accessor(row[i]) !== null) {\n        empty = false;\n        break;\n      }\n    }\n\n    if (empty) {\n      var j = 0;\n\n      while (j < data.length) {\n        data[j].splice(i, 1);\n        j++;\n      }\n    } else if (onlyTrimAtTheEnd) {\n      break;\n    }\n\n    i--;\n  }\n\n  return data;\n}\n\nfunction parseSheet(content, xml, values, styles, properties, options) {\n  var sheet = xml.createDocument(content);\n  var cells = xml.select(sheet, null, '/a:worksheet/a:sheetData/a:row/a:c', namespaces).map(function (node) {\n    return Cell(node, sheet, xml, values, styles, properties, options);\n  });\n\n  if (cells.length === 0) {\n    return {\n      cells: cells\n    };\n  } // \"//a:dimension/@ref\" causes \"RangeError: Maximum call stack size exceeded\" error.\n  // That selector was in the legacy code I copy-pasted and no one knows why it was there.\n  // let dimensions = xml.select(sheet, null, '//a:dimension/@ref', namespaces)[0]\n\n\n  var dimensions = xml.select(sheet, null, '/a:worksheet/a:dimension/@ref', namespaces)[0];\n\n  if (dimensions) {\n    dimensions = dimensions.textContent.split(':').map(CellCoords).map(function (_ref8) {\n      var _ref9 = _slicedToArray(_ref8, 2),\n          row = _ref9[0],\n          column = _ref9[1];\n\n      return {\n        row: row,\n        column: column\n      };\n    }); // When there's only a single cell on a sheet\n    // there can sometimes be just \"A1\" for the dimensions string.\n\n    if (dimensions.length === 1) {\n      dimensions = [dimensions[0], dimensions[0]];\n    }\n  } else {\n    dimensions = calculateDimensions(cells);\n  }\n\n  return {\n    cells: cells,\n    dimensions: dimensions\n  };\n}\n\nfunction parseValues(content, xml) {\n  if (!content) {\n    return [];\n  }\n\n  var strings = xml.createDocument(content);\n  return xml.select(strings, null, '//a:si', namespaces).map(function (string) {\n    return xml.select(strings, string, './/a:t[not(ancestor::a:rPh)]', namespaces).map(function (_) {\n      return _.textContent;\n    }).join('');\n  });\n} // http://officeopenxml.com/SSstyles.php\n\n\nfunction parseStyles(content, xml) {\n  if (!content) {\n    return {};\n  } // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/708978af-b598-45c4-a598-d3518a5a09f0/howwhen-is-cellstylexfs-vs-cellxfs-applied-to-a-cell?forum=os_binaryfile\n  // https://www.office-forums.com/threads/cellxfs-cellstylexfs.2163519/\n\n\n  var doc = xml.createDocument(content);\n  var baseStyles = xml.select(doc, null, '//a:styleSheet/a:cellStyleXfs/a:xf', namespaces).map(parseCellStyle);\n  var numFmts = xml.select(doc, null, '//a:styleSheet/a:numFmts/a:numFmt', namespaces).map(parseNumberFormatStyle).reduce(function (formats, format) {\n    formats[format.id] = format;\n    return formats;\n  }, []);\n  return xml.select(doc, null, '//a:styleSheet/a:cellXfs/a:xf', namespaces).map(function (xf) {\n    if (xf.hasAttribute('xfId')) {\n      return _extends({}, baseStyles[xf.xfId], parseCellStyle(xf, numFmts));\n    }\n\n    return parseCellStyle(xf, numFmts);\n  });\n}\n\nfunction parseNumberFormatStyle(numFmt) {\n  return {\n    id: numFmt.getAttribute('numFmtId'),\n    template: numFmt.getAttribute('formatCode')\n  };\n} // http://www.datypic.com/sc/ooxml/e-ssml_xf-2.html\n\n\nfunction parseCellStyle(xf, numFmts) {\n  var style = {};\n\n  if (xf.hasAttribute('numFmtId')) {\n    var numberFormatId = xf.getAttribute('numFmtId');\n\n    if (numFmts[numberFormatId]) {\n      style.numberFormat = numFmts[numberFormatId];\n    } else {\n      style.numberFormat = {\n        id: numberFormatId\n      };\n    }\n  }\n\n  return style;\n} // I guess `xl/workbook.xml` file should always be present inside the *.xlsx archive.\n\n\nfunction parseProperties(content, xml) {\n  var book = xml.createDocument(content); // http://webapp.docx4java.org/OnlineDemo/ecma376/SpreadsheetML/workbookPr.html\n\n  var properties = {}; // https://support.microsoft.com/en-gb/help/214330/differences-between-the-1900-and-the-1904-date-system-in-excel\n\n  var workbookProperties = xml.select(book, null, '//a:workbookPr', namespaces)[0];\n\n  if (workbookProperties && workbookProperties.getAttribute('date1904') === '1') {\n    properties.epoch1904 = true;\n  } // Get sheets info (indexes, names, if they're available).\n  // Example:\n  // <sheets>\n  //   <sheet\n  //     xmlns:ns=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"\n  //     name=\"Sheet1\"\n  //     sheetId=\"1\"\n  //     ns:id=\"rId3\"/>\n  // </sheets>\n  // http://www.datypic.com/sc/ooxml/e-ssml_sheet-1.html\n\n\n  properties.sheets = [];\n  var i = 0;\n\n  for (var _iterator5 = xml.select(book, null, '//a:sheets/a:sheet', namespaces), _isArray5 = Array.isArray(_iterator5), _i6 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n    var _ref10;\n\n    if (_isArray5) {\n      if (_i6 >= _iterator5.length) break;\n      _ref10 = _iterator5[_i6++];\n    } else {\n      _i6 = _iterator5.next();\n      if (_i6.done) break;\n      _ref10 = _i6.value;\n    }\n\n    var sheet = _ref10;\n\n    if (sheet.getAttribute('name')) {\n      properties.sheets.push({\n        id: sheet.getAttribute('sheetId'),\n        name: sheet.getAttribute('name'),\n        relationId: sheet.getAttribute('r:id')\n      });\n    }\n\n    i++;\n  }\n\n  return properties;\n}\n/**\r\n * Returns sheet file paths.\r\n * Seems that the correct place to look for the\r\n * `sheetId` -> `filename` mapping seems to be in the\r\n * `xl/_rels/workbook.xml.rels` file.\r\n * https://github.com/tidyverse/readxl/issues/104\r\n * @param  {string} content â€” `xl/_rels/workbook.xml.rels` file contents.\r\n * @param  {object} xml\r\n * @return {object}\r\n */\n\n\nfunction parseFileNames(content, xml) {\n  // Example:\n  // <Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">\n  //   ...\n  //   <Relationship\n  //     Id=\"rId3\"\n  //     Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet\"\n  //     Target=\"worksheets/sheet1.xml\"/>\n  // </Relationships>\n  var document = xml.createDocument(content);\n  var fileNames = {\n    sheets: {},\n    sharedStrings: undefined,\n    styles: undefined\n  };\n\n  for (var _iterator6 = xml.select(document, null, '/rr:Relationships/rr:Relationship', namespaces), _isArray6 = Array.isArray(_iterator6), _i7 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {\n    var _ref11;\n\n    if (_isArray6) {\n      if (_i7 >= _iterator6.length) break;\n      _ref11 = _iterator6[_i7++];\n    } else {\n      _i7 = _iterator6.next();\n      if (_i7.done) break;\n      _ref11 = _i7.value;\n    }\n\n    var relationship = _ref11;\n    var filePath = relationship.getAttribute('Target');\n\n    switch (relationship.getAttribute('Type')) {\n      case 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles':\n        fileNames.styles = filePath;\n        break;\n\n      case 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings':\n        fileNames.sharedStrings = filePath;\n        break;\n\n      case 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet':\n        fileNames.sheets[relationship.getAttribute('Id')] = filePath;\n        break;\n    }\n  }\n\n  if (!fileNames.styles) {\n    throw new Error('\"styles.xml\" file not found in the *.xlsx file');\n  } // Seems like \"sharedStrings.xml\" is not required to exist.\n  // For example, when the spreadsheet doesn't contain any strings.\n  // https://github.com/catamphetamine/read-excel-file/issues/85\n  // if (!fileNames.sharedStrings) {\n  //   throw new Error('\"sharedStrings.xml\" file not found in the *.xlsx file')\n  // }\n\n\n  return fileNames;\n}\n\nfunction isDateTemplate(template) {\n  var tokens = template.split(/\\W+/);\n\n  for (var _iterator7 = tokens, _isArray7 = Array.isArray(_iterator7), _i8 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {\n    var _ref12;\n\n    if (_isArray7) {\n      if (_i8 >= _iterator7.length) break;\n      _ref12 = _iterator7[_i8++];\n    } else {\n      _i8 = _iterator7.next();\n      if (_i8.done) break;\n      _ref12 = _i8.value;\n    }\n\n    var token = _ref12;\n\n    if (['MM', 'DD', 'YY', 'YYYY'].indexOf(token) < 0) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction createSheetNotFoundError(sheet, sheets) {\n  var sheetsList = sheets && sheets.map(function (sheet, i) {\n    return '\"' + sheet.name + '\" (#' + (i + 1) + ')';\n  }).join(', ');\n  return new Error('Sheet ' + (typeof sheet === 'number' ? '#' + sheet : '\"' + sheet + '\"') + ' not found in the *.xlsx file.' + (sheets ? ' Available sheets: ' + sheetsList + '.' : ''));\n}","map":{"version":3,"sources":["../source/readXlsx.js"],"names":["namespaces","a","r","rr","letters","options","sheet","fileNames","parseFileNames","contents","values","parseValues","styles","parseStyles","properties","parseProperties","name","sheetRelationId","_sheet","createSheetNotFoundError","parseSheet","data","leftTop","rightBottom","colsCount","rowsCount","i","j","cell","row","column","rowMap","dropEmptyRows","dropEmptyColumns","onlyTrimAtTheEnd","comparator","allRows","allCols","minRow","maxRow","minCol","maxCol","n","col","coords","parseInt","colToInt","CellCoords","cellNode","value","xml","parseFloat","style","isDateTemplate","parseDate","accessor","empty","cells","Cell","dimensions","calculateDimensions","strings","_","doc","baseStyles","numFmts","formats","format","xf","parseCellStyle","id","numFmt","template","numberFormatId","book","workbookProperties","relationId","document","sheets","sharedStrings","undefined","relationship","filePath","tokens","token","sheetsList"],"mappings":"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","sourcesContent":["import parseDate from './parseDate'\r\n\r\nconst namespaces = {\r\n  a: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',\r\n  // This one seems to be for `r:id` attributes on `<sheet>`s.\r\n  r: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',\r\n  // This one seems to be for `<Relationships/>` file.\r\n  rr: 'http://schemas.openxmlformats.org/package/2006/relationships'\r\n}\r\n\r\n// Maps \"A1\"-like coordinates to `{ row, column }` numeric coordinates.\r\nconst letters = [\"\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\r\n\r\n/**\r\n * Reads an (unzipped) XLSX file structure into a 2D array of cells.\r\n * @param  {object} contents - A list of XML files inside XLSX file (which is a zipped directory).\r\n * @param  {number?} options.sheet - Workbook sheet id (`1` by default).\r\n * @param  {string?} options.dateFormat - Date format, e.g. \"MM/DD/YY\". Values having this format template set will be parsed as dates.\r\n * @param  {object} contents - A list of XML files inside XLSX file (which is a zipped directory).\r\n * @return {object} An object of shape `{ data, cells, properties }`. `data: string[][]` is an array of rows, each row being an array of cell values. `cells: string[][]` is an array of rows, each row being an array of cells. `properties: object` is the spreadsheet properties (e.g. whether date epoch is 1904 instead of 1900).\r\n */\r\nexport default function readXlsx(contents, xml, options = {}) {\r\n  if (!options.sheet) {\r\n    options = {\r\n      sheet: 1,\r\n      ...options\r\n    }\r\n  }\r\n\r\n  // Some Excel editors don't want to use standard naming scheme for sheet files.\r\n  // https://github.com/tidyverse/readxl/issues/104\r\n  const fileNames = parseFileNames(contents['xl/_rels/workbook.xml.rels'], xml)\r\n  // Default file path for \"shared strings\": \"xl/sharedStrings.xml\".\r\n  const values = parseValues(contents[`xl/${fileNames.sharedStrings}`], xml)\r\n  // Default file path for \"styles\": \"xl/styles.xml\".\r\n  const styles = parseStyles(contents[`xl/${fileNames.styles}`], xml)\r\n  const properties = parseProperties(contents['xl/workbook.xml'], xml)\r\n\r\n  // A feature for getting the list of sheets in an Excel file.\r\n  // https://github.com/catamphetamine/read-excel-file/issues/14\r\n  if (options.getSheets) {\r\n    return properties.sheets.map(({ name }) => ({\r\n      name\r\n    }))\r\n  }\r\n\r\n  // Find the sheet by name, or take the first one.\r\n  let sheetRelationId\r\n  if (typeof options.sheet === 'number') {\r\n    const _sheet = properties.sheets[options.sheet - 1]\r\n    sheetRelationId = _sheet && _sheet.relationId\r\n  } else {\r\n    for (const sheet of properties.sheets) {\r\n      if (sheet.name === options.sheet) {\r\n        sheetRelationId = sheet.relationId\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  // If the sheet wasn't found then throw an error.\r\n  // Example: \"xl/worksheets/sheet1.xml\".\r\n  if (!sheetRelationId || !fileNames.sheets[sheetRelationId]) {\r\n    throw createSheetNotFoundError(options.sheet, properties.sheets)\r\n  }\r\n\r\n  // Parse sheet data.\r\n  const sheet = parseSheet(\r\n    contents[`xl/${fileNames.sheets[sheetRelationId]}`],\r\n    xml,\r\n    values,\r\n    styles,\r\n    properties,\r\n    options\r\n  )\r\n\r\n  // If the sheet is empty.\r\n  if (sheet.cells.length === 0) {\r\n    if (options.properties) {\r\n      return {\r\n        data: [],\r\n        properties\r\n      }\r\n    }\r\n    return []\r\n  }\r\n\r\n  const [ leftTop, rightBottom ] = sheet.dimensions\r\n\r\n  const colsCount = (rightBottom.column - leftTop.column) + 1\r\n  const rowsCount = (rightBottom.row - leftTop.row) + 1\r\n\r\n  // `sheet.cells` seem to not necessarily be sorted by row and column.\r\n  let data = new Array(rowsCount)\r\n  let i = 0\r\n  while (i < rowsCount) {\r\n    data[i] = new Array(colsCount)\r\n    let j = 0\r\n    while (j < colsCount) {\r\n      data[i][j] = null\r\n      j++\r\n    }\r\n    i++\r\n  }\r\n  for (const cell of sheet.cells) {\r\n    const row = cell.row - leftTop.row\r\n    const column = cell.column - leftTop.column\r\n    data[row][column] = cell.value\r\n  }\r\n\r\n  // Fill in the row map.\r\n  const { rowMap } = options\r\n  if (rowMap) {\r\n    let i = 0\r\n    while (i < data.length) {\r\n      rowMap[i] = i\r\n      i++\r\n    }\r\n  }\r\n\r\n  data = dropEmptyRows(\r\n    dropEmptyColumns(data, { onlyTrimAtTheEnd: true }),\r\n    { onlyTrimAtTheEnd: true, rowMap }\r\n  )\r\n\r\n  if (options.transformData) {\r\n    data = options.transformData(data)\r\n    // data = options.transformData(data, {\r\n    //   dropEmptyRowsAndColumns(data) {\r\n    //     return dropEmptyRows(dropEmptyColumns(data), { rowMap })\r\n    //   }\r\n    // })\r\n  }\r\n\r\n  if (options.properties) {\r\n    return {\r\n      data,\r\n      properties\r\n    }\r\n  }\r\n\r\n  return data\r\n}\r\n\r\nfunction calculateDimensions (cells) {\r\n  const comparator = (a, b) => a - b\r\n  const allRows = cells.map(cell => cell.row).sort(comparator)\r\n  const allCols = cells.map(cell => cell.column).sort(comparator)\r\n  const minRow = allRows[0]\r\n  const maxRow = allRows[allRows.length - 1]\r\n  const minCol = allCols[0]\r\n  const maxCol = allCols[allCols.length - 1]\r\n\r\n  return [\r\n    { row: minRow, column: minCol },\r\n    { row: maxRow, column: maxCol }\r\n  ]\r\n}\r\n\r\nfunction colToInt(col) {\r\n  // `for ... of ...` would require Babel polyfill for iterating a string.\r\n  let n = 0\r\n  let i = 0\r\n  while (i < col.length) {\r\n    n *= 26\r\n    n += letters.indexOf(col[i])\r\n    i++\r\n  }\r\n  return n\r\n}\r\n\r\nfunction CellCoords(coords) {\r\n  // Examples: \"AA2091\", \"R988\", \"B1\"\r\n  coords = coords.split(/(\\d+)/)\r\n  return [\r\n    // Row.\r\n    parseInt(coords[1]),\r\n    // Column.\r\n    colToInt(coords[0].trim())\r\n  ]\r\n}\r\n\r\nfunction Cell(cellNode, sheet, xml, values, styles, properties, options) {\r\n  const coords = CellCoords(cellNode.getAttribute('r'))\r\n\r\n  let value = xml.select(sheet, cellNode, 'a:v', namespaces)[0]\r\n  // For `xpath` `value` can be `undefined` while for native `DOMParser` it's `null`.\r\n  // So using `value && ...` instead of `if (value !== undefined) { ... }` here.\r\n  value = value && value.textContent\r\n\r\n  // http://webapp.docx4java.org/OnlineDemo/ecma376/SpreadsheetML/ST_CellType.html\r\n  switch (cellNode.getAttribute('t')) {\r\n    // If the cell contains formula string.\r\n    case 'str':\r\n      value = value.trim()\r\n      if (value === '') {\r\n        value = undefined\r\n      }\r\n      break\r\n\r\n    // If the cell contains a \"shared\" string.\r\n    case 's':\r\n      // If a cell has no value then there's no `<c/>` element for it.\r\n      // If a `<c/>` element exists then it's not empty.\r\n      // The `<v/>`alue is a key in the \"shared strings\" dictionary of the\r\n      // XLSX file, so look it up in the `values` dictionary by the numeric key.\r\n      value = values[parseInt(value)].trim()\r\n      if (value === '') {\r\n        value = undefined\r\n      }\r\n      break\r\n\r\n    case 'b':\r\n      value = value === '1' ? true : false\r\n      break\r\n\r\n    case 'n':\r\n    // Default type is \"n\".\r\n    // http://www.datypic.com/sc/ooxml/t-ssml_CT_Cell.html\r\n    default:\r\n      if (value === undefined) {\r\n        break\r\n      }\r\n      value = parseFloat(value)\r\n      // XLSX has no specific format for dates.\r\n      // Sometimes a date can be heuristically detected.\r\n      // https://github.com/catamphetamine/read-excel-file/issues/3#issuecomment-395770777\r\n      const style = styles[parseInt(cellNode.getAttribute('s') || 0)]\r\n      if ((style.numberFormat.id >= 14 && style.numberFormat.id <= 22) ||\r\n        (style.numberFormat.id >= 45 && style.numberFormat.id <= 47) ||\r\n        (options.dateFormat && style.numberFormat.template === options.dateFormat) ||\r\n        (options.smartDateParser !== false && style.numberFormat.template && isDateTemplate(style.numberFormat.template))) {\r\n        value = parseDate(value, properties)\r\n      }\r\n      break\r\n  }\r\n\r\n  // Convert empty values to `null`.\r\n  if (value === undefined) {\r\n    value = null\r\n  }\r\n\r\n  return {\r\n    row    : coords[0],\r\n    column : coords[1],\r\n    value\r\n  }\r\n}\r\n\r\nexport function dropEmptyRows(data, {\r\n  rowMap,\r\n  accessor = _ => _,\r\n  onlyTrimAtTheEnd\r\n} = {}) {\r\n  // Drop empty rows.\r\n  let i = data.length - 1\r\n  while (i >= 0) {\r\n    // Check if the row is empty.\r\n    let empty = true\r\n    for (const cell of data[i]) {\r\n      if (accessor(cell) !== null) {\r\n        empty = false\r\n        break\r\n      }\r\n    }\r\n    // Remove the empty row.\r\n    if (empty) {\r\n      data.splice(i, 1)\r\n      if (rowMap) {\r\n        rowMap.splice(i, 1)\r\n      }\r\n    } else if (onlyTrimAtTheEnd) {\r\n      break\r\n    }\r\n    i--\r\n  }\r\n  return data\r\n}\r\n\r\nexport function dropEmptyColumns(data, {\r\n  accessor = _ => _,\r\n  onlyTrimAtTheEnd\r\n} = {}) {\r\n  let i = data[0].length - 1\r\n  while (i >= 0) {\r\n    let empty = true\r\n    for (const row of data) {\r\n      if (accessor(row[i]) !== null) {\r\n        empty = false\r\n        break\r\n      }\r\n    }\r\n    if (empty) {\r\n      let j = 0;\r\n      while (j < data.length) {\r\n        data[j].splice(i, 1)\r\n        j++\r\n      }\r\n    } else if (onlyTrimAtTheEnd) {\r\n      break\r\n    }\r\n    i--\r\n  }\r\n  return data\r\n}\r\n\r\nfunction parseSheet(content, xml, values, styles, properties, options) {\r\n  const sheet = xml.createDocument(content)\r\n\r\n  const cells = xml.select(sheet, null, '/a:worksheet/a:sheetData/a:row/a:c', namespaces).map(node => Cell(node, sheet, xml, values, styles, properties, options))\r\n\r\n  if (cells.length === 0) {\r\n    return { cells }\r\n  }\r\n\r\n  // \"//a:dimension/@ref\" causes \"RangeError: Maximum call stack size exceeded\" error.\r\n  // That selector was in the legacy code I copy-pasted and no one knows why it was there.\r\n  // let dimensions = xml.select(sheet, null, '//a:dimension/@ref', namespaces)[0]\r\n  let dimensions = xml.select(sheet, null, '/a:worksheet/a:dimension/@ref', namespaces)[0]\r\n\r\n  if (dimensions) {\r\n    dimensions = dimensions.textContent.split(':').map(CellCoords).map(([row, column]) => ({\r\n      row,\r\n      column\r\n    }))\r\n    // When there's only a single cell on a sheet\r\n    // there can sometimes be just \"A1\" for the dimensions string.\r\n    if (dimensions.length === 1) {\r\n      dimensions = [dimensions[0], dimensions[0]]\r\n    }\r\n  } else {\r\n    dimensions = calculateDimensions(cells)\r\n  }\r\n\r\n  return { cells, dimensions }\r\n}\r\n\r\nfunction parseValues(content, xml) {\r\n  if (!content) {\r\n    return []\r\n  }\r\n  const strings = xml.createDocument(content)\r\n  return xml.select(strings, null, '//a:si', namespaces)\r\n    .map(string => xml.select(strings, string, './/a:t[not(ancestor::a:rPh)]', namespaces).map(_ => _.textContent).join(''))\r\n}\r\n\r\n// http://officeopenxml.com/SSstyles.php\r\nfunction parseStyles(content, xml) {\r\n  if (!content) {\r\n    return {}\r\n  }\r\n  // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/708978af-b598-45c4-a598-d3518a5a09f0/howwhen-is-cellstylexfs-vs-cellxfs-applied-to-a-cell?forum=os_binaryfile\r\n  // https://www.office-forums.com/threads/cellxfs-cellstylexfs.2163519/\r\n  const doc = xml.createDocument(content)\r\n  const baseStyles = xml.select(doc, null, '//a:styleSheet/a:cellStyleXfs/a:xf', namespaces).map(parseCellStyle);\r\n  const numFmts = xml.select(doc, null, '//a:styleSheet/a:numFmts/a:numFmt', namespaces)\r\n    .map(parseNumberFormatStyle)\r\n    .reduce((formats, format) => {\r\n      formats[format.id] = format\r\n      return formats\r\n    }, [])\r\n\r\n  return xml.select(doc, null, '//a:styleSheet/a:cellXfs/a:xf', namespaces).map((xf) => {\r\n    if (xf.hasAttribute('xfId')) {\r\n      return {\r\n        ...baseStyles[xf.xfId],\r\n        ...parseCellStyle(xf, numFmts)\r\n      }\r\n    }\r\n    return parseCellStyle(xf, numFmts)\r\n  })\r\n}\r\n\r\nfunction parseNumberFormatStyle(numFmt) {\r\n  return {\r\n    id: numFmt.getAttribute('numFmtId'),\r\n    template: numFmt.getAttribute('formatCode')\r\n  }\r\n}\r\n\r\n// http://www.datypic.com/sc/ooxml/e-ssml_xf-2.html\r\nfunction parseCellStyle(xf, numFmts) {\r\n  const style = {}\r\n  if (xf.hasAttribute('numFmtId')) {\r\n    const numberFormatId = xf.getAttribute('numFmtId')\r\n    if (numFmts[numberFormatId]) {\r\n      style.numberFormat = numFmts[numberFormatId]\r\n    } else {\r\n      style.numberFormat = { id: numberFormatId }\r\n    }\r\n  }\r\n  return style\r\n}\r\n\r\n// I guess `xl/workbook.xml` file should always be present inside the *.xlsx archive.\r\nfunction parseProperties(content, xml) {\r\n  const book = xml.createDocument(content)\r\n  // http://webapp.docx4java.org/OnlineDemo/ecma376/SpreadsheetML/workbookPr.html\r\n  const properties = {};\r\n  // https://support.microsoft.com/en-gb/help/214330/differences-between-the-1900-and-the-1904-date-system-in-excel\r\n  const workbookProperties = xml.select(book, null, '//a:workbookPr', namespaces)[0]\r\n  if (workbookProperties && workbookProperties.getAttribute('date1904') === '1') {\r\n    properties.epoch1904 = true\r\n  }\r\n  // Get sheets info (indexes, names, if they're available).\r\n  // Example:\r\n  // <sheets>\r\n  //   <sheet\r\n  //     xmlns:ns=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"\r\n  //     name=\"Sheet1\"\r\n  //     sheetId=\"1\"\r\n  //     ns:id=\"rId3\"/>\r\n  // </sheets>\r\n  // http://www.datypic.com/sc/ooxml/e-ssml_sheet-1.html\r\n  properties.sheets = []\r\n  let i = 0\r\n  for (const sheet of xml.select(book, null, '//a:sheets/a:sheet', namespaces)) {\r\n    if (sheet.getAttribute('name')) {\r\n      properties.sheets.push({\r\n        id: sheet.getAttribute('sheetId'),\r\n        name: sheet.getAttribute('name'),\r\n        relationId: sheet.getAttribute('r:id')\r\n      })\r\n    }\r\n    i++\r\n  }\r\n  return properties;\r\n}\r\n\r\n/**\r\n * Returns sheet file paths.\r\n * Seems that the correct place to look for the\r\n * `sheetId` -> `filename` mapping seems to be in the\r\n * `xl/_rels/workbook.xml.rels` file.\r\n * https://github.com/tidyverse/readxl/issues/104\r\n * @param  {string} content â€” `xl/_rels/workbook.xml.rels` file contents.\r\n * @param  {object} xml\r\n * @return {object}\r\n */\r\nfunction parseFileNames(content, xml) {\r\n  // Example:\r\n  // <Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">\r\n  //   ...\r\n  //   <Relationship\r\n  //     Id=\"rId3\"\r\n  //     Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet\"\r\n  //     Target=\"worksheets/sheet1.xml\"/>\r\n  // </Relationships>\r\n  const document = xml.createDocument(content)\r\n  const fileNames = {\r\n    sheets: {},\r\n    sharedStrings: undefined,\r\n    styles: undefined\r\n  }\r\n  for (const relationship of xml.select(document, null, '/rr:Relationships/rr:Relationship', namespaces)) {\r\n    const filePath = relationship.getAttribute('Target')\r\n    switch (relationship.getAttribute('Type')) {\r\n      case 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles':\r\n        fileNames.styles = filePath\r\n        break\r\n      case 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings':\r\n        fileNames.sharedStrings = filePath\r\n        break\r\n      case 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet':\r\n        fileNames.sheets[relationship.getAttribute('Id')] = filePath\r\n        break\r\n    }\r\n  }\r\n  if (!fileNames.styles) {\r\n    throw new Error('\"styles.xml\" file not found in the *.xlsx file')\r\n  }\r\n  // Seems like \"sharedStrings.xml\" is not required to exist.\r\n  // For example, when the spreadsheet doesn't contain any strings.\r\n  // https://github.com/catamphetamine/read-excel-file/issues/85\r\n  // if (!fileNames.sharedStrings) {\r\n  //   throw new Error('\"sharedStrings.xml\" file not found in the *.xlsx file')\r\n  // }\r\n  return fileNames\r\n}\r\n\r\nfunction isDateTemplate(template) {\r\n  const tokens = template.split(/\\W+/)\r\n  for (const token of tokens) {\r\n    if (['MM', 'DD', 'YY', 'YYYY'].indexOf(token) < 0) {\r\n      return false\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\nfunction createSheetNotFoundError(sheet, sheets) {\r\n  const sheetsList = sheets && sheets.map((sheet, i) => `\"${sheet.name}\" (#${i + 1})`).join(', ')\r\n  return new Error(`Sheet ${typeof sheet === 'number' ? '#' + sheet : '\"' + sheet + '\"'} not found in the *.xlsx file.${sheets ? ' Available sheets: ' + sheetsList + '.' : ''}`)\r\n}"]},"metadata":{},"sourceType":"module"}