{"ast":null,"code":"import { hasOwnProperty, isObject, objectEach, inherit } from \"../../helpers/object.mjs\";\nimport { getCellType } from \"../../cellTypes/registry.mjs\";\n/**\r\n * Expands \"type\" property of the meta object to single values. For example `type: 'numeric'` sets\r\n * \"renderer\", \"editor\", \"validator\" properties to specific functions designed for numeric values.\r\n * If \"type\" is passed as an object that object will be returned, excluding properties that\r\n * already exist in the \"metaObject\" if passed.\r\n *\r\n * @param {object|string} type Type to expand;.\r\n * @param {object|undefined} [metaObject] Source meta object.\r\n * @returns {object|undefined}\r\n */\n\nexport function expandMetaType(type, metaObject) {\n  var validType = typeof type === 'string' ? getCellType(type) : type;\n\n  if (!isObject(validType)) {\n    return;\n  }\n\n  var preventSourceOverwrite = isObject(metaObject);\n  var expandedType = {};\n  objectEach(validType, function (value, property) {\n    if (property !== 'CELL_TYPE' && (!preventSourceOverwrite || preventSourceOverwrite && !hasOwnProperty(metaObject, property))) {\n      expandedType[property] = value;\n    }\n  });\n  return expandedType;\n}\n/**\r\n * Creates new class which extends properties from TableMeta layer class.\r\n *\r\n * @param {TableMeta} TableMeta The TableMeta which the new ColumnMeta is created from.\r\n * @param {string[]} [conflictList] List of the properties which are conflicted with the column meta layer.\r\n *                                  Conflicted properties are overwritten by `undefined` value, to separate them\r\n *                                  from the TableMeta layer.\r\n * @returns {ColumnMeta} Returns constructor ready to initialize with `new` operator.\r\n */\n\nexport function columnFactory(TableMeta) {\n  var conflictList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : []; // Do not use ES6 \"class extends\" syntax here. It seems that the babel produces code\n  // which drastically decreases the performance of the ColumnMeta class creation.\n\n  /**\r\n   * Base \"class\" for column meta.\r\n   */\n\n  function ColumnMeta() {}\n\n  inherit(ColumnMeta, TableMeta); // Clear conflict settings\n\n  for (var i = 0; i < conflictList.length; i++) {\n    ColumnMeta.prototype[conflictList[i]] = void 0;\n  }\n\n  return ColumnMeta;\n}\n/**\r\n * Helper which checks if the provided argument is an unsigned number.\r\n *\r\n * @param {*} value Value to check.\r\n * @returns {boolean}\r\n */\n\nexport function isUnsignedNumber(value) {\n  return Number.isInteger(value) && value >= 0;\n}\n/**\r\n * Function which makes assertion by custom condition. Function throws an error when assertion doesn't meet the spec.\r\n *\r\n * @param {Function} condition Function with custom logic. The condition has to return boolean values.\r\n * @param {string} errorMessage String which describes assertion error.\r\n */\n\nexport function assert(condition, errorMessage) {\n  if (!condition()) {\n    throw new Error(\"Assertion failed: \".concat(errorMessage));\n  }\n}\n/**\r\n * Check if given variable is null or undefined.\r\n *\r\n * @param {*} variable Variable to check.\r\n * @returns {boolean}\r\n */\n\nexport function isNullish(variable) {\n  return variable === null || variable === void 0;\n}","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/dataMap/metaManager/utils.mjs"],"names":["hasOwnProperty","isObject","objectEach","inherit","getCellType","expandMetaType","type","metaObject","validType","preventSourceOverwrite","expandedType","value","property","columnFactory","TableMeta","conflictList","arguments","length","undefined","ColumnMeta","i","prototype","isUnsignedNumber","Number","isInteger","assert","condition","errorMessage","Error","concat","isNullish","variable"],"mappings":"AAEA,SAASA,cAAT,EAAyBC,QAAzB,EAAmCC,UAAnC,EAA+CC,OAA/C,QAA8D,0BAA9D;AACA,SAASC,WAAT,QAA4B,8BAA5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,cAAT,CAAwBC,IAAxB,EAA8BC,UAA9B,EAA0C;AAC/C,MAAIC,SAAS,GAAG,OAAOF,IAAP,KAAgB,QAAhB,GAA2BF,WAAW,CAACE,IAAD,CAAtC,GAA+CA,IAA/D;;AAEA,MAAI,CAACL,QAAQ,CAACO,SAAD,CAAb,EAA0B;AACxB;AACD;;AAED,MAAIC,sBAAsB,GAAGR,QAAQ,CAACM,UAAD,CAArC;AACA,MAAIG,YAAY,GAAG,EAAnB;AACAR,EAAAA,UAAU,CAACM,SAAD,EAAY,UAAUG,KAAV,EAAiBC,QAAjB,EAA2B;AAC/C,QAAIA,QAAQ,KAAK,WAAb,KAA6B,CAACH,sBAAD,IAA2BA,sBAAsB,IAAI,CAACT,cAAc,CAACO,UAAD,EAAaK,QAAb,CAAjG,CAAJ,EAA8H;AAC5HF,MAAAA,YAAY,CAACE,QAAD,CAAZ,GAAyBD,KAAzB;AACD;AACF,GAJS,CAAV;AAKA,SAAOD,YAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASG,aAAT,CAAuBC,SAAvB,EAAkC;AACvC,MAAIC,YAAY,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAvF,CADuC,CAGvC;AACA;;AAEA;AACF;AACA;;AACE,WAASG,UAAT,GAAsB,CAAE;;AAExBhB,EAAAA,OAAO,CAACgB,UAAD,EAAaL,SAAb,CAAP,CAXuC,CAWP;;AAEhC,OAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,YAAY,CAACE,MAAjC,EAAyCG,CAAC,EAA1C,EAA8C;AAC5CD,IAAAA,UAAU,CAACE,SAAX,CAAqBN,YAAY,CAACK,CAAD,CAAjC,IAAwC,KAAK,CAA7C;AACD;;AAED,SAAOD,UAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASG,gBAAT,CAA0BX,KAA1B,EAAiC;AACtC,SAAOY,MAAM,CAACC,SAAP,CAAiBb,KAAjB,KAA2BA,KAAK,IAAI,CAA3C;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASc,MAAT,CAAgBC,SAAhB,EAA2BC,YAA3B,EAAyC;AAC9C,MAAI,CAACD,SAAS,EAAd,EAAkB;AAChB,UAAM,IAAIE,KAAJ,CAAU,qBAAqBC,MAArB,CAA4BF,YAA5B,CAAV,CAAN;AACD;AACF;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASG,SAAT,CAAmBC,QAAnB,EAA6B;AAClC,SAAOA,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAA9C;AACD","sourcesContent":["import \"core-js/modules/es.number.is-integer.js\";\r\nimport \"core-js/modules/es.number.constructor.js\";\r\nimport { hasOwnProperty, isObject, objectEach, inherit } from \"../../helpers/object.mjs\";\r\nimport { getCellType } from \"../../cellTypes/registry.mjs\";\r\n/**\r\n * Expands \"type\" property of the meta object to single values. For example `type: 'numeric'` sets\r\n * \"renderer\", \"editor\", \"validator\" properties to specific functions designed for numeric values.\r\n * If \"type\" is passed as an object that object will be returned, excluding properties that\r\n * already exist in the \"metaObject\" if passed.\r\n *\r\n * @param {object|string} type Type to expand;.\r\n * @param {object|undefined} [metaObject] Source meta object.\r\n * @returns {object|undefined}\r\n */\r\n\r\nexport function expandMetaType(type, metaObject) {\r\n  var validType = typeof type === 'string' ? getCellType(type) : type;\r\n\r\n  if (!isObject(validType)) {\r\n    return;\r\n  }\r\n\r\n  var preventSourceOverwrite = isObject(metaObject);\r\n  var expandedType = {};\r\n  objectEach(validType, function (value, property) {\r\n    if (property !== 'CELL_TYPE' && (!preventSourceOverwrite || preventSourceOverwrite && !hasOwnProperty(metaObject, property))) {\r\n      expandedType[property] = value;\r\n    }\r\n  });\r\n  return expandedType;\r\n}\r\n/**\r\n * Creates new class which extends properties from TableMeta layer class.\r\n *\r\n * @param {TableMeta} TableMeta The TableMeta which the new ColumnMeta is created from.\r\n * @param {string[]} [conflictList] List of the properties which are conflicted with the column meta layer.\r\n *                                  Conflicted properties are overwritten by `undefined` value, to separate them\r\n *                                  from the TableMeta layer.\r\n * @returns {ColumnMeta} Returns constructor ready to initialize with `new` operator.\r\n */\r\n\r\nexport function columnFactory(TableMeta) {\r\n  var conflictList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\r\n\r\n  // Do not use ES6 \"class extends\" syntax here. It seems that the babel produces code\r\n  // which drastically decreases the performance of the ColumnMeta class creation.\r\n\r\n  /**\r\n   * Base \"class\" for column meta.\r\n   */\r\n  function ColumnMeta() {}\r\n\r\n  inherit(ColumnMeta, TableMeta); // Clear conflict settings\r\n\r\n  for (var i = 0; i < conflictList.length; i++) {\r\n    ColumnMeta.prototype[conflictList[i]] = void 0;\r\n  }\r\n\r\n  return ColumnMeta;\r\n}\r\n/**\r\n * Helper which checks if the provided argument is an unsigned number.\r\n *\r\n * @param {*} value Value to check.\r\n * @returns {boolean}\r\n */\r\n\r\nexport function isUnsignedNumber(value) {\r\n  return Number.isInteger(value) && value >= 0;\r\n}\r\n/**\r\n * Function which makes assertion by custom condition. Function throws an error when assertion doesn't meet the spec.\r\n *\r\n * @param {Function} condition Function with custom logic. The condition has to return boolean values.\r\n * @param {string} errorMessage String which describes assertion error.\r\n */\r\n\r\nexport function assert(condition, errorMessage) {\r\n  if (!condition()) {\r\n    throw new Error(\"Assertion failed: \".concat(errorMessage));\r\n  }\r\n}\r\n/**\r\n * Check if given variable is null or undefined.\r\n *\r\n * @param {*} variable Variable to check.\r\n * @returns {boolean}\r\n */\r\n\r\nexport function isNullish(variable) {\r\n  return variable === null || variable === void 0;\r\n}"]},"metadata":{},"sourceType":"module"}