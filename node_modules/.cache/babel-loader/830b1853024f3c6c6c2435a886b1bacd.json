{"ast":null,"code":"import LinkedList from \"../dataStructures/linkedList.mjs\";\n/**\r\n * Refactored implementation of mergeSort (part of javascript-algorithms project) by Github users:\r\n * mgechev, AndriiHeonia and lekkas (part of javascript-algorithms project - all project contributors\r\n * at repository website).\r\n *\r\n * Link to repository: https://github.com/mgechev/javascript-algorithms.\r\n */\n\n/**\r\n * Specifies a function that defines the sort order. The array is sorted according to each\r\n * character's Unicode code point value, according to the string conversion of each element.\r\n *\r\n * @param {*} a The first compared element.\r\n * @param {*} b The second compared element.\r\n * @returns {number}\r\n */\n\nvar defaultCompareFunction = function defaultCompareFunction(a, b) {\n  // sort lexically\n  var firstValue = a.toString();\n  var secondValue = b.toString();\n\n  if (firstValue === secondValue) {\n    return 0;\n  } else if (firstValue < secondValue) {\n    return -1;\n  }\n\n  return 1;\n};\n/**\r\n * Mergesort method which is recursively called for sorting the input array.\r\n *\r\n * @param {Array} array The array which should be sorted.\r\n * @param {Function} compareFunction Compares two items in an array. If compareFunction is not supplied,\r\n * elements are sorted by converting them to strings and comparing strings in Unicode code point order.\r\n * @param {number} startIndex Left side of the subarray.\r\n * @param {number} endIndex Right side of the subarray.\r\n * @returns {Array} Array with sorted subarray.\r\n */\n\n\nexport default function mergeSort(array) {\n  var compareFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultCompareFunction;\n  var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var endIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : array.length; // eslint-disable-line max-len\n\n  if (Math.abs(endIndex - startIndex) <= 1) {\n    return [];\n  }\n\n  var middleIndex = Math.ceil((startIndex + endIndex) / 2);\n  mergeSort(array, compareFunction, startIndex, middleIndex);\n  mergeSort(array, compareFunction, middleIndex, endIndex);\n  return merge(array, compareFunction, startIndex, middleIndex, endIndex);\n}\n/**\r\n * Devides and sort merges two subarrays of given array.\r\n *\r\n * @param {Array} array The array which subarrays should be sorted.\r\n * @param {Function} compareFunction The function with comparision logic.\r\n * @param {number} startIndex The start of the first subarray.\r\n * This subarray is with end middle - 1.\r\n * @param {number} middleIndex The start of the second array.\r\n * @param {number} endIndex End - 1 is the end of the second array.\r\n * @returns {Array} The array with sorted subarray.\r\n */\n\nfunction merge(array, compareFunction, startIndex, middleIndex, endIndex) {\n  var leftElements = new LinkedList();\n  var rightElements = new LinkedList();\n  var leftSize = middleIndex - startIndex;\n  var rightSize = endIndex - middleIndex;\n  var maxSize = Math.max(leftSize, rightSize);\n  var size = endIndex - startIndex;\n\n  for (var _i = 0; _i < maxSize; _i += 1) {\n    if (_i < leftSize) {\n      leftElements.push(array[startIndex + _i]);\n    }\n\n    if (_i < rightSize) {\n      rightElements.push(array[middleIndex + _i]);\n    }\n  }\n\n  var i = 0;\n\n  while (i < size) {\n    if (leftElements.first && rightElements.first) {\n      if (compareFunction(leftElements.first.data, rightElements.first.data) > 0) {\n        array[startIndex + i] = rightElements.shift().data;\n      } else {\n        array[startIndex + i] = leftElements.shift().data;\n      }\n    } else if (leftElements.first) {\n      array[startIndex + i] = leftElements.shift().data;\n    } else {\n      array[startIndex + i] = rightElements.shift().data;\n    }\n\n    i += 1;\n  }\n\n  return array;\n}","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/utils/sortingAlgorithms/mergeSort.mjs"],"names":["LinkedList","defaultCompareFunction","a","b","firstValue","toString","secondValue","mergeSort","array","compareFunction","arguments","length","undefined","startIndex","endIndex","Math","abs","middleIndex","ceil","merge","leftElements","rightElements","leftSize","rightSize","maxSize","max","size","_i","push","i","first","data","shift"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.object.to-string.js\";\r\nimport \"core-js/modules/es.regexp.to-string.js\";\r\nimport LinkedList from \"../dataStructures/linkedList.mjs\";\r\n/**\r\n * Refactored implementation of mergeSort (part of javascript-algorithms project) by Github users:\r\n * mgechev, AndriiHeonia and lekkas (part of javascript-algorithms project - all project contributors\r\n * at repository website).\r\n *\r\n * Link to repository: https://github.com/mgechev/javascript-algorithms.\r\n */\r\n\r\n/**\r\n * Specifies a function that defines the sort order. The array is sorted according to each\r\n * character's Unicode code point value, according to the string conversion of each element.\r\n *\r\n * @param {*} a The first compared element.\r\n * @param {*} b The second compared element.\r\n * @returns {number}\r\n */\r\n\r\nvar defaultCompareFunction = function defaultCompareFunction(a, b) {\r\n  // sort lexically\r\n  var firstValue = a.toString();\r\n  var secondValue = b.toString();\r\n\r\n  if (firstValue === secondValue) {\r\n    return 0;\r\n  } else if (firstValue < secondValue) {\r\n    return -1;\r\n  }\r\n\r\n  return 1;\r\n};\r\n/**\r\n * Mergesort method which is recursively called for sorting the input array.\r\n *\r\n * @param {Array} array The array which should be sorted.\r\n * @param {Function} compareFunction Compares two items in an array. If compareFunction is not supplied,\r\n * elements are sorted by converting them to strings and comparing strings in Unicode code point order.\r\n * @param {number} startIndex Left side of the subarray.\r\n * @param {number} endIndex Right side of the subarray.\r\n * @returns {Array} Array with sorted subarray.\r\n */\r\n\r\n\r\nexport default function mergeSort(array) {\r\n  var compareFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultCompareFunction;\r\n  var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\r\n  var endIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : array.length;\r\n\r\n  // eslint-disable-line max-len\r\n  if (Math.abs(endIndex - startIndex) <= 1) {\r\n    return [];\r\n  }\r\n\r\n  var middleIndex = Math.ceil((startIndex + endIndex) / 2);\r\n  mergeSort(array, compareFunction, startIndex, middleIndex);\r\n  mergeSort(array, compareFunction, middleIndex, endIndex);\r\n  return merge(array, compareFunction, startIndex, middleIndex, endIndex);\r\n}\r\n/**\r\n * Devides and sort merges two subarrays of given array.\r\n *\r\n * @param {Array} array The array which subarrays should be sorted.\r\n * @param {Function} compareFunction The function with comparision logic.\r\n * @param {number} startIndex The start of the first subarray.\r\n * This subarray is with end middle - 1.\r\n * @param {number} middleIndex The start of the second array.\r\n * @param {number} endIndex End - 1 is the end of the second array.\r\n * @returns {Array} The array with sorted subarray.\r\n */\r\n\r\nfunction merge(array, compareFunction, startIndex, middleIndex, endIndex) {\r\n  var leftElements = new LinkedList();\r\n  var rightElements = new LinkedList();\r\n  var leftSize = middleIndex - startIndex;\r\n  var rightSize = endIndex - middleIndex;\r\n  var maxSize = Math.max(leftSize, rightSize);\r\n  var size = endIndex - startIndex;\r\n\r\n  for (var _i = 0; _i < maxSize; _i += 1) {\r\n    if (_i < leftSize) {\r\n      leftElements.push(array[startIndex + _i]);\r\n    }\r\n\r\n    if (_i < rightSize) {\r\n      rightElements.push(array[middleIndex + _i]);\r\n    }\r\n  }\r\n\r\n  var i = 0;\r\n\r\n  while (i < size) {\r\n    if (leftElements.first && rightElements.first) {\r\n      if (compareFunction(leftElements.first.data, rightElements.first.data) > 0) {\r\n        array[startIndex + i] = rightElements.shift().data;\r\n      } else {\r\n        array[startIndex + i] = leftElements.shift().data;\r\n      }\r\n    } else if (leftElements.first) {\r\n      array[startIndex + i] = leftElements.shift().data;\r\n    } else {\r\n      array[startIndex + i] = rightElements.shift().data;\r\n    }\r\n\r\n    i += 1;\r\n  }\r\n\r\n  return array;\r\n}"]},"metadata":{},"sourceType":"module"}