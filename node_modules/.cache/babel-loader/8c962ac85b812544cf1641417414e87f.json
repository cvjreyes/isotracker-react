{"ast":null,"code":"import { isObject } from \"../../helpers/object.mjs\";\nimport { isDefined } from \"../../helpers/mixed.mjs\";\nimport { CellCoords } from \"../../3rdparty/walkontable/src/index.mjs\";\nexport var DIRECTIONS = {\n  horizontal: 'horizontal',\n  vertical: 'vertical'\n};\n/**\r\n * Get deltas array.\r\n *\r\n * @param {CellCoords} start The point in the grid where the selection starts.\r\n * @param {CellCoords} end The point in the grid where the selection ends.\r\n * @param {Array} data The chunk of the data which belongs to the selected box.\r\n * @param {string} direction The selection direction.\r\n * @returns {Array}\r\n */\n\nexport function getDeltas(start, end, data, direction) {\n  var rowsLength = data.length;\n  var columnsLength = data ? data[0].length : 0;\n  var deltas = [];\n  var diffRow = end.row - start.row;\n  var diffCol = end.col - start.col;\n\n  if (['down', 'up'].indexOf(direction) !== -1) {\n    var arr = [];\n\n    for (var col = 0; col < diffCol; col++) {\n      var startValue = parseInt(data[0][col], 10);\n      var endValue = parseInt(data[rowsLength - 1][col], 10);\n      var delta = (direction === 'down' ? endValue - startValue : startValue - endValue) / (rowsLength - 1) || 0;\n      arr.push(delta);\n    }\n\n    deltas.push(arr);\n  }\n\n  if (['right', 'left'].indexOf(direction) !== -1) {\n    for (var row = 0; row < diffRow; row++) {\n      var _startValue = parseInt(data[row][0], 10);\n\n      var _endValue = parseInt(data[row][columnsLength - 1], 10);\n\n      var _delta = (direction === 'right' ? _endValue - _startValue : _startValue - _endValue) / (columnsLength - 1) || 0;\n\n      deltas.push([_delta]);\n    }\n  }\n\n  return deltas;\n}\n/**\r\n * Get direction between positions and cords of selections difference (drag area).\r\n *\r\n * @param {Array} startSelection The coordinates where the selection starts.\r\n * @param {Array} endSelection The coordinates where the selection ends.\r\n * @returns {{direction: string, start: CellCoords, end: CellCoords}}\r\n */\n\nexport function getDragDirectionAndRange(startSelection, endSelection) {\n  var startOfDragCoords;\n  var endOfDragCoords;\n  var directionOfDrag;\n\n  if (endSelection[0] === startSelection[0] && endSelection[1] < startSelection[1]) {\n    directionOfDrag = 'left';\n    startOfDragCoords = new CellCoords(endSelection[0], endSelection[1]);\n    endOfDragCoords = new CellCoords(endSelection[2], startSelection[1] - 1);\n  } else if (endSelection[2] === startSelection[2] && endSelection[0] === startSelection[0] && endSelection[3] > startSelection[3]) {\n    directionOfDrag = 'right';\n    startOfDragCoords = new CellCoords(endSelection[0], startSelection[3] + 1);\n    endOfDragCoords = new CellCoords(endSelection[2], endSelection[3]);\n  } else if (endSelection[0] < startSelection[0] && endSelection[1] === startSelection[1]) {\n    directionOfDrag = 'up';\n    startOfDragCoords = new CellCoords(endSelection[0], endSelection[1]);\n    endOfDragCoords = new CellCoords(startSelection[0] - 1, endSelection[3]);\n  } else if (endSelection[2] > startSelection[2] && endSelection[1] === startSelection[1]) {\n    directionOfDrag = 'down';\n    startOfDragCoords = new CellCoords(startSelection[2] + 1, endSelection[1]);\n    endOfDragCoords = new CellCoords(endSelection[2], endSelection[3]);\n  }\n\n  if (startOfDragCoords) {\n    startOfDragCoords.normalize();\n  }\n\n  if (endOfDragCoords) {\n    endOfDragCoords.normalize();\n  }\n\n  return {\n    directionOfDrag: directionOfDrag,\n    startOfDragCoords: startOfDragCoords,\n    endOfDragCoords: endOfDragCoords\n  };\n}\n/**\r\n * Get mapped FillHandle setting containing information about\r\n * allowed FillHandle directions and if allowed is automatic insertion of rows on drag.\r\n *\r\n * @param {boolean|object} fillHandle Property of Handsontable settings.\r\n * @returns {{directions: Array, autoInsertRow: boolean}} Object allowing access to information\r\n * about FillHandle in more useful way.\r\n */\n\nexport function getMappedFillHandleSetting(fillHandle) {\n  var mappedSettings = {};\n\n  if (fillHandle === true) {\n    mappedSettings.directions = Object.keys(DIRECTIONS);\n    mappedSettings.autoInsertRow = true;\n  } else if (isObject(fillHandle)) {\n    if (isDefined(fillHandle.autoInsertRow)) {\n      // autoInsertRow for horizontal direction will be always false\n      if (fillHandle.direction === DIRECTIONS.horizontal) {\n        mappedSettings.autoInsertRow = false;\n      } else {\n        mappedSettings.autoInsertRow = fillHandle.autoInsertRow;\n      }\n    } else {\n      mappedSettings.autoInsertRow = false;\n    }\n\n    if (isDefined(fillHandle.direction)) {\n      mappedSettings.directions = [fillHandle.direction];\n    } else {\n      mappedSettings.directions = Object.keys(DIRECTIONS);\n    }\n  } else if (typeof fillHandle === 'string') {\n    mappedSettings.directions = [fillHandle];\n    mappedSettings.autoInsertRow = true;\n  } else {\n    mappedSettings.directions = [];\n    mappedSettings.autoInsertRow = false;\n  }\n\n  return mappedSettings;\n}","map":{"version":3,"sources":["C:/Users/ssaez1/technip-repositories/isotracker/isotracker-react/node_modules/handsontable/plugins/autofill/utils.mjs"],"names":["isObject","isDefined","CellCoords","DIRECTIONS","horizontal","vertical","getDeltas","start","end","data","direction","rowsLength","length","columnsLength","deltas","diffRow","row","diffCol","col","indexOf","arr","startValue","parseInt","endValue","delta","push","_startValue","_endValue","_delta","getDragDirectionAndRange","startSelection","endSelection","startOfDragCoords","endOfDragCoords","directionOfDrag","normalize","getMappedFillHandleSetting","fillHandle","mappedSettings","directions","Object","keys","autoInsertRow"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.index-of.js\";\r\nimport \"core-js/modules/es.object.keys.js\";\r\nimport { isObject } from \"../../helpers/object.mjs\";\r\nimport { isDefined } from \"../../helpers/mixed.mjs\";\r\nimport { CellCoords } from \"../../3rdparty/walkontable/src/index.mjs\";\r\nexport var DIRECTIONS = {\r\n  horizontal: 'horizontal',\r\n  vertical: 'vertical'\r\n};\r\n/**\r\n * Get deltas array.\r\n *\r\n * @param {CellCoords} start The point in the grid where the selection starts.\r\n * @param {CellCoords} end The point in the grid where the selection ends.\r\n * @param {Array} data The chunk of the data which belongs to the selected box.\r\n * @param {string} direction The selection direction.\r\n * @returns {Array}\r\n */\r\n\r\nexport function getDeltas(start, end, data, direction) {\r\n  var rowsLength = data.length;\r\n  var columnsLength = data ? data[0].length : 0;\r\n  var deltas = [];\r\n  var diffRow = end.row - start.row;\r\n  var diffCol = end.col - start.col;\r\n\r\n  if (['down', 'up'].indexOf(direction) !== -1) {\r\n    var arr = [];\r\n\r\n    for (var col = 0; col < diffCol; col++) {\r\n      var startValue = parseInt(data[0][col], 10);\r\n      var endValue = parseInt(data[rowsLength - 1][col], 10);\r\n      var delta = (direction === 'down' ? endValue - startValue : startValue - endValue) / (rowsLength - 1) || 0;\r\n      arr.push(delta);\r\n    }\r\n\r\n    deltas.push(arr);\r\n  }\r\n\r\n  if (['right', 'left'].indexOf(direction) !== -1) {\r\n    for (var row = 0; row < diffRow; row++) {\r\n      var _startValue = parseInt(data[row][0], 10);\r\n\r\n      var _endValue = parseInt(data[row][columnsLength - 1], 10);\r\n\r\n      var _delta = (direction === 'right' ? _endValue - _startValue : _startValue - _endValue) / (columnsLength - 1) || 0;\r\n\r\n      deltas.push([_delta]);\r\n    }\r\n  }\r\n\r\n  return deltas;\r\n}\r\n/**\r\n * Get direction between positions and cords of selections difference (drag area).\r\n *\r\n * @param {Array} startSelection The coordinates where the selection starts.\r\n * @param {Array} endSelection The coordinates where the selection ends.\r\n * @returns {{direction: string, start: CellCoords, end: CellCoords}}\r\n */\r\n\r\nexport function getDragDirectionAndRange(startSelection, endSelection) {\r\n  var startOfDragCoords;\r\n  var endOfDragCoords;\r\n  var directionOfDrag;\r\n\r\n  if (endSelection[0] === startSelection[0] && endSelection[1] < startSelection[1]) {\r\n    directionOfDrag = 'left';\r\n    startOfDragCoords = new CellCoords(endSelection[0], endSelection[1]);\r\n    endOfDragCoords = new CellCoords(endSelection[2], startSelection[1] - 1);\r\n  } else if (endSelection[2] === startSelection[2] && endSelection[0] === startSelection[0] && endSelection[3] > startSelection[3]) {\r\n    directionOfDrag = 'right';\r\n    startOfDragCoords = new CellCoords(endSelection[0], startSelection[3] + 1);\r\n    endOfDragCoords = new CellCoords(endSelection[2], endSelection[3]);\r\n  } else if (endSelection[0] < startSelection[0] && endSelection[1] === startSelection[1]) {\r\n    directionOfDrag = 'up';\r\n    startOfDragCoords = new CellCoords(endSelection[0], endSelection[1]);\r\n    endOfDragCoords = new CellCoords(startSelection[0] - 1, endSelection[3]);\r\n  } else if (endSelection[2] > startSelection[2] && endSelection[1] === startSelection[1]) {\r\n    directionOfDrag = 'down';\r\n    startOfDragCoords = new CellCoords(startSelection[2] + 1, endSelection[1]);\r\n    endOfDragCoords = new CellCoords(endSelection[2], endSelection[3]);\r\n  }\r\n\r\n  if (startOfDragCoords) {\r\n    startOfDragCoords.normalize();\r\n  }\r\n\r\n  if (endOfDragCoords) {\r\n    endOfDragCoords.normalize();\r\n  }\r\n\r\n  return {\r\n    directionOfDrag: directionOfDrag,\r\n    startOfDragCoords: startOfDragCoords,\r\n    endOfDragCoords: endOfDragCoords\r\n  };\r\n}\r\n/**\r\n * Get mapped FillHandle setting containing information about\r\n * allowed FillHandle directions and if allowed is automatic insertion of rows on drag.\r\n *\r\n * @param {boolean|object} fillHandle Property of Handsontable settings.\r\n * @returns {{directions: Array, autoInsertRow: boolean}} Object allowing access to information\r\n * about FillHandle in more useful way.\r\n */\r\n\r\nexport function getMappedFillHandleSetting(fillHandle) {\r\n  var mappedSettings = {};\r\n\r\n  if (fillHandle === true) {\r\n    mappedSettings.directions = Object.keys(DIRECTIONS);\r\n    mappedSettings.autoInsertRow = true;\r\n  } else if (isObject(fillHandle)) {\r\n    if (isDefined(fillHandle.autoInsertRow)) {\r\n      // autoInsertRow for horizontal direction will be always false\r\n      if (fillHandle.direction === DIRECTIONS.horizontal) {\r\n        mappedSettings.autoInsertRow = false;\r\n      } else {\r\n        mappedSettings.autoInsertRow = fillHandle.autoInsertRow;\r\n      }\r\n    } else {\r\n      mappedSettings.autoInsertRow = false;\r\n    }\r\n\r\n    if (isDefined(fillHandle.direction)) {\r\n      mappedSettings.directions = [fillHandle.direction];\r\n    } else {\r\n      mappedSettings.directions = Object.keys(DIRECTIONS);\r\n    }\r\n  } else if (typeof fillHandle === 'string') {\r\n    mappedSettings.directions = [fillHandle];\r\n    mappedSettings.autoInsertRow = true;\r\n  } else {\r\n    mappedSettings.directions = [];\r\n    mappedSettings.autoInsertRow = false;\r\n  }\r\n\r\n  return mappedSettings;\r\n}"]},"metadata":{},"sourceType":"module"}