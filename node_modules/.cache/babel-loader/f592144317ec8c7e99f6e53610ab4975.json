{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { getScrollbarWidth, getStyle, offset, outerHeight, outerWidth } from \"./../../../helpers/dom/element.mjs\";\nimport { objectEach } from \"./../../../helpers/object.mjs\";\nimport EventManager from \"./../../../eventManager.mjs\";\nimport { RENDER_TYPE, FULLY_VISIBLE_TYPE, ViewportColumnsCalculator, ViewportRowsCalculator } from \"./calculator/index.mjs\";\n/**\r\n * @class Viewport\r\n */\n\nvar Viewport = /*#__PURE__*/function () {\n  /**\r\n   * @param {Walkontable} wotInstance The Walkontable instance.\r\n   */\n  function Viewport(wotInstance) {\n    var _this = this;\n\n    _classCallCheck(this, Viewport);\n\n    this.wot = wotInstance; // legacy support\n\n    this.instance = this.wot;\n    this.oversizedRows = [];\n    this.oversizedColumnHeaders = [];\n    this.hasOversizedColumnHeadersMarked = {};\n    this.clientHeight = 0;\n    this.containerWidth = NaN;\n    this.rowHeaderWidth = NaN;\n    this.rowsVisibleCalculator = null;\n    this.columnsVisibleCalculator = null;\n    this.eventManager = new EventManager(this.wot);\n    this.eventManager.addEventListener(this.wot.rootWindow, 'resize', function () {\n      _this.clientHeight = _this.getWorkspaceHeight();\n    });\n  }\n  /**\r\n   * @returns {number}\r\n   */\n\n\n  _createClass(Viewport, [{\n    key: \"getWorkspaceHeight\",\n    value: function getWorkspaceHeight() {\n      var currentDocument = this.wot.rootDocument;\n      var trimmingContainer = this.instance.wtOverlays.topOverlay.trimmingContainer;\n      var height = 0;\n\n      if (trimmingContainer === this.wot.rootWindow) {\n        height = currentDocument.documentElement.clientHeight;\n      } else {\n        var elemHeight = outerHeight(trimmingContainer); // returns height without DIV scrollbar\n\n        height = elemHeight > 0 && trimmingContainer.clientHeight > 0 ? trimmingContainer.clientHeight : Infinity;\n      }\n\n      return height;\n    }\n  }, {\n    key: \"getWorkspaceWidth\",\n    value: function getWorkspaceWidth() {\n      var wot = this.wot;\n      var rootDocument = wot.rootDocument,\n          rootWindow = wot.rootWindow;\n      var trimmingContainer = this.instance.wtOverlays.leftOverlay.trimmingContainer;\n      var docOffsetWidth = rootDocument.documentElement.offsetWidth;\n      var totalColumns = wot.getSetting('totalColumns');\n      var preventOverflow = wot.getSetting('preventOverflow');\n      var width;\n      var overflow;\n\n      if (preventOverflow) {\n        return outerWidth(this.instance.wtTable.wtRootElement);\n      }\n\n      if (wot.getSetting('freezeOverlays')) {\n        width = Math.min(docOffsetWidth - this.getWorkspaceOffset().left, docOffsetWidth);\n      } else {\n        width = Math.min(this.getContainerFillWidth(), docOffsetWidth - this.getWorkspaceOffset().left, docOffsetWidth);\n      }\n\n      if (trimmingContainer === rootWindow && totalColumns > 0 && this.sumColumnWidths(0, totalColumns - 1) > width) {\n        // in case sum of column widths is higher than available stylesheet width, let's assume using the whole window\n        // otherwise continue below, which will allow stretching\n        // this is used in `scroll_window.html`\n        // TODO test me\n        return rootDocument.documentElement.clientWidth;\n      }\n\n      if (trimmingContainer !== rootWindow) {\n        overflow = getStyle(this.instance.wtOverlays.leftOverlay.trimmingContainer, 'overflow', rootWindow);\n\n        if (overflow === 'scroll' || overflow === 'hidden' || overflow === 'auto') {\n          // this is used in `scroll.html`\n          // TODO test me\n          return Math.max(width, trimmingContainer.clientWidth);\n        }\n      }\n\n      var stretchSetting = wot.getSetting('stretchH');\n\n      if (stretchSetting === 'none' || !stretchSetting) {\n        // if no stretching is used, return the maximum used workspace width\n        return Math.max(width, outerWidth(this.instance.wtTable.TABLE));\n      } // if stretching is used, return the actual container width, so the columns can fit inside it\n\n\n      return width;\n    }\n    /**\r\n     * Checks if viewport has vertical scroll.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"hasVerticalScroll\",\n    value: function hasVerticalScroll() {\n      return this.getWorkspaceActualHeight() > this.getWorkspaceHeight();\n    }\n    /**\r\n     * Checks if viewport has horizontal scroll.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"hasHorizontalScroll\",\n    value: function hasHorizontalScroll() {\n      return this.getWorkspaceActualWidth() > this.getWorkspaceWidth();\n    }\n    /**\r\n     * @param {number} from The visual column index from the width sum is start calculated.\r\n     * @param {number} length The length of the column to traverse.\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"sumColumnWidths\",\n    value: function sumColumnWidths(from, length) {\n      var wtTable = this.wot.wtTable;\n      var sum = 0;\n      var column = from;\n\n      while (column < length) {\n        sum += wtTable.getColumnWidth(column);\n        column += 1;\n      }\n\n      return sum;\n    }\n    /**\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getContainerFillWidth\",\n    value: function getContainerFillWidth() {\n      if (this.containerWidth) {\n        return this.containerWidth;\n      }\n\n      var mainContainer = this.instance.wtTable.holder;\n      var dummyElement = this.wot.rootDocument.createElement('div');\n      dummyElement.style.width = '100%';\n      dummyElement.style.height = '1px';\n      mainContainer.appendChild(dummyElement);\n      var fillWidth = dummyElement.offsetWidth;\n      this.containerWidth = fillWidth;\n      mainContainer.removeChild(dummyElement);\n      return fillWidth;\n    }\n    /**\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getWorkspaceOffset\",\n    value: function getWorkspaceOffset() {\n      return offset(this.wot.wtTable.TABLE);\n    }\n    /**\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getWorkspaceActualHeight\",\n    value: function getWorkspaceActualHeight() {\n      return outerHeight(this.wot.wtTable.TABLE);\n    }\n    /**\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getWorkspaceActualWidth\",\n    value: function getWorkspaceActualWidth() {\n      var wtTable = this.wot.wtTable;\n      return outerWidth(wtTable.TABLE) || outerWidth(wtTable.TBODY) || outerWidth(wtTable.THEAD); // IE8 reports 0 as <table> offsetWidth;\n    }\n    /**\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getColumnHeaderHeight\",\n    value: function getColumnHeaderHeight() {\n      var columnHeaders = this.instance.getSetting('columnHeaders');\n\n      if (!columnHeaders.length) {\n        this.columnHeaderHeight = 0;\n      } else if (isNaN(this.columnHeaderHeight)) {\n        this.columnHeaderHeight = outerHeight(this.wot.wtTable.THEAD);\n      }\n\n      return this.columnHeaderHeight;\n    }\n    /**\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getViewportHeight\",\n    value: function getViewportHeight() {\n      var containerHeight = this.getWorkspaceHeight();\n\n      if (containerHeight === Infinity) {\n        return containerHeight;\n      }\n\n      var columnHeaderHeight = this.getColumnHeaderHeight();\n\n      if (columnHeaderHeight > 0) {\n        containerHeight -= columnHeaderHeight;\n      }\n\n      return containerHeight;\n    }\n    /**\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getRowHeaderWidth\",\n    value: function getRowHeaderWidth() {\n      var rowHeadersWidthSetting = this.instance.getSetting('rowHeaderWidth');\n      var rowHeaders = this.instance.getSetting('rowHeaders');\n\n      if (rowHeadersWidthSetting) {\n        this.rowHeaderWidth = 0;\n\n        for (var i = 0, len = rowHeaders.length; i < len; i++) {\n          this.rowHeaderWidth += rowHeadersWidthSetting[i] || rowHeadersWidthSetting;\n        }\n      }\n\n      if (this.wot.cloneSource) {\n        return this.wot.cloneSource.wtViewport.getRowHeaderWidth();\n      }\n\n      if (isNaN(this.rowHeaderWidth)) {\n        if (rowHeaders.length) {\n          var TH = this.instance.wtTable.TABLE.querySelector('TH');\n          this.rowHeaderWidth = 0;\n\n          for (var _i = 0, _len = rowHeaders.length; _i < _len; _i++) {\n            if (TH) {\n              this.rowHeaderWidth += outerWidth(TH);\n              TH = TH.nextSibling;\n            } else {\n              // yes this is a cheat but it worked like that before, just taking assumption from CSS instead of measuring.\n              // TODO: proper fix\n              this.rowHeaderWidth += 50;\n            }\n          }\n        } else {\n          this.rowHeaderWidth = 0;\n        }\n      }\n\n      this.rowHeaderWidth = this.instance.getSetting('onModifyRowHeaderWidth', this.rowHeaderWidth) || this.rowHeaderWidth;\n      return this.rowHeaderWidth;\n    }\n    /**\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getViewportWidth\",\n    value: function getViewportWidth() {\n      var containerWidth = this.getWorkspaceWidth();\n\n      if (containerWidth === Infinity) {\n        return containerWidth;\n      }\n\n      var rowHeaderWidth = this.getRowHeaderWidth();\n\n      if (rowHeaderWidth > 0) {\n        return containerWidth - rowHeaderWidth;\n      }\n\n      return containerWidth;\n    }\n    /**\r\n     * Creates:\r\n     * - rowsRenderCalculator (before draw, to qualify rows for rendering)\r\n     * - rowsVisibleCalculator (after draw, to measure which rows are actually visible).\r\n     *\r\n     * @param {number} calculationType The render type ID, which determines for what type of\r\n     *                                 calculation calculator is created.\r\n     * @returns {ViewportRowsCalculator}\r\n     */\n\n  }, {\n    key: \"createRowsCalculator\",\n    value: function createRowsCalculator() {\n      var calculationType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RENDER_TYPE;\n      var wot = this.wot;\n      var wtSettings = wot.wtSettings,\n          wtOverlays = wot.wtOverlays,\n          wtTable = wot.wtTable,\n          rootDocument = wot.rootDocument;\n      var height;\n      var scrollbarHeight;\n      var fixedRowsHeight;\n      this.rowHeaderWidth = NaN;\n\n      if (wtSettings.settings.renderAllRows && calculationType === RENDER_TYPE) {\n        height = Infinity;\n      } else {\n        height = this.getViewportHeight();\n      }\n\n      var pos = wtOverlays.topOverlay.getScrollPosition() - wtOverlays.topOverlay.getTableParentOffset();\n\n      if (pos < 0) {\n        pos = 0;\n      }\n\n      var fixedRowsTop = wot.getSetting('fixedRowsTop');\n      var fixedRowsBottom = wot.getSetting('fixedRowsBottom');\n      var totalRows = wot.getSetting('totalRows');\n\n      if (fixedRowsTop) {\n        fixedRowsHeight = wtOverlays.topOverlay.sumCellSizes(0, fixedRowsTop);\n        pos += fixedRowsHeight;\n        height -= fixedRowsHeight;\n      }\n\n      if (fixedRowsBottom && wtOverlays.bottomOverlay.clone) {\n        fixedRowsHeight = wtOverlays.bottomOverlay.sumCellSizes(totalRows - fixedRowsBottom, totalRows);\n        height -= fixedRowsHeight;\n      }\n\n      if (wtTable.holder.clientHeight === wtTable.holder.offsetHeight) {\n        scrollbarHeight = 0;\n      } else {\n        scrollbarHeight = getScrollbarWidth(rootDocument);\n      }\n\n      return new ViewportRowsCalculator({\n        viewportSize: height,\n        scrollOffset: pos,\n        totalItems: wot.getSetting('totalRows'),\n        itemSizeFn: function itemSizeFn(sourceRow) {\n          return wtTable.getRowHeight(sourceRow);\n        },\n        overrideFn: wtSettings.settings.viewportRowCalculatorOverride,\n        calculationType: calculationType,\n        scrollbarHeight: scrollbarHeight\n      });\n    }\n    /**\r\n     * Creates:\r\n     * - columnsRenderCalculator (before draw, to qualify columns for rendering)\r\n     * - columnsVisibleCalculator (after draw, to measure which columns are actually visible).\r\n     *\r\n     * @param {number} calculationType The render type ID, which determines for what type of\r\n     *                                 calculation calculator is created.\r\n     * @returns {ViewportRowsCalculator}\r\n     */\n\n  }, {\n    key: \"createColumnsCalculator\",\n    value: function createColumnsCalculator() {\n      var calculationType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RENDER_TYPE;\n      var wot = this.wot;\n      var wtSettings = wot.wtSettings,\n          wtOverlays = wot.wtOverlays,\n          wtTable = wot.wtTable,\n          rootDocument = wot.rootDocument;\n      var width = this.getViewportWidth();\n      var pos = wtOverlays.leftOverlay.getScrollPosition() - wtOverlays.leftOverlay.getTableParentOffset();\n      this.columnHeaderHeight = NaN;\n\n      if (pos < 0) {\n        pos = 0;\n      }\n\n      var fixedColumnsLeft = wot.getSetting('fixedColumnsLeft');\n\n      if (fixedColumnsLeft) {\n        var fixedColumnsWidth = wtOverlays.leftOverlay.sumCellSizes(0, fixedColumnsLeft);\n        pos += fixedColumnsWidth;\n        width -= fixedColumnsWidth;\n      }\n\n      if (wtTable.holder.clientWidth !== wtTable.holder.offsetWidth) {\n        width -= getScrollbarWidth(rootDocument);\n      }\n\n      return new ViewportColumnsCalculator({\n        viewportSize: width,\n        scrollOffset: pos,\n        totalItems: wot.getSetting('totalColumns'),\n        itemSizeFn: function itemSizeFn(sourceCol) {\n          return wot.wtTable.getColumnWidth(sourceCol);\n        },\n        overrideFn: wtSettings.settings.viewportColumnCalculatorOverride,\n        calculationType: calculationType,\n        stretchMode: wot.getSetting('stretchH'),\n        stretchingItemWidthFn: function stretchingItemWidthFn(stretchedWidth, column) {\n          return wot.getSetting('onBeforeStretchingColumnWidth', stretchedWidth, column);\n        }\n      });\n    }\n    /**\r\n     * Creates rowsRenderCalculator and columnsRenderCalculator (before draw, to determine what rows and\r\n     * cols should be rendered).\r\n     *\r\n     * @param {boolean} fastDraw If `true`, will try to avoid full redraw and only update the border positions.\r\n     *                           If `false` or `undefined`, will perform a full redraw.\r\n     * @returns {boolean} The fastDraw value, possibly modified.\r\n     */\n\n  }, {\n    key: \"createRenderCalculators\",\n    value: function createRenderCalculators() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var runFastDraw = fastDraw;\n\n      if (runFastDraw) {\n        var proposedRowsVisibleCalculator = this.createRowsCalculator(FULLY_VISIBLE_TYPE);\n        var proposedColumnsVisibleCalculator = this.createColumnsCalculator(FULLY_VISIBLE_TYPE);\n\n        if (!(this.areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) && this.areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator))) {\n          runFastDraw = false;\n        }\n      }\n\n      if (!runFastDraw) {\n        this.rowsRenderCalculator = this.createRowsCalculator(RENDER_TYPE);\n        this.columnsRenderCalculator = this.createColumnsCalculator(RENDER_TYPE);\n      } // delete temporarily to make sure that renderers always use rowsRenderCalculator, not rowsVisibleCalculator\n\n\n      this.rowsVisibleCalculator = null;\n      this.columnsVisibleCalculator = null;\n      return runFastDraw;\n    }\n    /**\r\n     * Creates rowsVisibleCalculator and columnsVisibleCalculator (after draw, to determine what are\r\n     * the actually fully visible rows and columns).\r\n     */\n\n  }, {\n    key: \"createVisibleCalculators\",\n    value: function createVisibleCalculators() {\n      this.rowsVisibleCalculator = this.createRowsCalculator(FULLY_VISIBLE_TYPE);\n      this.columnsVisibleCalculator = this.createColumnsCalculator(FULLY_VISIBLE_TYPE);\n    }\n    /**\r\n     * Returns information whether proposedRowsVisibleCalculator viewport\r\n     * is contained inside rows rendered in previous draw (cached in rowsRenderCalculator).\r\n     *\r\n     * @param {ViewportRowsCalculator} proposedRowsVisibleCalculator The instance of the viewport calculator to compare with.\r\n     * @returns {boolean} Returns `true` if all proposed visible rows are already rendered (meaning: redraw is not needed).\r\n     *                    Returns `false` if at least one proposed visible row is not already rendered (meaning: redraw is needed).\r\n     */\n\n  }, {\n    key: \"areAllProposedVisibleRowsAlreadyRendered\",\n    value: function areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) {\n      if (!this.rowsVisibleCalculator) {\n        return false;\n      }\n\n      var startRow = proposedRowsVisibleCalculator.startRow,\n          endRow = proposedRowsVisibleCalculator.endRow;\n      var _this$rowsRenderCalcu = this.rowsRenderCalculator,\n          renderedStartRow = _this$rowsRenderCalcu.startRow,\n          renderedEndRow = _this$rowsRenderCalcu.endRow;\n\n      if (startRow < renderedStartRow || startRow === renderedStartRow && startRow > 0) {\n        return false;\n      } else if (endRow > renderedEndRow || endRow === renderedEndRow && endRow < this.wot.getSetting('totalRows') - 1) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\r\n     * Returns information whether proposedColumnsVisibleCalculator viewport\r\n     * is contained inside column rendered in previous draw (cached in columnsRenderCalculator).\r\n     *\r\n     * @param {ViewportRowsCalculator} proposedColumnsVisibleCalculator The instance of the viewport calculator to compare with.\r\n     * @returns {boolean} Returns `true` if all proposed visible columns are already rendered (meaning: redraw is not needed).\r\n     *                    Returns `false` if at least one proposed visible column is not already rendered (meaning: redraw is needed).\r\n     */\n\n  }, {\n    key: \"areAllProposedVisibleColumnsAlreadyRendered\",\n    value: function areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator) {\n      if (!this.columnsVisibleCalculator) {\n        return false;\n      }\n\n      var startColumn = proposedColumnsVisibleCalculator.startColumn,\n          endColumn = proposedColumnsVisibleCalculator.endColumn;\n      var _this$columnsRenderCa = this.columnsRenderCalculator,\n          renderedStartColumn = _this$columnsRenderCa.startColumn,\n          renderedEndColumn = _this$columnsRenderCa.endColumn;\n\n      if (startColumn < renderedStartColumn || startColumn === renderedStartColumn && startColumn > 0) {\n        return false;\n      } else if (endColumn > renderedEndColumn || endColumn === renderedEndColumn && endColumn < this.wot.getSetting('totalColumns') - 1) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\r\n     * Resets values in keys of the hasOversizedColumnHeadersMarked object after updateSettings.\r\n     */\n\n  }, {\n    key: \"resetHasOversizedColumnHeadersMarked\",\n    value: function resetHasOversizedColumnHeadersMarked() {\n      objectEach(this.hasOversizedColumnHeadersMarked, function (value, key, object) {\n        object[key] = void 0;\n      });\n    }\n  }]);\n\n  return Viewport;\n}();\n\nexport default Viewport;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/3rdparty/walkontable/src/viewport.mjs"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","getScrollbarWidth","getStyle","offset","outerHeight","outerWidth","objectEach","EventManager","RENDER_TYPE","FULLY_VISIBLE_TYPE","ViewportColumnsCalculator","ViewportRowsCalculator","Viewport","wotInstance","_this","wot","oversizedRows","oversizedColumnHeaders","hasOversizedColumnHeadersMarked","clientHeight","containerWidth","NaN","rowHeaderWidth","rowsVisibleCalculator","columnsVisibleCalculator","eventManager","addEventListener","rootWindow","getWorkspaceHeight","value","currentDocument","rootDocument","trimmingContainer","wtOverlays","topOverlay","height","documentElement","elemHeight","Infinity","getWorkspaceWidth","leftOverlay","docOffsetWidth","offsetWidth","totalColumns","getSetting","preventOverflow","width","overflow","wtTable","wtRootElement","Math","min","getWorkspaceOffset","left","getContainerFillWidth","sumColumnWidths","clientWidth","max","stretchSetting","TABLE","hasVerticalScroll","getWorkspaceActualHeight","hasHorizontalScroll","getWorkspaceActualWidth","from","sum","column","getColumnWidth","mainContainer","holder","dummyElement","createElement","style","appendChild","fillWidth","removeChild","TBODY","THEAD","getColumnHeaderHeight","columnHeaders","columnHeaderHeight","isNaN","getViewportHeight","containerHeight","getRowHeaderWidth","rowHeadersWidthSetting","rowHeaders","len","cloneSource","wtViewport","TH","querySelector","_i","_len","nextSibling","getViewportWidth","createRowsCalculator","calculationType","arguments","undefined","wtSettings","scrollbarHeight","fixedRowsHeight","settings","renderAllRows","pos","getScrollPosition","getTableParentOffset","fixedRowsTop","fixedRowsBottom","totalRows","sumCellSizes","bottomOverlay","clone","offsetHeight","viewportSize","scrollOffset","totalItems","itemSizeFn","sourceRow","getRowHeight","overrideFn","viewportRowCalculatorOverride","createColumnsCalculator","fixedColumnsLeft","fixedColumnsWidth","sourceCol","viewportColumnCalculatorOverride","stretchMode","stretchingItemWidthFn","stretchedWidth","createRenderCalculators","fastDraw","runFastDraw","proposedRowsVisibleCalculator","proposedColumnsVisibleCalculator","areAllProposedVisibleRowsAlreadyRendered","areAllProposedVisibleColumnsAlreadyRendered","rowsRenderCalculator","columnsRenderCalculator","createVisibleCalculators","startRow","endRow","_this$rowsRenderCalcu","renderedStartRow","renderedEndRow","startColumn","endColumn","_this$columnsRenderCa","renderedStartColumn","renderedEndColumn","resetHasOversizedColumnHeadersMarked","object"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport { getScrollbarWidth, getStyle, offset, outerHeight, outerWidth } from \"./../../../helpers/dom/element.mjs\";\r\nimport { objectEach } from \"./../../../helpers/object.mjs\";\r\nimport EventManager from \"./../../../eventManager.mjs\";\r\nimport { RENDER_TYPE, FULLY_VISIBLE_TYPE, ViewportColumnsCalculator, ViewportRowsCalculator } from \"./calculator/index.mjs\";\r\n/**\r\n * @class Viewport\r\n */\r\n\r\nvar Viewport = /*#__PURE__*/function () {\r\n  /**\r\n   * @param {Walkontable} wotInstance The Walkontable instance.\r\n   */\r\n  function Viewport(wotInstance) {\r\n    var _this = this;\r\n\r\n    _classCallCheck(this, Viewport);\r\n\r\n    this.wot = wotInstance; // legacy support\r\n\r\n    this.instance = this.wot;\r\n    this.oversizedRows = [];\r\n    this.oversizedColumnHeaders = [];\r\n    this.hasOversizedColumnHeadersMarked = {};\r\n    this.clientHeight = 0;\r\n    this.containerWidth = NaN;\r\n    this.rowHeaderWidth = NaN;\r\n    this.rowsVisibleCalculator = null;\r\n    this.columnsVisibleCalculator = null;\r\n    this.eventManager = new EventManager(this.wot);\r\n    this.eventManager.addEventListener(this.wot.rootWindow, 'resize', function () {\r\n      _this.clientHeight = _this.getWorkspaceHeight();\r\n    });\r\n  }\r\n  /**\r\n   * @returns {number}\r\n   */\r\n\r\n\r\n  _createClass(Viewport, [{\r\n    key: \"getWorkspaceHeight\",\r\n    value: function getWorkspaceHeight() {\r\n      var currentDocument = this.wot.rootDocument;\r\n      var trimmingContainer = this.instance.wtOverlays.topOverlay.trimmingContainer;\r\n      var height = 0;\r\n\r\n      if (trimmingContainer === this.wot.rootWindow) {\r\n        height = currentDocument.documentElement.clientHeight;\r\n      } else {\r\n        var elemHeight = outerHeight(trimmingContainer); // returns height without DIV scrollbar\r\n\r\n        height = elemHeight > 0 && trimmingContainer.clientHeight > 0 ? trimmingContainer.clientHeight : Infinity;\r\n      }\r\n\r\n      return height;\r\n    }\r\n  }, {\r\n    key: \"getWorkspaceWidth\",\r\n    value: function getWorkspaceWidth() {\r\n      var wot = this.wot;\r\n      var rootDocument = wot.rootDocument,\r\n          rootWindow = wot.rootWindow;\r\n      var trimmingContainer = this.instance.wtOverlays.leftOverlay.trimmingContainer;\r\n      var docOffsetWidth = rootDocument.documentElement.offsetWidth;\r\n      var totalColumns = wot.getSetting('totalColumns');\r\n      var preventOverflow = wot.getSetting('preventOverflow');\r\n      var width;\r\n      var overflow;\r\n\r\n      if (preventOverflow) {\r\n        return outerWidth(this.instance.wtTable.wtRootElement);\r\n      }\r\n\r\n      if (wot.getSetting('freezeOverlays')) {\r\n        width = Math.min(docOffsetWidth - this.getWorkspaceOffset().left, docOffsetWidth);\r\n      } else {\r\n        width = Math.min(this.getContainerFillWidth(), docOffsetWidth - this.getWorkspaceOffset().left, docOffsetWidth);\r\n      }\r\n\r\n      if (trimmingContainer === rootWindow && totalColumns > 0 && this.sumColumnWidths(0, totalColumns - 1) > width) {\r\n        // in case sum of column widths is higher than available stylesheet width, let's assume using the whole window\r\n        // otherwise continue below, which will allow stretching\r\n        // this is used in `scroll_window.html`\r\n        // TODO test me\r\n        return rootDocument.documentElement.clientWidth;\r\n      }\r\n\r\n      if (trimmingContainer !== rootWindow) {\r\n        overflow = getStyle(this.instance.wtOverlays.leftOverlay.trimmingContainer, 'overflow', rootWindow);\r\n\r\n        if (overflow === 'scroll' || overflow === 'hidden' || overflow === 'auto') {\r\n          // this is used in `scroll.html`\r\n          // TODO test me\r\n          return Math.max(width, trimmingContainer.clientWidth);\r\n        }\r\n      }\r\n\r\n      var stretchSetting = wot.getSetting('stretchH');\r\n\r\n      if (stretchSetting === 'none' || !stretchSetting) {\r\n        // if no stretching is used, return the maximum used workspace width\r\n        return Math.max(width, outerWidth(this.instance.wtTable.TABLE));\r\n      } // if stretching is used, return the actual container width, so the columns can fit inside it\r\n\r\n\r\n      return width;\r\n    }\r\n    /**\r\n     * Checks if viewport has vertical scroll.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"hasVerticalScroll\",\r\n    value: function hasVerticalScroll() {\r\n      return this.getWorkspaceActualHeight() > this.getWorkspaceHeight();\r\n    }\r\n    /**\r\n     * Checks if viewport has horizontal scroll.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"hasHorizontalScroll\",\r\n    value: function hasHorizontalScroll() {\r\n      return this.getWorkspaceActualWidth() > this.getWorkspaceWidth();\r\n    }\r\n    /**\r\n     * @param {number} from The visual column index from the width sum is start calculated.\r\n     * @param {number} length The length of the column to traverse.\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"sumColumnWidths\",\r\n    value: function sumColumnWidths(from, length) {\r\n      var wtTable = this.wot.wtTable;\r\n      var sum = 0;\r\n      var column = from;\r\n\r\n      while (column < length) {\r\n        sum += wtTable.getColumnWidth(column);\r\n        column += 1;\r\n      }\r\n\r\n      return sum;\r\n    }\r\n    /**\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getContainerFillWidth\",\r\n    value: function getContainerFillWidth() {\r\n      if (this.containerWidth) {\r\n        return this.containerWidth;\r\n      }\r\n\r\n      var mainContainer = this.instance.wtTable.holder;\r\n      var dummyElement = this.wot.rootDocument.createElement('div');\r\n      dummyElement.style.width = '100%';\r\n      dummyElement.style.height = '1px';\r\n      mainContainer.appendChild(dummyElement);\r\n      var fillWidth = dummyElement.offsetWidth;\r\n      this.containerWidth = fillWidth;\r\n      mainContainer.removeChild(dummyElement);\r\n      return fillWidth;\r\n    }\r\n    /**\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getWorkspaceOffset\",\r\n    value: function getWorkspaceOffset() {\r\n      return offset(this.wot.wtTable.TABLE);\r\n    }\r\n    /**\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getWorkspaceActualHeight\",\r\n    value: function getWorkspaceActualHeight() {\r\n      return outerHeight(this.wot.wtTable.TABLE);\r\n    }\r\n    /**\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getWorkspaceActualWidth\",\r\n    value: function getWorkspaceActualWidth() {\r\n      var wtTable = this.wot.wtTable;\r\n      return outerWidth(wtTable.TABLE) || outerWidth(wtTable.TBODY) || outerWidth(wtTable.THEAD); // IE8 reports 0 as <table> offsetWidth;\r\n    }\r\n    /**\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getColumnHeaderHeight\",\r\n    value: function getColumnHeaderHeight() {\r\n      var columnHeaders = this.instance.getSetting('columnHeaders');\r\n\r\n      if (!columnHeaders.length) {\r\n        this.columnHeaderHeight = 0;\r\n      } else if (isNaN(this.columnHeaderHeight)) {\r\n        this.columnHeaderHeight = outerHeight(this.wot.wtTable.THEAD);\r\n      }\r\n\r\n      return this.columnHeaderHeight;\r\n    }\r\n    /**\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getViewportHeight\",\r\n    value: function getViewportHeight() {\r\n      var containerHeight = this.getWorkspaceHeight();\r\n\r\n      if (containerHeight === Infinity) {\r\n        return containerHeight;\r\n      }\r\n\r\n      var columnHeaderHeight = this.getColumnHeaderHeight();\r\n\r\n      if (columnHeaderHeight > 0) {\r\n        containerHeight -= columnHeaderHeight;\r\n      }\r\n\r\n      return containerHeight;\r\n    }\r\n    /**\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getRowHeaderWidth\",\r\n    value: function getRowHeaderWidth() {\r\n      var rowHeadersWidthSetting = this.instance.getSetting('rowHeaderWidth');\r\n      var rowHeaders = this.instance.getSetting('rowHeaders');\r\n\r\n      if (rowHeadersWidthSetting) {\r\n        this.rowHeaderWidth = 0;\r\n\r\n        for (var i = 0, len = rowHeaders.length; i < len; i++) {\r\n          this.rowHeaderWidth += rowHeadersWidthSetting[i] || rowHeadersWidthSetting;\r\n        }\r\n      }\r\n\r\n      if (this.wot.cloneSource) {\r\n        return this.wot.cloneSource.wtViewport.getRowHeaderWidth();\r\n      }\r\n\r\n      if (isNaN(this.rowHeaderWidth)) {\r\n        if (rowHeaders.length) {\r\n          var TH = this.instance.wtTable.TABLE.querySelector('TH');\r\n          this.rowHeaderWidth = 0;\r\n\r\n          for (var _i = 0, _len = rowHeaders.length; _i < _len; _i++) {\r\n            if (TH) {\r\n              this.rowHeaderWidth += outerWidth(TH);\r\n              TH = TH.nextSibling;\r\n            } else {\r\n              // yes this is a cheat but it worked like that before, just taking assumption from CSS instead of measuring.\r\n              // TODO: proper fix\r\n              this.rowHeaderWidth += 50;\r\n            }\r\n          }\r\n        } else {\r\n          this.rowHeaderWidth = 0;\r\n        }\r\n      }\r\n\r\n      this.rowHeaderWidth = this.instance.getSetting('onModifyRowHeaderWidth', this.rowHeaderWidth) || this.rowHeaderWidth;\r\n      return this.rowHeaderWidth;\r\n    }\r\n    /**\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getViewportWidth\",\r\n    value: function getViewportWidth() {\r\n      var containerWidth = this.getWorkspaceWidth();\r\n\r\n      if (containerWidth === Infinity) {\r\n        return containerWidth;\r\n      }\r\n\r\n      var rowHeaderWidth = this.getRowHeaderWidth();\r\n\r\n      if (rowHeaderWidth > 0) {\r\n        return containerWidth - rowHeaderWidth;\r\n      }\r\n\r\n      return containerWidth;\r\n    }\r\n    /**\r\n     * Creates:\r\n     * - rowsRenderCalculator (before draw, to qualify rows for rendering)\r\n     * - rowsVisibleCalculator (after draw, to measure which rows are actually visible).\r\n     *\r\n     * @param {number} calculationType The render type ID, which determines for what type of\r\n     *                                 calculation calculator is created.\r\n     * @returns {ViewportRowsCalculator}\r\n     */\r\n\r\n  }, {\r\n    key: \"createRowsCalculator\",\r\n    value: function createRowsCalculator() {\r\n      var calculationType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RENDER_TYPE;\r\n      var wot = this.wot;\r\n      var wtSettings = wot.wtSettings,\r\n          wtOverlays = wot.wtOverlays,\r\n          wtTable = wot.wtTable,\r\n          rootDocument = wot.rootDocument;\r\n      var height;\r\n      var scrollbarHeight;\r\n      var fixedRowsHeight;\r\n      this.rowHeaderWidth = NaN;\r\n\r\n      if (wtSettings.settings.renderAllRows && calculationType === RENDER_TYPE) {\r\n        height = Infinity;\r\n      } else {\r\n        height = this.getViewportHeight();\r\n      }\r\n\r\n      var pos = wtOverlays.topOverlay.getScrollPosition() - wtOverlays.topOverlay.getTableParentOffset();\r\n\r\n      if (pos < 0) {\r\n        pos = 0;\r\n      }\r\n\r\n      var fixedRowsTop = wot.getSetting('fixedRowsTop');\r\n      var fixedRowsBottom = wot.getSetting('fixedRowsBottom');\r\n      var totalRows = wot.getSetting('totalRows');\r\n\r\n      if (fixedRowsTop) {\r\n        fixedRowsHeight = wtOverlays.topOverlay.sumCellSizes(0, fixedRowsTop);\r\n        pos += fixedRowsHeight;\r\n        height -= fixedRowsHeight;\r\n      }\r\n\r\n      if (fixedRowsBottom && wtOverlays.bottomOverlay.clone) {\r\n        fixedRowsHeight = wtOverlays.bottomOverlay.sumCellSizes(totalRows - fixedRowsBottom, totalRows);\r\n        height -= fixedRowsHeight;\r\n      }\r\n\r\n      if (wtTable.holder.clientHeight === wtTable.holder.offsetHeight) {\r\n        scrollbarHeight = 0;\r\n      } else {\r\n        scrollbarHeight = getScrollbarWidth(rootDocument);\r\n      }\r\n\r\n      return new ViewportRowsCalculator({\r\n        viewportSize: height,\r\n        scrollOffset: pos,\r\n        totalItems: wot.getSetting('totalRows'),\r\n        itemSizeFn: function itemSizeFn(sourceRow) {\r\n          return wtTable.getRowHeight(sourceRow);\r\n        },\r\n        overrideFn: wtSettings.settings.viewportRowCalculatorOverride,\r\n        calculationType: calculationType,\r\n        scrollbarHeight: scrollbarHeight\r\n      });\r\n    }\r\n    /**\r\n     * Creates:\r\n     * - columnsRenderCalculator (before draw, to qualify columns for rendering)\r\n     * - columnsVisibleCalculator (after draw, to measure which columns are actually visible).\r\n     *\r\n     * @param {number} calculationType The render type ID, which determines for what type of\r\n     *                                 calculation calculator is created.\r\n     * @returns {ViewportRowsCalculator}\r\n     */\r\n\r\n  }, {\r\n    key: \"createColumnsCalculator\",\r\n    value: function createColumnsCalculator() {\r\n      var calculationType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RENDER_TYPE;\r\n      var wot = this.wot;\r\n      var wtSettings = wot.wtSettings,\r\n          wtOverlays = wot.wtOverlays,\r\n          wtTable = wot.wtTable,\r\n          rootDocument = wot.rootDocument;\r\n      var width = this.getViewportWidth();\r\n      var pos = wtOverlays.leftOverlay.getScrollPosition() - wtOverlays.leftOverlay.getTableParentOffset();\r\n      this.columnHeaderHeight = NaN;\r\n\r\n      if (pos < 0) {\r\n        pos = 0;\r\n      }\r\n\r\n      var fixedColumnsLeft = wot.getSetting('fixedColumnsLeft');\r\n\r\n      if (fixedColumnsLeft) {\r\n        var fixedColumnsWidth = wtOverlays.leftOverlay.sumCellSizes(0, fixedColumnsLeft);\r\n        pos += fixedColumnsWidth;\r\n        width -= fixedColumnsWidth;\r\n      }\r\n\r\n      if (wtTable.holder.clientWidth !== wtTable.holder.offsetWidth) {\r\n        width -= getScrollbarWidth(rootDocument);\r\n      }\r\n\r\n      return new ViewportColumnsCalculator({\r\n        viewportSize: width,\r\n        scrollOffset: pos,\r\n        totalItems: wot.getSetting('totalColumns'),\r\n        itemSizeFn: function itemSizeFn(sourceCol) {\r\n          return wot.wtTable.getColumnWidth(sourceCol);\r\n        },\r\n        overrideFn: wtSettings.settings.viewportColumnCalculatorOverride,\r\n        calculationType: calculationType,\r\n        stretchMode: wot.getSetting('stretchH'),\r\n        stretchingItemWidthFn: function stretchingItemWidthFn(stretchedWidth, column) {\r\n          return wot.getSetting('onBeforeStretchingColumnWidth', stretchedWidth, column);\r\n        }\r\n      });\r\n    }\r\n    /**\r\n     * Creates rowsRenderCalculator and columnsRenderCalculator (before draw, to determine what rows and\r\n     * cols should be rendered).\r\n     *\r\n     * @param {boolean} fastDraw If `true`, will try to avoid full redraw and only update the border positions.\r\n     *                           If `false` or `undefined`, will perform a full redraw.\r\n     * @returns {boolean} The fastDraw value, possibly modified.\r\n     */\r\n\r\n  }, {\r\n    key: \"createRenderCalculators\",\r\n    value: function createRenderCalculators() {\r\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\r\n      var runFastDraw = fastDraw;\r\n\r\n      if (runFastDraw) {\r\n        var proposedRowsVisibleCalculator = this.createRowsCalculator(FULLY_VISIBLE_TYPE);\r\n        var proposedColumnsVisibleCalculator = this.createColumnsCalculator(FULLY_VISIBLE_TYPE);\r\n\r\n        if (!(this.areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) && this.areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator))) {\r\n          runFastDraw = false;\r\n        }\r\n      }\r\n\r\n      if (!runFastDraw) {\r\n        this.rowsRenderCalculator = this.createRowsCalculator(RENDER_TYPE);\r\n        this.columnsRenderCalculator = this.createColumnsCalculator(RENDER_TYPE);\r\n      } // delete temporarily to make sure that renderers always use rowsRenderCalculator, not rowsVisibleCalculator\r\n\r\n\r\n      this.rowsVisibleCalculator = null;\r\n      this.columnsVisibleCalculator = null;\r\n      return runFastDraw;\r\n    }\r\n    /**\r\n     * Creates rowsVisibleCalculator and columnsVisibleCalculator (after draw, to determine what are\r\n     * the actually fully visible rows and columns).\r\n     */\r\n\r\n  }, {\r\n    key: \"createVisibleCalculators\",\r\n    value: function createVisibleCalculators() {\r\n      this.rowsVisibleCalculator = this.createRowsCalculator(FULLY_VISIBLE_TYPE);\r\n      this.columnsVisibleCalculator = this.createColumnsCalculator(FULLY_VISIBLE_TYPE);\r\n    }\r\n    /**\r\n     * Returns information whether proposedRowsVisibleCalculator viewport\r\n     * is contained inside rows rendered in previous draw (cached in rowsRenderCalculator).\r\n     *\r\n     * @param {ViewportRowsCalculator} proposedRowsVisibleCalculator The instance of the viewport calculator to compare with.\r\n     * @returns {boolean} Returns `true` if all proposed visible rows are already rendered (meaning: redraw is not needed).\r\n     *                    Returns `false` if at least one proposed visible row is not already rendered (meaning: redraw is needed).\r\n     */\r\n\r\n  }, {\r\n    key: \"areAllProposedVisibleRowsAlreadyRendered\",\r\n    value: function areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) {\r\n      if (!this.rowsVisibleCalculator) {\r\n        return false;\r\n      }\r\n\r\n      var startRow = proposedRowsVisibleCalculator.startRow,\r\n          endRow = proposedRowsVisibleCalculator.endRow;\r\n      var _this$rowsRenderCalcu = this.rowsRenderCalculator,\r\n          renderedStartRow = _this$rowsRenderCalcu.startRow,\r\n          renderedEndRow = _this$rowsRenderCalcu.endRow;\r\n\r\n      if (startRow < renderedStartRow || startRow === renderedStartRow && startRow > 0) {\r\n        return false;\r\n      } else if (endRow > renderedEndRow || endRow === renderedEndRow && endRow < this.wot.getSetting('totalRows') - 1) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    }\r\n    /**\r\n     * Returns information whether proposedColumnsVisibleCalculator viewport\r\n     * is contained inside column rendered in previous draw (cached in columnsRenderCalculator).\r\n     *\r\n     * @param {ViewportRowsCalculator} proposedColumnsVisibleCalculator The instance of the viewport calculator to compare with.\r\n     * @returns {boolean} Returns `true` if all proposed visible columns are already rendered (meaning: redraw is not needed).\r\n     *                    Returns `false` if at least one proposed visible column is not already rendered (meaning: redraw is needed).\r\n     */\r\n\r\n  }, {\r\n    key: \"areAllProposedVisibleColumnsAlreadyRendered\",\r\n    value: function areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator) {\r\n      if (!this.columnsVisibleCalculator) {\r\n        return false;\r\n      }\r\n\r\n      var startColumn = proposedColumnsVisibleCalculator.startColumn,\r\n          endColumn = proposedColumnsVisibleCalculator.endColumn;\r\n      var _this$columnsRenderCa = this.columnsRenderCalculator,\r\n          renderedStartColumn = _this$columnsRenderCa.startColumn,\r\n          renderedEndColumn = _this$columnsRenderCa.endColumn;\r\n\r\n      if (startColumn < renderedStartColumn || startColumn === renderedStartColumn && startColumn > 0) {\r\n        return false;\r\n      } else if (endColumn > renderedEndColumn || endColumn === renderedEndColumn && endColumn < this.wot.getSetting('totalColumns') - 1) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    }\r\n    /**\r\n     * Resets values in keys of the hasOversizedColumnHeadersMarked object after updateSettings.\r\n     */\r\n\r\n  }, {\r\n    key: \"resetHasOversizedColumnHeadersMarked\",\r\n    value: function resetHasOversizedColumnHeadersMarked() {\r\n      objectEach(this.hasOversizedColumnHeadersMarked, function (value, key, object) {\r\n        object[key] = void 0;\r\n      });\r\n    }\r\n  }]);\r\n\r\n  return Viewport;\r\n}();\r\n\r\nexport default Viewport;"]},"metadata":{},"sourceType":"module"}