{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { getScrollableElement, getTrimmingContainer } from \"./../../../../helpers/dom/element.mjs\";\nimport { defineGetter } from \"./../../../../helpers/object.mjs\";\nimport { arrayEach } from \"./../../../../helpers/array.mjs\";\nimport { warn } from \"./../../../../helpers/console.mjs\";\nimport EventManager from \"./../../../../eventManager.mjs\";\nimport { CLONE_TYPES, CLONE_TOP, CLONE_LEFT } from \"./constants.mjs\";\n/**\r\n * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable\r\n * and (optionally) implements behavior needed for native horizontal and vertical scrolling.\r\n *\r\n * @class Overlay\r\n */\n\nexport var Overlay = /*#__PURE__*/function () {\n  /**\r\n   * @param {Walkontable} wotInstance The Walkontable instance.\r\n   */\n  function Overlay(wotInstance) {\n    _classCallCheck(this, Overlay);\n\n    defineGetter(this, 'wot', wotInstance, {\n      writable: false\n    });\n    var _this$wot$wtTable = this.wot.wtTable,\n        TABLE = _this$wot$wtTable.TABLE,\n        hider = _this$wot$wtTable.hider,\n        spreader = _this$wot$wtTable.spreader,\n        holder = _this$wot$wtTable.holder,\n        wtRootElement = _this$wot$wtTable.wtRootElement; // legacy support, deprecated in the future\n\n    this.instance = this.wot;\n    this.type = '';\n    this.mainTableScrollableElement = null;\n    this.TABLE = TABLE;\n    this.hider = hider;\n    this.spreader = spreader;\n    this.holder = holder;\n    this.wtRootElement = wtRootElement;\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    this.updateStateOfRendering();\n  }\n  /**\r\n   * Update internal state of object with an information about the need of full rendering of the overlay.\r\n   *\r\n   * @returns {boolean} Returns `true` if the state has changed since the last check.\r\n   */\n\n\n  _createClass(Overlay, [{\n    key: \"updateStateOfRendering\",\n    value: function updateStateOfRendering() {\n      var previousState = this.needFullRender;\n      this.needFullRender = this.shouldBeRendered();\n      var changed = previousState !== this.needFullRender;\n\n      if (changed && !this.needFullRender) {\n        this.reset();\n      }\n\n      return changed;\n    }\n    /**\r\n     * Checks if overlay should be fully rendered.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"shouldBeRendered\",\n    value: function shouldBeRendered() {\n      return true;\n    }\n    /**\r\n     * Update the trimming container.\r\n     */\n\n  }, {\n    key: \"updateTrimmingContainer\",\n    value: function updateTrimmingContainer() {\n      this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    }\n    /**\r\n     * Update the main scrollable element.\r\n     */\n\n  }, {\n    key: \"updateMainScrollableElement\",\n    value: function updateMainScrollableElement() {\n      var _this$wot = this.wot,\n          wtTable = _this$wot.wtTable,\n          rootWindow = _this$wot.rootWindow;\n\n      if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = this.wot.wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n      }\n    }\n    /**\r\n     * Calculates coordinates of the provided element, relative to the root Handsontable element.\r\n     * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.\r\n     *\r\n     * @param {HTMLElement} element The cell element to calculate the position for.\r\n     * @param {number} rowIndex Visual row index.\r\n     * @param {number} columnIndex Visual column index.\r\n     * @returns {{top: number, left: number}|undefined}\r\n     */\n\n  }, {\n    key: \"getRelativeCellPosition\",\n    value: function getRelativeCellPosition(element, rowIndex, columnIndex) {\n      if (this.clone.wtTable.holder.contains(element) === false) {\n        warn(\"The provided element is not a child of the \".concat(this.type, \" overlay\"));\n        return;\n      }\n\n      var windowScroll = this.mainTableScrollableElement === this.wot.rootWindow;\n      var fixedColumn = columnIndex < this.wot.getSetting('fixedColumnsLeft');\n      var fixedRowTop = rowIndex < this.wot.getSetting('fixedRowsTop');\n      var fixedRowBottom = rowIndex >= this.wot.getSetting('totalRows') - this.wot.getSetting('fixedRowsBottom');\n      var spreaderOffset = {\n        left: this.clone.wtTable.spreader.offsetLeft,\n        top: this.clone.wtTable.spreader.offsetTop\n      };\n      var elementOffset = {\n        left: element.offsetLeft,\n        top: element.offsetTop\n      };\n      var offsetObject = null;\n\n      if (windowScroll) {\n        offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumn, elementOffset, spreaderOffset);\n      } else {\n        offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumn, elementOffset, spreaderOffset);\n      }\n\n      return offsetObject;\n    }\n    /**\r\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\r\n     * as a scrollable element.\r\n     *\r\n     * @private\r\n     * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\r\n     * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\r\n     * @param {number} elementOffset Offset position of the cell element.\r\n     * @param {number} spreaderOffset Offset position of the spreader element.\r\n     * @returns {{top: number, left: number}}\r\n     */\n\n  }, {\n    key: \"getRelativeCellPositionWithinWindow\",\n    value: function getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {\n      var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n\n      if (!onFixedColumn) {\n        horizontalOffset = spreaderOffset.left;\n      } else {\n        horizontalOffset = absoluteRootElementPosition.left <= 0 ? -1 * absoluteRootElementPosition.left : 0;\n      }\n\n      if (onFixedRowTop) {\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;\n      } else {\n        verticalOffset = spreaderOffset.top;\n      }\n\n      return {\n        left: elementOffset.left + horizontalOffset,\n        top: elementOffset.top + verticalOffset\n      };\n    }\n    /**\r\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\r\n     * as a scrollable element.\r\n     *\r\n     * @private\r\n     * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\r\n     * @param {boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.\r\n     * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\r\n     * @param {number} elementOffset Offset position of the cell element.\r\n     * @param {number} spreaderOffset Offset position of the spreader element.\r\n     * @returns {{top: number, left: number}}\r\n     */\n\n  }, {\n    key: \"getRelativeCellPositionWithinHolder\",\n    value: function getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {\n      var tableScrollPosition = {\n        horizontal: this.clone.cloneSource.wtOverlays.leftOverlay.getScrollPosition(),\n        vertical: this.clone.cloneSource.wtOverlays.topOverlay.getScrollPosition()\n      };\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n\n      if (!onFixedColumn) {\n        horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.left;\n      }\n\n      if (onFixedRowBottom) {\n        var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;\n      } else if (!onFixedRowTop) {\n        verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;\n      }\n\n      return {\n        left: elementOffset.left - horizontalOffset,\n        top: elementOffset.top - verticalOffset\n      };\n    }\n    /**\r\n     * Make a clone of table for overlay.\r\n     *\r\n     * @param {string} direction Can be `Overlay.CLONE_TOP`, `Overlay.CLONE_LEFT`,\r\n     *                           `Overlay.CLONE_TOP_LEFT_CORNER`.\r\n     * @returns {Walkontable}\r\n     */\n\n  }, {\n    key: \"makeClone\",\n    value: function makeClone(direction) {\n      if (CLONE_TYPES.indexOf(direction) === -1) {\n        throw new Error(\"Clone type \\\"\".concat(direction, \"\\\" is not supported.\"));\n      }\n\n      var _this$wot2 = this.wot,\n          wtTable = _this$wot2.wtTable,\n          rootDocument = _this$wot2.rootDocument,\n          rootWindow = _this$wot2.rootWindow;\n      var clone = rootDocument.createElement('DIV');\n      var clonedTable = rootDocument.createElement('TABLE');\n      var tableParent = wtTable.wtRootElement.parentNode;\n      clone.className = \"ht_clone_\".concat(direction, \" handsontable\");\n      clone.style.position = 'absolute';\n      clone.style.top = 0;\n      clone.style.left = 0;\n      clone.style.overflow = 'visible';\n      clonedTable.className = wtTable.TABLE.className;\n      clone.appendChild(clonedTable);\n      this.type = direction;\n      tableParent.appendChild(clone);\n      var preventOverflow = this.wot.getSetting('preventOverflow');\n\n      if (preventOverflow === true || preventOverflow === 'horizontal' && this.type === CLONE_TOP || preventOverflow === 'vertical' && this.type === CLONE_LEFT) {\n        this.mainTableScrollableElement = rootWindow;\n      } else if (rootWindow.getComputedStyle(tableParent).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n      } // Create a new instance of the Walkontable class\n\n\n      return new this.wot.constructor({\n        cloneSource: this.wot,\n        cloneOverlay: this,\n        table: clonedTable\n      });\n    }\n    /**\r\n     * Refresh/Redraw overlay.\r\n     *\r\n     * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\r\n     *                                   the data. It will only work if Table.draw() does not force\r\n     *                                   rendering anyway.\r\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; // When hot settings are changed we allow to refresh overlay once before blocking\n\n      var nextCycleRenderFlag = this.shouldBeRendered();\n\n      if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {\n        this.clone.draw(fastDraw);\n      }\n\n      this.needFullRender = nextCycleRenderFlag;\n    }\n    /**\r\n     * Reset overlay styles to initial values.\r\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (!this.clone) {\n        return;\n      }\n\n      var holder = this.clone.wtTable.holder;\n      var hider = this.clone.wtTable.hider;\n      var holderStyle = holder.style;\n      var hidderStyle = hider.style;\n      var rootStyle = holder.parentNode.style;\n      arrayEach([holderStyle, hidderStyle, rootStyle], function (style) {\n        style.width = '';\n        style.height = '';\n      });\n    }\n    /**\r\n     * Destroy overlay instance.\r\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      new EventManager(this.clone).destroy();\n    }\n  }]);\n\n  return Overlay;\n}();","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/3rdparty/walkontable/src/overlay/_base.mjs"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","getScrollableElement","getTrimmingContainer","defineGetter","arrayEach","warn","EventManager","CLONE_TYPES","CLONE_TOP","CLONE_LEFT","Overlay","wotInstance","_this$wot$wtTable","wot","wtTable","TABLE","hider","spreader","holder","wtRootElement","type","mainTableScrollableElement","trimmingContainer","parentNode","updateStateOfRendering","value","previousState","needFullRender","shouldBeRendered","changed","reset","updateTrimmingContainer","updateMainScrollableElement","_this$wot","rootWindow","getComputedStyle","getPropertyValue","getRelativeCellPosition","element","rowIndex","columnIndex","clone","contains","concat","windowScroll","fixedColumn","getSetting","fixedRowTop","fixedRowBottom","spreaderOffset","left","offsetLeft","top","offsetTop","elementOffset","offsetObject","getRelativeCellPositionWithinWindow","getRelativeCellPositionWithinHolder","onFixedRowTop","onFixedColumn","absoluteRootElementPosition","getBoundingClientRect","horizontalOffset","verticalOffset","absoluteOverlayPosition","onFixedRowBottom","tableScrollPosition","horizontal","cloneSource","wtOverlays","leftOverlay","getScrollPosition","vertical","topOverlay","makeClone","direction","indexOf","Error","_this$wot2","rootDocument","createElement","clonedTable","tableParent","className","style","position","overflow","appendChild","preventOverflow","constructor","cloneOverlay","table","refresh","fastDraw","arguments","undefined","nextCycleRenderFlag","draw","holderStyle","hidderStyle","rootStyle","width","height","destroy"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.index-of.js\";\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport { getScrollableElement, getTrimmingContainer } from \"./../../../../helpers/dom/element.mjs\";\r\nimport { defineGetter } from \"./../../../../helpers/object.mjs\";\r\nimport { arrayEach } from \"./../../../../helpers/array.mjs\";\r\nimport { warn } from \"./../../../../helpers/console.mjs\";\r\nimport EventManager from \"./../../../../eventManager.mjs\";\r\nimport { CLONE_TYPES, CLONE_TOP, CLONE_LEFT } from \"./constants.mjs\";\r\n/**\r\n * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable\r\n * and (optionally) implements behavior needed for native horizontal and vertical scrolling.\r\n *\r\n * @class Overlay\r\n */\r\n\r\nexport var Overlay = /*#__PURE__*/function () {\r\n  /**\r\n   * @param {Walkontable} wotInstance The Walkontable instance.\r\n   */\r\n  function Overlay(wotInstance) {\r\n    _classCallCheck(this, Overlay);\r\n\r\n    defineGetter(this, 'wot', wotInstance, {\r\n      writable: false\r\n    });\r\n    var _this$wot$wtTable = this.wot.wtTable,\r\n        TABLE = _this$wot$wtTable.TABLE,\r\n        hider = _this$wot$wtTable.hider,\r\n        spreader = _this$wot$wtTable.spreader,\r\n        holder = _this$wot$wtTable.holder,\r\n        wtRootElement = _this$wot$wtTable.wtRootElement; // legacy support, deprecated in the future\r\n\r\n    this.instance = this.wot;\r\n    this.type = '';\r\n    this.mainTableScrollableElement = null;\r\n    this.TABLE = TABLE;\r\n    this.hider = hider;\r\n    this.spreader = spreader;\r\n    this.holder = holder;\r\n    this.wtRootElement = wtRootElement;\r\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\r\n    this.updateStateOfRendering();\r\n  }\r\n  /**\r\n   * Update internal state of object with an information about the need of full rendering of the overlay.\r\n   *\r\n   * @returns {boolean} Returns `true` if the state has changed since the last check.\r\n   */\r\n\r\n\r\n  _createClass(Overlay, [{\r\n    key: \"updateStateOfRendering\",\r\n    value: function updateStateOfRendering() {\r\n      var previousState = this.needFullRender;\r\n      this.needFullRender = this.shouldBeRendered();\r\n      var changed = previousState !== this.needFullRender;\r\n\r\n      if (changed && !this.needFullRender) {\r\n        this.reset();\r\n      }\r\n\r\n      return changed;\r\n    }\r\n    /**\r\n     * Checks if overlay should be fully rendered.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"shouldBeRendered\",\r\n    value: function shouldBeRendered() {\r\n      return true;\r\n    }\r\n    /**\r\n     * Update the trimming container.\r\n     */\r\n\r\n  }, {\r\n    key: \"updateTrimmingContainer\",\r\n    value: function updateTrimmingContainer() {\r\n      this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\r\n    }\r\n    /**\r\n     * Update the main scrollable element.\r\n     */\r\n\r\n  }, {\r\n    key: \"updateMainScrollableElement\",\r\n    value: function updateMainScrollableElement() {\r\n      var _this$wot = this.wot,\r\n          wtTable = _this$wot.wtTable,\r\n          rootWindow = _this$wot.rootWindow;\r\n\r\n      if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\r\n        this.mainTableScrollableElement = this.wot.wtTable.holder;\r\n      } else {\r\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\r\n      }\r\n    }\r\n    /**\r\n     * Calculates coordinates of the provided element, relative to the root Handsontable element.\r\n     * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.\r\n     *\r\n     * @param {HTMLElement} element The cell element to calculate the position for.\r\n     * @param {number} rowIndex Visual row index.\r\n     * @param {number} columnIndex Visual column index.\r\n     * @returns {{top: number, left: number}|undefined}\r\n     */\r\n\r\n  }, {\r\n    key: \"getRelativeCellPosition\",\r\n    value: function getRelativeCellPosition(element, rowIndex, columnIndex) {\r\n      if (this.clone.wtTable.holder.contains(element) === false) {\r\n        warn(\"The provided element is not a child of the \".concat(this.type, \" overlay\"));\r\n        return;\r\n      }\r\n\r\n      var windowScroll = this.mainTableScrollableElement === this.wot.rootWindow;\r\n      var fixedColumn = columnIndex < this.wot.getSetting('fixedColumnsLeft');\r\n      var fixedRowTop = rowIndex < this.wot.getSetting('fixedRowsTop');\r\n      var fixedRowBottom = rowIndex >= this.wot.getSetting('totalRows') - this.wot.getSetting('fixedRowsBottom');\r\n      var spreaderOffset = {\r\n        left: this.clone.wtTable.spreader.offsetLeft,\r\n        top: this.clone.wtTable.spreader.offsetTop\r\n      };\r\n      var elementOffset = {\r\n        left: element.offsetLeft,\r\n        top: element.offsetTop\r\n      };\r\n      var offsetObject = null;\r\n\r\n      if (windowScroll) {\r\n        offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumn, elementOffset, spreaderOffset);\r\n      } else {\r\n        offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumn, elementOffset, spreaderOffset);\r\n      }\r\n\r\n      return offsetObject;\r\n    }\r\n    /**\r\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\r\n     * as a scrollable element.\r\n     *\r\n     * @private\r\n     * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\r\n     * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\r\n     * @param {number} elementOffset Offset position of the cell element.\r\n     * @param {number} spreaderOffset Offset position of the spreader element.\r\n     * @returns {{top: number, left: number}}\r\n     */\r\n\r\n  }, {\r\n    key: \"getRelativeCellPositionWithinWindow\",\r\n    value: function getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {\r\n      var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();\r\n      var horizontalOffset = 0;\r\n      var verticalOffset = 0;\r\n\r\n      if (!onFixedColumn) {\r\n        horizontalOffset = spreaderOffset.left;\r\n      } else {\r\n        horizontalOffset = absoluteRootElementPosition.left <= 0 ? -1 * absoluteRootElementPosition.left : 0;\r\n      }\r\n\r\n      if (onFixedRowTop) {\r\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\r\n        verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;\r\n      } else {\r\n        verticalOffset = spreaderOffset.top;\r\n      }\r\n\r\n      return {\r\n        left: elementOffset.left + horizontalOffset,\r\n        top: elementOffset.top + verticalOffset\r\n      };\r\n    }\r\n    /**\r\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\r\n     * as a scrollable element.\r\n     *\r\n     * @private\r\n     * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\r\n     * @param {boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.\r\n     * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\r\n     * @param {number} elementOffset Offset position of the cell element.\r\n     * @param {number} spreaderOffset Offset position of the spreader element.\r\n     * @returns {{top: number, left: number}}\r\n     */\r\n\r\n  }, {\r\n    key: \"getRelativeCellPositionWithinHolder\",\r\n    value: function getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {\r\n      var tableScrollPosition = {\r\n        horizontal: this.clone.cloneSource.wtOverlays.leftOverlay.getScrollPosition(),\r\n        vertical: this.clone.cloneSource.wtOverlays.topOverlay.getScrollPosition()\r\n      };\r\n      var horizontalOffset = 0;\r\n      var verticalOffset = 0;\r\n\r\n      if (!onFixedColumn) {\r\n        horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.left;\r\n      }\r\n\r\n      if (onFixedRowBottom) {\r\n        var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();\r\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\r\n        verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;\r\n      } else if (!onFixedRowTop) {\r\n        verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;\r\n      }\r\n\r\n      return {\r\n        left: elementOffset.left - horizontalOffset,\r\n        top: elementOffset.top - verticalOffset\r\n      };\r\n    }\r\n    /**\r\n     * Make a clone of table for overlay.\r\n     *\r\n     * @param {string} direction Can be `Overlay.CLONE_TOP`, `Overlay.CLONE_LEFT`,\r\n     *                           `Overlay.CLONE_TOP_LEFT_CORNER`.\r\n     * @returns {Walkontable}\r\n     */\r\n\r\n  }, {\r\n    key: \"makeClone\",\r\n    value: function makeClone(direction) {\r\n      if (CLONE_TYPES.indexOf(direction) === -1) {\r\n        throw new Error(\"Clone type \\\"\".concat(direction, \"\\\" is not supported.\"));\r\n      }\r\n\r\n      var _this$wot2 = this.wot,\r\n          wtTable = _this$wot2.wtTable,\r\n          rootDocument = _this$wot2.rootDocument,\r\n          rootWindow = _this$wot2.rootWindow;\r\n      var clone = rootDocument.createElement('DIV');\r\n      var clonedTable = rootDocument.createElement('TABLE');\r\n      var tableParent = wtTable.wtRootElement.parentNode;\r\n      clone.className = \"ht_clone_\".concat(direction, \" handsontable\");\r\n      clone.style.position = 'absolute';\r\n      clone.style.top = 0;\r\n      clone.style.left = 0;\r\n      clone.style.overflow = 'visible';\r\n      clonedTable.className = wtTable.TABLE.className;\r\n      clone.appendChild(clonedTable);\r\n      this.type = direction;\r\n      tableParent.appendChild(clone);\r\n      var preventOverflow = this.wot.getSetting('preventOverflow');\r\n\r\n      if (preventOverflow === true || preventOverflow === 'horizontal' && this.type === CLONE_TOP || preventOverflow === 'vertical' && this.type === CLONE_LEFT) {\r\n        this.mainTableScrollableElement = rootWindow;\r\n      } else if (rootWindow.getComputedStyle(tableParent).getPropertyValue('overflow') === 'hidden') {\r\n        this.mainTableScrollableElement = wtTable.holder;\r\n      } else {\r\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\r\n      } // Create a new instance of the Walkontable class\r\n\r\n\r\n      return new this.wot.constructor({\r\n        cloneSource: this.wot,\r\n        cloneOverlay: this,\r\n        table: clonedTable\r\n      });\r\n    }\r\n    /**\r\n     * Refresh/Redraw overlay.\r\n     *\r\n     * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\r\n     *                                   the data. It will only work if Table.draw() does not force\r\n     *                                   rendering anyway.\r\n     */\r\n\r\n  }, {\r\n    key: \"refresh\",\r\n    value: function refresh() {\r\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\r\n      // When hot settings are changed we allow to refresh overlay once before blocking\r\n      var nextCycleRenderFlag = this.shouldBeRendered();\r\n\r\n      if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {\r\n        this.clone.draw(fastDraw);\r\n      }\r\n\r\n      this.needFullRender = nextCycleRenderFlag;\r\n    }\r\n    /**\r\n     * Reset overlay styles to initial values.\r\n     */\r\n\r\n  }, {\r\n    key: \"reset\",\r\n    value: function reset() {\r\n      if (!this.clone) {\r\n        return;\r\n      }\r\n\r\n      var holder = this.clone.wtTable.holder;\r\n      var hider = this.clone.wtTable.hider;\r\n      var holderStyle = holder.style;\r\n      var hidderStyle = hider.style;\r\n      var rootStyle = holder.parentNode.style;\r\n      arrayEach([holderStyle, hidderStyle, rootStyle], function (style) {\r\n        style.width = '';\r\n        style.height = '';\r\n      });\r\n    }\r\n    /**\r\n     * Destroy overlay instance.\r\n     */\r\n\r\n  }, {\r\n    key: \"destroy\",\r\n    value: function destroy() {\r\n      new EventManager(this.clone).destroy();\r\n    }\r\n  }]);\r\n\r\n  return Overlay;\r\n}();"]},"metadata":{},"sourceType":"module"}