{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { stringify } from \"./3rdparty/SheetClip/index.mjs\";\nimport { cellMethodLookupFactory, countFirstRowKeys as _countFirstRowKeys } from \"./helpers/data.mjs\";\nimport { createObjectPropListener, deepClone, deepExtend, deepObjectSize, duckSchema, hasOwnProperty, isObject, objectEach } from \"./helpers/object.mjs\";\nimport { extendArray, to2dArray } from \"./helpers/array.mjs\";\nimport { rangeEach } from \"./helpers/number.mjs\";\nimport { isDefined } from \"./helpers/mixed.mjs\";\nvar copyableLookup = cellMethodLookupFactory('copyable', false);\n/**\n * Utility class that gets and saves data from/to the data source using mapping of columns numbers to object property names.\n *\n * @todo Refactor arguments of methods getRange, getText to be numbers (not objects).\n * @todo Remove priv, GridSettings from object constructor.\n *\n * @util\n * @class DataMap\n * @private\n */\n\nvar DataMap = /*#__PURE__*/function () {\n  /**\n   * @param {object} instance Instance of Handsontable.\n   * @param {Array} data Array of arrays or array of objects containing data.\n   * @param {TableMeta} tableMeta The table meta instance.\n   */\n  function DataMap(instance, data, tableMeta) {\n    _classCallCheck(this, DataMap);\n    /**\n     * Instance of {@link Handsontable}.\n     *\n     * @private\n     * @type {Handsontable}\n     */\n\n\n    this.instance = instance;\n    /**\n     * Instance of {@link TableMeta}.\n     *\n     * @private\n     * @type {TableMeta}\n     */\n\n    this.tableMeta = tableMeta;\n    /**\n     * Reference to the original dataset.\n     *\n     * @type {*}\n     */\n\n    this.dataSource = data;\n    /**\n     * Generated schema based on the first row from the source data.\n     *\n     * @type {object}\n     */\n\n    this.duckSchema = this.dataSource && this.dataSource[0] ? duckSchema(this.dataSource[0]) : {};\n    /**\n     * Cached array of properties to columns.\n     *\n     * @type {Array}\n     */\n\n    this.colToPropCache = void 0;\n    /**\n     * Cached map of properties to columns.\n     *\n     * @type {Map}\n     */\n\n    this.propToColCache = void 0;\n    this.createMap();\n  }\n  /**\n   * Generates cache for property to and from column addressation.\n   */\n\n\n  _createClass(DataMap, [{\n    key: \"createMap\",\n    value: function createMap() {\n      var schema = this.getSchema();\n\n      if (typeof schema === 'undefined') {\n        throw new Error('trying to create `columns` definition but you didn\\'t provide `schema` nor `data`');\n      }\n\n      var columns = this.tableMeta.columns;\n      var i;\n      this.colToPropCache = [];\n      this.propToColCache = new Map();\n\n      if (columns) {\n        var columnsLen = 0;\n        var filteredIndex = 0;\n        var columnsAsFunc = false;\n\n        if (typeof columns === 'function') {\n          var schemaLen = deepObjectSize(schema);\n          columnsLen = schemaLen > 0 ? schemaLen : this.countFirstRowKeys();\n          columnsAsFunc = true;\n        } else {\n          var maxCols = this.tableMeta.maxCols;\n          columnsLen = Math.min(maxCols, columns.length);\n        }\n\n        for (i = 0; i < columnsLen; i++) {\n          var column = columnsAsFunc ? columns(i) : columns[i];\n\n          if (isObject(column)) {\n            if (typeof column.data !== 'undefined') {\n              var index = columnsAsFunc ? filteredIndex : i;\n              this.colToPropCache[index] = column.data;\n              this.propToColCache.set(column.data, index);\n            }\n\n            filteredIndex += 1;\n          }\n        }\n      } else {\n        this.recursiveDuckColumns(schema);\n      }\n    }\n    /**\n     * Get the amount of physical columns in the first data row.\n     *\n     * @returns {number} Amount of physical columns in the first data row.\n     */\n\n  }, {\n    key: \"countFirstRowKeys\",\n    value: function countFirstRowKeys() {\n      return _countFirstRowKeys(this.dataSource);\n    }\n    /**\n     * Generates columns' translation cache.\n     *\n     * @param {object} schema An object to generate schema from.\n     * @param {number} lastCol The column index.\n     * @param {number} parent The property cache for recursive calls.\n     * @returns {number}\n     */\n\n  }, {\n    key: \"recursiveDuckColumns\",\n    value: function recursiveDuckColumns(schema, lastCol, parent) {\n      var _this = this;\n\n      var lastColumn = lastCol;\n      var propertyParent = parent;\n      var prop;\n\n      if (typeof lastColumn === 'undefined') {\n        lastColumn = 0;\n        propertyParent = '';\n      }\n\n      if (_typeof(schema) === 'object' && !Array.isArray(schema)) {\n        objectEach(schema, function (value, key) {\n          if (value === null) {\n            prop = propertyParent + key;\n\n            _this.colToPropCache.push(prop);\n\n            _this.propToColCache.set(prop, lastColumn);\n\n            lastColumn += 1;\n          } else {\n            lastColumn = _this.recursiveDuckColumns(value, lastColumn, \"\".concat(key, \".\"));\n          }\n        });\n      }\n\n      return lastColumn;\n    }\n    /**\n     * Returns property name that corresponds with the given column index.\n     *\n     * @param {string|number} column Visual column index or another passed argument.\n     * @returns {string|number} Column property, physical column index or passed argument.\n     */\n\n  }, {\n    key: \"colToProp\",\n    value: function colToProp(column) {\n      // TODO: Should it work? Please, look at the test:\n      // \"it should return the provided property name, when the user passes a property name as a column number\".\n      if (Number.isInteger(column) === false) {\n        return column;\n      }\n\n      var physicalColumn = this.instance.toPhysicalColumn(column); // Out of range, not visible column index.\n\n      if (physicalColumn === null) {\n        return column;\n      } // Cached property.\n\n\n      if (this.colToPropCache && isDefined(this.colToPropCache[physicalColumn])) {\n        return this.colToPropCache[physicalColumn];\n      }\n\n      return physicalColumn;\n    }\n    /**\n     * Translates property into visual column index.\n     *\n     * @param {string|number} prop Column property which may be also a physical column index.\n     * @returns {string|number} Visual column index or passed argument.\n     */\n\n  }, {\n    key: \"propToCol\",\n    value: function propToCol(prop) {\n      var cachedPhysicalIndex = this.propToColCache.get(prop);\n\n      if (isDefined(cachedPhysicalIndex)) {\n        return this.instance.toVisualColumn(cachedPhysicalIndex);\n      } // Property may be a physical column index.\n\n\n      var visualColumn = this.instance.toVisualColumn(prop);\n\n      if (visualColumn === null) {\n        return prop;\n      }\n\n      return visualColumn;\n    }\n    /**\n     * Returns data's schema.\n     *\n     * @returns {object}\n     */\n\n  }, {\n    key: \"getSchema\",\n    value: function getSchema() {\n      var schema = this.tableMeta.dataSchema;\n\n      if (schema) {\n        if (typeof schema === 'function') {\n          return schema();\n        }\n\n        return schema;\n      }\n\n      return this.duckSchema;\n    }\n    /**\n     * Creates row at the bottom of the data array.\n     *\n     * @param {number} [index] Physical index of the row before which the new row will be inserted.\n     * @param {number} [amount=1] An amount of rows to add.\n     * @param {string} [source] Source of method call.\n     * @fires Hooks#afterCreateRow\n     * @returns {number} Returns number of created rows.\n     */\n\n  }, {\n    key: \"createRow\",\n    value: function createRow(index) {\n      var _this2 = this;\n\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n      var sourceRowsCount = this.instance.countSourceRows();\n      var physicalRowIndex = sourceRowsCount;\n      var numberOfCreatedRows = 0;\n      var rowIndex = index;\n\n      if (typeof rowIndex !== 'number' || rowIndex >= sourceRowsCount) {\n        rowIndex = sourceRowsCount;\n      }\n\n      if (rowIndex < this.instance.countRows()) {\n        physicalRowIndex = this.instance.toPhysicalRow(rowIndex);\n      }\n\n      var continueProcess = this.instance.runHooks('beforeCreateRow', rowIndex, amount, source);\n\n      if (continueProcess === false || physicalRowIndex === null) {\n        return 0;\n      }\n\n      var maxRows = this.tableMeta.maxRows;\n      var columnCount = this.instance.countCols();\n      var rowsToAdd = [];\n\n      var _loop = function _loop() {\n        var row = null;\n\n        if (_this2.instance.dataType === 'array') {\n          if (_this2.tableMeta.dataSchema) {\n            // Clone template array\n            row = deepClone(_this2.getSchema());\n          } else {\n            row = [];\n            /* eslint-disable no-loop-func */\n\n            rangeEach(columnCount - 1, function () {\n              return row.push(null);\n            });\n          }\n        } else if (_this2.instance.dataType === 'function') {\n          row = _this2.tableMeta.dataSchema(rowIndex + numberOfCreatedRows);\n        } else {\n          row = {};\n          deepExtend(row, _this2.getSchema());\n        }\n\n        rowsToAdd.push(row);\n        numberOfCreatedRows += 1;\n      };\n\n      while (numberOfCreatedRows < amount && sourceRowsCount + numberOfCreatedRows < maxRows) {\n        _loop();\n      }\n\n      this.instance.rowIndexMapper.insertIndexes(rowIndex, numberOfCreatedRows);\n      this.spliceData.apply(this, [physicalRowIndex, 0].concat(rowsToAdd));\n      this.instance.runHooks('afterCreateRow', rowIndex, numberOfCreatedRows, source);\n      this.instance.forceFullRender = true; // used when data was changed\n\n      return numberOfCreatedRows;\n    }\n    /**\n     * Creates column at the right of the data array.\n     *\n     * @param {number} [index] Visual index of the column before which the new column will be inserted.\n     * @param {number} [amount=1] An amount of columns to add.\n     * @param {string} [source] Source of method call.\n     * @fires Hooks#afterCreateCol\n     * @returns {number} Returns number of created columns.\n     */\n\n  }, {\n    key: \"createCol\",\n    value: function createCol(index) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (!this.instance.isColumnModificationAllowed()) {\n        throw new Error('Cannot create new column. When data source in an object, ' + 'you can only have as much columns as defined in first data row, data schema or in the \\'columns\\' setting.' + 'If you want to be able to add new columns, you have to use array datasource.');\n      }\n\n      var dataSource = this.dataSource;\n      var maxCols = this.tableMeta.maxCols;\n      var columnIndex = index;\n\n      if (typeof columnIndex !== 'number' || columnIndex >= this.instance.countSourceCols()) {\n        columnIndex = this.instance.countSourceCols();\n      }\n\n      var continueProcess = this.instance.runHooks('beforeCreateCol', columnIndex, amount, source);\n\n      if (continueProcess === false) {\n        return 0;\n      }\n\n      var physicalColumnIndex = this.instance.countSourceCols();\n\n      if (columnIndex < this.instance.countCols()) {\n        physicalColumnIndex = this.instance.toPhysicalColumn(columnIndex);\n      }\n\n      var numberOfSourceRows = this.instance.countSourceRows();\n      var nrOfColumns = this.instance.countCols();\n      var numberOfCreatedCols = 0;\n      var currentIndex = physicalColumnIndex;\n\n      while (numberOfCreatedCols < amount && nrOfColumns < maxCols) {\n        if (typeof columnIndex !== 'number' || columnIndex >= nrOfColumns) {\n          if (numberOfSourceRows > 0) {\n            for (var row = 0; row < numberOfSourceRows; row += 1) {\n              if (typeof dataSource[row] === 'undefined') {\n                dataSource[row] = [];\n              }\n\n              dataSource[row].push(null);\n            }\n          } else {\n            dataSource.push([null]);\n          }\n        } else {\n          for (var _row = 0; _row < numberOfSourceRows; _row++) {\n            dataSource[_row].splice(currentIndex, 0, null);\n          }\n        }\n\n        numberOfCreatedCols += 1;\n        currentIndex += 1;\n        nrOfColumns += 1;\n      }\n\n      this.instance.columnIndexMapper.insertIndexes(columnIndex, numberOfCreatedCols);\n      this.instance.runHooks('afterCreateCol', columnIndex, numberOfCreatedCols, source);\n      this.instance.forceFullRender = true; // used when data was changed\n\n      return numberOfCreatedCols;\n    }\n    /**\n     * Removes row from the data array.\n     *\n     * @fires Hooks#beforeRemoveRow\n     * @fires Hooks#afterRemoveRow\n     * @param {number} [index] Visual index of the row to be removed. If not provided, the last row will be removed.\n     * @param {number} [amount=1] Amount of the rows to be removed. If not provided, one row will be removed.\n     * @param {string} [source] Source of method call.\n     * @returns {boolean} Returns `false` when action was cancelled, otherwise `true`.\n     */\n\n  }, {\n    key: \"removeRow\",\n    value: function removeRow(index) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n      var rowIndex = Number.isInteger(index) ? index : -amount; // -amount = taking indexes from the end.\n\n      var removedPhysicalIndexes = this.visualRowsToPhysical(rowIndex, amount);\n      var sourceRowsLength = this.instance.countSourceRows();\n      rowIndex = (sourceRowsLength + rowIndex) % sourceRowsLength; // It handle also callback from the `NestedRows` plugin. Removing parent node has effect in removing children nodes.\n\n      var actionWasNotCancelled = this.instance.runHooks('beforeRemoveRow', rowIndex, removedPhysicalIndexes.length, removedPhysicalIndexes, source);\n\n      if (actionWasNotCancelled === false) {\n        return false;\n      }\n\n      var data = this.dataSource; // List of removed indexes might be changed in the `beforeRemoveRow` hook. There may be new values.\n\n      var numberOfRemovedIndexes = removedPhysicalIndexes.length;\n      var newData = this.filterData(rowIndex, numberOfRemovedIndexes, removedPhysicalIndexes);\n\n      if (newData) {\n        data.length = 0;\n        Array.prototype.push.apply(data, newData);\n      } // TODO: Function `removeRow` should validate fully, probably above.\n\n\n      if (rowIndex < this.instance.countRows()) {\n        this.instance.rowIndexMapper.removeIndexes(removedPhysicalIndexes);\n        var customDefinedColumns = isDefined(this.tableMeta.columns) || isDefined(this.tableMeta.dataSchema); // All rows have been removed. There shouldn't be any columns.\n\n        if (this.instance.rowIndexMapper.getNotTrimmedIndexesLength() === 0 && customDefinedColumns === false) {\n          this.instance.columnIndexMapper.setIndexesSequence([]);\n        }\n      }\n\n      this.instance.runHooks('afterRemoveRow', rowIndex, numberOfRemovedIndexes, removedPhysicalIndexes, source);\n      this.instance.forceFullRender = true; // used when data was changed\n\n      return true;\n    }\n    /**\n     * Removes column from the data array.\n     *\n     * @fires Hooks#beforeRemoveCol\n     * @fires Hooks#afterRemoveCol\n     * @param {number} [index] Visual index of the column to be removed. If not provided, the last column will be removed.\n     * @param {number} [amount=1] Amount of the columns to be removed. If not provided, one column will be removed.\n     * @param {string} [source] Source of method call.\n     * @returns {boolean} Returns `false` when action was cancelled, otherwise `true`.\n     */\n\n  }, {\n    key: \"removeCol\",\n    value: function removeCol(index) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (this.instance.dataType === 'object' || this.tableMeta.columns) {\n        throw new Error('cannot remove column with object data source or columns option specified');\n      }\n\n      var columnIndex = typeof index !== 'number' ? -amount : index;\n      columnIndex = (this.instance.countCols() + columnIndex) % this.instance.countCols();\n      var logicColumns = this.visualColumnsToPhysical(columnIndex, amount);\n      var descendingLogicColumns = logicColumns.slice(0).sort(function (a, b) {\n        return b - a;\n      });\n      var actionWasNotCancelled = this.instance.runHooks('beforeRemoveCol', columnIndex, amount, logicColumns, source);\n\n      if (actionWasNotCancelled === false) {\n        return false;\n      }\n\n      var isTableUniform = true;\n      var removedColumnsCount = descendingLogicColumns.length;\n      var data = this.dataSource;\n\n      for (var c = 0; c < removedColumnsCount; c++) {\n        if (isTableUniform && logicColumns[0] !== logicColumns[c] - c) {\n          isTableUniform = false;\n        }\n      }\n\n      if (isTableUniform) {\n        for (var r = 0, rlen = this.instance.countSourceRows(); r < rlen; r++) {\n          data[r].splice(logicColumns[0], amount);\n        }\n      } else {\n        for (var _r = 0, _rlen = this.instance.countSourceRows(); _r < _rlen; _r++) {\n          for (var _c = 0; _c < removedColumnsCount; _c++) {\n            data[_r].splice(descendingLogicColumns[_c], 1);\n          }\n        }\n      } // TODO: Function `removeCol` should validate fully, probably above.\n\n\n      if (columnIndex < this.instance.countCols()) {\n        this.instance.columnIndexMapper.removeIndexes(logicColumns); // All columns have been removed. There shouldn't be any rows.\n\n        if (this.instance.columnIndexMapper.getNotTrimmedIndexesLength() === 0) {\n          this.instance.rowIndexMapper.setIndexesSequence([]);\n        }\n      }\n\n      this.instance.runHooks('afterRemoveCol', columnIndex, amount, logicColumns, source);\n      this.instance.forceFullRender = true; // used when data was changed\n\n      return true;\n    }\n    /**\n     * Add/Removes data from the column.\n     *\n     * @param {number} col Physical index of column in which do you want to do splice.\n     * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n     * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n     * @param {Array} [elements] The new columns to add.\n     * @returns {Array} Returns removed portion of columns.\n     */\n\n  }, {\n    key: \"spliceCol\",\n    value: function spliceCol(col, index, amount) {\n      var colData = this.instance.getDataAtCol(col);\n      var removed = colData.slice(index, index + amount);\n      var after = colData.slice(index + amount);\n\n      for (var _len = arguments.length, elements = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        elements[_key - 3] = arguments[_key];\n      }\n\n      extendArray(elements, after);\n      var i = 0;\n\n      while (i < amount) {\n        elements.push(null); // add null in place of removed elements\n\n        i += 1;\n      }\n\n      to2dArray(elements);\n      this.instance.populateFromArray(index, col, elements, null, null, 'spliceCol');\n      return removed;\n    }\n    /**\n     * Add/Removes data from the row.\n     *\n     * @param {number} row Physical index of row in which do you want to do splice.\n     * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n     * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n     * @param {Array} [elements] The new rows to add.\n     * @returns {Array} Returns removed portion of rows.\n     */\n\n  }, {\n    key: \"spliceRow\",\n    value: function spliceRow(row, index, amount) {\n      var rowData = this.instance.getSourceDataAtRow(row);\n      var removed = rowData.slice(index, index + amount);\n      var after = rowData.slice(index + amount);\n\n      for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        elements[_key2 - 3] = arguments[_key2];\n      }\n\n      extendArray(elements, after);\n      var i = 0;\n\n      while (i < amount) {\n        elements.push(null); // add null in place of removed elements\n\n        i += 1;\n      }\n\n      this.instance.populateFromArray(row, index, [elements], null, null, 'spliceRow');\n      return removed;\n    }\n    /**\n     * Add/remove row(s) to/from the data source.\n     *\n     * @param {number} index Physical index of the element to add/remove.\n     * @param {number} amount Number of rows to add/remove.\n     * @param {...object} elements Row elements to be added.\n     */\n\n  }, {\n    key: \"spliceData\",\n    value: function spliceData(index, amount) {\n      for (var _len3 = arguments.length, elements = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        elements[_key3 - 2] = arguments[_key3];\n      }\n\n      var continueSplicing = this.instance.runHooks('beforeDataSplice', index, amount, elements);\n\n      if (continueSplicing !== false) {\n        var _this$dataSource;\n\n        (_this$dataSource = this.dataSource).splice.apply(_this$dataSource, [index, amount].concat(elements));\n      }\n    }\n    /**\n     * Filter unwanted data elements from the data source.\n     *\n     * @param {number} index Visual index of the element to remove.\n     * @param {number} amount Number of rows to add/remove.\n     * @param {number} physicalRows Physical row indexes.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"filterData\",\n    value: function filterData(index, amount, physicalRows) {\n      var continueSplicing = this.instance.runHooks('beforeDataFilter', index, amount, physicalRows);\n\n      if (continueSplicing !== false) {\n        var newData = this.dataSource.filter(function (row, rowIndex) {\n          return physicalRows.indexOf(rowIndex) === -1;\n        });\n        return newData;\n      }\n    }\n    /**\n     * Returns single value from the data array.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} prop The column property.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(row, prop) {\n      var physicalRow = this.instance.toPhysicalRow(row);\n      var dataRow = this.dataSource[physicalRow]; // TODO: To remove, use 'modifyData' hook instead (see below)\n\n      var modifiedRowData = this.instance.runHooks('modifyRowData', physicalRow);\n      dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow; //\n\n      var value = null; // try to get value under property `prop` (includes dot)\n\n      if (dataRow && dataRow.hasOwnProperty && hasOwnProperty(dataRow, prop)) {\n        value = dataRow[prop];\n      } else if (typeof prop === 'string' && prop.indexOf('.') > -1) {\n        var sliced = prop.split('.');\n        var out = dataRow;\n\n        if (!out) {\n          return null;\n        }\n\n        for (var i = 0, ilen = sliced.length; i < ilen; i++) {\n          out = out[sliced[i]];\n\n          if (typeof out === 'undefined') {\n            return null;\n          }\n        }\n\n        value = out;\n      } else if (typeof prop === 'function') {\n        /**\n         *  Allows for interacting with complex structures, for example\n         *  d3/jQuery getter/setter properties:\n         *\n         *    {columns: [{\n         *      data: function(row, value){\n         *        if(arguments.length === 1){\n         *          return row.property();\n         *        }\n         *        row.property(value);\n         *      }\n         *    }]}.\n         */\n        value = prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0]);\n      }\n\n      if (this.instance.hasHook('modifyData')) {\n        var valueHolder = createObjectPropListener(value);\n        this.instance.runHooks('modifyData', physicalRow, this.propToCol(prop), valueHolder, 'get');\n\n        if (valueHolder.isTouched()) {\n          value = valueHolder.value;\n        }\n      }\n\n      return value;\n    }\n    /**\n     * Returns single value from the data array (intended for clipboard copy to an external application).\n     *\n     * @param {number} row Physical row index.\n     * @param {number} prop The column property.\n     * @returns {string}\n     */\n\n  }, {\n    key: \"getCopyable\",\n    value: function getCopyable(row, prop) {\n      if (copyableLookup.call(this.instance, row, this.propToCol(prop))) {\n        return this.get(row, prop);\n      }\n\n      return '';\n    }\n    /**\n     * Saves single value to the data array.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} prop The column property.\n     * @param {string} value The value to set.\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(row, prop, value) {\n      var physicalRow = this.instance.toPhysicalRow(row);\n      var newValue = value;\n      var dataRow = this.dataSource[physicalRow]; // TODO: To remove, use 'modifyData' hook instead (see below)\n\n      var modifiedRowData = this.instance.runHooks('modifyRowData', physicalRow);\n      dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow; //\n\n      if (this.instance.hasHook('modifyData')) {\n        var valueHolder = createObjectPropListener(newValue);\n        this.instance.runHooks('modifyData', physicalRow, this.propToCol(prop), valueHolder, 'set');\n\n        if (valueHolder.isTouched()) {\n          newValue = valueHolder.value;\n        }\n      } // try to set value under property `prop` (includes dot)\n\n\n      if (dataRow && dataRow.hasOwnProperty && hasOwnProperty(dataRow, prop)) {\n        dataRow[prop] = newValue;\n      } else if (typeof prop === 'string' && prop.indexOf('.') > -1) {\n        var sliced = prop.split('.');\n        var out = dataRow;\n        var i = 0;\n        var ilen;\n\n        for (i = 0, ilen = sliced.length - 1; i < ilen; i++) {\n          if (typeof out[sliced[i]] === 'undefined') {\n            out[sliced[i]] = {};\n          }\n\n          out = out[sliced[i]];\n        }\n\n        out[sliced[i]] = newValue;\n      } else if (typeof prop === 'function') {\n        /* see the `function` handler in `get` */\n        prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0], newValue);\n      } else {\n        dataRow[prop] = newValue;\n      }\n    }\n    /**\n     * This ridiculous piece of code maps rows Id that are present in table data to those displayed for user.\n     * The trick is, the physical row id (stored in settings.data) is not necessary the same\n     * as the visual (displayed) row id (e.g. When sorting is applied).\n     *\n     * @param {number} index Visual row index.\n     * @param {number} amount An amount of rows to translate.\n     * @returns {number}\n     */\n\n  }, {\n    key: \"visualRowsToPhysical\",\n    value: function visualRowsToPhysical(index, amount) {\n      var totalRows = this.instance.countSourceRows();\n      var logicRows = [];\n      var physicRow = (totalRows + index) % totalRows;\n      var rowsToRemove = amount;\n      var row;\n\n      while (physicRow < totalRows && rowsToRemove) {\n        row = this.instance.toPhysicalRow(physicRow);\n        logicRows.push(row);\n        rowsToRemove -= 1;\n        physicRow += 1;\n      }\n\n      return logicRows;\n    }\n    /**\n     *\n     * @param {number} index Visual column index.\n     * @param {number} amount An amount of rows to translate.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"visualColumnsToPhysical\",\n    value: function visualColumnsToPhysical(index, amount) {\n      var totalCols = this.instance.countCols();\n      var visualCols = [];\n      var physicalCol = (totalCols + index) % totalCols;\n      var colsToRemove = amount;\n\n      while (physicalCol < totalCols && colsToRemove) {\n        var col = this.instance.toPhysicalColumn(physicalCol);\n        visualCols.push(col);\n        colsToRemove -= 1;\n        physicalCol += 1;\n      }\n\n      return visualCols;\n    }\n    /**\n     * Clears the data array.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      for (var r = 0; r < this.instance.countSourceRows(); r++) {\n        for (var c = 0; c < this.instance.countCols(); c++) {\n          this.set(r, this.colToProp(c), '');\n        }\n      }\n    }\n    /**\n     * Get data length.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      var maxRowsFromSettings = this.tableMeta.maxRows;\n      var maxRows;\n\n      if (maxRowsFromSettings < 0 || maxRowsFromSettings === 0) {\n        maxRows = 0;\n      } else {\n        maxRows = maxRowsFromSettings || Infinity;\n      }\n\n      var length = this.instance.rowIndexMapper.getNotTrimmedIndexesLength();\n      return Math.min(length, maxRows);\n    }\n    /**\n     * Returns the data array.\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var start = {\n        row: 0,\n        col: 0\n      };\n      var end = {\n        row: Math.max(this.instance.countRows() - 1, 0),\n        col: Math.max(this.instance.countCols() - 1, 0)\n      };\n\n      if (start.row - end.row === 0 && !this.instance.countSourceRows()) {\n        return [];\n      }\n\n      return this.getRange(start, end, DataMap.DESTINATION_RENDERER);\n    }\n    /**\n     * Count the number of columns cached in the `colToProp` cache.\n     *\n     * @returns {number} Amount of cached columns.\n     */\n\n  }, {\n    key: \"countCachedColumns\",\n    value: function countCachedColumns() {\n      return this.colToPropCache.length;\n    }\n    /**\n     * Returns data range as array.\n     *\n     * @param {object} [start] Start selection position. Visual indexes.\n     * @param {object} [end] End selection position. Visual indexes.\n     * @param {number} destination Destination of datamap.get.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getRange\",\n    value: function getRange(start, end, destination) {\n      var output = [];\n      var r;\n      var c;\n      var row;\n      var maxRows = this.tableMeta.maxRows;\n      var maxCols = this.tableMeta.maxCols;\n\n      if (maxRows === 0 || maxCols === 0) {\n        return [];\n      }\n\n      var getFn = destination === DataMap.DESTINATION_CLIPBOARD_GENERATOR ? this.getCopyable : this.get;\n      var rlen = Math.min(Math.max(maxRows - 1, 0), Math.max(start.row, end.row));\n      var clen = Math.min(Math.max(maxCols - 1, 0), Math.max(start.col, end.col));\n\n      for (r = Math.min(start.row, end.row); r <= rlen; r++) {\n        row = []; // We just store indexes for rows without headers.\n\n        var physicalRow = r >= 0 ? this.instance.toPhysicalRow(r) : r;\n\n        for (c = Math.min(start.col, end.col); c <= clen; c++) {\n          if (physicalRow === null) {\n            break;\n          }\n\n          row.push(getFn.call(this, r, this.colToProp(c)));\n        }\n\n        if (physicalRow !== null) {\n          output.push(row);\n        }\n      }\n\n      return output;\n    }\n    /**\n     * Return data as text (tab separated columns).\n     *\n     * @param {object} [start] Start selection position. Visual indexes.\n     * @param {object} [end] End selection position. Visual indexes.\n     * @returns {string}\n     */\n\n  }, {\n    key: \"getText\",\n    value: function getText(start, end) {\n      return stringify(this.getRange(start, end, DataMap.DESTINATION_RENDERER));\n    }\n    /**\n     * Return data as copyable text (tab separated columns intended for clipboard copy to an external application).\n     *\n     * @param {object} [start] Start selection position. Visual indexes.\n     * @param {object} [end] End selection position. Visual indexes.\n     * @returns {string}\n     */\n\n  }, {\n    key: \"getCopyableText\",\n    value: function getCopyableText(start, end) {\n      return stringify(this.getRange(start, end, DataMap.DESTINATION_CLIPBOARD_GENERATOR));\n    }\n    /**\n     * Destroy instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.instance = null;\n      this.tableMeta = null;\n      this.dataSource = null;\n      this.duckSchema = null;\n      this.colToPropCache.length = 0;\n      this.propToColCache.clear();\n      this.propToColCache = void 0;\n    }\n  }], [{\n    key: \"DESTINATION_RENDERER\",\n    get:\n    /**\n     * @type {number}\n     */\n    function get() {\n      return 1;\n    }\n    /**\n     * @type {number}\n     */\n\n  }, {\n    key: \"DESTINATION_CLIPBOARD_GENERATOR\",\n    get: function get() {\n      return 2;\n    }\n  }]);\n\n  return DataMap;\n}();\n\nexport default DataMap;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/dataMap.mjs"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","stringify","cellMethodLookupFactory","countFirstRowKeys","_countFirstRowKeys","createObjectPropListener","deepClone","deepExtend","deepObjectSize","duckSchema","hasOwnProperty","isObject","objectEach","extendArray","to2dArray","rangeEach","isDefined","copyableLookup","DataMap","data","tableMeta","dataSource","colToPropCache","propToColCache","createMap","value","schema","getSchema","Error","columns","Map","columnsLen","filteredIndex","columnsAsFunc","schemaLen","maxCols","Math","min","column","index","set","recursiveDuckColumns","lastCol","parent","_this","lastColumn","propertyParent","prop","Array","isArray","push","concat","colToProp","Number","isInteger","physicalColumn","toPhysicalColumn","propToCol","cachedPhysicalIndex","get","toVisualColumn","visualColumn","dataSchema","createRow","_this2","amount","arguments","undefined","source","sourceRowsCount","countSourceRows","physicalRowIndex","numberOfCreatedRows","rowIndex","countRows","toPhysicalRow","continueProcess","runHooks","maxRows","columnCount","countCols","rowsToAdd","_loop","row","dataType","rowIndexMapper","insertIndexes","spliceData","apply","forceFullRender","createCol","isColumnModificationAllowed","columnIndex","countSourceCols","physicalColumnIndex","numberOfSourceRows","nrOfColumns","numberOfCreatedCols","currentIndex","_row","splice","columnIndexMapper","removeRow","removedPhysicalIndexes","visualRowsToPhysical","sourceRowsLength","actionWasNotCancelled","numberOfRemovedIndexes","newData","filterData","removeIndexes","customDefinedColumns","getNotTrimmedIndexesLength","setIndexesSequence","removeCol","logicColumns","visualColumnsToPhysical","descendingLogicColumns","slice","sort","a","b","isTableUniform","removedColumnsCount","c","r","rlen","_r","_rlen","_c","spliceCol","col","colData","getDataAtCol","removed","after","_len","elements","_key","populateFromArray","spliceRow","rowData","getSourceDataAtRow","_len2","_key2","_len3","_key3","continueSplicing","_this$dataSource","physicalRows","filter","indexOf","physicalRow","dataRow","modifiedRowData","isNaN","sliced","split","out","ilen","hasHook","valueHolder","isTouched","getCopyable","call","newValue","totalRows","logicRows","physicRow","rowsToRemove","totalCols","visualCols","physicalCol","colsToRemove","clear","getLength","maxRowsFromSettings","Infinity","getAll","start","end","max","getRange","DESTINATION_RENDERER","countCachedColumns","destination","output","getFn","DESTINATION_CLIPBOARD_GENERATOR","clen","getText","getCopyableText","destroy"],"mappings":"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","sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.number.is-integer.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { stringify } from \"./3rdparty/SheetClip/index.mjs\";\nimport { cellMethodLookupFactory, countFirstRowKeys as _countFirstRowKeys } from \"./helpers/data.mjs\";\nimport { createObjectPropListener, deepClone, deepExtend, deepObjectSize, duckSchema, hasOwnProperty, isObject, objectEach } from \"./helpers/object.mjs\";\nimport { extendArray, to2dArray } from \"./helpers/array.mjs\";\nimport { rangeEach } from \"./helpers/number.mjs\";\nimport { isDefined } from \"./helpers/mixed.mjs\";\nvar copyableLookup = cellMethodLookupFactory('copyable', false);\n/**\n * Utility class that gets and saves data from/to the data source using mapping of columns numbers to object property names.\n *\n * @todo Refactor arguments of methods getRange, getText to be numbers (not objects).\n * @todo Remove priv, GridSettings from object constructor.\n *\n * @util\n * @class DataMap\n * @private\n */\n\nvar DataMap = /*#__PURE__*/function () {\n  /**\n   * @param {object} instance Instance of Handsontable.\n   * @param {Array} data Array of arrays or array of objects containing data.\n   * @param {TableMeta} tableMeta The table meta instance.\n   */\n  function DataMap(instance, data, tableMeta) {\n    _classCallCheck(this, DataMap);\n\n    /**\n     * Instance of {@link Handsontable}.\n     *\n     * @private\n     * @type {Handsontable}\n     */\n    this.instance = instance;\n    /**\n     * Instance of {@link TableMeta}.\n     *\n     * @private\n     * @type {TableMeta}\n     */\n\n    this.tableMeta = tableMeta;\n    /**\n     * Reference to the original dataset.\n     *\n     * @type {*}\n     */\n\n    this.dataSource = data;\n    /**\n     * Generated schema based on the first row from the source data.\n     *\n     * @type {object}\n     */\n\n    this.duckSchema = this.dataSource && this.dataSource[0] ? duckSchema(this.dataSource[0]) : {};\n    /**\n     * Cached array of properties to columns.\n     *\n     * @type {Array}\n     */\n\n    this.colToPropCache = void 0;\n    /**\n     * Cached map of properties to columns.\n     *\n     * @type {Map}\n     */\n\n    this.propToColCache = void 0;\n    this.createMap();\n  }\n  /**\n   * Generates cache for property to and from column addressation.\n   */\n\n\n  _createClass(DataMap, [{\n    key: \"createMap\",\n    value: function createMap() {\n      var schema = this.getSchema();\n\n      if (typeof schema === 'undefined') {\n        throw new Error('trying to create `columns` definition but you didn\\'t provide `schema` nor `data`');\n      }\n\n      var columns = this.tableMeta.columns;\n      var i;\n      this.colToPropCache = [];\n      this.propToColCache = new Map();\n\n      if (columns) {\n        var columnsLen = 0;\n        var filteredIndex = 0;\n        var columnsAsFunc = false;\n\n        if (typeof columns === 'function') {\n          var schemaLen = deepObjectSize(schema);\n          columnsLen = schemaLen > 0 ? schemaLen : this.countFirstRowKeys();\n          columnsAsFunc = true;\n        } else {\n          var maxCols = this.tableMeta.maxCols;\n          columnsLen = Math.min(maxCols, columns.length);\n        }\n\n        for (i = 0; i < columnsLen; i++) {\n          var column = columnsAsFunc ? columns(i) : columns[i];\n\n          if (isObject(column)) {\n            if (typeof column.data !== 'undefined') {\n              var index = columnsAsFunc ? filteredIndex : i;\n              this.colToPropCache[index] = column.data;\n              this.propToColCache.set(column.data, index);\n            }\n\n            filteredIndex += 1;\n          }\n        }\n      } else {\n        this.recursiveDuckColumns(schema);\n      }\n    }\n    /**\n     * Get the amount of physical columns in the first data row.\n     *\n     * @returns {number} Amount of physical columns in the first data row.\n     */\n\n  }, {\n    key: \"countFirstRowKeys\",\n    value: function countFirstRowKeys() {\n      return _countFirstRowKeys(this.dataSource);\n    }\n    /**\n     * Generates columns' translation cache.\n     *\n     * @param {object} schema An object to generate schema from.\n     * @param {number} lastCol The column index.\n     * @param {number} parent The property cache for recursive calls.\n     * @returns {number}\n     */\n\n  }, {\n    key: \"recursiveDuckColumns\",\n    value: function recursiveDuckColumns(schema, lastCol, parent) {\n      var _this = this;\n\n      var lastColumn = lastCol;\n      var propertyParent = parent;\n      var prop;\n\n      if (typeof lastColumn === 'undefined') {\n        lastColumn = 0;\n        propertyParent = '';\n      }\n\n      if (_typeof(schema) === 'object' && !Array.isArray(schema)) {\n        objectEach(schema, function (value, key) {\n          if (value === null) {\n            prop = propertyParent + key;\n\n            _this.colToPropCache.push(prop);\n\n            _this.propToColCache.set(prop, lastColumn);\n\n            lastColumn += 1;\n          } else {\n            lastColumn = _this.recursiveDuckColumns(value, lastColumn, \"\".concat(key, \".\"));\n          }\n        });\n      }\n\n      return lastColumn;\n    }\n    /**\n     * Returns property name that corresponds with the given column index.\n     *\n     * @param {string|number} column Visual column index or another passed argument.\n     * @returns {string|number} Column property, physical column index or passed argument.\n     */\n\n  }, {\n    key: \"colToProp\",\n    value: function colToProp(column) {\n      // TODO: Should it work? Please, look at the test:\n      // \"it should return the provided property name, when the user passes a property name as a column number\".\n      if (Number.isInteger(column) === false) {\n        return column;\n      }\n\n      var physicalColumn = this.instance.toPhysicalColumn(column); // Out of range, not visible column index.\n\n      if (physicalColumn === null) {\n        return column;\n      } // Cached property.\n\n\n      if (this.colToPropCache && isDefined(this.colToPropCache[physicalColumn])) {\n        return this.colToPropCache[physicalColumn];\n      }\n\n      return physicalColumn;\n    }\n    /**\n     * Translates property into visual column index.\n     *\n     * @param {string|number} prop Column property which may be also a physical column index.\n     * @returns {string|number} Visual column index or passed argument.\n     */\n\n  }, {\n    key: \"propToCol\",\n    value: function propToCol(prop) {\n      var cachedPhysicalIndex = this.propToColCache.get(prop);\n\n      if (isDefined(cachedPhysicalIndex)) {\n        return this.instance.toVisualColumn(cachedPhysicalIndex);\n      } // Property may be a physical column index.\n\n\n      var visualColumn = this.instance.toVisualColumn(prop);\n\n      if (visualColumn === null) {\n        return prop;\n      }\n\n      return visualColumn;\n    }\n    /**\n     * Returns data's schema.\n     *\n     * @returns {object}\n     */\n\n  }, {\n    key: \"getSchema\",\n    value: function getSchema() {\n      var schema = this.tableMeta.dataSchema;\n\n      if (schema) {\n        if (typeof schema === 'function') {\n          return schema();\n        }\n\n        return schema;\n      }\n\n      return this.duckSchema;\n    }\n    /**\n     * Creates row at the bottom of the data array.\n     *\n     * @param {number} [index] Physical index of the row before which the new row will be inserted.\n     * @param {number} [amount=1] An amount of rows to add.\n     * @param {string} [source] Source of method call.\n     * @fires Hooks#afterCreateRow\n     * @returns {number} Returns number of created rows.\n     */\n\n  }, {\n    key: \"createRow\",\n    value: function createRow(index) {\n      var _this2 = this;\n\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n      var sourceRowsCount = this.instance.countSourceRows();\n      var physicalRowIndex = sourceRowsCount;\n      var numberOfCreatedRows = 0;\n      var rowIndex = index;\n\n      if (typeof rowIndex !== 'number' || rowIndex >= sourceRowsCount) {\n        rowIndex = sourceRowsCount;\n      }\n\n      if (rowIndex < this.instance.countRows()) {\n        physicalRowIndex = this.instance.toPhysicalRow(rowIndex);\n      }\n\n      var continueProcess = this.instance.runHooks('beforeCreateRow', rowIndex, amount, source);\n\n      if (continueProcess === false || physicalRowIndex === null) {\n        return 0;\n      }\n\n      var maxRows = this.tableMeta.maxRows;\n      var columnCount = this.instance.countCols();\n      var rowsToAdd = [];\n\n      var _loop = function _loop() {\n        var row = null;\n\n        if (_this2.instance.dataType === 'array') {\n          if (_this2.tableMeta.dataSchema) {\n            // Clone template array\n            row = deepClone(_this2.getSchema());\n          } else {\n            row = [];\n            /* eslint-disable no-loop-func */\n\n            rangeEach(columnCount - 1, function () {\n              return row.push(null);\n            });\n          }\n        } else if (_this2.instance.dataType === 'function') {\n          row = _this2.tableMeta.dataSchema(rowIndex + numberOfCreatedRows);\n        } else {\n          row = {};\n          deepExtend(row, _this2.getSchema());\n        }\n\n        rowsToAdd.push(row);\n        numberOfCreatedRows += 1;\n      };\n\n      while (numberOfCreatedRows < amount && sourceRowsCount + numberOfCreatedRows < maxRows) {\n        _loop();\n      }\n\n      this.instance.rowIndexMapper.insertIndexes(rowIndex, numberOfCreatedRows);\n      this.spliceData.apply(this, [physicalRowIndex, 0].concat(rowsToAdd));\n      this.instance.runHooks('afterCreateRow', rowIndex, numberOfCreatedRows, source);\n      this.instance.forceFullRender = true; // used when data was changed\n\n      return numberOfCreatedRows;\n    }\n    /**\n     * Creates column at the right of the data array.\n     *\n     * @param {number} [index] Visual index of the column before which the new column will be inserted.\n     * @param {number} [amount=1] An amount of columns to add.\n     * @param {string} [source] Source of method call.\n     * @fires Hooks#afterCreateCol\n     * @returns {number} Returns number of created columns.\n     */\n\n  }, {\n    key: \"createCol\",\n    value: function createCol(index) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (!this.instance.isColumnModificationAllowed()) {\n        throw new Error('Cannot create new column. When data source in an object, ' + 'you can only have as much columns as defined in first data row, data schema or in the \\'columns\\' setting.' + 'If you want to be able to add new columns, you have to use array datasource.');\n      }\n\n      var dataSource = this.dataSource;\n      var maxCols = this.tableMeta.maxCols;\n      var columnIndex = index;\n\n      if (typeof columnIndex !== 'number' || columnIndex >= this.instance.countSourceCols()) {\n        columnIndex = this.instance.countSourceCols();\n      }\n\n      var continueProcess = this.instance.runHooks('beforeCreateCol', columnIndex, amount, source);\n\n      if (continueProcess === false) {\n        return 0;\n      }\n\n      var physicalColumnIndex = this.instance.countSourceCols();\n\n      if (columnIndex < this.instance.countCols()) {\n        physicalColumnIndex = this.instance.toPhysicalColumn(columnIndex);\n      }\n\n      var numberOfSourceRows = this.instance.countSourceRows();\n      var nrOfColumns = this.instance.countCols();\n      var numberOfCreatedCols = 0;\n      var currentIndex = physicalColumnIndex;\n\n      while (numberOfCreatedCols < amount && nrOfColumns < maxCols) {\n        if (typeof columnIndex !== 'number' || columnIndex >= nrOfColumns) {\n          if (numberOfSourceRows > 0) {\n            for (var row = 0; row < numberOfSourceRows; row += 1) {\n              if (typeof dataSource[row] === 'undefined') {\n                dataSource[row] = [];\n              }\n\n              dataSource[row].push(null);\n            }\n          } else {\n            dataSource.push([null]);\n          }\n        } else {\n          for (var _row = 0; _row < numberOfSourceRows; _row++) {\n            dataSource[_row].splice(currentIndex, 0, null);\n          }\n        }\n\n        numberOfCreatedCols += 1;\n        currentIndex += 1;\n        nrOfColumns += 1;\n      }\n\n      this.instance.columnIndexMapper.insertIndexes(columnIndex, numberOfCreatedCols);\n      this.instance.runHooks('afterCreateCol', columnIndex, numberOfCreatedCols, source);\n      this.instance.forceFullRender = true; // used when data was changed\n\n      return numberOfCreatedCols;\n    }\n    /**\n     * Removes row from the data array.\n     *\n     * @fires Hooks#beforeRemoveRow\n     * @fires Hooks#afterRemoveRow\n     * @param {number} [index] Visual index of the row to be removed. If not provided, the last row will be removed.\n     * @param {number} [amount=1] Amount of the rows to be removed. If not provided, one row will be removed.\n     * @param {string} [source] Source of method call.\n     * @returns {boolean} Returns `false` when action was cancelled, otherwise `true`.\n     */\n\n  }, {\n    key: \"removeRow\",\n    value: function removeRow(index) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n      var rowIndex = Number.isInteger(index) ? index : -amount; // -amount = taking indexes from the end.\n\n      var removedPhysicalIndexes = this.visualRowsToPhysical(rowIndex, amount);\n      var sourceRowsLength = this.instance.countSourceRows();\n      rowIndex = (sourceRowsLength + rowIndex) % sourceRowsLength; // It handle also callback from the `NestedRows` plugin. Removing parent node has effect in removing children nodes.\n\n      var actionWasNotCancelled = this.instance.runHooks('beforeRemoveRow', rowIndex, removedPhysicalIndexes.length, removedPhysicalIndexes, source);\n\n      if (actionWasNotCancelled === false) {\n        return false;\n      }\n\n      var data = this.dataSource; // List of removed indexes might be changed in the `beforeRemoveRow` hook. There may be new values.\n\n      var numberOfRemovedIndexes = removedPhysicalIndexes.length;\n      var newData = this.filterData(rowIndex, numberOfRemovedIndexes, removedPhysicalIndexes);\n\n      if (newData) {\n        data.length = 0;\n        Array.prototype.push.apply(data, newData);\n      } // TODO: Function `removeRow` should validate fully, probably above.\n\n\n      if (rowIndex < this.instance.countRows()) {\n        this.instance.rowIndexMapper.removeIndexes(removedPhysicalIndexes);\n        var customDefinedColumns = isDefined(this.tableMeta.columns) || isDefined(this.tableMeta.dataSchema); // All rows have been removed. There shouldn't be any columns.\n\n        if (this.instance.rowIndexMapper.getNotTrimmedIndexesLength() === 0 && customDefinedColumns === false) {\n          this.instance.columnIndexMapper.setIndexesSequence([]);\n        }\n      }\n\n      this.instance.runHooks('afterRemoveRow', rowIndex, numberOfRemovedIndexes, removedPhysicalIndexes, source);\n      this.instance.forceFullRender = true; // used when data was changed\n\n      return true;\n    }\n    /**\n     * Removes column from the data array.\n     *\n     * @fires Hooks#beforeRemoveCol\n     * @fires Hooks#afterRemoveCol\n     * @param {number} [index] Visual index of the column to be removed. If not provided, the last column will be removed.\n     * @param {number} [amount=1] Amount of the columns to be removed. If not provided, one column will be removed.\n     * @param {string} [source] Source of method call.\n     * @returns {boolean} Returns `false` when action was cancelled, otherwise `true`.\n     */\n\n  }, {\n    key: \"removeCol\",\n    value: function removeCol(index) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (this.instance.dataType === 'object' || this.tableMeta.columns) {\n        throw new Error('cannot remove column with object data source or columns option specified');\n      }\n\n      var columnIndex = typeof index !== 'number' ? -amount : index;\n      columnIndex = (this.instance.countCols() + columnIndex) % this.instance.countCols();\n      var logicColumns = this.visualColumnsToPhysical(columnIndex, amount);\n      var descendingLogicColumns = logicColumns.slice(0).sort(function (a, b) {\n        return b - a;\n      });\n      var actionWasNotCancelled = this.instance.runHooks('beforeRemoveCol', columnIndex, amount, logicColumns, source);\n\n      if (actionWasNotCancelled === false) {\n        return false;\n      }\n\n      var isTableUniform = true;\n      var removedColumnsCount = descendingLogicColumns.length;\n      var data = this.dataSource;\n\n      for (var c = 0; c < removedColumnsCount; c++) {\n        if (isTableUniform && logicColumns[0] !== logicColumns[c] - c) {\n          isTableUniform = false;\n        }\n      }\n\n      if (isTableUniform) {\n        for (var r = 0, rlen = this.instance.countSourceRows(); r < rlen; r++) {\n          data[r].splice(logicColumns[0], amount);\n        }\n      } else {\n        for (var _r = 0, _rlen = this.instance.countSourceRows(); _r < _rlen; _r++) {\n          for (var _c = 0; _c < removedColumnsCount; _c++) {\n            data[_r].splice(descendingLogicColumns[_c], 1);\n          }\n        }\n      } // TODO: Function `removeCol` should validate fully, probably above.\n\n\n      if (columnIndex < this.instance.countCols()) {\n        this.instance.columnIndexMapper.removeIndexes(logicColumns); // All columns have been removed. There shouldn't be any rows.\n\n        if (this.instance.columnIndexMapper.getNotTrimmedIndexesLength() === 0) {\n          this.instance.rowIndexMapper.setIndexesSequence([]);\n        }\n      }\n\n      this.instance.runHooks('afterRemoveCol', columnIndex, amount, logicColumns, source);\n      this.instance.forceFullRender = true; // used when data was changed\n\n      return true;\n    }\n    /**\n     * Add/Removes data from the column.\n     *\n     * @param {number} col Physical index of column in which do you want to do splice.\n     * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n     * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n     * @param {Array} [elements] The new columns to add.\n     * @returns {Array} Returns removed portion of columns.\n     */\n\n  }, {\n    key: \"spliceCol\",\n    value: function spliceCol(col, index, amount) {\n      var colData = this.instance.getDataAtCol(col);\n      var removed = colData.slice(index, index + amount);\n      var after = colData.slice(index + amount);\n\n      for (var _len = arguments.length, elements = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        elements[_key - 3] = arguments[_key];\n      }\n\n      extendArray(elements, after);\n      var i = 0;\n\n      while (i < amount) {\n        elements.push(null); // add null in place of removed elements\n\n        i += 1;\n      }\n\n      to2dArray(elements);\n      this.instance.populateFromArray(index, col, elements, null, null, 'spliceCol');\n      return removed;\n    }\n    /**\n     * Add/Removes data from the row.\n     *\n     * @param {number} row Physical index of row in which do you want to do splice.\n     * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n     * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n     * @param {Array} [elements] The new rows to add.\n     * @returns {Array} Returns removed portion of rows.\n     */\n\n  }, {\n    key: \"spliceRow\",\n    value: function spliceRow(row, index, amount) {\n      var rowData = this.instance.getSourceDataAtRow(row);\n      var removed = rowData.slice(index, index + amount);\n      var after = rowData.slice(index + amount);\n\n      for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        elements[_key2 - 3] = arguments[_key2];\n      }\n\n      extendArray(elements, after);\n      var i = 0;\n\n      while (i < amount) {\n        elements.push(null); // add null in place of removed elements\n\n        i += 1;\n      }\n\n      this.instance.populateFromArray(row, index, [elements], null, null, 'spliceRow');\n      return removed;\n    }\n    /**\n     * Add/remove row(s) to/from the data source.\n     *\n     * @param {number} index Physical index of the element to add/remove.\n     * @param {number} amount Number of rows to add/remove.\n     * @param {...object} elements Row elements to be added.\n     */\n\n  }, {\n    key: \"spliceData\",\n    value: function spliceData(index, amount) {\n      for (var _len3 = arguments.length, elements = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        elements[_key3 - 2] = arguments[_key3];\n      }\n\n      var continueSplicing = this.instance.runHooks('beforeDataSplice', index, amount, elements);\n\n      if (continueSplicing !== false) {\n        var _this$dataSource;\n\n        (_this$dataSource = this.dataSource).splice.apply(_this$dataSource, [index, amount].concat(elements));\n      }\n    }\n    /**\n     * Filter unwanted data elements from the data source.\n     *\n     * @param {number} index Visual index of the element to remove.\n     * @param {number} amount Number of rows to add/remove.\n     * @param {number} physicalRows Physical row indexes.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"filterData\",\n    value: function filterData(index, amount, physicalRows) {\n      var continueSplicing = this.instance.runHooks('beforeDataFilter', index, amount, physicalRows);\n\n      if (continueSplicing !== false) {\n        var newData = this.dataSource.filter(function (row, rowIndex) {\n          return physicalRows.indexOf(rowIndex) === -1;\n        });\n        return newData;\n      }\n    }\n    /**\n     * Returns single value from the data array.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} prop The column property.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(row, prop) {\n      var physicalRow = this.instance.toPhysicalRow(row);\n      var dataRow = this.dataSource[physicalRow]; // TODO: To remove, use 'modifyData' hook instead (see below)\n\n      var modifiedRowData = this.instance.runHooks('modifyRowData', physicalRow);\n      dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow; //\n\n      var value = null; // try to get value under property `prop` (includes dot)\n\n      if (dataRow && dataRow.hasOwnProperty && hasOwnProperty(dataRow, prop)) {\n        value = dataRow[prop];\n      } else if (typeof prop === 'string' && prop.indexOf('.') > -1) {\n        var sliced = prop.split('.');\n        var out = dataRow;\n\n        if (!out) {\n          return null;\n        }\n\n        for (var i = 0, ilen = sliced.length; i < ilen; i++) {\n          out = out[sliced[i]];\n\n          if (typeof out === 'undefined') {\n            return null;\n          }\n        }\n\n        value = out;\n      } else if (typeof prop === 'function') {\n        /**\n         *  Allows for interacting with complex structures, for example\n         *  d3/jQuery getter/setter properties:\n         *\n         *    {columns: [{\n         *      data: function(row, value){\n         *        if(arguments.length === 1){\n         *          return row.property();\n         *        }\n         *        row.property(value);\n         *      }\n         *    }]}.\n         */\n        value = prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0]);\n      }\n\n      if (this.instance.hasHook('modifyData')) {\n        var valueHolder = createObjectPropListener(value);\n        this.instance.runHooks('modifyData', physicalRow, this.propToCol(prop), valueHolder, 'get');\n\n        if (valueHolder.isTouched()) {\n          value = valueHolder.value;\n        }\n      }\n\n      return value;\n    }\n    /**\n     * Returns single value from the data array (intended for clipboard copy to an external application).\n     *\n     * @param {number} row Physical row index.\n     * @param {number} prop The column property.\n     * @returns {string}\n     */\n\n  }, {\n    key: \"getCopyable\",\n    value: function getCopyable(row, prop) {\n      if (copyableLookup.call(this.instance, row, this.propToCol(prop))) {\n        return this.get(row, prop);\n      }\n\n      return '';\n    }\n    /**\n     * Saves single value to the data array.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} prop The column property.\n     * @param {string} value The value to set.\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(row, prop, value) {\n      var physicalRow = this.instance.toPhysicalRow(row);\n      var newValue = value;\n      var dataRow = this.dataSource[physicalRow]; // TODO: To remove, use 'modifyData' hook instead (see below)\n\n      var modifiedRowData = this.instance.runHooks('modifyRowData', physicalRow);\n      dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow; //\n\n      if (this.instance.hasHook('modifyData')) {\n        var valueHolder = createObjectPropListener(newValue);\n        this.instance.runHooks('modifyData', physicalRow, this.propToCol(prop), valueHolder, 'set');\n\n        if (valueHolder.isTouched()) {\n          newValue = valueHolder.value;\n        }\n      } // try to set value under property `prop` (includes dot)\n\n\n      if (dataRow && dataRow.hasOwnProperty && hasOwnProperty(dataRow, prop)) {\n        dataRow[prop] = newValue;\n      } else if (typeof prop === 'string' && prop.indexOf('.') > -1) {\n        var sliced = prop.split('.');\n        var out = dataRow;\n        var i = 0;\n        var ilen;\n\n        for (i = 0, ilen = sliced.length - 1; i < ilen; i++) {\n          if (typeof out[sliced[i]] === 'undefined') {\n            out[sliced[i]] = {};\n          }\n\n          out = out[sliced[i]];\n        }\n\n        out[sliced[i]] = newValue;\n      } else if (typeof prop === 'function') {\n        /* see the `function` handler in `get` */\n        prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0], newValue);\n      } else {\n        dataRow[prop] = newValue;\n      }\n    }\n    /**\n     * This ridiculous piece of code maps rows Id that are present in table data to those displayed for user.\n     * The trick is, the physical row id (stored in settings.data) is not necessary the same\n     * as the visual (displayed) row id (e.g. When sorting is applied).\n     *\n     * @param {number} index Visual row index.\n     * @param {number} amount An amount of rows to translate.\n     * @returns {number}\n     */\n\n  }, {\n    key: \"visualRowsToPhysical\",\n    value: function visualRowsToPhysical(index, amount) {\n      var totalRows = this.instance.countSourceRows();\n      var logicRows = [];\n      var physicRow = (totalRows + index) % totalRows;\n      var rowsToRemove = amount;\n      var row;\n\n      while (physicRow < totalRows && rowsToRemove) {\n        row = this.instance.toPhysicalRow(physicRow);\n        logicRows.push(row);\n        rowsToRemove -= 1;\n        physicRow += 1;\n      }\n\n      return logicRows;\n    }\n    /**\n     *\n     * @param {number} index Visual column index.\n     * @param {number} amount An amount of rows to translate.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"visualColumnsToPhysical\",\n    value: function visualColumnsToPhysical(index, amount) {\n      var totalCols = this.instance.countCols();\n      var visualCols = [];\n      var physicalCol = (totalCols + index) % totalCols;\n      var colsToRemove = amount;\n\n      while (physicalCol < totalCols && colsToRemove) {\n        var col = this.instance.toPhysicalColumn(physicalCol);\n        visualCols.push(col);\n        colsToRemove -= 1;\n        physicalCol += 1;\n      }\n\n      return visualCols;\n    }\n    /**\n     * Clears the data array.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      for (var r = 0; r < this.instance.countSourceRows(); r++) {\n        for (var c = 0; c < this.instance.countCols(); c++) {\n          this.set(r, this.colToProp(c), '');\n        }\n      }\n    }\n    /**\n     * Get data length.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      var maxRowsFromSettings = this.tableMeta.maxRows;\n      var maxRows;\n\n      if (maxRowsFromSettings < 0 || maxRowsFromSettings === 0) {\n        maxRows = 0;\n      } else {\n        maxRows = maxRowsFromSettings || Infinity;\n      }\n\n      var length = this.instance.rowIndexMapper.getNotTrimmedIndexesLength();\n      return Math.min(length, maxRows);\n    }\n    /**\n     * Returns the data array.\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var start = {\n        row: 0,\n        col: 0\n      };\n      var end = {\n        row: Math.max(this.instance.countRows() - 1, 0),\n        col: Math.max(this.instance.countCols() - 1, 0)\n      };\n\n      if (start.row - end.row === 0 && !this.instance.countSourceRows()) {\n        return [];\n      }\n\n      return this.getRange(start, end, DataMap.DESTINATION_RENDERER);\n    }\n    /**\n     * Count the number of columns cached in the `colToProp` cache.\n     *\n     * @returns {number} Amount of cached columns.\n     */\n\n  }, {\n    key: \"countCachedColumns\",\n    value: function countCachedColumns() {\n      return this.colToPropCache.length;\n    }\n    /**\n     * Returns data range as array.\n     *\n     * @param {object} [start] Start selection position. Visual indexes.\n     * @param {object} [end] End selection position. Visual indexes.\n     * @param {number} destination Destination of datamap.get.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getRange\",\n    value: function getRange(start, end, destination) {\n      var output = [];\n      var r;\n      var c;\n      var row;\n      var maxRows = this.tableMeta.maxRows;\n      var maxCols = this.tableMeta.maxCols;\n\n      if (maxRows === 0 || maxCols === 0) {\n        return [];\n      }\n\n      var getFn = destination === DataMap.DESTINATION_CLIPBOARD_GENERATOR ? this.getCopyable : this.get;\n      var rlen = Math.min(Math.max(maxRows - 1, 0), Math.max(start.row, end.row));\n      var clen = Math.min(Math.max(maxCols - 1, 0), Math.max(start.col, end.col));\n\n      for (r = Math.min(start.row, end.row); r <= rlen; r++) {\n        row = []; // We just store indexes for rows without headers.\n\n        var physicalRow = r >= 0 ? this.instance.toPhysicalRow(r) : r;\n\n        for (c = Math.min(start.col, end.col); c <= clen; c++) {\n          if (physicalRow === null) {\n            break;\n          }\n\n          row.push(getFn.call(this, r, this.colToProp(c)));\n        }\n\n        if (physicalRow !== null) {\n          output.push(row);\n        }\n      }\n\n      return output;\n    }\n    /**\n     * Return data as text (tab separated columns).\n     *\n     * @param {object} [start] Start selection position. Visual indexes.\n     * @param {object} [end] End selection position. Visual indexes.\n     * @returns {string}\n     */\n\n  }, {\n    key: \"getText\",\n    value: function getText(start, end) {\n      return stringify(this.getRange(start, end, DataMap.DESTINATION_RENDERER));\n    }\n    /**\n     * Return data as copyable text (tab separated columns intended for clipboard copy to an external application).\n     *\n     * @param {object} [start] Start selection position. Visual indexes.\n     * @param {object} [end] End selection position. Visual indexes.\n     * @returns {string}\n     */\n\n  }, {\n    key: \"getCopyableText\",\n    value: function getCopyableText(start, end) {\n      return stringify(this.getRange(start, end, DataMap.DESTINATION_CLIPBOARD_GENERATOR));\n    }\n    /**\n     * Destroy instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.instance = null;\n      this.tableMeta = null;\n      this.dataSource = null;\n      this.duckSchema = null;\n      this.colToPropCache.length = 0;\n      this.propToColCache.clear();\n      this.propToColCache = void 0;\n    }\n  }], [{\n    key: \"DESTINATION_RENDERER\",\n    get:\n    /**\n     * @type {number}\n     */\n    function get() {\n      return 1;\n    }\n    /**\n     * @type {number}\n     */\n\n  }, {\n    key: \"DESTINATION_CLIPBOARD_GENERATOR\",\n    get: function get() {\n      return 2;\n    }\n  }]);\n\n  return DataMap;\n}();\n\nexport default DataMap;"]},"metadata":{},"sourceType":"module"}