{"ast":null,"code":"import { arrayEach } from \"./../helpers/array.mjs\";\nimport { defineGetter, objectEach } from \"./../helpers/object.mjs\";\nvar MIXIN_NAME = 'hooksRefRegisterer';\n/**\n * Mixin object to extend objects functionality for auto registering hooks in an Handsontable instance.\n *\n * @type {object}\n */\n\nvar hooksRefRegisterer = {\n  /**\n   * Internal hooks storage.\n   */\n  _hooksStorage: Object.create(null),\n\n  /**\n   * Add hook to the collection.\n   *\n   * @param {string} key The hook name.\n   * @param {Function} callback The hook callback.\n   * @returns {object}\n   */\n  addHook: function addHook(key, callback) {\n    if (!this._hooksStorage[key]) {\n      this._hooksStorage[key] = [];\n    }\n\n    this.hot.addHook(key, callback);\n\n    this._hooksStorage[key].push(callback);\n\n    return this;\n  },\n\n  /**\n   * Remove all hooks listeners by hook name.\n   *\n   * @param {string} key The hook name.\n   */\n  removeHooksByKey: function removeHooksByKey(key) {\n    var _this = this;\n\n    arrayEach(this._hooksStorage[key] || [], function (callback) {\n      _this.hot.removeHook(key, callback);\n    });\n  },\n\n  /**\n   * Clear all added hooks.\n   */\n  clearHooks: function clearHooks() {\n    var _this2 = this;\n\n    objectEach(this._hooksStorage, function (callbacks, name) {\n      return _this2.removeHooksByKey(name);\n    });\n    this._hooksStorage = {};\n  }\n};\ndefineGetter(hooksRefRegisterer, 'MIXIN_NAME', MIXIN_NAME, {\n  writable: false,\n  enumerable: false\n});\nexport default hooksRefRegisterer;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/mixins/hooksRefRegisterer.mjs"],"names":["arrayEach","defineGetter","objectEach","MIXIN_NAME","hooksRefRegisterer","_hooksStorage","Object","create","addHook","key","callback","hot","push","removeHooksByKey","_this","removeHook","clearHooks","_this2","callbacks","name","writable","enumerable"],"mappings":"AAAA,SAASA,SAAT,QAA0B,wBAA1B;AACA,SAASC,YAAT,EAAuBC,UAAvB,QAAyC,yBAAzC;AACA,IAAIC,UAAU,GAAG,oBAAjB;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,kBAAkB,GAAG;AACvB;AACF;AACA;AACEC,EAAAA,aAAa,EAAEC,MAAM,CAACC,MAAP,CAAc,IAAd,CAJQ;;AAMvB;AACF;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,OAAO,EAAE,SAASA,OAAT,CAAiBC,GAAjB,EAAsBC,QAAtB,EAAgC;AACvC,QAAI,CAAC,KAAKL,aAAL,CAAmBI,GAAnB,CAAL,EAA8B;AAC5B,WAAKJ,aAAL,CAAmBI,GAAnB,IAA0B,EAA1B;AACD;;AAED,SAAKE,GAAL,CAASH,OAAT,CAAiBC,GAAjB,EAAsBC,QAAtB;;AAEA,SAAKL,aAAL,CAAmBI,GAAnB,EAAwBG,IAAxB,CAA6BF,QAA7B;;AAEA,WAAO,IAAP;AACD,GAvBsB;;AAyBvB;AACF;AACA;AACA;AACA;AACEG,EAAAA,gBAAgB,EAAE,SAASA,gBAAT,CAA0BJ,GAA1B,EAA+B;AAC/C,QAAIK,KAAK,GAAG,IAAZ;;AAEAd,IAAAA,SAAS,CAAC,KAAKK,aAAL,CAAmBI,GAAnB,KAA2B,EAA5B,EAAgC,UAAUC,QAAV,EAAoB;AAC3DI,MAAAA,KAAK,CAACH,GAAN,CAAUI,UAAV,CAAqBN,GAArB,EAA0BC,QAA1B;AACD,KAFQ,CAAT;AAGD,GApCsB;;AAsCvB;AACF;AACA;AACEM,EAAAA,UAAU,EAAE,SAASA,UAAT,GAAsB;AAChC,QAAIC,MAAM,GAAG,IAAb;;AAEAf,IAAAA,UAAU,CAAC,KAAKG,aAAN,EAAqB,UAAUa,SAAV,EAAqBC,IAArB,EAA2B;AACxD,aAAOF,MAAM,CAACJ,gBAAP,CAAwBM,IAAxB,CAAP;AACD,KAFS,CAAV;AAGA,SAAKd,aAAL,GAAqB,EAArB;AACD;AAhDsB,CAAzB;AAkDAJ,YAAY,CAACG,kBAAD,EAAqB,YAArB,EAAmCD,UAAnC,EAA+C;AACzDiB,EAAAA,QAAQ,EAAE,KAD+C;AAEzDC,EAAAA,UAAU,EAAE;AAF6C,CAA/C,CAAZ;AAIA,eAAejB,kBAAf","sourcesContent":["import { arrayEach } from \"./../helpers/array.mjs\";\nimport { defineGetter, objectEach } from \"./../helpers/object.mjs\";\nvar MIXIN_NAME = 'hooksRefRegisterer';\n/**\n * Mixin object to extend objects functionality for auto registering hooks in an Handsontable instance.\n *\n * @type {object}\n */\n\nvar hooksRefRegisterer = {\n  /**\n   * Internal hooks storage.\n   */\n  _hooksStorage: Object.create(null),\n\n  /**\n   * Add hook to the collection.\n   *\n   * @param {string} key The hook name.\n   * @param {Function} callback The hook callback.\n   * @returns {object}\n   */\n  addHook: function addHook(key, callback) {\n    if (!this._hooksStorage[key]) {\n      this._hooksStorage[key] = [];\n    }\n\n    this.hot.addHook(key, callback);\n\n    this._hooksStorage[key].push(callback);\n\n    return this;\n  },\n\n  /**\n   * Remove all hooks listeners by hook name.\n   *\n   * @param {string} key The hook name.\n   */\n  removeHooksByKey: function removeHooksByKey(key) {\n    var _this = this;\n\n    arrayEach(this._hooksStorage[key] || [], function (callback) {\n      _this.hot.removeHook(key, callback);\n    });\n  },\n\n  /**\n   * Clear all added hooks.\n   */\n  clearHooks: function clearHooks() {\n    var _this2 = this;\n\n    objectEach(this._hooksStorage, function (callbacks, name) {\n      return _this2.removeHooksByKey(name);\n    });\n    this._hooksStorage = {};\n  }\n};\ndefineGetter(hooksRefRegisterer, 'MIXIN_NAME', MIXIN_NAME, {\n  writable: false,\n  enumerable: false\n});\nexport default hooksRefRegisterer;"]},"metadata":{},"sourceType":"module"}