{"ast":null,"code":"import \"core-js/modules/web.immediate\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport { addClass, empty, removeClass } from \"./helpers/dom/element.mjs\";\nimport { isFunction } from \"./helpers/function.mjs\";\nimport { isDefined, isUndefined, isRegExp, _injectProductInfo, isEmpty } from \"./helpers/mixed.mjs\";\nimport { isMobileBrowser, isIpadOS } from \"./helpers/browser.mjs\";\nimport EditorManager from \"./editorManager.mjs\";\nimport EventManager from \"./eventManager.mjs\";\nimport { deepClone, duckSchema, isObjectEqual, deepObjectSize, hasOwnProperty, createObjectPropListener, objectEach } from \"./helpers/object.mjs\";\nimport { arrayMap, arrayEach, arrayReduce, getDifferenceOfArrays, stringToArray } from \"./helpers/array.mjs\";\nimport { instanceToHTML } from \"./utils/parseTable.mjs\";\nimport { getPlugin, getPluginsNames } from \"./plugins/registry.mjs\";\nimport { getRenderer } from \"./renderers/registry.mjs\";\nimport { getValidator } from \"./validators/registry.mjs\";\nimport { randomString, toUpperCaseFirst } from \"./helpers/string.mjs\";\nimport { rangeEach, rangeEachReverse } from \"./helpers/number.mjs\";\nimport TableView from \"./tableView.mjs\";\nimport DataSource from \"./dataSource.mjs\";\nimport { translateRowsToColumns, cellMethodLookupFactory, spreadsheetColumnLabel } from \"./helpers/data.mjs\";\nimport { IndexMapper } from \"./translations/index.mjs\";\nimport { registerAsRootInstance, hasValidParameter, isRootInstance } from \"./utils/rootInstance.mjs\";\nimport { CellCoords, ViewportColumnsCalculator } from \"./3rdparty/walkontable/src/index.mjs\";\nimport Hooks from \"./pluginHooks.mjs\";\nimport { hasLanguageDictionary, getValidLanguageCode, getTranslatedPhrase } from \"./i18n/registry.mjs\";\nimport { warnUserAboutLanguageRegistration, normalizeLanguageCode } from \"./i18n/utils.mjs\";\nimport { startObserving as keyStateStartObserving, stopObserving as keyStateStopObserving } from \"./utils/keyStateObserver.mjs\";\nimport { Selection } from \"./selection/index.mjs\";\nimport { MetaManager, DataMap } from \"./dataMap/index.mjs\";\nimport { createUniqueMap } from \"./utils/dataStructures/uniqueMap.mjs\";\nvar activeGuid = null;\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * Handsontable constructor.\n *\n * @core\n * @class Core\n * @description\n * After Handsontable is constructed, you can modify the grid behavior using the available public methods.\n *\n * ## How to call methods.\n *\n * These are 2 equal ways to call a Handsontable method:\n *\n * ```js\n * // all following examples assume that you constructed Handsontable like this\n * const hot = new Handsontable(document.getElementById('example1'), options);\n *\n * // now, to use setDataAtCell method, you can either:\n * hot.setDataAtCell(0, 0, 'new value');\n * ```\n *\n * Alternatively, you can call the method using jQuery wrapper (__obsolete__, requires initialization using our jQuery guide\n * ```js\n * $('#example1').handsontable('setDataAtCell', 0, 0, 'new value');\n * ```\n *\n * @param {HTMLElement} rootElement The element to which the Handsontable instance is injected.\n * @param {object} userSettings The user defined options.\n * @param {boolean} [rootInstanceSymbol=false] Indicates if the instance is root of all later instances created.\n */\n\nexport default function Core(rootElement, userSettings) {\n  var _this = this;\n\n  var rootInstanceSymbol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var preventScrollingToCell = false;\n  var instance = this;\n  var eventManager = new EventManager(instance);\n  var datamap;\n  var dataSource;\n  var grid;\n  var editorManager;\n  var firstRun = true;\n  userSettings.language = getValidLanguageCode(userSettings.language);\n  var metaManager = new MetaManager(userSettings);\n  var tableMeta = metaManager.getTableMeta();\n  var globalMeta = metaManager.getGlobalMeta();\n  var pluginsRegistry = createUniqueMap();\n\n  if (hasValidParameter(rootInstanceSymbol)) {\n    registerAsRootInstance(this);\n  } // TODO: check if references to DOM elements should be move to UI layer (Walkontable)\n\n  /**\n   * Reference to the container element.\n   *\n   * @private\n   * @type {HTMLElement}\n   */\n\n\n  this.rootElement = rootElement;\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  /**\n   * The nearest document over container.\n   *\n   * @private\n   * @type {Document}\n   */\n\n  this.rootDocument = rootElement.ownerDocument;\n  /**\n   * Window object over container's document.\n   *\n   * @private\n   * @type {Window}\n   */\n\n  this.rootWindow = this.rootDocument.defaultView;\n  /**\n   * A boolean to tell if the Handsontable has been fully destroyed. This is set to `true`\n   * after `afterDestroy` hook is called.\n   *\n   * @memberof Core#\n   * @member isDestroyed\n   * @type {boolean}\n   */\n\n  this.isDestroyed = false;\n  /**\n   * The counter determines how many times the render suspending was called. It allows\n   * tracking the nested suspending calls. For each render suspend resuming call the\n   * counter is decremented. The value equal to 0 means the render suspending feature\n   * is disabled.\n   *\n   * @private\n   * @type {number}\n   */\n\n  this.renderSuspendedCounter = 0;\n  /**\n   * The counter determines how many times the execution suspending was called. It allows\n   * tracking the nested suspending calls. For each execution suspend resuming call the\n   * counter is decremented. The value equal to 0 means the execution suspending feature\n   * is disabled.\n   *\n   * @private\n   * @type {number}\n   */\n\n  this.executionSuspendedCounter = 0;\n  keyStateStartObserving(this.rootDocument);\n  this.container = this.rootDocument.createElement('div');\n  this.renderCall = false;\n  rootElement.insertBefore(this.container, rootElement.firstChild);\n\n  if (isRootInstance(this)) {\n    _injectProductInfo(userSettings.licenseKey, rootElement);\n  }\n\n  this.guid = \"ht_\".concat(randomString()); // this is the namespace for global events\n\n  /**\n   * Instance of index mapper which is responsible for managing the column indexes.\n   *\n   * @memberof Core#\n   * @member columnIndexMapper\n   * @type {IndexMapper}\n   */\n\n  this.columnIndexMapper = new IndexMapper();\n  /**\n   * Instance of index mapper which is responsible for managing the row indexes.\n   *\n   * @memberof Core#\n   * @member rowIndexMapper\n   * @type {IndexMapper}\n   */\n\n  this.rowIndexMapper = new IndexMapper();\n  dataSource = new DataSource(instance);\n\n  if (!this.rootElement.id || this.rootElement.id.substring(0, 3) === 'ht_') {\n    this.rootElement.id = this.guid; // if root element does not have an id, assign a random id\n  }\n\n  var visualToRenderableCoords = function visualToRenderableCoords(coords) {\n    var visualRow = coords.row,\n        visualColumn = coords.col;\n    return new CellCoords( // We just store indexes for rows and columns without headers.\n    visualRow >= 0 ? instance.rowIndexMapper.getRenderableFromVisualIndex(visualRow) : visualRow, visualColumn >= 0 ? instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumn) : visualColumn);\n  };\n\n  var renderableToVisualCoords = function renderableToVisualCoords(coords) {\n    var renderableRow = coords.row,\n        renderableColumn = coords.col;\n    return new CellCoords( // We just store indexes for rows and columns without headers.\n    renderableRow >= 0 ? instance.rowIndexMapper.getVisualFromRenderableIndex(renderableRow) : renderableRow, renderableColumn >= 0 ? instance.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn) : renderableColumn // eslint-disable-line max-len\n    );\n  };\n\n  var selection = new Selection(tableMeta, {\n    countCols: function countCols() {\n      return instance.countCols();\n    },\n    countRows: function countRows() {\n      return instance.countRows();\n    },\n    propToCol: function propToCol(prop) {\n      return datamap.propToCol(prop);\n    },\n    isEditorOpened: function isEditorOpened() {\n      return instance.getActiveEditor() ? instance.getActiveEditor().isOpened() : false;\n    },\n    countColsTranslated: function countColsTranslated() {\n      return _this.view.countRenderableColumns();\n    },\n    countRowsTranslated: function countRowsTranslated() {\n      return _this.view.countRenderableRows();\n    },\n    visualToRenderableCoords: visualToRenderableCoords,\n    renderableToVisualCoords: renderableToVisualCoords,\n    isDisabledCellSelection: function isDisabledCellSelection(visualRow, visualColumn) {\n      return instance.getCellMeta(visualRow, visualColumn).disableVisualSelection;\n    }\n  });\n  this.selection = selection;\n\n  var onIndexMapperCacheUpdate = function onIndexMapperCacheUpdate(_ref) {\n    var hiddenIndexesChanged = _ref.hiddenIndexesChanged;\n\n    if (hiddenIndexesChanged) {\n      _this.selection.refresh();\n    }\n  };\n\n  this.columnIndexMapper.addLocalHook('cacheUpdated', onIndexMapperCacheUpdate);\n  this.rowIndexMapper.addLocalHook('cacheUpdated', onIndexMapperCacheUpdate);\n  this.selection.addLocalHook('beforeSetRangeStart', function (cellCoords) {\n    _this.runHooks('beforeSetRangeStart', cellCoords);\n  });\n  this.selection.addLocalHook('beforeSetRangeStartOnly', function (cellCoords) {\n    _this.runHooks('beforeSetRangeStartOnly', cellCoords);\n  });\n  this.selection.addLocalHook('beforeSetRangeEnd', function (cellCoords) {\n    _this.runHooks('beforeSetRangeEnd', cellCoords);\n\n    if (cellCoords.row < 0) {\n      cellCoords.row = _this.view.wt.wtTable.getFirstVisibleRow();\n    }\n\n    if (cellCoords.col < 0) {\n      cellCoords.col = _this.view.wt.wtTable.getFirstVisibleColumn();\n    }\n  });\n  this.selection.addLocalHook('afterSetRangeEnd', function (cellCoords) {\n    var preventScrolling = createObjectPropListener(false);\n\n    var selectionRange = _this.selection.getSelectedRange();\n\n    var _selectionRange$curre = selectionRange.current(),\n        from = _selectionRange$curre.from,\n        to = _selectionRange$curre.to;\n\n    var selectionLayerLevel = selectionRange.size() - 1;\n\n    _this.runHooks('afterSelection', from.row, from.col, to.row, to.col, preventScrolling, selectionLayerLevel);\n\n    _this.runHooks('afterSelectionByProp', from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), preventScrolling, selectionLayerLevel); // eslint-disable-line max-len\n\n\n    var isSelectedByAnyHeader = _this.selection.isSelectedByAnyHeader();\n\n    var currentSelectedRange = _this.selection.selectedRange.current();\n\n    var scrollToCell = true;\n\n    if (preventScrollingToCell) {\n      scrollToCell = false;\n    }\n\n    if (preventScrolling.isTouched()) {\n      scrollToCell = !preventScrolling.value;\n    }\n\n    var isSelectedByRowHeader = _this.selection.isSelectedByRowHeader();\n\n    var isSelectedByColumnHeader = _this.selection.isSelectedByColumnHeader();\n\n    if (scrollToCell !== false) {\n      if (!isSelectedByAnyHeader) {\n        if (currentSelectedRange && !_this.selection.isMultiple()) {\n          _this.view.scrollViewport(visualToRenderableCoords(currentSelectedRange.from));\n        } else {\n          _this.view.scrollViewport(visualToRenderableCoords(cellCoords));\n        }\n      } else if (isSelectedByRowHeader) {\n        _this.view.scrollViewportVertically(instance.rowIndexMapper.getRenderableFromVisualIndex(cellCoords.row));\n      } else if (isSelectedByColumnHeader) {\n        _this.view.scrollViewportHorizontally(instance.columnIndexMapper.getRenderableFromVisualIndex(cellCoords.col));\n      }\n    } // @TODO: These CSS classes are no longer needed anymore. They are used only as a indicator of the selected\n    // rows/columns in the MergedCells plugin (via border.js#L520 in the walkontable module). After fixing\n    // the Border class this should be removed.\n\n\n    if (isSelectedByRowHeader && isSelectedByColumnHeader) {\n      addClass(_this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n    } else if (isSelectedByRowHeader) {\n      removeClass(_this.rootElement, 'ht__selection--columns');\n      addClass(_this.rootElement, 'ht__selection--rows');\n    } else if (isSelectedByColumnHeader) {\n      removeClass(_this.rootElement, 'ht__selection--rows');\n      addClass(_this.rootElement, 'ht__selection--columns');\n    } else {\n      removeClass(_this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n    }\n\n    _this._refreshBorders(null);\n  });\n  this.selection.addLocalHook('afterSelectionFinished', function (cellRanges) {\n    var selectionLayerLevel = cellRanges.length - 1;\n    var _cellRanges$selection = cellRanges[selectionLayerLevel],\n        from = _cellRanges$selection.from,\n        to = _cellRanges$selection.to;\n\n    _this.runHooks('afterSelectionEnd', from.row, from.col, to.row, to.col, selectionLayerLevel);\n\n    _this.runHooks('afterSelectionEndByProp', from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), selectionLayerLevel);\n  });\n  this.selection.addLocalHook('afterIsMultipleSelection', function (isMultiple) {\n    var changedIsMultiple = _this.runHooks('afterIsMultipleSelection', isMultiple.value);\n\n    if (isMultiple.value) {\n      isMultiple.value = changedIsMultiple;\n    }\n  });\n  this.selection.addLocalHook('beforeModifyTransformStart', function (cellCoordsDelta) {\n    _this.runHooks('modifyTransformStart', cellCoordsDelta);\n  });\n  this.selection.addLocalHook('afterModifyTransformStart', function (coords, rowTransformDir, colTransformDir) {\n    _this.runHooks('afterModifyTransformStart', coords, rowTransformDir, colTransformDir);\n  });\n  this.selection.addLocalHook('beforeModifyTransformEnd', function (cellCoordsDelta) {\n    _this.runHooks('modifyTransformEnd', cellCoordsDelta);\n  });\n  this.selection.addLocalHook('afterModifyTransformEnd', function (coords, rowTransformDir, colTransformDir) {\n    _this.runHooks('afterModifyTransformEnd', coords, rowTransformDir, colTransformDir);\n  });\n  this.selection.addLocalHook('afterDeselect', function () {\n    editorManager.destroyEditor();\n\n    _this._refreshBorders();\n\n    removeClass(_this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n\n    _this.runHooks('afterDeselect');\n  });\n  this.selection.addLocalHook('insertRowRequire', function (totalRows) {\n    _this.alter('insert_row', totalRows, 1, 'auto');\n  });\n  this.selection.addLocalHook('insertColRequire', function (totalCols) {\n    _this.alter('insert_col', totalCols, 1, 'auto');\n  });\n  grid = {\n    /**\n     * Inserts or removes rows and columns.\n     *\n     * @memberof Core#\n     * @function alter\n     * @private\n     * @param {string} action Possible values: \"insert_row\", \"insert_col\", \"remove_row\", \"remove_col\".\n     * @param {number|Array} index Row or column visual index which from the alter action will be triggered.\n     *                             Alter actions such as \"remove_row\" and \"remove_col\" support array indexes in the\n     *                             format `[[index, amount], [index, amount]...]` this can be used to remove\n     *                             non-consecutive columns or rows in one call.\n     * @param {number} [amount=1] Ammount rows or columns to remove.\n     * @param {string} [source] Optional. Source of hook runner.\n     * @param {boolean} [keepEmptyRows] Optional. Flag for preventing deletion of empty rows.\n     */\n    alter: function alter(action, index) {\n      var amount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var source = arguments.length > 3 ? arguments[3] : undefined;\n      var keepEmptyRows = arguments.length > 4 ? arguments[4] : undefined;\n      var delta;\n\n      var normalizeIndexesGroup = function normalizeIndexesGroup(indexes) {\n        if (indexes.length === 0) {\n          return [];\n        }\n\n        var sortedIndexes = _toConsumableArray(indexes); // Sort the indexes in ascending order.\n\n\n        sortedIndexes.sort(function (_ref2, _ref3) {\n          var _ref4 = _slicedToArray(_ref2, 1),\n              indexA = _ref4[0];\n\n          var _ref5 = _slicedToArray(_ref3, 1),\n              indexB = _ref5[0];\n\n          if (indexA === indexB) {\n            return 0;\n          }\n\n          return indexA > indexB ? 1 : -1;\n        }); // Normalize the {index, amount} groups into bigger groups.\n\n        var normalizedIndexes = arrayReduce(sortedIndexes, function (acc, _ref6) {\n          var _ref7 = _slicedToArray(_ref6, 2),\n              groupIndex = _ref7[0],\n              groupAmount = _ref7[1];\n\n          var previousItem = acc[acc.length - 1];\n\n          var _previousItem = _slicedToArray(previousItem, 2),\n              prevIndex = _previousItem[0],\n              prevAmount = _previousItem[1];\n\n          var prevLastIndex = prevIndex + prevAmount;\n\n          if (groupIndex <= prevLastIndex) {\n            var amountToAdd = Math.max(groupAmount - (prevLastIndex - groupIndex), 0);\n            previousItem[1] += amountToAdd;\n          } else {\n            acc.push([groupIndex, groupAmount]);\n          }\n\n          return acc;\n        }, [sortedIndexes[0]]);\n        return normalizedIndexes;\n      };\n      /* eslint-disable no-case-declarations */\n\n\n      switch (action) {\n        case 'insert_row':\n          var numberOfSourceRows = instance.countSourceRows();\n\n          if (tableMeta.maxRows === numberOfSourceRows) {\n            return;\n          } // eslint-disable-next-line no-param-reassign\n\n\n          index = isDefined(index) ? index : numberOfSourceRows;\n          delta = datamap.createRow(index, amount, source);\n\n          if (delta) {\n            metaManager.createRow(instance.toPhysicalRow(index), amount);\n            var currentSelectedRange = selection.selectedRange.current();\n            var currentFromRange = currentSelectedRange === null || currentSelectedRange === void 0 ? void 0 : currentSelectedRange.from;\n            var currentFromRow = currentFromRange === null || currentFromRange === void 0 ? void 0 : currentFromRange.row; // Moving down the selection (when it exist). It should be present on the \"old\" row.\n            // TODO: The logic here should be handled by selection module.\n\n            if (isDefined(currentFromRow) && currentFromRow >= index) {\n              var _currentSelectedRange = currentSelectedRange.to,\n                  currentToRow = _currentSelectedRange.row,\n                  currentToColumn = _currentSelectedRange.col;\n              var currentFromColumn = currentFromRange.col; // Workaround: headers are not stored inside selection.\n\n              if (selection.isSelectedByRowHeader()) {\n                currentFromColumn = -1;\n              } // Remove from the stack the last added selection as that selection below will be\n              // replaced by new transformed selection.\n\n\n              selection.getSelectedRange().pop(); // I can't use transforms as they don't work in negative indexes.\n\n              selection.setRangeStartOnly(new CellCoords(currentFromRow + delta, currentFromColumn), true);\n              selection.setRangeEnd(new CellCoords(currentToRow + delta, currentToColumn)); // will call render() internally\n            } else {\n              instance._refreshBorders(); // it will call render and prepare methods\n\n            }\n          }\n\n          break;\n\n        case 'insert_col':\n          delta = datamap.createCol(index, amount, source);\n\n          if (delta) {\n            metaManager.createColumn(instance.toPhysicalColumn(index), amount);\n\n            if (Array.isArray(tableMeta.colHeaders)) {\n              var spliceArray = [index, 0];\n              spliceArray.length += delta; // inserts empty (undefined) elements at the end of an array\n\n              Array.prototype.splice.apply(tableMeta.colHeaders, spliceArray); // inserts empty (undefined) elements into the colHeader array\n            }\n\n            var _currentSelectedRange2 = selection.selectedRange.current();\n\n            var _currentFromRange = _currentSelectedRange2 === null || _currentSelectedRange2 === void 0 ? void 0 : _currentSelectedRange2.from;\n\n            var _currentFromColumn = _currentFromRange === null || _currentFromRange === void 0 ? void 0 : _currentFromRange.col; // Moving right the selection (when it exist). It should be present on the \"old\" row.\n            // TODO: The logic here should be handled by selection module.\n\n\n            if (isDefined(_currentFromColumn) && _currentFromColumn >= index) {\n              var _currentSelectedRange3 = _currentSelectedRange2.to,\n                  _currentToRow = _currentSelectedRange3.row,\n                  _currentToColumn = _currentSelectedRange3.col;\n              var _currentFromRow = _currentFromRange.row; // Workaround: headers are not stored inside selection.\n\n              if (selection.isSelectedByColumnHeader()) {\n                _currentFromRow = -1;\n              } // Remove from the stack the last added selection as that selection below will be\n              // replaced by new transformed selection.\n\n\n              selection.getSelectedRange().pop(); // I can't use transforms as they don't work in negative indexes.\n\n              selection.setRangeStartOnly(new CellCoords(_currentFromRow, _currentFromColumn + delta), true);\n              selection.setRangeEnd(new CellCoords(_currentToRow, _currentToColumn + delta)); // will call render() internally\n            } else {\n              instance._refreshBorders(); // it will call render and prepare methods\n\n            }\n          }\n\n          break;\n\n        case 'remove_row':\n          var removeRow = function removeRow(indexes) {\n            var offset = 0; // Normalize the {index, amount} groups into bigger groups.\n\n            arrayEach(indexes, function (_ref8) {\n              var _ref9 = _slicedToArray(_ref8, 2),\n                  groupIndex = _ref9[0],\n                  groupAmount = _ref9[1];\n\n              var calcIndex = isEmpty(groupIndex) ? instance.countRows() - 1 : Math.max(groupIndex - offset, 0); // If the 'index' is an integer decrease it by 'offset' otherwise pass it through to make the value\n              // compatible with datamap.removeCol method.\n\n              if (Number.isInteger(groupIndex)) {\n                // eslint-disable-next-line no-param-reassign\n                groupIndex = Math.max(groupIndex - offset, 0);\n              } // TODO: for datamap.removeRow index should be passed as it is (with undefined and null values). If not, the logic\n              // inside the datamap.removeRow breaks the removing functionality.\n\n\n              var wasRemoved = datamap.removeRow(groupIndex, groupAmount, source);\n\n              if (!wasRemoved) {\n                return;\n              }\n\n              metaManager.removeRow(instance.toPhysicalRow(calcIndex), groupAmount);\n              var totalRows = instance.countRows();\n              var fixedRowsTop = tableMeta.fixedRowsTop;\n\n              if (fixedRowsTop >= calcIndex + 1) {\n                tableMeta.fixedRowsTop -= Math.min(groupAmount, fixedRowsTop - calcIndex);\n              }\n\n              var fixedRowsBottom = tableMeta.fixedRowsBottom;\n\n              if (fixedRowsBottom && calcIndex >= totalRows - fixedRowsBottom) {\n                tableMeta.fixedRowsBottom -= Math.min(groupAmount, fixedRowsBottom);\n              }\n\n              offset += groupAmount;\n            });\n          };\n\n          if (Array.isArray(index)) {\n            removeRow(normalizeIndexesGroup(index));\n          } else {\n            removeRow([[index, amount]]);\n          }\n\n          grid.adjustRowsAndCols();\n\n          instance._refreshBorders(); // it will call render and prepare methods\n\n\n          break;\n\n        case 'remove_col':\n          var removeCol = function removeCol(indexes) {\n            var offset = 0; // Normalize the {index, amount} groups into bigger groups.\n\n            arrayEach(indexes, function (_ref10) {\n              var _ref11 = _slicedToArray(_ref10, 2),\n                  groupIndex = _ref11[0],\n                  groupAmount = _ref11[1];\n\n              var calcIndex = isEmpty(groupIndex) ? instance.countCols() - 1 : Math.max(groupIndex - offset, 0);\n              var physicalColumnIndex = instance.toPhysicalColumn(calcIndex); // If the 'index' is an integer decrease it by 'offset' otherwise pass it through to make the value\n              // compatible with datamap.removeCol method.\n\n              if (Number.isInteger(groupIndex)) {\n                // eslint-disable-next-line no-param-reassign\n                groupIndex = Math.max(groupIndex - offset, 0);\n              } // TODO: for datamap.removeCol index should be passed as it is (with undefined and null values). If not, the logic\n              // inside the datamap.removeCol breaks the removing functionality.\n\n\n              var wasRemoved = datamap.removeCol(groupIndex, groupAmount, source);\n\n              if (!wasRemoved) {\n                return;\n              }\n\n              metaManager.removeColumn(physicalColumnIndex, groupAmount);\n              var fixedColumnsLeft = tableMeta.fixedColumnsLeft;\n\n              if (fixedColumnsLeft >= calcIndex + 1) {\n                tableMeta.fixedColumnsLeft -= Math.min(groupAmount, fixedColumnsLeft - calcIndex);\n              }\n\n              if (Array.isArray(tableMeta.colHeaders)) {\n                if (typeof physicalColumnIndex === 'undefined') {\n                  physicalColumnIndex = -1;\n                }\n\n                tableMeta.colHeaders.splice(physicalColumnIndex, groupAmount);\n              }\n\n              offset += groupAmount;\n            });\n          };\n\n          if (Array.isArray(index)) {\n            removeCol(normalizeIndexesGroup(index));\n          } else {\n            removeCol([[index, amount]]);\n          }\n\n          grid.adjustRowsAndCols();\n\n          instance._refreshBorders(); // it will call render and prepare methods\n\n\n          break;\n\n        default:\n          throw new Error(\"There is no such action \\\"\".concat(action, \"\\\"\"));\n      }\n\n      if (!keepEmptyRows) {\n        grid.adjustRowsAndCols(); // makes sure that we did not add rows that will be removed in next refresh\n      }\n    },\n\n    /**\n     * Makes sure there are empty rows at the bottom of the table.\n     */\n    adjustRowsAndCols: function adjustRowsAndCols() {\n      var minRows = tableMeta.minRows;\n      var minSpareRows = tableMeta.minSpareRows;\n      var minCols = tableMeta.minCols;\n      var minSpareCols = tableMeta.minSpareCols;\n\n      if (minRows) {\n        // should I add empty rows to data source to meet minRows?\n        var nrOfRows = instance.countRows();\n\n        if (nrOfRows < minRows) {\n          // The synchronization with cell meta is not desired here. For `minRows` option,\n          // we don't want to touch/shift cell meta objects.\n          datamap.createRow(nrOfRows, minRows - nrOfRows, 'auto');\n        }\n      }\n\n      if (minSpareRows) {\n        var emptyRows = instance.countEmptyRows(true); // should I add empty rows to meet minSpareRows?\n\n        if (emptyRows < minSpareRows) {\n          var emptyRowsMissing = minSpareRows - emptyRows;\n          var rowsToCreate = Math.min(emptyRowsMissing, tableMeta.maxRows - instance.countSourceRows()); // The synchronization with cell meta is not desired here. For `minSpareRows` option,\n          // we don't want to touch/shift cell meta objects.\n\n          datamap.createRow(instance.countRows(), rowsToCreate, 'auto');\n        }\n      }\n\n      {\n        var emptyCols; // count currently empty cols\n\n        if (minCols || minSpareCols) {\n          emptyCols = instance.countEmptyCols(true);\n        }\n\n        var nrOfColumns = instance.countCols(); // should I add empty cols to meet minCols?\n\n        if (minCols && !tableMeta.columns && nrOfColumns < minCols) {\n          // The synchronization with cell meta is not desired here. For `minSpareRows` option,\n          // we don't want to touch/shift cell meta objects.\n          var colsToCreate = minCols - nrOfColumns;\n          emptyCols += colsToCreate;\n          datamap.createCol(nrOfColumns, colsToCreate, 'auto');\n        } // should I add empty cols to meet minSpareCols?\n\n\n        if (minSpareCols && !tableMeta.columns && instance.dataType === 'array' && emptyCols < minSpareCols) {\n          nrOfColumns = instance.countCols();\n          var emptyColsMissing = minSpareCols - emptyCols;\n\n          var _colsToCreate = Math.min(emptyColsMissing, tableMeta.maxCols - nrOfColumns); // The synchronization with cell meta is not desired here. For `minSpareRows` option,\n          // we don't want to touch/shift cell meta objects.\n\n\n          datamap.createCol(nrOfColumns, _colsToCreate, 'auto');\n        }\n      }\n      var rowCount = instance.countRows();\n      var colCount = instance.countCols();\n\n      if (rowCount === 0 || colCount === 0) {\n        selection.deselect();\n      }\n\n      if (selection.isSelected()) {\n        arrayEach(selection.selectedRange, function (range) {\n          var selectionChanged = false;\n          var fromRow = range.from.row;\n          var fromCol = range.from.col;\n          var toRow = range.to.row;\n          var toCol = range.to.col; // if selection is outside, move selection to last row\n\n          if (fromRow > rowCount - 1) {\n            fromRow = rowCount - 1;\n            selectionChanged = true;\n\n            if (toRow > fromRow) {\n              toRow = fromRow;\n            }\n          } else if (toRow > rowCount - 1) {\n            toRow = rowCount - 1;\n            selectionChanged = true;\n\n            if (fromRow > toRow) {\n              fromRow = toRow;\n            }\n          } // if selection is outside, move selection to last row\n\n\n          if (fromCol > colCount - 1) {\n            fromCol = colCount - 1;\n            selectionChanged = true;\n\n            if (toCol > fromCol) {\n              toCol = fromCol;\n            }\n          } else if (toCol > colCount - 1) {\n            toCol = colCount - 1;\n            selectionChanged = true;\n\n            if (fromCol > toCol) {\n              fromCol = toCol;\n            }\n          }\n\n          if (selectionChanged) {\n            instance.selectCell(fromRow, fromCol, toRow, toCol);\n          }\n        });\n      }\n\n      if (instance.view) {\n        instance.view.adjustElementsSize();\n      }\n    },\n\n    /**\n     * Populate the data from the provided 2d array from the given cell coordinates.\n     *\n     * @private\n     * @param {object} start Start selection position. Visual indexes.\n     * @param {Array} input 2d data array.\n     * @param {object} [end] End selection position (only for drag-down mode). Visual indexes.\n     * @param {string} [source=\"populateFromArray\"] Source information string.\n     * @param {string} [method=\"overwrite\"] Populate method. Possible options: `shift_down`, `shift_right`, `overwrite`.\n     * @param {string} direction (left|right|up|down) String specifying the direction.\n     * @param {Array} deltas The deltas array. A difference between values of adjacent cells.\n     *                       Useful **only** when the type of handled cells is `numeric`.\n     * @returns {object|undefined} Ending td in pasted area (only if any cell was changed).\n     */\n    populateFromArray: function populateFromArray(start, input, end, source, method, direction, deltas) {\n      // TODO: either remove or implement the `direction` argument. Currently it's not working at all.\n      var r;\n      var rlen;\n      var c;\n      var clen;\n      var setData = [];\n      var current = {};\n      rlen = input.length;\n\n      if (rlen === 0) {\n        return false;\n      }\n\n      var repeatCol;\n      var repeatRow;\n      var cmax;\n      var rmax;\n      /* eslint-disable no-case-declarations */\n      // insert data with specified pasteMode method\n\n      switch (method) {\n        case 'shift_down':\n          repeatCol = end ? end.col - start.col + 1 : 0;\n          repeatRow = end ? end.row - start.row + 1 : 0; // eslint-disable-next-line no-param-reassign\n\n          input = translateRowsToColumns(input);\n\n          for (c = 0, clen = input.length, cmax = Math.max(clen, repeatCol); c < cmax; c++) {\n            if (c < clen) {\n              var _instance;\n\n              for (r = 0, rlen = input[c].length; r < repeatRow - rlen; r++) {\n                input[c].push(input[c][r % rlen]);\n              }\n\n              input[c].unshift(start.col + c, start.row, 0);\n\n              (_instance = instance).spliceCol.apply(_instance, _toConsumableArray(input[c]));\n            } else {\n              var _instance2;\n\n              input[c % clen][0] = start.col + c;\n\n              (_instance2 = instance).spliceCol.apply(_instance2, _toConsumableArray(input[c % clen]));\n            }\n          }\n\n          break;\n\n        case 'shift_right':\n          repeatCol = end ? end.col - start.col + 1 : 0;\n          repeatRow = end ? end.row - start.row + 1 : 0;\n\n          for (r = 0, rlen = input.length, rmax = Math.max(rlen, repeatRow); r < rmax; r++) {\n            if (r < rlen) {\n              var _instance3;\n\n              for (c = 0, clen = input[r].length; c < repeatCol - clen; c++) {\n                input[r].push(input[r][c % clen]);\n              }\n\n              input[r].unshift(start.row + r, start.col, 0);\n\n              (_instance3 = instance).spliceRow.apply(_instance3, _toConsumableArray(input[r]));\n            } else {\n              var _instance4;\n\n              input[r % rlen][0] = start.row + r;\n\n              (_instance4 = instance).spliceRow.apply(_instance4, _toConsumableArray(input[r % rlen]));\n            }\n          }\n\n          break;\n\n        case 'overwrite':\n        default:\n          // overwrite and other not specified options\n          current.row = start.row;\n          current.col = start.col;\n          var selected = {\n            // selected range\n            row: end && start ? end.row - start.row + 1 : 1,\n            col: end && start ? end.col - start.col + 1 : 1\n          };\n          var skippedRow = 0;\n          var skippedColumn = 0;\n          var pushData = true;\n          var cellMeta;\n\n          var getInputValue = function getInputValue(row) {\n            var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            var rowValue = input[row % input.length];\n\n            if (col !== null) {\n              return rowValue[col % rowValue.length];\n            }\n\n            return rowValue;\n          };\n\n          var rowInputLength = input.length;\n          var rowSelectionLength = end ? end.row - start.row + 1 : 0;\n\n          if (end) {\n            rlen = rowSelectionLength;\n          } else {\n            rlen = Math.max(rowInputLength, rowSelectionLength);\n          }\n\n          for (r = 0; r < rlen; r++) {\n            if (end && current.row > end.row && rowSelectionLength > rowInputLength || !tableMeta.allowInsertRow && current.row > instance.countRows() - 1 || current.row >= tableMeta.maxRows) {\n              break;\n            }\n\n            var visualRow = r - skippedRow;\n            var colInputLength = getInputValue(visualRow).length;\n            var colSelectionLength = end ? end.col - start.col + 1 : 0;\n\n            if (end) {\n              clen = colSelectionLength;\n            } else {\n              clen = Math.max(colInputLength, colSelectionLength);\n            }\n\n            current.col = start.col;\n            cellMeta = instance.getCellMeta(current.row, current.col);\n\n            if ((source === 'CopyPaste.paste' || source === 'Autofill.fill') && cellMeta.skipRowOnPaste) {\n              skippedRow += 1;\n              current.row += 1;\n              rlen += 1;\n              /* eslint-disable no-continue */\n\n              continue;\n            }\n\n            skippedColumn = 0;\n\n            for (c = 0; c < clen; c++) {\n              if (end && current.col > end.col && colSelectionLength > colInputLength || !tableMeta.allowInsertColumn && current.col > instance.countCols() - 1 || current.col >= tableMeta.maxCols) {\n                break;\n              }\n\n              cellMeta = instance.getCellMeta(current.row, current.col);\n\n              if ((source === 'CopyPaste.paste' || source === 'Autofill.fill') && cellMeta.skipColumnOnPaste) {\n                skippedColumn += 1;\n                current.col += 1;\n                clen += 1;\n                continue;\n              }\n\n              if (cellMeta.readOnly && source !== 'UndoRedo.undo') {\n                current.col += 1;\n                /* eslint-disable no-continue */\n\n                continue;\n              }\n\n              var visualColumn = c - skippedColumn;\n              var value = getInputValue(visualRow, visualColumn);\n              var orgValue = instance.getDataAtCell(current.row, current.col);\n              var index = {\n                row: visualRow,\n                col: visualColumn\n              };\n\n              if (source === 'Autofill.fill') {\n                var result = instance.runHooks('beforeAutofillInsidePopulate', index, direction, input, deltas, {}, selected);\n\n                if (result) {\n                  value = isUndefined(result.value) ? value : result.value;\n                }\n              }\n\n              if (value !== null && _typeof(value) === 'object') {\n                // when 'value' is array and 'orgValue' is null, set 'orgValue' to\n                // an empty array so that the null value can be compared to 'value'\n                // as an empty value for the array context\n                if (Array.isArray(value) && orgValue === null) orgValue = [];\n\n                if (orgValue === null || _typeof(orgValue) !== 'object') {\n                  pushData = false;\n                } else {\n                  var orgValueSchema = duckSchema(Array.isArray(orgValue) ? orgValue : orgValue[0] || orgValue);\n                  var valueSchema = duckSchema(Array.isArray(value) ? value : value[0] || value);\n                  /* eslint-disable max-depth */\n\n                  if (isObjectEqual(orgValueSchema, valueSchema)) {\n                    value = deepClone(value);\n                  } else {\n                    pushData = false;\n                  }\n                }\n              } else if (orgValue !== null && _typeof(orgValue) === 'object') {\n                pushData = false;\n              }\n\n              if (pushData) {\n                setData.push([current.row, current.col, value]);\n              }\n\n              pushData = true;\n              current.col += 1;\n            }\n\n            current.row += 1;\n          }\n\n          instance.setDataAtCell(setData, null, null, source || 'populateFromArray');\n          break;\n      }\n    }\n  };\n  /**\n   * Internal function to set `language` key of settings.\n   *\n   * @private\n   * @param {string} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'.\n   * @fires Hooks#afterLanguageChange\n   */\n\n  function setLanguage(languageCode) {\n    var normalizedLanguageCode = normalizeLanguageCode(languageCode);\n\n    if (hasLanguageDictionary(normalizedLanguageCode)) {\n      instance.runHooks('beforeLanguageChange', normalizedLanguageCode);\n      globalMeta.language = normalizedLanguageCode;\n      instance.runHooks('afterLanguageChange', normalizedLanguageCode);\n    } else {\n      warnUserAboutLanguageRegistration(languageCode);\n    }\n  }\n  /**\n   * Internal function to set `className` or `tableClassName`, depending on the key from the settings object.\n   *\n   * @private\n   * @param {string} className `className` or `tableClassName` from the key in the settings object.\n   * @param {string|string[]} classSettings String or array of strings. Contains class name(s) from settings object.\n   */\n\n\n  function setClassName(className, classSettings) {\n    var element = className === 'className' ? instance.rootElement : instance.table;\n\n    if (firstRun) {\n      addClass(element, classSettings);\n    } else {\n      var globalMetaSettingsArray = [];\n      var settingsArray = [];\n\n      if (globalMeta[className]) {\n        globalMetaSettingsArray = Array.isArray(globalMeta[className]) ? globalMeta[className] : stringToArray(globalMeta[className]);\n      }\n\n      if (classSettings) {\n        settingsArray = Array.isArray(classSettings) ? classSettings : stringToArray(classSettings);\n      }\n\n      var classNameToRemove = getDifferenceOfArrays(globalMetaSettingsArray, settingsArray);\n      var classNameToAdd = getDifferenceOfArrays(settingsArray, globalMetaSettingsArray);\n\n      if (classNameToRemove.length) {\n        removeClass(element, classNameToRemove);\n      }\n\n      if (classNameToAdd.length) {\n        addClass(element, classNameToAdd);\n      }\n    }\n\n    globalMeta[className] = classSettings;\n  }\n\n  this.init = function () {\n    dataSource.setData(tableMeta.data);\n    instance.runHooks('beforeInit');\n\n    if (isMobileBrowser() || isIpadOS()) {\n      addClass(instance.rootElement, 'mobile');\n    }\n\n    this.updateSettings(tableMeta, true);\n    this.view = new TableView(this);\n    editorManager = EditorManager.getInstance(instance, tableMeta, selection);\n    instance.runHooks('init');\n    this.forceFullRender = true; // used when data was changed\n\n    this.view.render();\n\n    if (_typeof(firstRun) === 'object') {\n      instance.runHooks('afterChange', firstRun[0], firstRun[1]);\n      firstRun = false;\n    }\n\n    instance.runHooks('afterInit');\n  };\n  /**\n   * @ignore\n   * @returns {object}\n   */\n\n\n  function ValidatorsQueue() {\n    // moved this one level up so it can be used in any function here. Probably this should be moved to a separate file\n    var resolved = false;\n    return {\n      validatorsInQueue: 0,\n      valid: true,\n      addValidatorToQueue: function addValidatorToQueue() {\n        this.validatorsInQueue += 1;\n        resolved = false;\n      },\n      removeValidatorFormQueue: function removeValidatorFormQueue() {\n        this.validatorsInQueue = this.validatorsInQueue - 1 < 0 ? 0 : this.validatorsInQueue - 1;\n        this.checkIfQueueIsEmpty();\n      },\n      onQueueEmpty: function onQueueEmpty() {},\n      checkIfQueueIsEmpty: function checkIfQueueIsEmpty() {\n        if (this.validatorsInQueue === 0 && resolved === false) {\n          resolved = true;\n          this.onQueueEmpty(this.valid);\n        }\n      }\n    };\n  }\n  /**\n   * Get parsed number from numeric string.\n   *\n   * @private\n   * @param {string} numericData Float (separated by a dot or a comma) or integer.\n   * @returns {number} Number if we get data in parsable format, not changed value otherwise.\n   */\n\n\n  function getParsedNumber(numericData) {\n    // Unifying \"float like\" string. Change from value with comma determiner to value with dot determiner,\n    // for example from `450,65` to `450.65`.\n    var unifiedNumericData = numericData.replace(',', '.');\n\n    if (isNaN(parseFloat(unifiedNumericData)) === false) {\n      return parseFloat(unifiedNumericData);\n    }\n\n    return numericData;\n  }\n  /**\n   * @ignore\n   * @param {Array} changes The 2D array containing information about each of the edited cells.\n   * @param {string} source The string that identifies source of validation.\n   * @param {Function} callback The callback function fot async validation.\n   */\n\n\n  function validateChanges(changes, source, callback) {\n    if (!changes.length) {\n      return;\n    }\n\n    var activeEditor = instance.getActiveEditor();\n    var beforeChangeResult = instance.runHooks('beforeChange', changes, source || 'edit');\n    var shouldBeCanceled = true;\n\n    if (beforeChangeResult === false) {\n      if (activeEditor) {\n        activeEditor.cancelChanges();\n      }\n\n      return;\n    }\n\n    var waitingForValidator = new ValidatorsQueue();\n\n    var isNumericData = function isNumericData(value) {\n      return value.length > 0 && /^\\s*[+-.]?\\s*(?:(?:\\d+(?:(\\.|,)\\d+)?(?:e[+-]?\\d+)?)|(?:0x[a-f\\d]+))\\s*$/.test(value);\n    };\n\n    waitingForValidator.onQueueEmpty = function (isValid) {\n      if (activeEditor && shouldBeCanceled) {\n        activeEditor.cancelChanges();\n      }\n\n      callback(isValid); // called when async validators are resolved and beforeChange was not async\n    };\n\n    for (var i = changes.length - 1; i >= 0; i--) {\n      if (changes[i] === null) {\n        changes.splice(i, 1);\n      } else {\n        var _changes$i = _slicedToArray(changes[i], 4),\n            row = _changes$i[0],\n            prop = _changes$i[1],\n            newValue = _changes$i[3];\n\n        var col = datamap.propToCol(prop);\n        var cellProperties = instance.getCellMeta(row, col);\n\n        if (cellProperties.type === 'numeric' && typeof newValue === 'string' && isNumericData(newValue)) {\n          changes[i][3] = getParsedNumber(newValue);\n        }\n        /* eslint-disable no-loop-func */\n\n\n        if (instance.getCellValidator(cellProperties)) {\n          waitingForValidator.addValidatorToQueue();\n          instance.validateCell(changes[i][3], cellProperties, function (index, cellPropertiesReference) {\n            return function (result) {\n              if (typeof result !== 'boolean') {\n                throw new Error('Validation error: result is not boolean');\n              }\n\n              if (result === false && cellPropertiesReference.allowInvalid === false) {\n                shouldBeCanceled = false;\n                changes.splice(index, 1); // cancel the change\n\n                cellPropertiesReference.valid = true; // we cancelled the change, so cell value is still valid\n\n                var cell = instance.getCell(cellPropertiesReference.visualRow, cellPropertiesReference.visualCol);\n\n                if (cell !== null) {\n                  removeClass(cell, tableMeta.invalidCellClassName);\n                } // index -= 1;\n\n              }\n\n              waitingForValidator.removeValidatorFormQueue();\n            };\n          }(i, cellProperties), source);\n        }\n      }\n    }\n\n    waitingForValidator.checkIfQueueIsEmpty();\n  }\n  /**\n   * Internal function to apply changes. Called after validateChanges.\n   *\n   * @private\n   * @param {Array} changes Array in form of [row, prop, oldValue, newValue].\n   * @param {string} source String that identifies how this change will be described in changes array (useful in onChange callback).\n   * @fires Hooks#beforeChangeRender\n   * @fires Hooks#afterChange\n   */\n\n\n  function applyChanges(changes, source) {\n    var i = changes.length - 1;\n\n    if (i < 0) {\n      return;\n    }\n\n    for (; i >= 0; i--) {\n      var skipThisChange = false;\n\n      if (changes[i] === null) {\n        changes.splice(i, 1);\n        /* eslint-disable no-continue */\n\n        continue;\n      }\n\n      if ((changes[i][2] === null || changes[i][2] === void 0) && (changes[i][3] === null || changes[i][3] === void 0)) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n\n      if (tableMeta.allowInsertRow) {\n        while (changes[i][0] > instance.countRows() - 1) {\n          var numberOfCreatedRows = datamap.createRow(void 0, void 0, source);\n\n          if (numberOfCreatedRows >= 1) {\n            metaManager.createRow(null, numberOfCreatedRows);\n          } else {\n            skipThisChange = true;\n            break;\n          }\n        }\n      }\n\n      if (instance.dataType === 'array' && (!tableMeta.columns || tableMeta.columns.length === 0) && tableMeta.allowInsertColumn) {\n        while (datamap.propToCol(changes[i][1]) > instance.countCols() - 1) {\n          var numberOfCreatedColumns = datamap.createCol(void 0, void 0, source);\n\n          if (numberOfCreatedColumns >= 1) {\n            metaManager.createColumn(null, numberOfCreatedColumns);\n          } else {\n            skipThisChange = true;\n            break;\n          }\n        }\n      }\n\n      if (skipThisChange) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n\n      datamap.set(changes[i][0], changes[i][1], changes[i][3]);\n    }\n\n    instance.forceFullRender = true; // used when data was changed\n\n    grid.adjustRowsAndCols();\n    instance.runHooks('beforeChangeRender', changes, source);\n    editorManager.lockEditor();\n\n    instance._refreshBorders(null);\n\n    editorManager.unlockEditor();\n    instance.view.adjustElementsSize();\n    instance.runHooks('afterChange', changes, source || 'edit');\n    var activeEditor = instance.getActiveEditor();\n\n    if (activeEditor && isDefined(activeEditor.refreshValue)) {\n      activeEditor.refreshValue();\n    }\n  }\n  /**\n   * Validate a single cell.\n   *\n   * @param {string|number} value The value to validate.\n   * @param {object} cellProperties The cell meta which corresponds with the value.\n   * @param {Function} callback The callback function.\n   * @param {string} source The string that identifies source of the validation.\n   */\n\n\n  this.validateCell = function (value, cellProperties, callback, source) {\n    var validator = instance.getCellValidator(cellProperties); // the `canBeValidated = false` argument suggests, that the cell passes validation by default.\n\n    /**\n     * @param {boolean} valid Indicates if the validation was successful.\n     * @param {boolean} [canBeValidated=true] Flag which controls the validation process.\n     */\n\n    function done(valid) {\n      var canBeValidated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true; // Fixes GH#3903\n\n      if (!canBeValidated || cellProperties.hidden === true) {\n        callback(valid);\n        return;\n      }\n\n      var col = cellProperties.visualCol;\n      var row = cellProperties.visualRow;\n      var td = instance.getCell(row, col, true);\n\n      if (td && td.nodeName !== 'TH') {\n        var renderableRow = instance.rowIndexMapper.getRenderableFromVisualIndex(row);\n        var renderableColumn = instance.columnIndexMapper.getRenderableFromVisualIndex(col);\n        instance.view.wt.wtSettings.settings.cellRenderer(renderableRow, renderableColumn, td);\n      }\n\n      callback(valid);\n    }\n\n    if (isRegExp(validator)) {\n      validator = function (expression) {\n        return function (cellValue, validatorCallback) {\n          validatorCallback(expression.test(cellValue));\n        };\n      }(validator);\n    }\n\n    if (isFunction(validator)) {\n      // eslint-disable-next-line no-param-reassign\n      value = instance.runHooks('beforeValidate', value, cellProperties.visualRow, cellProperties.prop, source); // To provide consistent behaviour, validation should be always asynchronous\n\n      instance._registerImmediate(function () {\n        validator.call(cellProperties, value, function (valid) {\n          if (!instance) {\n            return;\n          } // eslint-disable-next-line no-param-reassign\n\n\n          valid = instance.runHooks('afterValidate', valid, value, cellProperties.visualRow, cellProperties.prop, source);\n          cellProperties.valid = valid;\n          done(valid);\n          instance.runHooks('postAfterValidate', valid, value, cellProperties.visualRow, cellProperties.prop, source);\n        });\n      });\n    } else {\n      // resolve callback even if validator function was not found\n      instance._registerImmediate(function () {\n        cellProperties.valid = true;\n        done(cellProperties.valid, false);\n      });\n    }\n  };\n  /**\n   * @ignore\n   * @param {number} row The visual row index.\n   * @param {string|number} propOrCol The visual prop or column index.\n   * @param {*} value The cell value.\n   * @returns {Array}\n   */\n\n\n  function setDataInputToArray(row, propOrCol, value) {\n    if (Array.isArray(row)) {\n      // it's an array of changes\n      return row;\n    }\n\n    return [[row, propOrCol, value]];\n  }\n  /**\n   * @description\n   * Set new value to a cell. To change many cells at once (recommended way), pass an array of `changes` in format\n   * `[[row, col, value],...]` as the first argument.\n   *\n   * @memberof Core#\n   * @function setDataAtCell\n   * @param {number|Array} row Visual row index or array of changes in format `[[row, col, value],...]`.\n   * @param {number} [column] Visual column index.\n   * @param {string} [value] New value.\n   * @param {string} [source] String that identifies how this change will be described in the changes array (useful in afterChange or beforeChange callback). Set to 'edit' if left empty.\n   */\n\n\n  this.setDataAtCell = function (row, column, value, source) {\n    var input = setDataInputToArray(row, column, value);\n    var changes = [];\n    var changeSource = source;\n    var i;\n    var ilen;\n    var prop;\n\n    for (i = 0, ilen = input.length; i < ilen; i++) {\n      if (_typeof(input[i]) !== 'object') {\n        throw new Error('Method `setDataAtCell` accepts row number or changes array of arrays as its first parameter');\n      }\n\n      if (typeof input[i][1] !== 'number') {\n        throw new Error('Method `setDataAtCell` accepts row and column number as its parameters. If you want to use object property name, use method `setDataAtRowProp`'); // eslint-disable-line max-len\n      }\n\n      if (input[i][1] >= this.countCols()) {\n        prop = input[i][1];\n      } else {\n        prop = datamap.colToProp(input[i][1]);\n      }\n\n      changes.push([input[i][0], prop, dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);\n    }\n\n    if (!changeSource && _typeof(row) === 'object') {\n      changeSource = column;\n    }\n\n    instance.runHooks('afterSetDataAtCell', changes, changeSource);\n    validateChanges(changes, changeSource, function () {\n      applyChanges(changes, changeSource);\n    });\n  };\n  /**\n   * @description\n   * Set new value to a cell. To change many cells at once (recommended way), pass an array of `changes` in format\n   * `[[row, prop, value],...]` as the first argument.\n   *\n   * @memberof Core#\n   * @function setDataAtRowProp\n   * @param {number|Array} row Visual row index or array of changes in format `[[row, prop, value], ...]`.\n   * @param {string} prop Property name or the source string (e.g. `'first.name'` or `'0'`).\n   * @param {string} value Value to be set.\n   * @param {string} [source] String that identifies how this change will be described in changes array (useful in onChange callback).\n   */\n\n\n  this.setDataAtRowProp = function (row, prop, value, source) {\n    var input = setDataInputToArray(row, prop, value);\n    var changes = [];\n    var changeSource = source;\n    var i;\n    var ilen;\n\n    for (i = 0, ilen = input.length; i < ilen; i++) {\n      changes.push([input[i][0], input[i][1], dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);\n    }\n\n    if (!changeSource && _typeof(row) === 'object') {\n      changeSource = prop;\n    }\n\n    instance.runHooks('afterSetDataAtRowProp', changes, changeSource);\n    validateChanges(changes, changeSource, function () {\n      applyChanges(changes, changeSource);\n    });\n  };\n  /**\n   * Listen to the keyboard input on document body. This allows Handsontable to capture keyboard events and respond\n   * in the right way.\n   *\n   * @memberof Core#\n   * @function listen\n   * @fires Hooks#afterListen\n   */\n\n\n  this.listen = function () {\n    if (instance && !instance.isListening()) {\n      activeGuid = instance.guid;\n      instance.runHooks('afterListen');\n    }\n  };\n  /**\n   * Stop listening to keyboard input on the document body. Calling this method makes the Handsontable inactive for\n   * any keyboard events.\n   *\n   * @memberof Core#\n   * @function unlisten\n   */\n\n\n  this.unlisten = function () {\n    if (this.isListening()) {\n      activeGuid = null;\n      instance.runHooks('afterUnlisten');\n    }\n  };\n  /**\n   * Returns `true` if the current Handsontable instance is listening to keyboard input on document body.\n   *\n   * @memberof Core#\n   * @function isListening\n   * @returns {boolean} `true` if the instance is listening, `false` otherwise.\n   */\n\n\n  this.isListening = function () {\n    return activeGuid === instance.guid;\n  };\n  /**\n   * Destroys the current editor, render the table and prepares the editor of the newly selected cell.\n   *\n   * @memberof Core#\n   * @function destroyEditor\n   * @param {boolean} [revertOriginal=false] If `true`, the previous value will be restored. Otherwise, the edited value will be saved.\n   * @param {boolean} [prepareEditorIfNeeded=true] If `true` the editor under the selected cell will be prepared to open.\n   */\n\n\n  this.destroyEditor = function () {\n    var revertOriginal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    instance._refreshBorders(revertOriginal, prepareEditorIfNeeded);\n  };\n  /**\n   * Populate cells at position with 2D input array (e.g. `[[1, 2], [3, 4]]`). Use `endRow`, `endCol` when you\n   * want to cut input when a certain row is reached.\n   *\n   * Optional `method` argument has the same effect as pasteMode option (see {@link Options#pasteMode}).\n   *\n   * @memberof Core#\n   * @function populateFromArray\n   * @param {number} row Start visual row index.\n   * @param {number} column Start visual column index.\n   * @param {Array} input 2d array.\n   * @param {number} [endRow] End visual row index (use when you want to cut input when certain row is reached).\n   * @param {number} [endCol] End visual column index (use when you want to cut input when certain column is reached).\n   * @param {string} [source=populateFromArray] Used to identify this call in the resulting events (beforeChange, afterChange).\n   * @param {string} [method=overwrite] Populate method, possible values: `'shift_down'`, `'shift_right'`, `'overwrite'`.\n   * @param {string} direction Populate direction, possible values: `'left'`, `'right'`, `'up'`, `'down'`.\n   * @param {Array} deltas The deltas array. A difference between values of adjacent cells.\n   *                       Useful **only** when the type of handled cells is `numeric`.\n   * @returns {object|undefined} Ending td in pasted area (only if any cell was changed).\n   */\n\n\n  this.populateFromArray = function (row, column, input, endRow, endCol, source, method, direction, deltas) {\n    if (!(_typeof(input) === 'object' && _typeof(input[0]) === 'object')) {\n      throw new Error('populateFromArray parameter `input` must be an array of arrays'); // API changed in 0.9-beta2, let's check if you use it correctly\n    }\n\n    var c = typeof endRow === 'number' ? new CellCoords(endRow, endCol) : null;\n    return grid.populateFromArray(new CellCoords(row, column), input, c, source, method, direction, deltas);\n  };\n  /**\n   * Adds/removes data from the column. This method works the same as Array.splice for arrays (see {@link DataMap#spliceCol}).\n   *\n   * @memberof Core#\n   * @function spliceCol\n   * @param {number} column Index of the column in which do you want to do splice.\n   * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n   * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n   * @param {...number} [elements] The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array.\n   * @returns {Array} Returns removed portion of columns.\n   */\n\n\n  this.spliceCol = function (column, index, amount) {\n    var _datamap;\n\n    for (var _len = arguments.length, elements = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      elements[_key - 3] = arguments[_key];\n    }\n\n    return (_datamap = datamap).spliceCol.apply(_datamap, [column, index, amount].concat(elements));\n  };\n  /**\n   * Adds/removes data from the row. This method works the same as Array.splice for arrays (see {@link DataMap#spliceRow}).\n   *\n   * @memberof Core#\n   * @function spliceRow\n   * @param {number} row Index of column in which do you want to do splice.\n   * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n   * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n   * @param {...number} [elements] The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array.\n   * @returns {Array} Returns removed portion of rows.\n   */\n\n\n  this.spliceRow = function (row, index, amount) {\n    var _datamap2;\n\n    for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n      elements[_key2 - 3] = arguments[_key2];\n    }\n\n    return (_datamap2 = datamap).spliceRow.apply(_datamap2, [row, index, amount].concat(elements));\n  };\n  /**\n   * Returns indexes of the currently selected cells as an array of arrays `[[startRow, startCol, endRow, endCol],...]`.\n   *\n   * Start row and start column are the coordinates of the active cell (where the selection was started).\n   *\n   * The version 0.36.0 adds a non-consecutive selection feature. Since this version, the method returns an array of arrays.\n   * Additionally to collect the coordinates of the currently selected area (as it was previously done by the method)\n   * you need to use `getSelectedLast` method.\n   *\n   * @memberof Core#\n   * @function getSelected\n   * @returns {Array[]|undefined} An array of arrays of the selection's coordinates.\n   */\n\n\n  this.getSelected = function () {\n    // https://github.com/handsontable/handsontable/issues/44  //cjl\n    if (selection.isSelected()) {\n      return arrayMap(selection.getSelectedRange(), function (_ref12) {\n        var from = _ref12.from,\n            to = _ref12.to;\n        return [from.row, from.col, to.row, to.col];\n      });\n    }\n  };\n  /**\n   * Returns the last coordinates applied to the table as a an array `[startRow, startCol, endRow, endCol]`.\n   *\n   * @since 0.36.0\n   * @memberof Core#\n   * @function getSelectedLast\n   * @returns {Array|undefined} An array of the selection's coordinates.\n   */\n\n\n  this.getSelectedLast = function () {\n    var selected = this.getSelected();\n    var result;\n\n    if (selected && selected.length > 0) {\n      result = selected[selected.length - 1];\n    }\n\n    return result;\n  };\n  /**\n   * Returns the current selection as an array of CellRange objects.\n   *\n   * The version 0.36.0 adds a non-consecutive selection feature. Since this version, the method returns an array of arrays.\n   * Additionally to collect the coordinates of the currently selected area (as it was previously done by the method)\n   * you need to use `getSelectedRangeLast` method.\n   *\n   * @memberof Core#\n   * @function getSelectedRange\n   * @returns {CellRange[]|undefined} Selected range object or undefined if there is no selection.\n   */\n\n\n  this.getSelectedRange = function () {\n    // https://github.com/handsontable/handsontable/issues/44  //cjl\n    if (selection.isSelected()) {\n      return Array.from(selection.getSelectedRange());\n    }\n  };\n  /**\n   * Returns the last coordinates applied to the table as a CellRange object.\n   *\n   * @memberof Core#\n   * @function getSelectedRangeLast\n   * @since 0.36.0\n   * @returns {CellRange|undefined} Selected range object or undefined` if there is no selection.\n   */\n\n\n  this.getSelectedRangeLast = function () {\n    var selectedRange = this.getSelectedRange();\n    var result;\n\n    if (selectedRange && selectedRange.length > 0) {\n      result = selectedRange[selectedRange.length - 1];\n    }\n\n    return result;\n  };\n  /**\n   * Erases content from cells that have been selected in the table.\n   *\n   * @memberof Core#\n   * @function emptySelectedCells\n   * @param {string} [source] String that identifies how this change will be described in the changes array (useful in afterChange or beforeChange callback). Set to 'edit' if left empty.\n   * @since 0.36.0\n   */\n\n\n  this.emptySelectedCells = function (source) {\n    var _this2 = this;\n\n    if (!selection.isSelected() || this.countRows() === 0 || this.countCols() === 0) {\n      return;\n    }\n\n    var changes = [];\n    arrayEach(selection.getSelectedRange(), function (cellRange) {\n      var topLeft = cellRange.getTopLeftCorner();\n      var bottomRight = cellRange.getBottomRightCorner();\n      rangeEach(topLeft.row, bottomRight.row, function (row) {\n        rangeEach(topLeft.col, bottomRight.col, function (column) {\n          if (!_this2.getCellMeta(row, column).readOnly) {\n            changes.push([row, column, null]);\n          }\n        });\n      });\n    });\n\n    if (changes.length > 0) {\n      this.setDataAtCell(changes, source);\n    }\n  };\n  /**\n   * Checks if the table rendering process was suspended. See explanation in {@link Core#suspendRender}.\n   *\n   * @memberof Core#\n   * @function isRenderSuspended\n   * @since 8.3.0\n   * @returns {boolean}\n   */\n\n\n  this.isRenderSuspended = function () {\n    return this.renderSuspendedCounter > 0;\n  };\n  /**\n   * Suspends the rendering process. It's helpful to wrap the table render\n   * cycles triggered by API calls or UI actions (or both) and call the \"render\"\n   * once in the end. As a result, it improves the performance of wrapped operations.\n   * When the table is in the suspend state, most operations will have no visual\n   * effect until the rendering state is resumed. Resuming the state automatically\n   * invokes the table rendering. To make sure that after executing all operations,\n   * the table will be rendered, it's highly recommended to use the {@link Core#batchRender}\n   * method or {@link Core#batch}, which additionally aggregates the logic execution\n   * that happens behind the table.\n   *\n   * The method is intended to be used by advanced users. Suspending the rendering\n   * process could cause visual glitches when wrongly implemented.\n   *\n   * @memberof Core#\n   * @function suspendRender\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendRender();\n   * hot.alter('insert_row', 5, 45);\n   * hot.alter('insert_col', 10, 40);\n   * hot.setDataAtCell(1, 1, 'John');\n   * hot.setDataAtCell(2, 2, 'Mark');\n   * hot.setDataAtCell(3, 3, 'Ann');\n   * hot.setDataAtCell(4, 4, 'Sophia');\n   * hot.setDataAtCell(5, 5, 'Mia');\n   * hot.selectCell(0, 0);\n   * hot.resumeRender(); // It re-renders the table internally\n   * ```\n   */\n\n\n  this.suspendRender = function () {\n    this.renderSuspendedCounter += 1;\n  };\n  /**\n   * Resumes the rendering process. In combination with the {@link Core#suspendRender}\n   * method it allows aggregating the table render cycles triggered by API calls or UI\n   * actions (or both) and calls the \"render\" once in the end. When the table is in\n   * the suspend state, most operations will have no visual effect until the rendering\n   * state is resumed. Resuming the state automatically invokes the table rendering.\n   *\n   * The method is intended to be used by advanced users. Suspending the rendering\n   * process could cause visual glitches when wrongly implemented.\n   *\n   * @memberof Core#\n   * @function resumeRender\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendRender();\n   * hot.alter('insert_row', 5, 45);\n   * hot.alter('insert_col', 10, 40);\n   * hot.setDataAtCell(1, 1, 'John');\n   * hot.setDataAtCell(2, 2, 'Mark');\n   * hot.setDataAtCell(3, 3, 'Ann');\n   * hot.setDataAtCell(4, 4, 'Sophia');\n   * hot.setDataAtCell(5, 5, 'Mia');\n   * hot.selectCell(0, 0);\n   * hot.resumeRender(); // It re-renders the table internally\n   * ```\n   */\n\n\n  this.resumeRender = function () {\n    var nextValue = this.renderSuspendedCounter - 1;\n    this.renderSuspendedCounter = Math.max(nextValue, 0);\n\n    if (!this.isRenderSuspended() && nextValue === this.renderSuspendedCounter) {\n      if (this.renderCall) {\n        this.render();\n      } else {\n        this._refreshBorders(null);\n      }\n    }\n  };\n  /**\n   * Rerender the table. Calling this method starts the process of recalculating, redrawing and applying the changes\n   * to the DOM. While rendering the table all cell renderers are recalled.\n   *\n   * Calling this method manually is not recommended. Handsontable tries to render itself by choosing the most\n   * optimal moments in its lifecycle.\n   *\n   * @memberof Core#\n   * @function render\n   */\n\n\n  this.render = function () {\n    if (this.view) {\n      this.renderCall = true;\n      this.forceFullRender = true; // used when data was changed\n\n      if (!this.isRenderSuspended()) {\n        editorManager.lockEditor();\n\n        this._refreshBorders(null);\n\n        editorManager.unlockEditor();\n      }\n    }\n  };\n  /**\n   * The method aggregates multi-line API calls into a callback and postpones the\n   * table rendering process. After the execution of the operations, the table is\n   * rendered once. As a result, it improves the performance of wrapped operations.\n   * Without batching, a similar case could trigger multiple table render calls.\n   *\n   * @memberof Core#\n   * @function batchRender\n   * @param {Function} wrappedOperations Batched operations wrapped in a function.\n   * @returns {*} Returns result from the wrappedOperations callback.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.batchRender(() => {\n   *   hot.alter('insert_row', 5, 45);\n   *   hot.alter('insert_col', 10, 40);\n   *   hot.setDataAtCell(1, 1, 'John');\n   *   hot.setDataAtCell(2, 2, 'Mark');\n   *   hot.setDataAtCell(3, 3, 'Ann');\n   *   hot.setDataAtCell(4, 4, 'Sophia');\n   *   hot.setDataAtCell(5, 5, 'Mia');\n   *   hot.selectCell(0, 0);\n   *   // The table will be rendered once after executing the callback\n   * });\n   * ```\n   */\n\n\n  this.batchRender = function (wrappedOperations) {\n    this.suspendRender();\n    var result = wrappedOperations();\n    this.resumeRender();\n    return result;\n  };\n  /**\n   * Checks if the table indexes recalculation process was suspended. See explanation\n   * in {@link Core#suspendExecution}.\n   *\n   * @memberof Core#\n   * @function isExecutionSuspended\n   * @since 8.3.0\n   * @returns {boolean}\n   */\n\n\n  this.isExecutionSuspended = function () {\n    return this.executionSuspendedCounter > 0;\n  };\n  /**\n   * Suspends the execution process. It's helpful to wrap the table logic changes\n   * such as index changes into one call after which the cache is updated. As a result,\n   * it improves the performance of wrapped operations.\n   *\n   * The method is intended to be used by advanced users. Suspending the execution\n   * process could cause visual glitches caused by not updated the internal table cache.\n   *\n   * @memberof Core#\n   * @function suspendExecution\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendExecution();\n   * const filters = hot.getPlugin('filters');\n   *\n   * filters.addCondition(2, 'contains', ['3']);\n   * filters.filter();\n   * hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   * hot.resumeExecution(); // It updates the cache internally\n   * ```\n   */\n\n\n  this.suspendExecution = function () {\n    this.executionSuspendedCounter += 1;\n    this.columnIndexMapper.suspendOperations();\n    this.rowIndexMapper.suspendOperations();\n  };\n  /**\n   * Resumes the execution process. In combination with the {@link Core#suspendExecution}\n   * method it allows aggregating the table logic changes after which the cache is\n   * updated. Resuming the state automatically invokes the table cache updating process.\n   *\n   * The method is intended to be used by advanced users. Suspending the execution\n   * process could cause visual glitches caused by not updated the internal table cache.\n   *\n   * @memberof Core#\n   * @function resumeExecution\n   * @param {boolean} [forceFlushChanges=false] If `true`, the table internal data cache\n   * is recalculated after the execution of the batched operations. For nested\n   * {@link Core#batchExecution} calls, it can be desire to recalculate the table\n   * after each batch.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendExecution();\n   * const filters = hot.getPlugin('filters');\n   *\n   * filters.addCondition(2, 'contains', ['3']);\n   * filters.filter();\n   * hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   * hot.resumeExecution(); // It updates the cache internally\n   * ```\n   */\n\n\n  this.resumeExecution = function () {\n    var forceFlushChanges = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var nextValue = this.executionSuspendedCounter - 1;\n    this.executionSuspendedCounter = Math.max(nextValue, 0);\n\n    if (!this.isExecutionSuspended() && nextValue === this.executionSuspendedCounter || forceFlushChanges) {\n      this.columnIndexMapper.resumeOperations();\n      this.rowIndexMapper.resumeOperations();\n    }\n  };\n  /**\n   * The method aggregates multi-line API calls into a callback and postpones the\n   * table execution process. After the execution of the operations, the internal table\n   * cache is recalculated once. As a result, it improves the performance of wrapped\n   * operations. Without batching, a similar case could trigger multiple table cache rebuilds.\n   *\n   * @memberof Core#\n   * @function batchExecution\n   * @param {Function} wrappedOperations Batched operations wrapped in a function.\n   * @param {boolean} [forceFlushChanges=false] If `true`, the table internal data cache\n   * is recalculated after the execution of the batched operations. For nested calls,\n   * it can be a desire to recalculate the table after each batch.\n   * @returns {*} Returns result from the wrappedOperations callback.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.batchExecution(() => {\n   *   const filters = hot.getPlugin('filters');\n   *\n   *   filters.addCondition(2, 'contains', ['3']);\n   *   filters.filter();\n   *   hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   *   // The table cache will be recalculated once after executing the callback\n   * });\n   * ```\n   */\n\n\n  this.batchExecution = function (wrappedOperations) {\n    var forceFlushChanges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.suspendExecution();\n    var result = wrappedOperations();\n    this.resumeExecution(forceFlushChanges);\n    return result;\n  };\n  /**\n   * It batches the rendering process and index recalculations. The method aggregates\n   * multi-line API calls into a callback and postpones the table rendering process\n   * as well aggregates the table logic changes such as index changes into one call\n   * after which the cache is updated. After the execution of the operations, the\n   * table is rendered, and the cache is updated once. As a result, it improves the\n   * performance of wrapped operations.\n   *\n   * @memberof Core#\n   * @function batch\n   * @param {Function} wrappedOperations Batched operations wrapped in a function.\n   * @returns {*} Returns result from the wrappedOperations callback.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.batch(() => {\n   *   hot.alter('insert_row', 5, 45);\n   *   hot.alter('insert_col', 10, 40);\n   *   hot.setDataAtCell(1, 1, 'x');\n   *   hot.setDataAtCell(2, 2, 'c');\n   *   hot.setDataAtCell(3, 3, 'v');\n   *   hot.setDataAtCell(4, 4, 'b');\n   *   hot.setDataAtCell(5, 5, 'n');\n   *   hot.selectCell(0, 0);\n   *\n   *   const filters = hot.getPlugin('filters');\n   *\n   *   filters.addCondition(2, 'contains', ['3']);\n   *   filters.filter();\n   *   hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   *   // The table will be re-rendered and cache will be recalculated once after executing the callback\n   * });\n   * ```\n   */\n\n\n  this.batch = function (wrappedOperations) {\n    this.suspendRender();\n    this.suspendExecution();\n    var result = wrappedOperations();\n    this.resumeExecution();\n    this.resumeRender();\n    return result;\n  };\n  /**\n   * Updates dimensions of the table. The method compares previous dimensions with the current ones and updates accordingly.\n   *\n   * @memberof Core#\n   * @function refreshDimensions\n   * @fires Hooks#beforeRefreshDimensions\n   * @fires Hooks#afterRefreshDimensions\n   */\n\n\n  this.refreshDimensions = function () {\n    if (!instance.view) {\n      return;\n    }\n\n    var _instance$view$getLas = instance.view.getLastSize(),\n        lastWidth = _instance$view$getLas.width,\n        lastHeight = _instance$view$getLas.height;\n\n    var _instance$rootElement = instance.rootElement.getBoundingClientRect(),\n        width = _instance$rootElement.width,\n        height = _instance$rootElement.height;\n\n    var isSizeChanged = width !== lastWidth || height !== lastHeight;\n    var isResizeBlocked = instance.runHooks('beforeRefreshDimensions', {\n      width: lastWidth,\n      height: lastHeight\n    }, {\n      width: width,\n      height: height\n    }, isSizeChanged) === false;\n\n    if (isResizeBlocked) {\n      return;\n    }\n\n    if (isSizeChanged || instance.view.wt.wtOverlays.scrollableElement === instance.rootWindow) {\n      instance.view.setLastSize(width, height);\n      instance.render();\n    }\n\n    instance.runHooks('afterRefreshDimensions', {\n      width: lastWidth,\n      height: lastHeight\n    }, {\n      width: width,\n      height: height\n    }, isSizeChanged);\n  };\n  /**\n   * Loads new data to Handsontable. Loading new data resets the cell meta.\n   * Since 8.0.0 loading new data also resets states corresponding to rows and columns\n   * (for example, row/column sequence, column width, row height, frozen columns etc.).\n   *\n   * @memberof Core#\n   * @function loadData\n   * @param {Array} data Array of arrays or array of objects containing data.\n   * @param {string} [source] Source of the loadData call.\n   * @fires Hooks#beforeLoadData\n   * @fires Hooks#afterLoadData\n   * @fires Hooks#afterChange\n   */\n\n\n  this.loadData = function (data, source) {\n    if (Array.isArray(tableMeta.dataSchema)) {\n      instance.dataType = 'array';\n    } else if (isFunction(tableMeta.dataSchema)) {\n      instance.dataType = 'function';\n    } else {\n      instance.dataType = 'object';\n    }\n\n    if (datamap) {\n      datamap.destroy();\n    }\n\n    data = instance.runHooks('beforeLoadData', data, firstRun, source);\n    datamap = new DataMap(instance, data, tableMeta);\n\n    if (_typeof(data) === 'object' && data !== null) {\n      if (!(data.push && data.splice)) {\n        // check if data is array. Must use duck-type check so Backbone Collections also pass it\n        // when data is not an array, attempt to make a single-row array of it\n        // eslint-disable-next-line no-param-reassign\n        data = [data];\n      }\n    } else if (data === null) {\n      var dataSchema = datamap.getSchema(); // eslint-disable-next-line no-param-reassign\n\n      data = [];\n      var row;\n      var r = 0;\n      var rlen = 0;\n\n      for (r = 0, rlen = tableMeta.startRows; r < rlen; r++) {\n        if ((instance.dataType === 'object' || instance.dataType === 'function') && tableMeta.dataSchema) {\n          row = deepClone(dataSchema);\n          data.push(row);\n        } else if (instance.dataType === 'array') {\n          row = deepClone(dataSchema[0]);\n          data.push(row);\n        } else {\n          row = [];\n\n          for (var c = 0, clen = tableMeta.startCols; c < clen; c++) {\n            row.push(null);\n          }\n\n          data.push(row);\n        }\n      }\n    } else {\n      throw new Error(\"loadData only accepts array of objects or array of arrays (\".concat(_typeof(data), \" given)\"));\n    }\n\n    if (Array.isArray(data[0])) {\n      instance.dataType = 'array';\n    }\n\n    tableMeta.data = data;\n    datamap.dataSource = data;\n    dataSource.data = data;\n    dataSource.dataType = instance.dataType;\n    dataSource.colToProp = datamap.colToProp.bind(datamap);\n    dataSource.propToCol = datamap.propToCol.bind(datamap);\n    dataSource.countCachedColumns = datamap.countCachedColumns.bind(datamap);\n    metaManager.clearCellsCache();\n    instance.initIndexMappers();\n    grid.adjustRowsAndCols();\n    instance.runHooks('afterLoadData', data, firstRun, source);\n\n    if (firstRun) {\n      firstRun = [null, 'loadData'];\n    } else {\n      instance.runHooks('afterChange', null, 'loadData');\n      instance.render();\n    }\n  };\n  /**\n   * Init index mapper which manage indexes assigned to the data.\n   *\n   * @private\n   */\n\n\n  this.initIndexMappers = function () {\n    var columnsSettings = tableMeta.columns;\n    var finalNrOfColumns = 0; // We will check number of columns when the `columns` property was defined as an array. Columns option may\n    // narrow down or expand displayed dataset in that case.\n\n    if (Array.isArray(columnsSettings)) {\n      finalNrOfColumns = columnsSettings.length;\n    } else if (isFunction(columnsSettings)) {\n      if (instance.dataType === 'array') {\n        var nrOfSourceColumns = this.countSourceCols();\n\n        for (var columnIndex = 0; columnIndex < nrOfSourceColumns; columnIndex += 1) {\n          if (columnsSettings(columnIndex)) {\n            finalNrOfColumns += 1;\n          }\n        } // Extended dataset by the `columns` property? Moved code right from the refactored `countCols` method.\n\n      } else if (instance.dataType === 'object' || instance.dataType === 'function') {\n        finalNrOfColumns = datamap.colToPropCache.length;\n      } // In some cases we need to check columns length from the schema, i.e. `data` may be empty.\n\n    } else if (isDefined(tableMeta.dataSchema)) {\n      var schema = datamap.getSchema(); // Schema may be defined as an array of objects. Each object will define column.\n\n      finalNrOfColumns = Array.isArray(schema) ? schema.length : deepObjectSize(schema);\n    } else {\n      // We init index mappers by length of source data to provide indexes also for skipped indexes.\n      finalNrOfColumns = this.countSourceCols();\n    }\n\n    this.columnIndexMapper.initToLength(finalNrOfColumns);\n    this.rowIndexMapper.initToLength(this.countSourceRows());\n  };\n  /**\n   * Returns the current data object (the same one that was passed by `data` configuration option or `loadData` method,\n   * unless some modifications have been applied (i.e. Sequence of rows/columns was changed, some row/column was skipped).\n   * If that's the case - use the {@link Core#getSourceData} method.).\n   *\n   * Optionally you can provide cell range by defining `row`, `column`, `row2`, `column2` to get only a fragment of table data.\n   *\n   * @memberof Core#\n   * @function getData\n   * @param {number} [row] From visual row index.\n   * @param {number} [column] From visual column index.\n   * @param {number} [row2] To visual row index.\n   * @param {number} [column2] To visual column index.\n   * @returns {Array[]} Array with the data.\n   * @example\n   * ```js\n   * // Get all data (in order how it is rendered in the table).\n   * hot.getData();\n   * // Get data fragment (from top-left 0, 0 to bottom-right 3, 3).\n   * hot.getData(3, 3);\n   * // Get data fragment (from top-left 2, 1 to bottom-right 3, 3).\n   * hot.getData(2, 1, 3, 3);\n   * ```\n   */\n\n\n  this.getData = function (row, column, row2, column2) {\n    if (isUndefined(row)) {\n      return datamap.getAll();\n    }\n\n    return datamap.getRange(new CellCoords(row, column), new CellCoords(row2, column2), datamap.DESTINATION_RENDERER);\n  };\n  /**\n   * Returns a string value of the selected range. Each column is separated by tab, each row is separated by a new\n   * line character (see {@link DataMap#getCopyableText}).\n   *\n   * @memberof Core#\n   * @function getCopyableText\n   * @param {number} startRow From visual row index.\n   * @param {number} startCol From visual column index.\n   * @param {number} endRow To visual row index.\n   * @param {number} endCol To visual column index.\n   * @returns {string}\n   */\n\n\n  this.getCopyableText = function (startRow, startCol, endRow, endCol) {\n    return datamap.getCopyableText(new CellCoords(startRow, startCol), new CellCoords(endRow, endCol));\n  };\n  /**\n   * Returns the data's copyable value at specified `row` and `column` index (see {@link DataMap#getCopyable}).\n   *\n   * @memberof Core#\n   * @function getCopyableData\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {string}\n   */\n\n\n  this.getCopyableData = function (row, column) {\n    return datamap.getCopyable(row, datamap.colToProp(column));\n  };\n  /**\n   * Returns schema provided by constructor settings. If it doesn't exist then it returns the schema based on the data\n   * structure in the first row.\n   *\n   * @memberof Core#\n   * @function getSchema\n   * @returns {object} Schema object.\n   */\n\n\n  this.getSchema = function () {\n    return datamap.getSchema();\n  };\n  /**\n   * Use it if you need to change configuration after initialization. The `settings` argument is an object containing the new\n   * settings, declared the same way as in the initial settings object.\n   *\n   * __Note__, that although the `updateSettings` method doesn't overwrite the previously declared settings, it might reset\n   * the settings made post-initialization. (for example - ignore changes made using the columnResize feature).\n   *\n   * Since 8.0.0 passing `columns` or `data` inside `settings` objects will result in resetting states corresponding to rows and columns\n   * (for example, row/column sequence, column width, row height, frozen columns etc.).\n   *\n   * @memberof Core#\n   * @function updateSettings\n   * @param {object} settings New settings object (see {@link Options}).\n   * @param {boolean} [init=false] Internally used for in initialization mode.\n   * @example\n   * ```js\n   * hot.updateSettings({\n   *    contextMenu: true,\n   *    colHeaders: true,\n   *    fixedRowsTop: 2\n   * });\n   * ```\n   * @fires Hooks#afterCellMetaReset\n   * @fires Hooks#afterUpdateSettings\n   */\n\n\n  this.updateSettings = function (settings) {\n    var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var columnsAsFunc = false;\n    var i;\n    var j;\n\n    if (isDefined(settings.rows)) {\n      throw new Error('The \"rows\" setting is no longer supported. Do you mean startRows, minRows or maxRows?');\n    }\n\n    if (isDefined(settings.cols)) {\n      throw new Error('The \"cols\" setting is no longer supported. Do you mean startCols, minCols or maxCols?');\n    }\n\n    if (isDefined(settings.ganttChart)) {\n      throw new Error('Since 8.0.0 the \"ganttChart\" setting is no longer supported.');\n    } // eslint-disable-next-line no-restricted-syntax\n\n\n    for (i in settings) {\n      if (i === 'data') {\n        /* eslint-disable-next-line no-continue */\n        continue; // loadData will be triggered later\n      } else if (i === 'language') {\n        setLanguage(settings.language);\n        /* eslint-disable-next-line no-continue */\n\n        continue;\n      } else if (i === 'className') {\n        setClassName('className', settings.className);\n      } else if (i === 'tableClassName' && instance.table) {\n        setClassName('tableClassName', settings.tableClassName);\n        instance.view.wt.wtOverlays.syncOverlayTableClassNames();\n      } else if (Hooks.getSingleton().isRegistered(i) || Hooks.getSingleton().isDeprecated(i)) {\n        if (isFunction(settings[i]) || Array.isArray(settings[i])) {\n          settings[i].initialHook = true;\n          instance.addHook(i, settings[i]);\n        }\n      } else if (!init && hasOwnProperty(settings, i)) {\n        // Update settings\n        globalMeta[i] = settings[i];\n      }\n    } // Load data or create data map\n\n\n    if (settings.data === void 0 && tableMeta.data === void 0) {\n      instance.loadData(null, 'updateSettings'); // data source created just now\n    } else if (settings.data !== void 0) {\n      instance.loadData(settings.data, 'updateSettings'); // data source given as option\n    } else if (settings.columns !== void 0) {\n      datamap.createMap(); // The `column` property has changed - dataset may be expanded or narrowed down. The `loadData` do the same.\n\n      instance.initIndexMappers();\n    }\n\n    var clen = instance.countCols();\n    var columnSetting = tableMeta.columns; // Init columns constructors configuration\n\n    if (columnSetting && isFunction(columnSetting)) {\n      columnsAsFunc = true;\n    } // Clear cell meta cache\n\n\n    if (settings.cell !== void 0 || settings.cells !== void 0 || settings.columns !== void 0) {\n      metaManager.clearCache();\n    }\n\n    if (clen > 0) {\n      for (i = 0, j = 0; i < clen; i++) {\n        // Use settings provided by user\n        if (columnSetting) {\n          var column = columnsAsFunc ? columnSetting(i) : columnSetting[j];\n\n          if (column) {\n            metaManager.updateColumnMeta(j, column);\n          }\n        }\n\n        j += 1;\n      }\n    }\n\n    if (isDefined(settings.cell)) {\n      objectEach(settings.cell, function (cell) {\n        instance.setCellMetaObject(cell.row, cell.col, cell);\n      });\n    }\n\n    instance.runHooks('afterCellMetaReset');\n    var currentHeight = instance.rootElement.style.height;\n\n    if (currentHeight !== '') {\n      currentHeight = parseInt(instance.rootElement.style.height, 10);\n    }\n\n    var height = settings.height;\n\n    if (isFunction(height)) {\n      height = height();\n    }\n\n    if (init) {\n      var initialStyle = instance.rootElement.getAttribute('style');\n\n      if (initialStyle) {\n        instance.rootElement.setAttribute('data-initialstyle', instance.rootElement.getAttribute('style'));\n      }\n    }\n\n    if (height === null) {\n      var _initialStyle = instance.rootElement.getAttribute('data-initialstyle');\n\n      if (_initialStyle && (_initialStyle.indexOf('height') > -1 || _initialStyle.indexOf('overflow') > -1)) {\n        instance.rootElement.setAttribute('style', _initialStyle);\n      } else {\n        instance.rootElement.style.height = '';\n        instance.rootElement.style.overflow = '';\n      }\n    } else if (height !== void 0) {\n      instance.rootElement.style.height = isNaN(height) ? \"\".concat(height) : \"\".concat(height, \"px\");\n      instance.rootElement.style.overflow = 'hidden';\n    }\n\n    if (typeof settings.width !== 'undefined') {\n      var width = settings.width;\n\n      if (isFunction(width)) {\n        width = width();\n      }\n\n      instance.rootElement.style.width = isNaN(width) ? \"\".concat(width) : \"\".concat(width, \"px\");\n    }\n\n    if (!init) {\n      if (instance.view) {\n        instance.view.wt.wtViewport.resetHasOversizedColumnHeadersMarked();\n        instance.view.wt.exportSettingsAsClassNames();\n      }\n\n      instance.runHooks('afterUpdateSettings', settings);\n    }\n\n    grid.adjustRowsAndCols();\n\n    if (instance.view && !firstRun) {\n      instance.forceFullRender = true; // used when data was changed\n\n      editorManager.lockEditor();\n\n      instance._refreshBorders(null);\n\n      editorManager.unlockEditor();\n    }\n\n    if (!init && instance.view && (currentHeight === '' || height === '' || height === void 0) && currentHeight !== height) {\n      instance.view.wt.wtOverlays.updateMainScrollableElements();\n    }\n  };\n  /**\n   * Get value from the selected cell.\n   *\n   * @memberof Core#\n   * @function getValue\n   * @returns {*} Value of selected cell.\n   */\n\n\n  this.getValue = function () {\n    var sel = instance.getSelectedLast();\n\n    if (tableMeta.getValue) {\n      if (isFunction(tableMeta.getValue)) {\n        return tableMeta.getValue.call(instance);\n      } else if (sel) {\n        return instance.getData()[sel[0][0]][tableMeta.getValue];\n      }\n    } else if (sel) {\n      return instance.getDataAtCell(sel[0], sel[1]);\n    }\n  };\n  /**\n   * Returns the object settings.\n   *\n   * @memberof Core#\n   * @function getSettings\n   * @returns {object} Object containing the current table settings.\n   */\n\n\n  this.getSettings = function () {\n    return tableMeta;\n  };\n  /**\n   * Clears the data from the table (the table settings remain intact).\n   *\n   * @memberof Core#\n   * @function clear\n   */\n\n\n  this.clear = function () {\n    this.selectAll();\n    this.emptySelectedCells();\n  };\n  /**\n   * Allows altering the table structure by either inserting/removing rows or columns.\n   * This method works with an array data structure only.\n   *\n   * @memberof Core#\n   * @function alter\n   * @param {string} action Possible alter operations:\n   *  * `'insert_row'`\n   *  * `'insert_col'`\n   *  * `'remove_row'`\n   *  * `'remove_col'`.\n   * @param {number|number[]} index Visual index of the row/column before which the new row/column will be\n   *                                inserted/removed or an array of arrays in format `[[index, amount],...]`.\n   * @param {number} [amount=1] Amount of rows/columns to be inserted or removed.\n   * @param {string} [source] Source indicator.\n   * @param {boolean} [keepEmptyRows] Flag for preventing deletion of empty rows.\n   * @example\n   * ```js\n   * // Insert new row above the row at given visual index.\n   * hot.alter('insert_row', 10);\n   * // Insert 3 new columns before 10th column.\n   * hot.alter('insert_col', 10, 3);\n   * // Remove 2 rows starting from 10th row.\n   * hot.alter('remove_row', 10, 2);\n   * // Remove 5 non-contiquous rows (it removes 3 rows from visual index 1 and 2 rows from visual index 5).\n   * hot.alter('remove_row', [[1, 3], [5, 2]]);\n   * ```\n   */\n\n\n  this.alter = function (action, index, amount, source, keepEmptyRows) {\n    grid.alter(action, index, amount, source, keepEmptyRows);\n  };\n  /**\n   * Returns a TD element for the given `row` and `column` arguments, if it is rendered on screen.\n   * Returns `null` if the TD is not rendered on screen (probably because that part of the table is not visible).\n   *\n   * @memberof Core#\n   * @function getCell\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {boolean} [topmost=false] If set to `true`, it returns the TD element from the topmost overlay. For example,\n   * if the wanted cell is in the range of fixed rows, it will return a TD element from the `top` overlay.\n   * @returns {HTMLTableCellElement|null} The cell's TD element.\n   */\n\n\n  this.getCell = function (row, column) {\n    var topmost = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var renderableColumnIndex = column; // Handling also column headers.\n\n    var renderableRowIndex = row; // Handling also row headers.\n\n    if (column >= 0) {\n      if (this.columnIndexMapper.isHidden(this.toPhysicalColumn(column))) {\n        return null;\n      }\n\n      renderableColumnIndex = this.columnIndexMapper.getRenderableFromVisualIndex(column);\n    }\n\n    if (row >= 0) {\n      if (this.rowIndexMapper.isHidden(this.toPhysicalRow(row))) {\n        return null;\n      }\n\n      renderableRowIndex = this.rowIndexMapper.getRenderableFromVisualIndex(row);\n    }\n\n    if (renderableRowIndex === null || renderableColumnIndex === null) {\n      return null;\n    }\n\n    return instance.view.getCellAtCoords(new CellCoords(renderableRowIndex, renderableColumnIndex), topmost);\n  };\n  /**\n   * Returns the coordinates of the cell, provided as a HTML table cell element.\n   *\n   * @memberof Core#\n   * @function getCoords\n   * @param {HTMLTableCellElement} element The HTML Element representing the cell.\n   * @returns {CellCoords|null} Visual coordinates object.\n   * @example\n   * ```js\n   * hot.getCoords(hot.getCell(1, 1));\n   * // it returns CellCoords object instance with props row: 1 and col: 1.\n   * ```\n   */\n\n\n  this.getCoords = function (element) {\n    var renderableCoords = this.view.wt.wtTable.getCoords(element);\n\n    if (renderableCoords === null) {\n      return null;\n    }\n\n    var renderableRow = renderableCoords.row,\n        renderableColumn = renderableCoords.col;\n    var visualRow = renderableRow;\n    var visualColumn = renderableColumn;\n\n    if (renderableRow >= 0) {\n      visualRow = this.rowIndexMapper.getVisualFromRenderableIndex(renderableRow);\n    }\n\n    if (renderableColumn >= 0) {\n      visualColumn = this.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn);\n    }\n\n    return new CellCoords(visualRow, visualColumn);\n  };\n  /**\n   * Returns the property name that corresponds with the given column index (see {@link DataMap#colToProp}).\n   * If the data source is an array of arrays, it returns the columns index.\n   *\n   * @memberof Core#\n   * @function colToProp\n   * @param {number} column Visual column index.\n   * @returns {string|number} Column property or physical column index.\n   */\n\n\n  this.colToProp = function (column) {\n    return datamap.colToProp(column);\n  };\n  /**\n   * Returns column index that corresponds with the given property (see {@link DataMap#propToCol}).\n   *\n   * @memberof Core#\n   * @function propToCol\n   * @param {string|number} prop Property name or physical column index.\n   * @returns {number} Visual column index.\n   */\n\n\n  this.propToCol = function (prop) {\n    return datamap.propToCol(prop);\n  };\n  /**\n   * Translate physical row index into visual.\n   *\n   * This method is useful when you want to retrieve visual row index which can be reordered, moved or trimmed\n   * based on a physical index.\n   *\n   * @memberof Core#\n   * @function toVisualRow\n   * @param {number} row Physical row index.\n   * @returns {number} Returns visual row index.\n   */\n\n\n  this.toVisualRow = function (row) {\n    return _this.rowIndexMapper.getVisualFromPhysicalIndex(row);\n  };\n  /**\n   * Translate physical column index into visual.\n   *\n   * This method is useful when you want to retrieve visual column index which can be reordered, moved or trimmed\n   * based on a physical index.\n   *\n   * @memberof Core#\n   * @function toVisualColumn\n   * @param {number} column Physical column index.\n   * @returns {number} Returns visual column index.\n   */\n\n\n  this.toVisualColumn = function (column) {\n    return _this.columnIndexMapper.getVisualFromPhysicalIndex(column);\n  };\n  /**\n   * Translate visual row index into physical.\n   *\n   * This method is useful when you want to retrieve physical row index based on a visual index which can be\n   * reordered, moved or trimmed.\n   *\n   * @memberof Core#\n   * @function toPhysicalRow\n   * @param {number} row Visual row index.\n   * @returns {number} Returns physical row index.\n   */\n\n\n  this.toPhysicalRow = function (row) {\n    return _this.rowIndexMapper.getPhysicalFromVisualIndex(row);\n  };\n  /**\n   * Translate visual column index into physical.\n   *\n   * This method is useful when you want to retrieve physical column index based on a visual index which can be\n   * reordered, moved or trimmed.\n   *\n   * @memberof Core#\n   * @function toPhysicalColumn\n   * @param {number} column Visual column index.\n   * @returns {number} Returns physical column index.\n   */\n\n\n  this.toPhysicalColumn = function (column) {\n    return _this.columnIndexMapper.getPhysicalFromVisualIndex(column);\n  };\n  /**\n   * @description\n   * Returns the cell value at `row`, `column`.\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtCell\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {*} Data at cell.\n   */\n\n\n  this.getDataAtCell = function (row, column) {\n    return datamap.get(row, datamap.colToProp(column));\n  };\n  /**\n   * Returns value at visual `row` and `prop` indexes (see {@link DataMap#get}).\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtRowProp\n   * @param {number} row Visual row index.\n   * @param {string} prop Property name.\n   * @returns {*} Cell value.\n   */\n\n\n  this.getDataAtRowProp = function (row, prop) {\n    return datamap.get(row, prop);\n  };\n  /**\n   * @description\n   * Returns array of column values from the data source.\n   *\n   * __Note__: If columns were reordered or sorted, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtCol\n   * @param {number} column Visual column index.\n   * @returns {Array} Array of cell values.\n   */\n\n\n  this.getDataAtCol = function (column) {\n    var _ref13;\n\n    return (_ref13 = []).concat.apply(_ref13, _toConsumableArray(datamap.getRange(new CellCoords(0, column), new CellCoords(tableMeta.data.length - 1, column), datamap.DESTINATION_RENDERER)));\n  };\n  /**\n   * Given the object property name (e.g. `'first.name'` or `'0'`), returns an array of column's values from the table data.\n   * You can also provide a column index as the first argument.\n   *\n   * @memberof Core#\n   * @function getDataAtProp\n   * @param {string|number} prop Property name or physical column index.\n   * @returns {Array} Array of cell values.\n   */\n  // TODO: Getting data from `datamap` should work on visual indexes.\n\n\n  this.getDataAtProp = function (prop) {\n    var _ref14;\n\n    var range = datamap.getRange(new CellCoords(0, datamap.propToCol(prop)), new CellCoords(tableMeta.data.length - 1, datamap.propToCol(prop)), datamap.DESTINATION_RENDERER);\n    return (_ref14 = []).concat.apply(_ref14, _toConsumableArray(range));\n  };\n  /**\n   * Returns a clone of the source data object.\n   * Optionally you can provide a cell range by using the `row`, `column`, `row2`, `column2` arguments, to get only a\n   * fragment of the table data.\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceData\n   * @param {number} [row] From physical row index.\n   * @param {number} [column] From physical column index (or visual index, if data type is an array of objects).\n   * @param {number} [row2] To physical row index.\n   * @param {number} [column2] To physical column index (or visual index, if data type is an array of objects).\n   * @returns {Array[]|object[]} The table data.\n   */\n\n\n  this.getSourceData = function (row, column, row2, column2) {\n    var data;\n\n    if (row === void 0) {\n      data = dataSource.getData();\n    } else {\n      data = dataSource.getByRange(new CellCoords(row, column), new CellCoords(row2, column2));\n    }\n\n    return data;\n  };\n  /**\n   * Returns the source data object as an arrays of arrays format even when source data was provided in another format.\n   * Optionally you can provide a cell range by using the `row`, `column`, `row2`, `column2` arguments, to get only a\n   * fragment of the table data.\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceDataArray\n   * @param {number} [row] From physical row index.\n   * @param {number} [column] From physical column index (or visual index, if data type is an array of objects).\n   * @param {number} [row2] To physical row index.\n   * @param {number} [column2] To physical column index (or visual index, if data type is an array of objects).\n   * @returns {Array} An array of arrays.\n   */\n\n\n  this.getSourceDataArray = function (row, column, row2, column2) {\n    var data;\n\n    if (row === void 0) {\n      data = dataSource.getData(true);\n    } else {\n      data = dataSource.getByRange(new CellCoords(row, column), new CellCoords(row2, column2), true);\n    }\n\n    return data;\n  };\n  /**\n   * Returns an array of column values from the data source.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtCol\n   * @param {number} column Visual column index.\n   * @returns {Array} Array of the column's cell values.\n   */\n  // TODO: Getting data from `sourceData` should work always on physical indexes.\n\n\n  this.getSourceDataAtCol = function (column) {\n    return dataSource.getAtColumn(column);\n  };\n  /* eslint-disable jsdoc/require-param */\n\n  /**\n   * Set the provided value in the source data set at the provided coordinates.\n   *\n   * @memberof Core#\n   * @function setSourceDataAtCell\n   * @param {number|Array} row Physical row index or array of changes in format `[[row, prop, value], ...]`.\n   * @param {number|string} column Physical column index / prop name.\n   * @param {*} value The value to be set at the provided coordinates.\n   * @param {string} [source] Source of the change as a string.\n   */\n\n  /* eslint-enable jsdoc/require-param */\n\n\n  this.setSourceDataAtCell = function (row, column, value, source) {\n    var input = setDataInputToArray(row, column, value);\n    var isThereAnySetSourceListener = this.hasHook('afterSetSourceDataAtCell');\n    var changesForHook = [];\n\n    if (isThereAnySetSourceListener) {\n      arrayEach(input, function (_ref15) {\n        var _ref16 = _slicedToArray(_ref15, 3),\n            changeRow = _ref16[0],\n            changeProp = _ref16[1],\n            changeValue = _ref16[2];\n\n        changesForHook.push([changeRow, changeProp, dataSource.getAtCell(changeRow, changeProp), // The previous value.\n        changeValue]);\n      });\n    }\n\n    arrayEach(input, function (_ref17) {\n      var _ref18 = _slicedToArray(_ref17, 3),\n          changeRow = _ref18[0],\n          changeProp = _ref18[1],\n          changeValue = _ref18[2];\n\n      dataSource.setAtCell(changeRow, changeProp, changeValue);\n    });\n\n    if (isThereAnySetSourceListener) {\n      this.runHooks('afterSetSourceDataAtCell', changesForHook, source);\n    }\n\n    this.render();\n    var activeEditor = instance.getActiveEditor();\n\n    if (activeEditor && isDefined(activeEditor.refreshValue)) {\n      activeEditor.refreshValue();\n    }\n  };\n  /**\n   * Returns a single row of the data (array or object, depending on what data format you use).\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtRow\n   * @param {number} row Physical row index.\n   * @returns {Array|object} Single row of data.\n   */\n\n\n  this.getSourceDataAtRow = function (row) {\n    return dataSource.getAtRow(row);\n  };\n  /**\n   * Returns a single value from the data source.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtCell\n   * @param {number} row Physical row index.\n   * @param {number} column Visual column index.\n   * @returns {*} Cell data.\n   */\n  // TODO: Getting data from `sourceData` should work always on physical indexes.\n\n\n  this.getSourceDataAtCell = function (row, column) {\n    return dataSource.getAtCell(row, column);\n  };\n  /**\n   * @description\n   * Returns a single row of the data.\n   *\n   * __Note__: If rows were reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtRow\n   * @param {number} row Visual row index.\n   * @returns {Array} Array of row's cell data.\n   */\n\n\n  this.getDataAtRow = function (row) {\n    var data = datamap.getRange(new CellCoords(row, 0), new CellCoords(row, this.countCols() - 1), datamap.DESTINATION_RENDERER);\n    return data[0] || [];\n  };\n  /**\n   * @description\n   * Returns a data type defined in the Handsontable settings under the `type` key ([Options#type](https://handsontable.com/docs/Options.html#type)).\n   * If there are cells with different types in the selected range, it returns `'mixed'`.\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataType\n   * @param {number} rowFrom From visual row index.\n   * @param {number} columnFrom From visual column index.\n   * @param {number} rowTo To visual row index.\n   * @param {number} columnTo To visual column index.\n   * @returns {string} Cell type (e.q: `'mixed'`, `'text'`, `'numeric'`, `'autocomplete'`).\n   */\n\n\n  this.getDataType = function (rowFrom, columnFrom, rowTo, columnTo) {\n    var _this3 = this;\n\n    var coords = rowFrom === void 0 ? [0, 0, this.countRows(), this.countCols()] : [rowFrom, columnFrom, rowTo, columnTo];\n    var rowStart = coords[0],\n        columnStart = coords[1];\n    var rowEnd = coords[2],\n        columnEnd = coords[3];\n    var previousType = null;\n    var currentType = null;\n\n    if (rowEnd === void 0) {\n      rowEnd = rowStart;\n    }\n\n    if (columnEnd === void 0) {\n      columnEnd = columnStart;\n    }\n\n    var type = 'mixed';\n    rangeEach(Math.max(Math.min(rowStart, rowEnd), 0), Math.max(rowStart, rowEnd), function (row) {\n      var isTypeEqual = true;\n      rangeEach(Math.max(Math.min(columnStart, columnEnd), 0), Math.max(columnStart, columnEnd), function (column) {\n        var cellType = _this3.getCellMeta(row, column);\n\n        currentType = cellType.type;\n\n        if (previousType) {\n          isTypeEqual = previousType === currentType;\n        } else {\n          previousType = currentType;\n        }\n\n        return isTypeEqual;\n      });\n      type = isTypeEqual ? currentType : 'mixed';\n      return isTypeEqual;\n    });\n    return type;\n  };\n  /**\n   * Remove a property defined by the `key` argument from the cell meta object for the provided `row` and `column` coordinates.\n   *\n   * @memberof Core#\n   * @function removeCellMeta\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {string} key Property name.\n   * @fires Hooks#beforeRemoveCellMeta\n   * @fires Hooks#afterRemoveCellMeta\n   */\n\n\n  this.removeCellMeta = function (row, column, key) {\n    var _ref19 = [this.toPhysicalRow(row), this.toPhysicalColumn(column)],\n        physicalRow = _ref19[0],\n        physicalColumn = _ref19[1];\n    var cachedValue = metaManager.getCellMeta(physicalRow, physicalColumn, key);\n    var hookResult = instance.runHooks('beforeRemoveCellMeta', row, column, key, cachedValue);\n\n    if (hookResult !== false) {\n      metaManager.removeCellMeta(physicalRow, physicalColumn, key);\n      instance.runHooks('afterRemoveCellMeta', row, column, key, cachedValue);\n    }\n\n    cachedValue = null;\n  };\n  /**\n   * Removes or adds one or more rows of the cell meta objects to the cell meta collections.\n   *\n   * @since 0.30.0\n   * @memberof Core#\n   * @function spliceCellsMeta\n   * @param {number} visualIndex A visual index that specifies at what position to add/remove items.\n   * @param {number} [deleteAmount=0] The number of items to be removed. If set to 0, no cell meta objects will be removed.\n   * @param {...object} [cellMetaRows] The new cell meta row objects to be added to the cell meta collection.\n   */\n\n\n  this.spliceCellsMeta = function (visualIndex) {\n    var _this4 = this;\n\n    var deleteAmount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    for (var _len3 = arguments.length, cellMetaRows = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      cellMetaRows[_key3 - 2] = arguments[_key3];\n    }\n\n    if (cellMetaRows.length > 0 && !Array.isArray(cellMetaRows[0])) {\n      throw new Error('The 3rd argument (cellMetaRows) has to be passed as an array of cell meta objects array.');\n    }\n\n    if (deleteAmount > 0) {\n      metaManager.removeRow(this.toPhysicalRow(visualIndex), deleteAmount);\n    }\n\n    if (cellMetaRows.length > 0) {\n      arrayEach(cellMetaRows.reverse(), function (cellMetaRow) {\n        metaManager.createRow(_this4.toPhysicalRow(visualIndex));\n        arrayEach(cellMetaRow, function (cellMeta, columnIndex) {\n          return _this4.setCellMetaObject(visualIndex, columnIndex, cellMeta);\n        });\n      });\n    }\n  };\n  /**\n   * Set cell meta data object defined by `prop` to the corresponding params `row` and `column`.\n   *\n   * @memberof Core#\n   * @function setCellMetaObject\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {object} prop Meta object.\n   */\n\n\n  this.setCellMetaObject = function (row, column, prop) {\n    var _this5 = this;\n\n    if (_typeof(prop) === 'object') {\n      objectEach(prop, function (value, key) {\n        _this5.setCellMeta(row, column, key, value);\n      });\n    }\n  };\n  /**\n   * Sets a property defined by the `key` property to the meta object of a cell corresponding to params `row` and `column`.\n   *\n   * @memberof Core#\n   * @function setCellMeta\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {string} key Property name.\n   * @param {string} value Property value.\n   * @fires Hooks#beforeSetCellMeta\n   * @fires Hooks#afterSetCellMeta\n   */\n\n\n  this.setCellMeta = function (row, column, key, value) {\n    var allowSetCellMeta = instance.runHooks('beforeSetCellMeta', row, column, key, value);\n\n    if (allowSetCellMeta === false) {\n      return;\n    }\n\n    var physicalRow = row;\n    var physicalColumn = column;\n\n    if (row < this.countRows()) {\n      physicalRow = this.toPhysicalRow(row);\n    }\n\n    if (column < this.countCols()) {\n      physicalColumn = this.toPhysicalColumn(column);\n    }\n\n    metaManager.setCellMeta(physicalRow, physicalColumn, key, value);\n    instance.runHooks('afterSetCellMeta', row, column, key, value);\n  };\n  /**\n   * Get all the cells meta settings at least once generated in the table (in order of cell initialization).\n   *\n   * @memberof Core#\n   * @function getCellsMeta\n   * @returns {Array} Returns an array of ColumnSettings object instances.\n   */\n\n\n  this.getCellsMeta = function () {\n    return metaManager.getCellsMeta();\n  };\n  /**\n   * Returns the cell properties object for the given `row` and `column` coordinates.\n   *\n   * @memberof Core#\n   * @function getCellMeta\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {object} The cell properties object.\n   * @fires Hooks#beforeGetCellMeta\n   * @fires Hooks#afterGetCellMeta\n   */\n\n\n  this.getCellMeta = function (row, column) {\n    var physicalRow = this.toPhysicalRow(row);\n    var physicalColumn = this.toPhysicalColumn(column);\n\n    if (physicalRow === null) {\n      physicalRow = row;\n    }\n\n    if (physicalColumn === null) {\n      physicalColumn = column;\n    }\n\n    var prop = datamap.colToProp(column);\n    var cellProperties = metaManager.getCellMeta(physicalRow, physicalColumn); // TODO(perf): Add assigning this props and executing below code only once per table render cycle.\n\n    cellProperties.row = physicalRow;\n    cellProperties.col = physicalColumn;\n    cellProperties.visualRow = row;\n    cellProperties.visualCol = column;\n    cellProperties.prop = prop;\n    cellProperties.instance = instance;\n    instance.runHooks('beforeGetCellMeta', row, column, cellProperties); // for `type` added or changed in beforeGetCellMeta\n\n    if (instance.hasHook('beforeGetCellMeta') && hasOwnProperty(cellProperties, 'type')) {\n      metaManager.updateCellMeta(physicalRow, physicalColumn, {\n        type: cellProperties.type\n      });\n    }\n\n    if (cellProperties.cells) {\n      var settings = cellProperties.cells(physicalRow, physicalColumn, prop);\n\n      if (settings) {\n        metaManager.updateCellMeta(physicalRow, physicalColumn, settings);\n      }\n    }\n\n    instance.runHooks('afterGetCellMeta', row, column, cellProperties);\n    return cellProperties;\n  };\n  /**\n   * Returns an array of cell meta objects for specified physical row index.\n   *\n   * @memberof Core#\n   * @function getCellMetaAtRow\n   * @param {number} row Physical row index.\n   * @returns {Array}\n   */\n\n\n  this.getCellMetaAtRow = function (row) {\n    return metaManager.getCellsMetaAtRow(row);\n  };\n  /**\n   * Checks if the data format and config allows user to modify the column structure.\n   *\n   * @memberof Core#\n   * @function isColumnModificationAllowed\n   * @returns {boolean}\n   */\n\n\n  this.isColumnModificationAllowed = function () {\n    return !(instance.dataType === 'object' || tableMeta.columns);\n  };\n\n  var rendererLookup = cellMethodLookupFactory('renderer');\n  /**\n   * Returns the cell renderer function by given `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function getCellRenderer\n   * @param {number|object} row Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {number} column Visual column index.\n   * @returns {Function} The renderer function.\n   * @example\n   * ```js\n   * // Get cell renderer using `row` and `column` coordinates.\n   * hot.getCellRenderer(1, 1);\n   * // Get cell renderer using cell meta object.\n   * hot.getCellRenderer(hot.getCellMeta(1, 1));\n   * ```\n   */\n\n  this.getCellRenderer = function (row, column) {\n    return getRenderer(rendererLookup.call(this, row, column));\n  };\n  /**\n   * Returns the cell editor class by the provided `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function getCellEditor\n   * @param {number} row Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {number} column Visual column index.\n   * @returns {Function} The editor class.\n   * @example\n   * ```js\n   * // Get cell editor class using `row` and `column` coordinates.\n   * hot.getCellEditor(1, 1);\n   * // Get cell editor class using cell meta object.\n   * hot.getCellEditor(hot.getCellMeta(1, 1));\n   * ```\n   */\n\n\n  this.getCellEditor = cellMethodLookupFactory('editor');\n  var validatorLookup = cellMethodLookupFactory('validator');\n  /**\n   * Returns the cell validator by `row` and `column`.\n   *\n   * @memberof Core#\n   * @function getCellValidator\n   * @param {number|object} row Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {number} column Visual column index.\n   * @returns {Function|RegExp|undefined} The validator function.\n   * @example\n   * ```js\n   * // Get cell valiator using `row` and `column` coordinates.\n   * hot.getCellValidator(1, 1);\n   * // Get cell valiator using cell meta object.\n   * hot.getCellValidator(hot.getCellMeta(1, 1));\n   * ```\n   */\n\n  this.getCellValidator = function (row, column) {\n    var validator = validatorLookup.call(this, row, column);\n\n    if (typeof validator === 'string') {\n      validator = getValidator(validator);\n    }\n\n    return validator;\n  };\n  /**\n   * Validates all cells using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   * would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateCells\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateCells((valid) => {\n   *   if (valid) {\n   *     // ... code for validated cells\n   *   }\n   * })\n   * ```\n   */\n\n\n  this.validateCells = function (callback) {\n    this._validateCells(callback);\n  };\n  /**\n   * Validates rows using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   *  would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateRows\n   * @param {Array} [rows] Array of validation target visual row indexes.\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateRows([3, 4, 5], (valid) => {\n   *   if (valid) {\n   *     // ... code for validated rows\n   *   }\n   * })\n   * ```\n   */\n\n\n  this.validateRows = function (rows, callback) {\n    if (!Array.isArray(rows)) {\n      throw new Error('validateRows parameter `rows` must be an array');\n    }\n\n    this._validateCells(callback, rows);\n  };\n  /**\n   * Validates columns using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   *  would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateColumns\n   * @param {Array} [columns] Array of validation target visual columns indexes.\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateColumns([3, 4, 5], (valid) => {\n   *   if (valid) {\n   *     // ... code for validated columns\n   *   }\n   * })\n   * ```\n   */\n\n\n  this.validateColumns = function (columns, callback) {\n    if (!Array.isArray(columns)) {\n      throw new Error('validateColumns parameter `columns` must be an array');\n    }\n\n    this._validateCells(callback, undefined, columns);\n  };\n  /**\n   * Validates all cells using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it would equal `true`.\n   *\n   * Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _validateCells\n   * @param {Function} [callback] The callback function.\n   * @param {Array} [rows] An array of validation target visual row indexes.\n   * @param {Array} [columns] An array of validation target visual column indexes.\n   */\n\n\n  this._validateCells = function (callback, rows, columns) {\n    var waitingForValidator = new ValidatorsQueue();\n\n    if (callback) {\n      waitingForValidator.onQueueEmpty = callback;\n    }\n\n    var i = instance.countRows() - 1;\n\n    while (i >= 0) {\n      if (rows !== undefined && rows.indexOf(i) === -1) {\n        i -= 1;\n        continue;\n      }\n\n      var j = instance.countCols() - 1;\n\n      while (j >= 0) {\n        if (columns !== undefined && columns.indexOf(j) === -1) {\n          j -= 1;\n          continue;\n        }\n\n        waitingForValidator.addValidatorToQueue();\n        instance.validateCell(instance.getDataAtCell(i, j), instance.getCellMeta(i, j), function (result) {\n          if (typeof result !== 'boolean') {\n            throw new Error('Validation error: result is not boolean');\n          }\n\n          if (result === false) {\n            waitingForValidator.valid = false;\n          }\n\n          waitingForValidator.removeValidatorFormQueue();\n        }, 'validateCells');\n        j -= 1;\n      }\n\n      i -= 1;\n    }\n\n    waitingForValidator.checkIfQueueIsEmpty();\n  };\n  /**\n   * Returns an array of row headers' values (if they are enabled). If param `row` was given, it returns the header of the given row as a string.\n   *\n   * @memberof Core#\n   * @function getRowHeader\n   * @param {number} [row] Visual row index.\n   * @fires Hooks#modifyRowHeader\n   * @returns {Array|string|number} Array of header values / single header value.\n   */\n\n\n  this.getRowHeader = function (row) {\n    var rowHeader = tableMeta.rowHeaders;\n    var physicalRow = row;\n\n    if (physicalRow !== void 0) {\n      physicalRow = instance.runHooks('modifyRowHeader', physicalRow);\n    }\n\n    if (physicalRow === void 0) {\n      rowHeader = [];\n      rangeEach(instance.countRows() - 1, function (i) {\n        rowHeader.push(instance.getRowHeader(i));\n      });\n    } else if (Array.isArray(rowHeader) && rowHeader[physicalRow] !== void 0) {\n      rowHeader = rowHeader[physicalRow];\n    } else if (isFunction(rowHeader)) {\n      rowHeader = rowHeader(physicalRow);\n    } else if (rowHeader && typeof rowHeader !== 'string' && typeof rowHeader !== 'number') {\n      rowHeader = physicalRow + 1;\n    }\n\n    return rowHeader;\n  };\n  /**\n   * Returns information about if this table is configured to display row headers.\n   *\n   * @memberof Core#\n   * @function hasRowHeaders\n   * @returns {boolean} `true` if the instance has the row headers enabled, `false` otherwise.\n   */\n\n\n  this.hasRowHeaders = function () {\n    return !!tableMeta.rowHeaders;\n  };\n  /**\n   * Returns information about if this table is configured to display column headers.\n   *\n   * @memberof Core#\n   * @function hasColHeaders\n   * @returns {boolean} `true` if the instance has the column headers enabled, `false` otherwise.\n   */\n\n\n  this.hasColHeaders = function () {\n    if (tableMeta.colHeaders !== void 0 && tableMeta.colHeaders !== null) {\n      // Polymer has empty value = null\n      return !!tableMeta.colHeaders;\n    }\n\n    for (var i = 0, ilen = instance.countCols(); i < ilen; i++) {\n      if (instance.getColHeader(i)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Returns an array of column headers (in string format, if they are enabled). If param `column` is given, it\n   * returns the header at the given column.\n   *\n   * @memberof Core#\n   * @function getColHeader\n   * @param {number} [column] Visual column index.\n   * @fires Hooks#modifyColHeader\n   * @returns {Array|string|number} The column header(s).\n   */\n\n\n  this.getColHeader = function (column) {\n    var columnIndex = instance.runHooks('modifyColHeader', column);\n    var result = tableMeta.colHeaders;\n\n    if (columnIndex === void 0) {\n      var out = [];\n      var ilen = instance.countCols();\n\n      for (var i = 0; i < ilen; i++) {\n        out.push(instance.getColHeader(i));\n      }\n\n      result = out;\n    } else {\n      var translateVisualIndexToColumns = function translateVisualIndexToColumns(visualColumnIndex) {\n        var arr = [];\n        var columnsLen = instance.countCols();\n        var index = 0;\n\n        for (; index < columnsLen; index++) {\n          if (isFunction(tableMeta.columns) && tableMeta.columns(index)) {\n            arr.push(index);\n          }\n        }\n\n        return arr[visualColumnIndex];\n      };\n\n      var physicalColumn = instance.toPhysicalColumn(columnIndex);\n      var prop = translateVisualIndexToColumns(physicalColumn);\n\n      if (tableMeta.colHeaders === false) {\n        result = null;\n      } else if (tableMeta.columns && isFunction(tableMeta.columns) && tableMeta.columns(prop) && tableMeta.columns(prop).title) {\n        result = tableMeta.columns(prop).title;\n      } else if (tableMeta.columns && tableMeta.columns[physicalColumn] && tableMeta.columns[physicalColumn].title) {\n        result = tableMeta.columns[physicalColumn].title;\n      } else if (Array.isArray(tableMeta.colHeaders) && tableMeta.colHeaders[physicalColumn] !== void 0) {\n        result = tableMeta.colHeaders[physicalColumn];\n      } else if (isFunction(tableMeta.colHeaders)) {\n        result = tableMeta.colHeaders(physicalColumn);\n      } else if (tableMeta.colHeaders && typeof tableMeta.colHeaders !== 'string' && typeof tableMeta.colHeaders !== 'number') {\n        result = spreadsheetColumnLabel(columnIndex); // see #1458\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Return column width from settings (no guessing). Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _getColWidthFromSettings\n   * @param {number} col Visual col index.\n   * @returns {number}\n   */\n\n\n  this._getColWidthFromSettings = function (col) {\n    var width; // We currently don't support cell meta objects for headers (negative values)\n\n    if (col >= 0) {\n      var cellProperties = instance.getCellMeta(0, col);\n      width = cellProperties.width;\n    }\n\n    if (width === void 0 || width === tableMeta.width) {\n      width = tableMeta.colWidths;\n    }\n\n    if (width !== void 0 && width !== null) {\n      switch (_typeof(width)) {\n        case 'object':\n          // array\n          width = width[col];\n          break;\n\n        case 'function':\n          width = width(col);\n          break;\n\n        default:\n          break;\n      }\n\n      if (typeof width === 'string') {\n        width = parseInt(width, 10);\n      }\n    }\n\n    return width;\n  };\n  /**\n   * Returns the width of the requested column.\n   *\n   * @memberof Core#\n   * @function getColWidth\n   * @param {number} column Visual column index.\n   * @returns {number} Column width.\n   * @fires Hooks#modifyColWidth\n   */\n\n\n  this.getColWidth = function (column) {\n    var width = instance._getColWidthFromSettings(column);\n\n    width = instance.runHooks('modifyColWidth', width, column);\n\n    if (width === void 0) {\n      width = ViewportColumnsCalculator.DEFAULT_WIDTH;\n    }\n\n    return width;\n  };\n  /**\n   * Return row height from settings (no guessing). Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _getRowHeightFromSettings\n   * @param {number} row Visual row index.\n   * @returns {number}\n   */\n\n\n  this._getRowHeightFromSettings = function (row) {\n    // let cellProperties = instance.getCellMeta(row, 0);\n    // let height = cellProperties.height;\n    //\n    // if (height === void 0 || height === tableMeta.height) {\n    //  height = cellProperties.rowHeights;\n    // }\n    var height = tableMeta.rowHeights;\n\n    if (height !== void 0 && height !== null) {\n      switch (_typeof(height)) {\n        case 'object':\n          // array\n          height = height[row];\n          break;\n\n        case 'function':\n          height = height(row);\n          break;\n\n        default:\n          break;\n      }\n\n      if (typeof height === 'string') {\n        height = parseInt(height, 10);\n      }\n    }\n\n    return height;\n  };\n  /**\n   * Returns the row height.\n   *\n   * @memberof Core#\n   * @function getRowHeight\n   * @param {number} row Visual row index.\n   * @returns {number} The given row's height.\n   * @fires Hooks#modifyRowHeight\n   */\n\n\n  this.getRowHeight = function (row) {\n    var height = instance._getRowHeightFromSettings(row);\n\n    height = instance.runHooks('modifyRowHeight', height, row);\n    return height;\n  };\n  /**\n   * Returns the total number of rows in the data source.\n   *\n   * @memberof Core#\n   * @function countSourceRows\n   * @returns {number} Total number of rows.\n   */\n\n\n  this.countSourceRows = function () {\n    return dataSource.countRows();\n  };\n  /**\n   * Returns the total number of columns in the data source.\n   *\n   * @memberof Core#\n   * @function countSourceCols\n   * @returns {number} Total number of columns.\n   */\n\n\n  this.countSourceCols = function () {\n    return dataSource.countFirstRowKeys();\n  };\n  /**\n   * Returns the total number of visual rows in the table.\n   *\n   * @memberof Core#\n   * @function countRows\n   * @returns {number} Total number of rows.\n   */\n\n\n  this.countRows = function () {\n    return datamap.getLength();\n  };\n  /**\n   * Returns the total number of visible columns in the table.\n   *\n   * @memberof Core#\n   * @function countCols\n   * @returns {number} Total number of columns.\n   */\n\n\n  this.countCols = function () {\n    var maxCols = tableMeta.maxCols;\n    var dataLen = this.columnIndexMapper.getNotTrimmedIndexesLength();\n    return Math.min(maxCols, dataLen);\n  };\n  /**\n   * Returns the number of rendered rows (including rows partially or fully rendered outside viewport).\n   *\n   * @memberof Core#\n   * @function countRenderedRows\n   * @returns {number} Returns -1 if table is not visible.\n   */\n\n\n  this.countRenderedRows = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedRowsCount() : -1;\n  };\n  /**\n   * Returns the number of visible rows (rendered rows that fully fit inside viewport).\n   *\n   * @memberof Core#\n   * @function countVisibleRows\n   * @returns {number} Number of visible rows or -1.\n   */\n\n\n  this.countVisibleRows = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleRowsCount() : -1;\n  };\n  /**\n   * Returns the number of rendered columns (including columns partially or fully rendered outside viewport).\n   *\n   * @memberof Core#\n   * @function countRenderedCols\n   * @returns {number} Returns -1 if table is not visible.\n   */\n\n\n  this.countRenderedCols = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedColumnsCount() : -1;\n  };\n  /**\n   * Returns the number of visible columns. Returns -1 if table is not visible.\n   *\n   * @memberof Core#\n   * @function countVisibleCols\n   * @returns {number} Number of visible columns or -1.\n   */\n\n\n  this.countVisibleCols = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleColumnsCount() : -1;\n  };\n  /**\n   * Returns the number of empty rows. If the optional ending parameter is `true`, returns the\n   * number of empty rows at the bottom of the table.\n   *\n   * @memberof Core#\n   * @function countEmptyRows\n   * @param {boolean} [ending=false] If `true`, will only count empty rows at the end of the data source.\n   * @returns {number} Count empty rows.\n   */\n\n\n  this.countEmptyRows = function () {\n    var ending = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var emptyRows = 0;\n    rangeEachReverse(instance.countRows() - 1, function (visualIndex) {\n      if (instance.isEmptyRow(visualIndex)) {\n        emptyRows += 1;\n      } else if (ending === true) {\n        return false;\n      }\n    });\n    return emptyRows;\n  };\n  /**\n   * Returns the number of empty columns. If the optional ending parameter is `true`, returns the number of empty\n   * columns at right hand edge of the table.\n   *\n   * @memberof Core#\n   * @function countEmptyCols\n   * @param {boolean} [ending=false] If `true`, will only count empty columns at the end of the data source row.\n   * @returns {number} Count empty cols.\n   */\n\n\n  this.countEmptyCols = function () {\n    var ending = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (instance.countRows() < 1) {\n      return 0;\n    }\n\n    var emptyColumns = 0;\n    rangeEachReverse(instance.countCols() - 1, function (visualIndex) {\n      if (instance.isEmptyCol(visualIndex)) {\n        emptyColumns += 1;\n      } else if (ending === true) {\n        return false;\n      }\n    });\n    return emptyColumns;\n  };\n  /**\n   * Check if all cells in the row declared by the `row` argument are empty.\n   *\n   * @memberof Core#\n   * @function isEmptyRow\n   * @param {number} row Visual row index.\n   * @returns {boolean} `true` if the row at the given `row` is empty, `false` otherwise.\n   */\n\n\n  this.isEmptyRow = function (row) {\n    return tableMeta.isEmptyRow.call(instance, row);\n  };\n  /**\n   * Check if all cells in the the column declared by the `column` argument are empty.\n   *\n   * @memberof Core#\n   * @function isEmptyCol\n   * @param {number} column Column index.\n   * @returns {boolean} `true` if the column at the given `col` is empty, `false` otherwise.\n   */\n\n\n  this.isEmptyCol = function (column) {\n    return tableMeta.isEmptyCol.call(instance, column);\n  };\n  /**\n   * Select cell specified by `row` and `column` values or a range of cells finishing at `endRow`, `endCol`. If the table\n   * was configured to support data column properties that properties can be used to making a selection.\n   *\n   * By default, viewport will be scrolled to the selection. After the `selectCell` method had finished, the instance\n   * will be listening to keyboard input on the document.\n   *\n   * @example\n   * ```js\n   * // select a single cell\n   * hot.selectCell(2, 4);\n   * // select a single cell using column property\n   * hot.selectCell(2, 'address');\n   * // select a range of cells\n   * hot.selectCell(2, 4, 3, 5);\n   * // select a range of cells using column properties\n   * hot.selectCell(2, 'address', 3, 'phone_number');\n   * // select a range of cells without scrolling to them\n   * hot.selectCell(2, 'address', 3, 'phone_number', false);\n   * ```\n   *\n   * @memberof Core#\n   * @function selectCell\n   * @param {number} row Visual row index.\n   * @param {number|string} column Visual column index or column property.\n   * @param {number} [endRow] Visual end row index (if selecting a range).\n   * @param {number|string} [endColumn] Visual end column index or column property (if selecting a range).\n   * @param {boolean} [scrollToCell=true] If `true`, the viewport will be scrolled to the selection.\n   * @param {boolean} [changeListener=true] If `false`, Handsontable will not change keyboard events listener to himself.\n   * @returns {boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n\n  this.selectCell = function (row, column, endRow, endColumn) {\n    var scrollToCell = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var changeListener = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n    if (isUndefined(row) || isUndefined(column)) {\n      return false;\n    }\n\n    return this.selectCells([[row, column, endRow, endColumn]], scrollToCell, changeListener);\n  };\n  /**\n   * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n   * finishing at `endRow`, `endColumn`. The method supports two input formats which are the same as that\n   * produces by `getSelected` and `getSelectedRange` methods.\n   *\n   * By default, viewport will be scrolled to selection. After the `selectCells` method had finished, the instance\n   * will be listening to keyboard input on the document.\n   *\n   * @example\n   * ```js\n   * // Using an array of arrays.\n   * hot.selectCells([[1, 1, 2, 2], [3, 3], [6, 2, 0, 2]]);\n   * // Using an array of arrays with defined columns as props.\n   * hot.selectCells([[1, 'id', 2, 'first_name'], [3, 'full_name'], [6, 'last_name', 0, 'first_name']]);\n   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).\n   * const selected = hot.getSelectedRange();\n   *\n   * selected[0].from.row = 0;\n   * selected[0].from.col = 0;\n   *\n   * hot.selectCells(selected);\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectCells\n   * @param {Array[]|CellRange[]} coords Visual coords passed as an array of array (`[[rowStart, columnStart, rowEnd, columnEnd], ...]`)\n   *                                     the same format as `getSelected` method returns or as an CellRange objects\n   *                                     which is the same format what `getSelectedRange` method returns.\n   * @param {boolean} [scrollToCell=true] If `true`, the viewport will be scrolled to the selection.\n   * @param {boolean} [changeListener=true] If `false`, Handsontable will not change keyboard events listener to himself.\n   * @returns {boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n\n  this.selectCells = function () {\n    var coords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [[]];\n    var scrollToCell = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var changeListener = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    if (scrollToCell === false) {\n      preventScrollingToCell = true;\n    }\n\n    var wasSelected = selection.selectCells(coords);\n\n    if (wasSelected && changeListener) {\n      instance.listen();\n    }\n\n    preventScrollingToCell = false;\n    return wasSelected;\n  };\n  /**\n   * Select column specified by `startColumn` visual index, column property or a range of columns finishing at `endColumn`.\n   *\n   * @example\n   * ```js\n   * // Select column using visual index.\n   * hot.selectColumns(1);\n   * // Select column using column property.\n   * hot.selectColumns('id');\n   * // Select range of columns using visual indexes.\n   * hot.selectColumns(1, 4);\n   * // Select range of columns using column properties.\n   * hot.selectColumns('id', 'last_name');\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectColumns\n   * @param {number} startColumn The visual column index from which the selection starts.\n   * @param {number} [endColumn=startColumn] The visual column index to which the selection finishes. If `endColumn`\n   *                                         is not defined the column defined by `startColumn` will be selected.\n   * @returns {boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n\n  this.selectColumns = function (startColumn) {\n    var endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n    return selection.selectColumns(startColumn, endColumn);\n  };\n  /**\n   * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n   *\n   * @example\n   * ```js\n   * // Select row using visual index.\n   * hot.selectRows(1);\n   * // Select range of rows using visual indexes.\n   * hot.selectRows(1, 4);\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectRows\n   * @param {number} startRow The visual row index from which the selection starts.\n   * @param {number} [endRow=startRow] The visual row index to which the selection finishes. If `endRow`\n   *                                   is not defined the row defined by `startRow` will be selected.\n   * @returns {boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n\n  this.selectRows = function (startRow) {\n    var endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n    return selection.selectRows(startRow, endRow);\n  };\n  /**\n   * Deselects the current cell selection on the table.\n   *\n   * @memberof Core#\n   * @function deselectCell\n   */\n\n\n  this.deselectCell = function () {\n    selection.deselect();\n  };\n  /**\n   * Select the whole table. The previous selection will be overwritten.\n   *\n   * @since 0.38.2\n   * @memberof Core#\n   * @function selectAll\n   * @param {boolean} [includeHeaders=true] `true` If the selection should include the row, column and corner headers,\n   * `false` otherwise.\n   */\n\n\n  this.selectAll = function () {\n    var includeHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var includeRowHeaders = includeHeaders && this.hasRowHeaders();\n    var includeColumnHeaders = includeHeaders && this.hasColHeaders();\n    preventScrollingToCell = true;\n    selection.selectAll(includeRowHeaders, includeColumnHeaders);\n    preventScrollingToCell = false;\n  };\n\n  var getIndexToScroll = function getIndexToScroll(indexMapper, visualIndex) {\n    // Looking for a visual index on the right and then (when not found) on the left.\n    return indexMapper.getFirstNotHiddenIndex(visualIndex, 1, true);\n  };\n  /**\n   * Scroll viewport to coordinates specified by the `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function scrollViewportTo\n   * @param {number} [row] Row index. If the last argument isn't defined we treat the index as a visual row index. Otherwise,\n   * we are using the index for numbering only this rows which may be rendered (we don't consider hidden rows).\n   * @param {number} [column] Column index. If the last argument isn't defined we treat the index as a visual column index.\n   * Otherwise, we are using the index for numbering only this columns which may be rendered (we don't consider hidden columns).\n   * @param {boolean} [snapToBottom=false] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @param {boolean} [snapToRight=false] If `true`, viewport is scrolled to show the cell on the right side of the table.\n   * @param {boolean} [considerHiddenIndexes=true] If `true`, we handle visual indexes, otherwise we handle only indexes which\n   * may be rendered when they are in the viewport (we don't consider hidden indexes as they aren't rendered).\n   * @returns {boolean} `true` if scroll was successful, `false` otherwise.\n   */\n\n\n  this.scrollViewportTo = function (row, column) {\n    var snapToBottom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var snapToRight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var considerHiddenIndexes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var snapToTop = !snapToBottom;\n    var snapToLeft = !snapToRight;\n    var renderableRow = row;\n    var renderableColumn = column;\n\n    if (considerHiddenIndexes) {\n      var _isRowInteger = Number.isInteger(row);\n\n      var _isColumnInteger = Number.isInteger(column);\n\n      var visualRowToScroll = _isRowInteger ? getIndexToScroll(this.rowIndexMapper, row) : void 0;\n      var visualColumnToScroll = _isColumnInteger ? getIndexToScroll(this.columnIndexMapper, column) : void 0;\n\n      if (visualRowToScroll === null || visualColumnToScroll === null) {\n        return false;\n      }\n\n      renderableRow = _isRowInteger ? instance.rowIndexMapper.getRenderableFromVisualIndex(visualRowToScroll) : void 0;\n      renderableColumn = _isColumnInteger ? instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumnToScroll) : void 0;\n    }\n\n    var isRowInteger = Number.isInteger(renderableRow);\n    var isColumnInteger = Number.isInteger(renderableColumn);\n\n    if (isRowInteger && isColumnInteger) {\n      return instance.view.scrollViewport(new CellCoords(renderableRow, renderableColumn), snapToTop, snapToRight, snapToBottom, snapToLeft);\n    }\n\n    if (isRowInteger && isColumnInteger === false) {\n      return instance.view.scrollViewportVertically(renderableRow, snapToTop, snapToBottom);\n    }\n\n    if (isColumnInteger && isRowInteger === false) {\n      return instance.view.scrollViewportHorizontally(renderableColumn, snapToRight, snapToLeft);\n    }\n\n    return false;\n  };\n  /**\n   * Removes the table from the DOM and destroys the instance of the Handsontable.\n   *\n   * @memberof Core#\n   * @function destroy\n   * @fires Hooks#afterDestroy\n   */\n\n\n  this.destroy = function () {\n    instance._clearTimeouts();\n\n    instance._clearImmediates();\n\n    if (instance.view) {\n      // in case HT is destroyed before initialization has finished\n      instance.view.destroy();\n    }\n\n    if (dataSource) {\n      dataSource.destroy();\n    }\n\n    dataSource = null;\n    metaManager.clearCache();\n    keyStateStopObserving();\n\n    if (isRootInstance(instance)) {\n      var licenseInfo = this.rootDocument.querySelector('#hot-display-license-info');\n\n      if (licenseInfo) {\n        licenseInfo.parentNode.removeChild(licenseInfo);\n      }\n    }\n\n    empty(instance.rootElement);\n    eventManager.destroy();\n\n    if (editorManager) {\n      editorManager.destroy();\n    } // The plugin's `destroy` method is called as a consequence and it should handle\n    // unregistration of plugin's maps. Some unregistered maps reset the cache.\n\n\n    instance.batchExecution(function () {\n      instance.rowIndexMapper.unregisterAll();\n      instance.columnIndexMapper.unregisterAll();\n      pluginsRegistry.getItems().forEach(function (_ref20) {\n        var _ref21 = _slicedToArray(_ref20, 2),\n            plugin = _ref21[1];\n\n        plugin.destroy();\n      });\n      pluginsRegistry.clear();\n      instance.runHooks('afterDestroy');\n    }, true);\n    Hooks.getSingleton().destroy(instance);\n    objectEach(instance, function (property, key, obj) {\n      // replace instance methods with post mortem\n      if (isFunction(property)) {\n        obj[key] = postMortem(key);\n      } else if (key !== 'guid') {\n        // replace instance properties with null (restores memory)\n        // it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests\n        obj[key] = null;\n      }\n    });\n    instance.isDestroyed = true; // replace private properties with null (restores memory)\n    // it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests\n\n    if (datamap) {\n      datamap.destroy();\n    }\n\n    instance.rowIndexMapper = null;\n    instance.columnIndexMapper = null;\n    datamap = null;\n    grid = null;\n    selection = null;\n    editorManager = null;\n    instance = null;\n  };\n  /**\n   * Replacement for all methods after the Handsontable was destroyed.\n   *\n   * @private\n   * @param {string} method The method name.\n   * @returns {Function}\n   */\n\n\n  function postMortem(method) {\n    return function () {\n      throw new Error(\"The \\\"\".concat(method, \"\\\" method cannot be called because this Handsontable instance has been destroyed\"));\n    };\n  }\n  /**\n   * Returns the active editor class instance.\n   *\n   * @memberof Core#\n   * @function getActiveEditor\n   * @returns {BaseEditor} The active editor instance.\n   */\n\n\n  this.getActiveEditor = function () {\n    return editorManager.getActiveEditor();\n  };\n  /**\n   * Returns plugin instance by provided its name.\n   *\n   * @memberof Core#\n   * @function getPlugin\n   * @param {string} pluginName The plugin name.\n   * @returns {BasePlugin|undefined} The plugin instance or undefined if there is no plugin.\n   */\n\n\n  this.getPlugin = function (pluginName) {\n    var unifiedPluginName = toUpperCaseFirst(pluginName); // Workaround for the UndoRedo plugin which, currently doesn't follow the plugin architecture.\n\n    if (unifiedPluginName === 'UndoRedo') {\n      return this.undoRedo;\n    }\n\n    return pluginsRegistry.getItem(unifiedPluginName);\n  };\n  /**\n   * Returns name of the passed plugin.\n   *\n   * @private\n   * @memberof Core#\n   * @param {BasePlugin} plugin The plugin instance.\n   * @returns {string}\n   */\n\n\n  this.getPluginName = function (plugin) {\n    // Workaround for the UndoRedo plugin which, currently doesn't follow the plugin architecture.\n    if (plugin === this.undoRedo) {\n      return this.undoRedo.constructor.PLUGIN_KEY;\n    }\n\n    return pluginsRegistry.getId(plugin);\n  };\n  /**\n   * Returns the Handsontable instance.\n   *\n   * @memberof Core#\n   * @function getInstance\n   * @returns {Handsontable} The Handsontable instance.\n   */\n\n\n  this.getInstance = function () {\n    return instance;\n  };\n  /**\n   * Adds listener to the specified hook name (only for this Handsontable instance).\n   *\n   * @memberof Core#\n   * @function addHook\n   * @see Hooks#add\n   * @param {string} key Hook name (see {@link Hooks}).\n   * @param {Function|Array} callback Function or array of functions.\n   * @example\n   * ```js\n   * hot.addHook('beforeInit', myCallback);\n   * ```\n   */\n\n\n  this.addHook = function (key, callback) {\n    Hooks.getSingleton().add(key, callback, instance);\n  };\n  /**\n   * Check if for a specified hook name there are added listeners (only for this Handsontable instance). All available\n   * hooks you will find {@link Hooks}.\n   *\n   * @memberof Core#\n   * @function hasHook\n   * @see Hooks#has\n   * @param {string} key Hook name.\n   * @returns {boolean}\n   *\n   * @example\n   * ```js\n   * const hasBeforeInitListeners = hot.hasHook('beforeInit');\n   * ```\n   */\n\n\n  this.hasHook = function (key) {\n    return Hooks.getSingleton().has(key, instance);\n  };\n  /**\n   * Adds listener to specified hook name (only for this Handsontable instance). After the listener is triggered,\n   * it will be automatically removed.\n   *\n   * @memberof Core#\n   * @function addHookOnce\n   * @see Hooks#once\n   * @param {string} key Hook name (see {@link Hooks}).\n   * @param {Function|Array} callback Function or array of functions.\n   * @example\n   * ```js\n   * hot.addHookOnce('beforeInit', myCallback);\n   * ```\n   */\n\n\n  this.addHookOnce = function (key, callback) {\n    Hooks.getSingleton().once(key, callback, instance);\n  };\n  /**\n   * Removes the hook listener previously registered with {@link Core#addHook}.\n   *\n   * @memberof Core#\n   * @function removeHook\n   * @see Hooks#remove\n   * @param {string} key Hook name.\n   * @param {Function} callback Reference to the function which has been registered using {@link Core#addHook}.\n   *\n   * @example\n   * ```js\n   * hot.removeHook('beforeInit', myCallback);\n   * ```\n   */\n\n\n  this.removeHook = function (key, callback) {\n    Hooks.getSingleton().remove(key, callback, instance);\n  };\n  /**\n   * Run the callbacks for the hook provided in the `key` argument using the parameters given in the other arguments.\n   *\n   * @memberof Core#\n   * @function runHooks\n   * @see Hooks#run\n   * @param {string} key Hook name.\n   * @param {*} [p1] Argument passed to the callback.\n   * @param {*} [p2] Argument passed to the callback.\n   * @param {*} [p3] Argument passed to the callback.\n   * @param {*} [p4] Argument passed to the callback.\n   * @param {*} [p5] Argument passed to the callback.\n   * @param {*} [p6] Argument passed to the callback.\n   * @returns {*}\n   *\n   * @example\n   * ```js\n   * // Run built-in hook\n   * hot.runHooks('beforeInit');\n   * // Run custom hook\n   * hot.runHooks('customAction', 10, 'foo');\n   * ```\n   */\n\n\n  this.runHooks = function (key, p1, p2, p3, p4, p5, p6) {\n    return Hooks.getSingleton().run(instance, key, p1, p2, p3, p4, p5, p6);\n  };\n  /**\n   * Get language phrase for specified dictionary key.\n   *\n   * @memberof Core#\n   * @function getTranslatedPhrase\n   * @since 0.35.0\n   * @param {string} dictionaryKey Constant which is dictionary key.\n   * @param {*} extraArguments Arguments which will be handled by formatters.\n   * @returns {string}\n   */\n\n\n  this.getTranslatedPhrase = function (dictionaryKey, extraArguments) {\n    return getTranslatedPhrase(tableMeta.language, dictionaryKey, extraArguments);\n  };\n  /**\n   * Converts instance into outerHTML of HTMLTableElement.\n   *\n   * @memberof Core#\n   * @function toHTML\n   * @since 7.1.0\n   * @returns {string}\n   */\n\n\n  this.toHTML = function () {\n    return instanceToHTML(_this);\n  };\n  /**\n   * Converts instance into HTMLTableElement.\n   *\n   * @memberof Core#\n   * @function toTableElement\n   * @since 7.1.0\n   * @returns {HTMLTableElement}\n   */\n\n\n  this.toTableElement = function () {\n    var tempElement = _this.rootDocument.createElement('div');\n\n    tempElement.insertAdjacentHTML('afterbegin', instanceToHTML(_this));\n    return tempElement.firstElementChild;\n  };\n\n  this.timeouts = [];\n  /**\n   * Sets timeout. Purpose of this method is to clear all known timeouts when `destroy` method is called.\n   *\n   * @param {number|Function} handle Handler returned from setTimeout or function to execute (it will be automatically wraped\n   *                                 by setTimeout function).\n   * @param {number} [delay=0] If first argument is passed as a function this argument set delay of the execution of that function.\n   * @private\n   */\n\n  this._registerTimeout = function (handle) {\n    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var handleFunc = handle;\n\n    if (typeof handleFunc === 'function') {\n      handleFunc = setTimeout(handleFunc, delay);\n    }\n\n    this.timeouts.push(handleFunc);\n  };\n  /**\n   * Clears all known timeouts.\n   *\n   * @private\n   */\n\n\n  this._clearTimeouts = function () {\n    arrayEach(this.timeouts, function (handler) {\n      clearTimeout(handler);\n    });\n  };\n\n  this.immediates = [];\n  /**\n   * Execute function execution to the next event loop cycle. Purpose of this method is to clear all known timeouts when `destroy` method is called.\n   *\n   * @param {Function} callback Function to be delayed in execution.\n   * @private\n   */\n\n  this._registerImmediate = function (callback) {\n    this.immediates.push(setImmediate(callback));\n  };\n  /**\n   * Clears all known timeouts.\n   *\n   * @private\n   */\n\n\n  this._clearImmediates = function () {\n    arrayEach(this.immediates, function (handler) {\n      clearImmediate(handler);\n    });\n  };\n  /**\n   * Refresh selection borders. This is temporary method relic after selection rewrite.\n   *\n   * @private\n   * @param {boolean} [revertOriginal=false] If `true`, the previous value will be restored. Otherwise, the edited value will be saved.\n   * @param {boolean} [prepareEditorIfNeeded=true] If `true` the editor under the selected cell will be prepared to open.\n   */\n\n\n  this._refreshBorders = function () {\n    var revertOriginal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    editorManager.destroyEditor(revertOriginal);\n    instance.view.render();\n\n    if (prepareEditorIfNeeded && selection.isSelected()) {\n      editorManager.prepareEditor();\n    }\n  };\n\n  getPluginsNames().forEach(function (pluginName) {\n    var PluginClass = getPlugin(pluginName);\n    pluginsRegistry.addItem(pluginName, new PluginClass(_this));\n  });\n  Hooks.getSingleton().run(instance, 'construct');\n}","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/core.mjs"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","_i","_arr","_n","_d","_s","_e","call","next","done","push","value","length","err","Array","isArray","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","o","minLen","_arrayLikeToArray","n","Object","toString","slice","name","from","test","iter","len","arr2","addClass","empty","removeClass","isFunction","isDefined","isUndefined","isRegExp","_injectProductInfo","isEmpty","isMobileBrowser","isIpadOS","EditorManager","EventManager","deepClone","duckSchema","isObjectEqual","deepObjectSize","hasOwnProperty","createObjectPropListener","objectEach","arrayMap","arrayEach","arrayReduce","getDifferenceOfArrays","stringToArray","instanceToHTML","getPlugin","getPluginsNames","getRenderer","getValidator","randomString","toUpperCaseFirst","rangeEach","rangeEachReverse","TableView","DataSource","translateRowsToColumns","cellMethodLookupFactory","spreadsheetColumnLabel","IndexMapper","registerAsRootInstance","hasValidParameter","isRootInstance","CellCoords","ViewportColumnsCalculator","Hooks","hasLanguageDictionary","getValidLanguageCode","getTranslatedPhrase","warnUserAboutLanguageRegistration","normalizeLanguageCode","startObserving","keyStateStartObserving","stopObserving","keyStateStopObserving","Selection","MetaManager","DataMap","createUniqueMap","activeGuid","Core","rootElement","userSettings","_this","rootInstanceSymbol","arguments","undefined","preventScrollingToCell","instance","eventManager","datamap","dataSource","grid","editorManager","firstRun","language","metaManager","tableMeta","getTableMeta","globalMeta","getGlobalMeta","pluginsRegistry","rootDocument","ownerDocument","rootWindow","defaultView","isDestroyed","renderSuspendedCounter","executionSuspendedCounter","container","createElement","renderCall","insertBefore","firstChild","licenseKey","guid","concat","columnIndexMapper","rowIndexMapper","id","substring","visualToRenderableCoords","coords","visualRow","row","visualColumn","col","getRenderableFromVisualIndex","renderableToVisualCoords","renderableRow","renderableColumn","getVisualFromRenderableIndex","selection","countCols","countRows","propToCol","prop","isEditorOpened","getActiveEditor","isOpened","countColsTranslated","view","countRenderableColumns","countRowsTranslated","countRenderableRows","isDisabledCellSelection","getCellMeta","disableVisualSelection","onIndexMapperCacheUpdate","_ref","hiddenIndexesChanged","refresh","addLocalHook","cellCoords","runHooks","wt","wtTable","getFirstVisibleRow","getFirstVisibleColumn","preventScrolling","selectionRange","getSelectedRange","_selectionRange$curre","current","to","selectionLayerLevel","size","colToProp","isSelectedByAnyHeader","currentSelectedRange","selectedRange","scrollToCell","isTouched","isSelectedByRowHeader","isSelectedByColumnHeader","isMultiple","scrollViewport","scrollViewportVertically","scrollViewportHorizontally","_refreshBorders","cellRanges","_cellRanges$selection","changedIsMultiple","cellCoordsDelta","rowTransformDir","colTransformDir","destroyEditor","totalRows","alter","totalCols","action","index","amount","source","keepEmptyRows","delta","normalizeIndexesGroup","indexes","sortedIndexes","sort","_ref2","_ref3","_ref4","indexA","_ref5","indexB","normalizedIndexes","acc","_ref6","_ref7","groupIndex","groupAmount","previousItem","_previousItem","prevIndex","prevAmount","prevLastIndex","amountToAdd","Math","max","numberOfSourceRows","countSourceRows","maxRows","createRow","toPhysicalRow","currentFromRange","currentFromRow","_currentSelectedRange","currentToRow","currentToColumn","currentFromColumn","pop","setRangeStartOnly","setRangeEnd","createCol","createColumn","toPhysicalColumn","colHeaders","spliceArray","splice","apply","_currentSelectedRange2","_currentFromRange","_currentFromColumn","_currentSelectedRange3","_currentToRow","_currentToColumn","_currentFromRow","removeRow","offset","_ref8","_ref9","calcIndex","Number","isInteger","wasRemoved","fixedRowsTop","min","fixedRowsBottom","adjustRowsAndCols","removeCol","_ref10","_ref11","physicalColumnIndex","removeColumn","fixedColumnsLeft","Error","minRows","minSpareRows","minCols","minSpareCols","nrOfRows","emptyRows","countEmptyRows","emptyRowsMissing","rowsToCreate","emptyCols","countEmptyCols","nrOfColumns","columns","colsToCreate","dataType","emptyColsMissing","_colsToCreate","maxCols","rowCount","colCount","deselect","isSelected","range","selectionChanged","fromRow","fromCol","toRow","toCol","selectCell","adjustElementsSize","populateFromArray","start","input","end","method","direction","deltas","r","rlen","c","clen","setData","repeatCol","repeatRow","cmax","rmax","_instance","unshift","spliceCol","_instance2","_instance3","spliceRow","_instance4","selected","skippedRow","skippedColumn","pushData","cellMeta","getInputValue","rowValue","rowInputLength","rowSelectionLength","allowInsertRow","colInputLength","colSelectionLength","skipRowOnPaste","allowInsertColumn","skipColumnOnPaste","readOnly","orgValue","getDataAtCell","result","orgValueSchema","valueSchema","setDataAtCell","setLanguage","languageCode","normalizedLanguageCode","setClassName","className","classSettings","element","table","globalMetaSettingsArray","settingsArray","classNameToRemove","classNameToAdd","init","data","updateSettings","getInstance","forceFullRender","render","ValidatorsQueue","resolved","validatorsInQueue","valid","addValidatorToQueue","removeValidatorFormQueue","checkIfQueueIsEmpty","onQueueEmpty","getParsedNumber","numericData","unifiedNumericData","replace","isNaN","parseFloat","validateChanges","changes","callback","activeEditor","beforeChangeResult","shouldBeCanceled","cancelChanges","waitingForValidator","isNumericData","isValid","_changes$i","newValue","cellProperties","type","getCellValidator","validateCell","cellPropertiesReference","allowInvalid","cell","getCell","visualCol","invalidCellClassName","applyChanges","skipThisChange","numberOfCreatedRows","numberOfCreatedColumns","set","lockEditor","unlockEditor","refreshValue","validator","canBeValidated","hidden","td","nodeName","wtSettings","settings","cellRenderer","expression","cellValue","validatorCallback","_registerImmediate","setDataInputToArray","propOrCol","column","changeSource","ilen","getAtCell","setDataAtRowProp","listen","isListening","unlisten","revertOriginal","prepareEditorIfNeeded","endRow","endCol","_datamap","_len","elements","_key","_datamap2","_len2","_key2","getSelected","_ref12","getSelectedLast","getSelectedRangeLast","emptySelectedCells","_this2","cellRange","topLeft","getTopLeftCorner","bottomRight","getBottomRightCorner","isRenderSuspended","suspendRender","resumeRender","nextValue","batchRender","wrappedOperations","isExecutionSuspended","suspendExecution","suspendOperations","resumeExecution","forceFlushChanges","resumeOperations","batchExecution","batch","refreshDimensions","_instance$view$getLas","getLastSize","lastWidth","width","lastHeight","height","_instance$rootElement","getBoundingClientRect","isSizeChanged","isResizeBlocked","wtOverlays","scrollableElement","setLastSize","loadData","dataSchema","destroy","getSchema","startRows","startCols","bind","countCachedColumns","clearCellsCache","initIndexMappers","columnsSettings","finalNrOfColumns","nrOfSourceColumns","countSourceCols","columnIndex","colToPropCache","schema","initToLength","getData","row2","column2","getAll","getRange","DESTINATION_RENDERER","getCopyableText","startRow","startCol","getCopyableData","getCopyable","columnsAsFunc","j","rows","cols","ganttChart","tableClassName","syncOverlayTableClassNames","getSingleton","isRegistered","isDeprecated","initialHook","addHook","createMap","columnSetting","cells","clearCache","updateColumnMeta","setCellMetaObject","currentHeight","style","parseInt","initialStyle","getAttribute","setAttribute","_initialStyle","indexOf","overflow","wtViewport","resetHasOversizedColumnHeadersMarked","exportSettingsAsClassNames","updateMainScrollableElements","getValue","sel","getSettings","clear","selectAll","topmost","renderableColumnIndex","renderableRowIndex","isHidden","getCellAtCoords","getCoords","renderableCoords","toVisualRow","getVisualFromPhysicalIndex","toVisualColumn","getPhysicalFromVisualIndex","get","getDataAtRowProp","getDataAtCol","_ref13","getDataAtProp","_ref14","getSourceData","getByRange","getSourceDataArray","getSourceDataAtCol","getAtColumn","setSourceDataAtCell","isThereAnySetSourceListener","hasHook","changesForHook","_ref15","_ref16","changeRow","changeProp","changeValue","_ref17","_ref18","setAtCell","getSourceDataAtRow","getAtRow","getSourceDataAtCell","getDataAtRow","getDataType","rowFrom","columnFrom","rowTo","columnTo","_this3","rowStart","columnStart","rowEnd","columnEnd","previousType","currentType","isTypeEqual","cellType","removeCellMeta","key","_ref19","physicalRow","physicalColumn","cachedValue","hookResult","spliceCellsMeta","visualIndex","_this4","deleteAmount","_len3","cellMetaRows","_key3","reverse","cellMetaRow","_this5","setCellMeta","allowSetCellMeta","getCellsMeta","updateCellMeta","getCellMetaAtRow","getCellsMetaAtRow","isColumnModificationAllowed","rendererLookup","getCellRenderer","getCellEditor","validatorLookup","validateCells","_validateCells","validateRows","validateColumns","getRowHeader","rowHeader","rowHeaders","hasRowHeaders","hasColHeaders","getColHeader","out","translateVisualIndexToColumns","visualColumnIndex","columnsLen","title","_getColWidthFromSettings","colWidths","getColWidth","DEFAULT_WIDTH","_getRowHeightFromSettings","rowHeights","getRowHeight","countFirstRowKeys","getLength","dataLen","getNotTrimmedIndexesLength","countRenderedRows","drawn","getRenderedRowsCount","countVisibleRows","getVisibleRowsCount","countRenderedCols","getRenderedColumnsCount","countVisibleCols","getVisibleColumnsCount","ending","isEmptyRow","emptyColumns","isEmptyCol","endColumn","changeListener","selectCells","wasSelected","selectColumns","startColumn","selectRows","deselectCell","includeHeaders","includeRowHeaders","includeColumnHeaders","getIndexToScroll","indexMapper","getFirstNotHiddenIndex","scrollViewportTo","snapToBottom","snapToRight","considerHiddenIndexes","snapToTop","snapToLeft","_isRowInteger","_isColumnInteger","visualRowToScroll","visualColumnToScroll","isRowInteger","isColumnInteger","_clearTimeouts","_clearImmediates","licenseInfo","querySelector","parentNode","removeChild","unregisterAll","getItems","forEach","_ref20","_ref21","plugin","property","postMortem","pluginName","unifiedPluginName","undoRedo","getItem","getPluginName","PLUGIN_KEY","getId","add","has","addHookOnce","once","removeHook","remove","p1","p2","p3","p4","p5","p6","run","dictionaryKey","extraArguments","toHTML","toTableElement","tempElement","insertAdjacentHTML","firstElementChild","timeouts","_registerTimeout","handle","delay","handleFunc","setTimeout","handler","clearTimeout","immediates","setImmediate","clearImmediate","prepareEditor","PluginClass","addItem"],"mappings":"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","sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.number.is-integer.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.timers.js\";\nimport \"core-js/modules/web.immediate.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { addClass, empty, removeClass } from \"./helpers/dom/element.mjs\";\nimport { isFunction } from \"./helpers/function.mjs\";\nimport { isDefined, isUndefined, isRegExp, _injectProductInfo, isEmpty } from \"./helpers/mixed.mjs\";\nimport { isMobileBrowser, isIpadOS } from \"./helpers/browser.mjs\";\nimport EditorManager from \"./editorManager.mjs\";\nimport EventManager from \"./eventManager.mjs\";\nimport { deepClone, duckSchema, isObjectEqual, deepObjectSize, hasOwnProperty, createObjectPropListener, objectEach } from \"./helpers/object.mjs\";\nimport { arrayMap, arrayEach, arrayReduce, getDifferenceOfArrays, stringToArray } from \"./helpers/array.mjs\";\nimport { instanceToHTML } from \"./utils/parseTable.mjs\";\nimport { getPlugin, getPluginsNames } from \"./plugins/registry.mjs\";\nimport { getRenderer } from \"./renderers/registry.mjs\";\nimport { getValidator } from \"./validators/registry.mjs\";\nimport { randomString, toUpperCaseFirst } from \"./helpers/string.mjs\";\nimport { rangeEach, rangeEachReverse } from \"./helpers/number.mjs\";\nimport TableView from \"./tableView.mjs\";\nimport DataSource from \"./dataSource.mjs\";\nimport { translateRowsToColumns, cellMethodLookupFactory, spreadsheetColumnLabel } from \"./helpers/data.mjs\";\nimport { IndexMapper } from \"./translations/index.mjs\";\nimport { registerAsRootInstance, hasValidParameter, isRootInstance } from \"./utils/rootInstance.mjs\";\nimport { CellCoords, ViewportColumnsCalculator } from \"./3rdparty/walkontable/src/index.mjs\";\nimport Hooks from \"./pluginHooks.mjs\";\nimport { hasLanguageDictionary, getValidLanguageCode, getTranslatedPhrase } from \"./i18n/registry.mjs\";\nimport { warnUserAboutLanguageRegistration, normalizeLanguageCode } from \"./i18n/utils.mjs\";\nimport { startObserving as keyStateStartObserving, stopObserving as keyStateStopObserving } from \"./utils/keyStateObserver.mjs\";\nimport { Selection } from \"./selection/index.mjs\";\nimport { MetaManager, DataMap } from \"./dataMap/index.mjs\";\nimport { createUniqueMap } from \"./utils/dataStructures/uniqueMap.mjs\";\nvar activeGuid = null;\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * Handsontable constructor.\n *\n * @core\n * @class Core\n * @description\n * After Handsontable is constructed, you can modify the grid behavior using the available public methods.\n *\n * ## How to call methods.\n *\n * These are 2 equal ways to call a Handsontable method:\n *\n * ```js\n * // all following examples assume that you constructed Handsontable like this\n * const hot = new Handsontable(document.getElementById('example1'), options);\n *\n * // now, to use setDataAtCell method, you can either:\n * hot.setDataAtCell(0, 0, 'new value');\n * ```\n *\n * Alternatively, you can call the method using jQuery wrapper (__obsolete__, requires initialization using our jQuery guide\n * ```js\n * $('#example1').handsontable('setDataAtCell', 0, 0, 'new value');\n * ```\n *\n * @param {HTMLElement} rootElement The element to which the Handsontable instance is injected.\n * @param {object} userSettings The user defined options.\n * @param {boolean} [rootInstanceSymbol=false] Indicates if the instance is root of all later instances created.\n */\n\nexport default function Core(rootElement, userSettings) {\n  var _this = this;\n\n  var rootInstanceSymbol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var preventScrollingToCell = false;\n  var instance = this;\n  var eventManager = new EventManager(instance);\n  var datamap;\n  var dataSource;\n  var grid;\n  var editorManager;\n  var firstRun = true;\n  userSettings.language = getValidLanguageCode(userSettings.language);\n  var metaManager = new MetaManager(userSettings);\n  var tableMeta = metaManager.getTableMeta();\n  var globalMeta = metaManager.getGlobalMeta();\n  var pluginsRegistry = createUniqueMap();\n\n  if (hasValidParameter(rootInstanceSymbol)) {\n    registerAsRootInstance(this);\n  } // TODO: check if references to DOM elements should be move to UI layer (Walkontable)\n\n  /**\n   * Reference to the container element.\n   *\n   * @private\n   * @type {HTMLElement}\n   */\n\n\n  this.rootElement = rootElement;\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  /**\n   * The nearest document over container.\n   *\n   * @private\n   * @type {Document}\n   */\n\n  this.rootDocument = rootElement.ownerDocument;\n  /**\n   * Window object over container's document.\n   *\n   * @private\n   * @type {Window}\n   */\n\n  this.rootWindow = this.rootDocument.defaultView;\n  /**\n   * A boolean to tell if the Handsontable has been fully destroyed. This is set to `true`\n   * after `afterDestroy` hook is called.\n   *\n   * @memberof Core#\n   * @member isDestroyed\n   * @type {boolean}\n   */\n\n  this.isDestroyed = false;\n  /**\n   * The counter determines how many times the render suspending was called. It allows\n   * tracking the nested suspending calls. For each render suspend resuming call the\n   * counter is decremented. The value equal to 0 means the render suspending feature\n   * is disabled.\n   *\n   * @private\n   * @type {number}\n   */\n\n  this.renderSuspendedCounter = 0;\n  /**\n   * The counter determines how many times the execution suspending was called. It allows\n   * tracking the nested suspending calls. For each execution suspend resuming call the\n   * counter is decremented. The value equal to 0 means the execution suspending feature\n   * is disabled.\n   *\n   * @private\n   * @type {number}\n   */\n\n  this.executionSuspendedCounter = 0;\n  keyStateStartObserving(this.rootDocument);\n  this.container = this.rootDocument.createElement('div');\n  this.renderCall = false;\n  rootElement.insertBefore(this.container, rootElement.firstChild);\n\n  if (isRootInstance(this)) {\n    _injectProductInfo(userSettings.licenseKey, rootElement);\n  }\n\n  this.guid = \"ht_\".concat(randomString()); // this is the namespace for global events\n\n  /**\n   * Instance of index mapper which is responsible for managing the column indexes.\n   *\n   * @memberof Core#\n   * @member columnIndexMapper\n   * @type {IndexMapper}\n   */\n\n  this.columnIndexMapper = new IndexMapper();\n  /**\n   * Instance of index mapper which is responsible for managing the row indexes.\n   *\n   * @memberof Core#\n   * @member rowIndexMapper\n   * @type {IndexMapper}\n   */\n\n  this.rowIndexMapper = new IndexMapper();\n  dataSource = new DataSource(instance);\n\n  if (!this.rootElement.id || this.rootElement.id.substring(0, 3) === 'ht_') {\n    this.rootElement.id = this.guid; // if root element does not have an id, assign a random id\n  }\n\n  var visualToRenderableCoords = function visualToRenderableCoords(coords) {\n    var visualRow = coords.row,\n        visualColumn = coords.col;\n    return new CellCoords( // We just store indexes for rows and columns without headers.\n    visualRow >= 0 ? instance.rowIndexMapper.getRenderableFromVisualIndex(visualRow) : visualRow, visualColumn >= 0 ? instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumn) : visualColumn);\n  };\n\n  var renderableToVisualCoords = function renderableToVisualCoords(coords) {\n    var renderableRow = coords.row,\n        renderableColumn = coords.col;\n    return new CellCoords( // We just store indexes for rows and columns without headers.\n    renderableRow >= 0 ? instance.rowIndexMapper.getVisualFromRenderableIndex(renderableRow) : renderableRow, renderableColumn >= 0 ? instance.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn) : renderableColumn // eslint-disable-line max-len\n    );\n  };\n\n  var selection = new Selection(tableMeta, {\n    countCols: function countCols() {\n      return instance.countCols();\n    },\n    countRows: function countRows() {\n      return instance.countRows();\n    },\n    propToCol: function propToCol(prop) {\n      return datamap.propToCol(prop);\n    },\n    isEditorOpened: function isEditorOpened() {\n      return instance.getActiveEditor() ? instance.getActiveEditor().isOpened() : false;\n    },\n    countColsTranslated: function countColsTranslated() {\n      return _this.view.countRenderableColumns();\n    },\n    countRowsTranslated: function countRowsTranslated() {\n      return _this.view.countRenderableRows();\n    },\n    visualToRenderableCoords: visualToRenderableCoords,\n    renderableToVisualCoords: renderableToVisualCoords,\n    isDisabledCellSelection: function isDisabledCellSelection(visualRow, visualColumn) {\n      return instance.getCellMeta(visualRow, visualColumn).disableVisualSelection;\n    }\n  });\n  this.selection = selection;\n\n  var onIndexMapperCacheUpdate = function onIndexMapperCacheUpdate(_ref) {\n    var hiddenIndexesChanged = _ref.hiddenIndexesChanged;\n\n    if (hiddenIndexesChanged) {\n      _this.selection.refresh();\n    }\n  };\n\n  this.columnIndexMapper.addLocalHook('cacheUpdated', onIndexMapperCacheUpdate);\n  this.rowIndexMapper.addLocalHook('cacheUpdated', onIndexMapperCacheUpdate);\n  this.selection.addLocalHook('beforeSetRangeStart', function (cellCoords) {\n    _this.runHooks('beforeSetRangeStart', cellCoords);\n  });\n  this.selection.addLocalHook('beforeSetRangeStartOnly', function (cellCoords) {\n    _this.runHooks('beforeSetRangeStartOnly', cellCoords);\n  });\n  this.selection.addLocalHook('beforeSetRangeEnd', function (cellCoords) {\n    _this.runHooks('beforeSetRangeEnd', cellCoords);\n\n    if (cellCoords.row < 0) {\n      cellCoords.row = _this.view.wt.wtTable.getFirstVisibleRow();\n    }\n\n    if (cellCoords.col < 0) {\n      cellCoords.col = _this.view.wt.wtTable.getFirstVisibleColumn();\n    }\n  });\n  this.selection.addLocalHook('afterSetRangeEnd', function (cellCoords) {\n    var preventScrolling = createObjectPropListener(false);\n\n    var selectionRange = _this.selection.getSelectedRange();\n\n    var _selectionRange$curre = selectionRange.current(),\n        from = _selectionRange$curre.from,\n        to = _selectionRange$curre.to;\n\n    var selectionLayerLevel = selectionRange.size() - 1;\n\n    _this.runHooks('afterSelection', from.row, from.col, to.row, to.col, preventScrolling, selectionLayerLevel);\n\n    _this.runHooks('afterSelectionByProp', from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), preventScrolling, selectionLayerLevel); // eslint-disable-line max-len\n\n\n    var isSelectedByAnyHeader = _this.selection.isSelectedByAnyHeader();\n\n    var currentSelectedRange = _this.selection.selectedRange.current();\n\n    var scrollToCell = true;\n\n    if (preventScrollingToCell) {\n      scrollToCell = false;\n    }\n\n    if (preventScrolling.isTouched()) {\n      scrollToCell = !preventScrolling.value;\n    }\n\n    var isSelectedByRowHeader = _this.selection.isSelectedByRowHeader();\n\n    var isSelectedByColumnHeader = _this.selection.isSelectedByColumnHeader();\n\n    if (scrollToCell !== false) {\n      if (!isSelectedByAnyHeader) {\n        if (currentSelectedRange && !_this.selection.isMultiple()) {\n          _this.view.scrollViewport(visualToRenderableCoords(currentSelectedRange.from));\n        } else {\n          _this.view.scrollViewport(visualToRenderableCoords(cellCoords));\n        }\n      } else if (isSelectedByRowHeader) {\n        _this.view.scrollViewportVertically(instance.rowIndexMapper.getRenderableFromVisualIndex(cellCoords.row));\n      } else if (isSelectedByColumnHeader) {\n        _this.view.scrollViewportHorizontally(instance.columnIndexMapper.getRenderableFromVisualIndex(cellCoords.col));\n      }\n    } // @TODO: These CSS classes are no longer needed anymore. They are used only as a indicator of the selected\n    // rows/columns in the MergedCells plugin (via border.js#L520 in the walkontable module). After fixing\n    // the Border class this should be removed.\n\n\n    if (isSelectedByRowHeader && isSelectedByColumnHeader) {\n      addClass(_this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n    } else if (isSelectedByRowHeader) {\n      removeClass(_this.rootElement, 'ht__selection--columns');\n      addClass(_this.rootElement, 'ht__selection--rows');\n    } else if (isSelectedByColumnHeader) {\n      removeClass(_this.rootElement, 'ht__selection--rows');\n      addClass(_this.rootElement, 'ht__selection--columns');\n    } else {\n      removeClass(_this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n    }\n\n    _this._refreshBorders(null);\n  });\n  this.selection.addLocalHook('afterSelectionFinished', function (cellRanges) {\n    var selectionLayerLevel = cellRanges.length - 1;\n    var _cellRanges$selection = cellRanges[selectionLayerLevel],\n        from = _cellRanges$selection.from,\n        to = _cellRanges$selection.to;\n\n    _this.runHooks('afterSelectionEnd', from.row, from.col, to.row, to.col, selectionLayerLevel);\n\n    _this.runHooks('afterSelectionEndByProp', from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), selectionLayerLevel);\n  });\n  this.selection.addLocalHook('afterIsMultipleSelection', function (isMultiple) {\n    var changedIsMultiple = _this.runHooks('afterIsMultipleSelection', isMultiple.value);\n\n    if (isMultiple.value) {\n      isMultiple.value = changedIsMultiple;\n    }\n  });\n  this.selection.addLocalHook('beforeModifyTransformStart', function (cellCoordsDelta) {\n    _this.runHooks('modifyTransformStart', cellCoordsDelta);\n  });\n  this.selection.addLocalHook('afterModifyTransformStart', function (coords, rowTransformDir, colTransformDir) {\n    _this.runHooks('afterModifyTransformStart', coords, rowTransformDir, colTransformDir);\n  });\n  this.selection.addLocalHook('beforeModifyTransformEnd', function (cellCoordsDelta) {\n    _this.runHooks('modifyTransformEnd', cellCoordsDelta);\n  });\n  this.selection.addLocalHook('afterModifyTransformEnd', function (coords, rowTransformDir, colTransformDir) {\n    _this.runHooks('afterModifyTransformEnd', coords, rowTransformDir, colTransformDir);\n  });\n  this.selection.addLocalHook('afterDeselect', function () {\n    editorManager.destroyEditor();\n\n    _this._refreshBorders();\n\n    removeClass(_this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n\n    _this.runHooks('afterDeselect');\n  });\n  this.selection.addLocalHook('insertRowRequire', function (totalRows) {\n    _this.alter('insert_row', totalRows, 1, 'auto');\n  });\n  this.selection.addLocalHook('insertColRequire', function (totalCols) {\n    _this.alter('insert_col', totalCols, 1, 'auto');\n  });\n  grid = {\n    /**\n     * Inserts or removes rows and columns.\n     *\n     * @memberof Core#\n     * @function alter\n     * @private\n     * @param {string} action Possible values: \"insert_row\", \"insert_col\", \"remove_row\", \"remove_col\".\n     * @param {number|Array} index Row or column visual index which from the alter action will be triggered.\n     *                             Alter actions such as \"remove_row\" and \"remove_col\" support array indexes in the\n     *                             format `[[index, amount], [index, amount]...]` this can be used to remove\n     *                             non-consecutive columns or rows in one call.\n     * @param {number} [amount=1] Ammount rows or columns to remove.\n     * @param {string} [source] Optional. Source of hook runner.\n     * @param {boolean} [keepEmptyRows] Optional. Flag for preventing deletion of empty rows.\n     */\n    alter: function alter(action, index) {\n      var amount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var source = arguments.length > 3 ? arguments[3] : undefined;\n      var keepEmptyRows = arguments.length > 4 ? arguments[4] : undefined;\n      var delta;\n\n      var normalizeIndexesGroup = function normalizeIndexesGroup(indexes) {\n        if (indexes.length === 0) {\n          return [];\n        }\n\n        var sortedIndexes = _toConsumableArray(indexes); // Sort the indexes in ascending order.\n\n\n        sortedIndexes.sort(function (_ref2, _ref3) {\n          var _ref4 = _slicedToArray(_ref2, 1),\n              indexA = _ref4[0];\n\n          var _ref5 = _slicedToArray(_ref3, 1),\n              indexB = _ref5[0];\n\n          if (indexA === indexB) {\n            return 0;\n          }\n\n          return indexA > indexB ? 1 : -1;\n        }); // Normalize the {index, amount} groups into bigger groups.\n\n        var normalizedIndexes = arrayReduce(sortedIndexes, function (acc, _ref6) {\n          var _ref7 = _slicedToArray(_ref6, 2),\n              groupIndex = _ref7[0],\n              groupAmount = _ref7[1];\n\n          var previousItem = acc[acc.length - 1];\n\n          var _previousItem = _slicedToArray(previousItem, 2),\n              prevIndex = _previousItem[0],\n              prevAmount = _previousItem[1];\n\n          var prevLastIndex = prevIndex + prevAmount;\n\n          if (groupIndex <= prevLastIndex) {\n            var amountToAdd = Math.max(groupAmount - (prevLastIndex - groupIndex), 0);\n            previousItem[1] += amountToAdd;\n          } else {\n            acc.push([groupIndex, groupAmount]);\n          }\n\n          return acc;\n        }, [sortedIndexes[0]]);\n        return normalizedIndexes;\n      };\n      /* eslint-disable no-case-declarations */\n\n\n      switch (action) {\n        case 'insert_row':\n          var numberOfSourceRows = instance.countSourceRows();\n\n          if (tableMeta.maxRows === numberOfSourceRows) {\n            return;\n          } // eslint-disable-next-line no-param-reassign\n\n\n          index = isDefined(index) ? index : numberOfSourceRows;\n          delta = datamap.createRow(index, amount, source);\n\n          if (delta) {\n            metaManager.createRow(instance.toPhysicalRow(index), amount);\n            var currentSelectedRange = selection.selectedRange.current();\n            var currentFromRange = currentSelectedRange === null || currentSelectedRange === void 0 ? void 0 : currentSelectedRange.from;\n            var currentFromRow = currentFromRange === null || currentFromRange === void 0 ? void 0 : currentFromRange.row; // Moving down the selection (when it exist). It should be present on the \"old\" row.\n            // TODO: The logic here should be handled by selection module.\n\n            if (isDefined(currentFromRow) && currentFromRow >= index) {\n              var _currentSelectedRange = currentSelectedRange.to,\n                  currentToRow = _currentSelectedRange.row,\n                  currentToColumn = _currentSelectedRange.col;\n              var currentFromColumn = currentFromRange.col; // Workaround: headers are not stored inside selection.\n\n              if (selection.isSelectedByRowHeader()) {\n                currentFromColumn = -1;\n              } // Remove from the stack the last added selection as that selection below will be\n              // replaced by new transformed selection.\n\n\n              selection.getSelectedRange().pop(); // I can't use transforms as they don't work in negative indexes.\n\n              selection.setRangeStartOnly(new CellCoords(currentFromRow + delta, currentFromColumn), true);\n              selection.setRangeEnd(new CellCoords(currentToRow + delta, currentToColumn)); // will call render() internally\n            } else {\n              instance._refreshBorders(); // it will call render and prepare methods\n\n            }\n          }\n\n          break;\n\n        case 'insert_col':\n          delta = datamap.createCol(index, amount, source);\n\n          if (delta) {\n            metaManager.createColumn(instance.toPhysicalColumn(index), amount);\n\n            if (Array.isArray(tableMeta.colHeaders)) {\n              var spliceArray = [index, 0];\n              spliceArray.length += delta; // inserts empty (undefined) elements at the end of an array\n\n              Array.prototype.splice.apply(tableMeta.colHeaders, spliceArray); // inserts empty (undefined) elements into the colHeader array\n            }\n\n            var _currentSelectedRange2 = selection.selectedRange.current();\n\n            var _currentFromRange = _currentSelectedRange2 === null || _currentSelectedRange2 === void 0 ? void 0 : _currentSelectedRange2.from;\n\n            var _currentFromColumn = _currentFromRange === null || _currentFromRange === void 0 ? void 0 : _currentFromRange.col; // Moving right the selection (when it exist). It should be present on the \"old\" row.\n            // TODO: The logic here should be handled by selection module.\n\n\n            if (isDefined(_currentFromColumn) && _currentFromColumn >= index) {\n              var _currentSelectedRange3 = _currentSelectedRange2.to,\n                  _currentToRow = _currentSelectedRange3.row,\n                  _currentToColumn = _currentSelectedRange3.col;\n              var _currentFromRow = _currentFromRange.row; // Workaround: headers are not stored inside selection.\n\n              if (selection.isSelectedByColumnHeader()) {\n                _currentFromRow = -1;\n              } // Remove from the stack the last added selection as that selection below will be\n              // replaced by new transformed selection.\n\n\n              selection.getSelectedRange().pop(); // I can't use transforms as they don't work in negative indexes.\n\n              selection.setRangeStartOnly(new CellCoords(_currentFromRow, _currentFromColumn + delta), true);\n              selection.setRangeEnd(new CellCoords(_currentToRow, _currentToColumn + delta)); // will call render() internally\n            } else {\n              instance._refreshBorders(); // it will call render and prepare methods\n\n            }\n          }\n\n          break;\n\n        case 'remove_row':\n          var removeRow = function removeRow(indexes) {\n            var offset = 0; // Normalize the {index, amount} groups into bigger groups.\n\n            arrayEach(indexes, function (_ref8) {\n              var _ref9 = _slicedToArray(_ref8, 2),\n                  groupIndex = _ref9[0],\n                  groupAmount = _ref9[1];\n\n              var calcIndex = isEmpty(groupIndex) ? instance.countRows() - 1 : Math.max(groupIndex - offset, 0); // If the 'index' is an integer decrease it by 'offset' otherwise pass it through to make the value\n              // compatible with datamap.removeCol method.\n\n              if (Number.isInteger(groupIndex)) {\n                // eslint-disable-next-line no-param-reassign\n                groupIndex = Math.max(groupIndex - offset, 0);\n              } // TODO: for datamap.removeRow index should be passed as it is (with undefined and null values). If not, the logic\n              // inside the datamap.removeRow breaks the removing functionality.\n\n\n              var wasRemoved = datamap.removeRow(groupIndex, groupAmount, source);\n\n              if (!wasRemoved) {\n                return;\n              }\n\n              metaManager.removeRow(instance.toPhysicalRow(calcIndex), groupAmount);\n              var totalRows = instance.countRows();\n              var fixedRowsTop = tableMeta.fixedRowsTop;\n\n              if (fixedRowsTop >= calcIndex + 1) {\n                tableMeta.fixedRowsTop -= Math.min(groupAmount, fixedRowsTop - calcIndex);\n              }\n\n              var fixedRowsBottom = tableMeta.fixedRowsBottom;\n\n              if (fixedRowsBottom && calcIndex >= totalRows - fixedRowsBottom) {\n                tableMeta.fixedRowsBottom -= Math.min(groupAmount, fixedRowsBottom);\n              }\n\n              offset += groupAmount;\n            });\n          };\n\n          if (Array.isArray(index)) {\n            removeRow(normalizeIndexesGroup(index));\n          } else {\n            removeRow([[index, amount]]);\n          }\n\n          grid.adjustRowsAndCols();\n\n          instance._refreshBorders(); // it will call render and prepare methods\n\n\n          break;\n\n        case 'remove_col':\n          var removeCol = function removeCol(indexes) {\n            var offset = 0; // Normalize the {index, amount} groups into bigger groups.\n\n            arrayEach(indexes, function (_ref10) {\n              var _ref11 = _slicedToArray(_ref10, 2),\n                  groupIndex = _ref11[0],\n                  groupAmount = _ref11[1];\n\n              var calcIndex = isEmpty(groupIndex) ? instance.countCols() - 1 : Math.max(groupIndex - offset, 0);\n              var physicalColumnIndex = instance.toPhysicalColumn(calcIndex); // If the 'index' is an integer decrease it by 'offset' otherwise pass it through to make the value\n              // compatible with datamap.removeCol method.\n\n              if (Number.isInteger(groupIndex)) {\n                // eslint-disable-next-line no-param-reassign\n                groupIndex = Math.max(groupIndex - offset, 0);\n              } // TODO: for datamap.removeCol index should be passed as it is (with undefined and null values). If not, the logic\n              // inside the datamap.removeCol breaks the removing functionality.\n\n\n              var wasRemoved = datamap.removeCol(groupIndex, groupAmount, source);\n\n              if (!wasRemoved) {\n                return;\n              }\n\n              metaManager.removeColumn(physicalColumnIndex, groupAmount);\n              var fixedColumnsLeft = tableMeta.fixedColumnsLeft;\n\n              if (fixedColumnsLeft >= calcIndex + 1) {\n                tableMeta.fixedColumnsLeft -= Math.min(groupAmount, fixedColumnsLeft - calcIndex);\n              }\n\n              if (Array.isArray(tableMeta.colHeaders)) {\n                if (typeof physicalColumnIndex === 'undefined') {\n                  physicalColumnIndex = -1;\n                }\n\n                tableMeta.colHeaders.splice(physicalColumnIndex, groupAmount);\n              }\n\n              offset += groupAmount;\n            });\n          };\n\n          if (Array.isArray(index)) {\n            removeCol(normalizeIndexesGroup(index));\n          } else {\n            removeCol([[index, amount]]);\n          }\n\n          grid.adjustRowsAndCols();\n\n          instance._refreshBorders(); // it will call render and prepare methods\n\n\n          break;\n\n        default:\n          throw new Error(\"There is no such action \\\"\".concat(action, \"\\\"\"));\n      }\n\n      if (!keepEmptyRows) {\n        grid.adjustRowsAndCols(); // makes sure that we did not add rows that will be removed in next refresh\n      }\n    },\n\n    /**\n     * Makes sure there are empty rows at the bottom of the table.\n     */\n    adjustRowsAndCols: function adjustRowsAndCols() {\n      var minRows = tableMeta.minRows;\n      var minSpareRows = tableMeta.minSpareRows;\n      var minCols = tableMeta.minCols;\n      var minSpareCols = tableMeta.minSpareCols;\n\n      if (minRows) {\n        // should I add empty rows to data source to meet minRows?\n        var nrOfRows = instance.countRows();\n\n        if (nrOfRows < minRows) {\n          // The synchronization with cell meta is not desired here. For `minRows` option,\n          // we don't want to touch/shift cell meta objects.\n          datamap.createRow(nrOfRows, minRows - nrOfRows, 'auto');\n        }\n      }\n\n      if (minSpareRows) {\n        var emptyRows = instance.countEmptyRows(true); // should I add empty rows to meet minSpareRows?\n\n        if (emptyRows < minSpareRows) {\n          var emptyRowsMissing = minSpareRows - emptyRows;\n          var rowsToCreate = Math.min(emptyRowsMissing, tableMeta.maxRows - instance.countSourceRows()); // The synchronization with cell meta is not desired here. For `minSpareRows` option,\n          // we don't want to touch/shift cell meta objects.\n\n          datamap.createRow(instance.countRows(), rowsToCreate, 'auto');\n        }\n      }\n\n      {\n        var emptyCols; // count currently empty cols\n\n        if (minCols || minSpareCols) {\n          emptyCols = instance.countEmptyCols(true);\n        }\n\n        var nrOfColumns = instance.countCols(); // should I add empty cols to meet minCols?\n\n        if (minCols && !tableMeta.columns && nrOfColumns < minCols) {\n          // The synchronization with cell meta is not desired here. For `minSpareRows` option,\n          // we don't want to touch/shift cell meta objects.\n          var colsToCreate = minCols - nrOfColumns;\n          emptyCols += colsToCreate;\n          datamap.createCol(nrOfColumns, colsToCreate, 'auto');\n        } // should I add empty cols to meet minSpareCols?\n\n\n        if (minSpareCols && !tableMeta.columns && instance.dataType === 'array' && emptyCols < minSpareCols) {\n          nrOfColumns = instance.countCols();\n          var emptyColsMissing = minSpareCols - emptyCols;\n\n          var _colsToCreate = Math.min(emptyColsMissing, tableMeta.maxCols - nrOfColumns); // The synchronization with cell meta is not desired here. For `minSpareRows` option,\n          // we don't want to touch/shift cell meta objects.\n\n\n          datamap.createCol(nrOfColumns, _colsToCreate, 'auto');\n        }\n      }\n      var rowCount = instance.countRows();\n      var colCount = instance.countCols();\n\n      if (rowCount === 0 || colCount === 0) {\n        selection.deselect();\n      }\n\n      if (selection.isSelected()) {\n        arrayEach(selection.selectedRange, function (range) {\n          var selectionChanged = false;\n          var fromRow = range.from.row;\n          var fromCol = range.from.col;\n          var toRow = range.to.row;\n          var toCol = range.to.col; // if selection is outside, move selection to last row\n\n          if (fromRow > rowCount - 1) {\n            fromRow = rowCount - 1;\n            selectionChanged = true;\n\n            if (toRow > fromRow) {\n              toRow = fromRow;\n            }\n          } else if (toRow > rowCount - 1) {\n            toRow = rowCount - 1;\n            selectionChanged = true;\n\n            if (fromRow > toRow) {\n              fromRow = toRow;\n            }\n          } // if selection is outside, move selection to last row\n\n\n          if (fromCol > colCount - 1) {\n            fromCol = colCount - 1;\n            selectionChanged = true;\n\n            if (toCol > fromCol) {\n              toCol = fromCol;\n            }\n          } else if (toCol > colCount - 1) {\n            toCol = colCount - 1;\n            selectionChanged = true;\n\n            if (fromCol > toCol) {\n              fromCol = toCol;\n            }\n          }\n\n          if (selectionChanged) {\n            instance.selectCell(fromRow, fromCol, toRow, toCol);\n          }\n        });\n      }\n\n      if (instance.view) {\n        instance.view.adjustElementsSize();\n      }\n    },\n\n    /**\n     * Populate the data from the provided 2d array from the given cell coordinates.\n     *\n     * @private\n     * @param {object} start Start selection position. Visual indexes.\n     * @param {Array} input 2d data array.\n     * @param {object} [end] End selection position (only for drag-down mode). Visual indexes.\n     * @param {string} [source=\"populateFromArray\"] Source information string.\n     * @param {string} [method=\"overwrite\"] Populate method. Possible options: `shift_down`, `shift_right`, `overwrite`.\n     * @param {string} direction (left|right|up|down) String specifying the direction.\n     * @param {Array} deltas The deltas array. A difference between values of adjacent cells.\n     *                       Useful **only** when the type of handled cells is `numeric`.\n     * @returns {object|undefined} Ending td in pasted area (only if any cell was changed).\n     */\n    populateFromArray: function populateFromArray(start, input, end, source, method, direction, deltas) {\n      // TODO: either remove or implement the `direction` argument. Currently it's not working at all.\n      var r;\n      var rlen;\n      var c;\n      var clen;\n      var setData = [];\n      var current = {};\n      rlen = input.length;\n\n      if (rlen === 0) {\n        return false;\n      }\n\n      var repeatCol;\n      var repeatRow;\n      var cmax;\n      var rmax;\n      /* eslint-disable no-case-declarations */\n      // insert data with specified pasteMode method\n\n      switch (method) {\n        case 'shift_down':\n          repeatCol = end ? end.col - start.col + 1 : 0;\n          repeatRow = end ? end.row - start.row + 1 : 0; // eslint-disable-next-line no-param-reassign\n\n          input = translateRowsToColumns(input);\n\n          for (c = 0, clen = input.length, cmax = Math.max(clen, repeatCol); c < cmax; c++) {\n            if (c < clen) {\n              var _instance;\n\n              for (r = 0, rlen = input[c].length; r < repeatRow - rlen; r++) {\n                input[c].push(input[c][r % rlen]);\n              }\n\n              input[c].unshift(start.col + c, start.row, 0);\n\n              (_instance = instance).spliceCol.apply(_instance, _toConsumableArray(input[c]));\n            } else {\n              var _instance2;\n\n              input[c % clen][0] = start.col + c;\n\n              (_instance2 = instance).spliceCol.apply(_instance2, _toConsumableArray(input[c % clen]));\n            }\n          }\n\n          break;\n\n        case 'shift_right':\n          repeatCol = end ? end.col - start.col + 1 : 0;\n          repeatRow = end ? end.row - start.row + 1 : 0;\n\n          for (r = 0, rlen = input.length, rmax = Math.max(rlen, repeatRow); r < rmax; r++) {\n            if (r < rlen) {\n              var _instance3;\n\n              for (c = 0, clen = input[r].length; c < repeatCol - clen; c++) {\n                input[r].push(input[r][c % clen]);\n              }\n\n              input[r].unshift(start.row + r, start.col, 0);\n\n              (_instance3 = instance).spliceRow.apply(_instance3, _toConsumableArray(input[r]));\n            } else {\n              var _instance4;\n\n              input[r % rlen][0] = start.row + r;\n\n              (_instance4 = instance).spliceRow.apply(_instance4, _toConsumableArray(input[r % rlen]));\n            }\n          }\n\n          break;\n\n        case 'overwrite':\n        default:\n          // overwrite and other not specified options\n          current.row = start.row;\n          current.col = start.col;\n          var selected = {\n            // selected range\n            row: end && start ? end.row - start.row + 1 : 1,\n            col: end && start ? end.col - start.col + 1 : 1\n          };\n          var skippedRow = 0;\n          var skippedColumn = 0;\n          var pushData = true;\n          var cellMeta;\n\n          var getInputValue = function getInputValue(row) {\n            var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            var rowValue = input[row % input.length];\n\n            if (col !== null) {\n              return rowValue[col % rowValue.length];\n            }\n\n            return rowValue;\n          };\n\n          var rowInputLength = input.length;\n          var rowSelectionLength = end ? end.row - start.row + 1 : 0;\n\n          if (end) {\n            rlen = rowSelectionLength;\n          } else {\n            rlen = Math.max(rowInputLength, rowSelectionLength);\n          }\n\n          for (r = 0; r < rlen; r++) {\n            if (end && current.row > end.row && rowSelectionLength > rowInputLength || !tableMeta.allowInsertRow && current.row > instance.countRows() - 1 || current.row >= tableMeta.maxRows) {\n              break;\n            }\n\n            var visualRow = r - skippedRow;\n            var colInputLength = getInputValue(visualRow).length;\n            var colSelectionLength = end ? end.col - start.col + 1 : 0;\n\n            if (end) {\n              clen = colSelectionLength;\n            } else {\n              clen = Math.max(colInputLength, colSelectionLength);\n            }\n\n            current.col = start.col;\n            cellMeta = instance.getCellMeta(current.row, current.col);\n\n            if ((source === 'CopyPaste.paste' || source === 'Autofill.fill') && cellMeta.skipRowOnPaste) {\n              skippedRow += 1;\n              current.row += 1;\n              rlen += 1;\n              /* eslint-disable no-continue */\n\n              continue;\n            }\n\n            skippedColumn = 0;\n\n            for (c = 0; c < clen; c++) {\n              if (end && current.col > end.col && colSelectionLength > colInputLength || !tableMeta.allowInsertColumn && current.col > instance.countCols() - 1 || current.col >= tableMeta.maxCols) {\n                break;\n              }\n\n              cellMeta = instance.getCellMeta(current.row, current.col);\n\n              if ((source === 'CopyPaste.paste' || source === 'Autofill.fill') && cellMeta.skipColumnOnPaste) {\n                skippedColumn += 1;\n                current.col += 1;\n                clen += 1;\n                continue;\n              }\n\n              if (cellMeta.readOnly && source !== 'UndoRedo.undo') {\n                current.col += 1;\n                /* eslint-disable no-continue */\n\n                continue;\n              }\n\n              var visualColumn = c - skippedColumn;\n              var value = getInputValue(visualRow, visualColumn);\n              var orgValue = instance.getDataAtCell(current.row, current.col);\n              var index = {\n                row: visualRow,\n                col: visualColumn\n              };\n\n              if (source === 'Autofill.fill') {\n                var result = instance.runHooks('beforeAutofillInsidePopulate', index, direction, input, deltas, {}, selected);\n\n                if (result) {\n                  value = isUndefined(result.value) ? value : result.value;\n                }\n              }\n\n              if (value !== null && _typeof(value) === 'object') {\n                // when 'value' is array and 'orgValue' is null, set 'orgValue' to\n                // an empty array so that the null value can be compared to 'value'\n                // as an empty value for the array context\n                if (Array.isArray(value) && orgValue === null) orgValue = [];\n\n                if (orgValue === null || _typeof(orgValue) !== 'object') {\n                  pushData = false;\n                } else {\n                  var orgValueSchema = duckSchema(Array.isArray(orgValue) ? orgValue : orgValue[0] || orgValue);\n                  var valueSchema = duckSchema(Array.isArray(value) ? value : value[0] || value);\n                  /* eslint-disable max-depth */\n\n                  if (isObjectEqual(orgValueSchema, valueSchema)) {\n                    value = deepClone(value);\n                  } else {\n                    pushData = false;\n                  }\n                }\n              } else if (orgValue !== null && _typeof(orgValue) === 'object') {\n                pushData = false;\n              }\n\n              if (pushData) {\n                setData.push([current.row, current.col, value]);\n              }\n\n              pushData = true;\n              current.col += 1;\n            }\n\n            current.row += 1;\n          }\n\n          instance.setDataAtCell(setData, null, null, source || 'populateFromArray');\n          break;\n      }\n    }\n  };\n  /**\n   * Internal function to set `language` key of settings.\n   *\n   * @private\n   * @param {string} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'.\n   * @fires Hooks#afterLanguageChange\n   */\n\n  function setLanguage(languageCode) {\n    var normalizedLanguageCode = normalizeLanguageCode(languageCode);\n\n    if (hasLanguageDictionary(normalizedLanguageCode)) {\n      instance.runHooks('beforeLanguageChange', normalizedLanguageCode);\n      globalMeta.language = normalizedLanguageCode;\n      instance.runHooks('afterLanguageChange', normalizedLanguageCode);\n    } else {\n      warnUserAboutLanguageRegistration(languageCode);\n    }\n  }\n  /**\n   * Internal function to set `className` or `tableClassName`, depending on the key from the settings object.\n   *\n   * @private\n   * @param {string} className `className` or `tableClassName` from the key in the settings object.\n   * @param {string|string[]} classSettings String or array of strings. Contains class name(s) from settings object.\n   */\n\n\n  function setClassName(className, classSettings) {\n    var element = className === 'className' ? instance.rootElement : instance.table;\n\n    if (firstRun) {\n      addClass(element, classSettings);\n    } else {\n      var globalMetaSettingsArray = [];\n      var settingsArray = [];\n\n      if (globalMeta[className]) {\n        globalMetaSettingsArray = Array.isArray(globalMeta[className]) ? globalMeta[className] : stringToArray(globalMeta[className]);\n      }\n\n      if (classSettings) {\n        settingsArray = Array.isArray(classSettings) ? classSettings : stringToArray(classSettings);\n      }\n\n      var classNameToRemove = getDifferenceOfArrays(globalMetaSettingsArray, settingsArray);\n      var classNameToAdd = getDifferenceOfArrays(settingsArray, globalMetaSettingsArray);\n\n      if (classNameToRemove.length) {\n        removeClass(element, classNameToRemove);\n      }\n\n      if (classNameToAdd.length) {\n        addClass(element, classNameToAdd);\n      }\n    }\n\n    globalMeta[className] = classSettings;\n  }\n\n  this.init = function () {\n    dataSource.setData(tableMeta.data);\n    instance.runHooks('beforeInit');\n\n    if (isMobileBrowser() || isIpadOS()) {\n      addClass(instance.rootElement, 'mobile');\n    }\n\n    this.updateSettings(tableMeta, true);\n    this.view = new TableView(this);\n    editorManager = EditorManager.getInstance(instance, tableMeta, selection);\n    instance.runHooks('init');\n    this.forceFullRender = true; // used when data was changed\n\n    this.view.render();\n\n    if (_typeof(firstRun) === 'object') {\n      instance.runHooks('afterChange', firstRun[0], firstRun[1]);\n      firstRun = false;\n    }\n\n    instance.runHooks('afterInit');\n  };\n  /**\n   * @ignore\n   * @returns {object}\n   */\n\n\n  function ValidatorsQueue() {\n    // moved this one level up so it can be used in any function here. Probably this should be moved to a separate file\n    var resolved = false;\n    return {\n      validatorsInQueue: 0,\n      valid: true,\n      addValidatorToQueue: function addValidatorToQueue() {\n        this.validatorsInQueue += 1;\n        resolved = false;\n      },\n      removeValidatorFormQueue: function removeValidatorFormQueue() {\n        this.validatorsInQueue = this.validatorsInQueue - 1 < 0 ? 0 : this.validatorsInQueue - 1;\n        this.checkIfQueueIsEmpty();\n      },\n      onQueueEmpty: function onQueueEmpty() {},\n      checkIfQueueIsEmpty: function checkIfQueueIsEmpty() {\n        if (this.validatorsInQueue === 0 && resolved === false) {\n          resolved = true;\n          this.onQueueEmpty(this.valid);\n        }\n      }\n    };\n  }\n  /**\n   * Get parsed number from numeric string.\n   *\n   * @private\n   * @param {string} numericData Float (separated by a dot or a comma) or integer.\n   * @returns {number} Number if we get data in parsable format, not changed value otherwise.\n   */\n\n\n  function getParsedNumber(numericData) {\n    // Unifying \"float like\" string. Change from value with comma determiner to value with dot determiner,\n    // for example from `450,65` to `450.65`.\n    var unifiedNumericData = numericData.replace(',', '.');\n\n    if (isNaN(parseFloat(unifiedNumericData)) === false) {\n      return parseFloat(unifiedNumericData);\n    }\n\n    return numericData;\n  }\n  /**\n   * @ignore\n   * @param {Array} changes The 2D array containing information about each of the edited cells.\n   * @param {string} source The string that identifies source of validation.\n   * @param {Function} callback The callback function fot async validation.\n   */\n\n\n  function validateChanges(changes, source, callback) {\n    if (!changes.length) {\n      return;\n    }\n\n    var activeEditor = instance.getActiveEditor();\n    var beforeChangeResult = instance.runHooks('beforeChange', changes, source || 'edit');\n    var shouldBeCanceled = true;\n\n    if (beforeChangeResult === false) {\n      if (activeEditor) {\n        activeEditor.cancelChanges();\n      }\n\n      return;\n    }\n\n    var waitingForValidator = new ValidatorsQueue();\n\n    var isNumericData = function isNumericData(value) {\n      return value.length > 0 && /^\\s*[+-.]?\\s*(?:(?:\\d+(?:(\\.|,)\\d+)?(?:e[+-]?\\d+)?)|(?:0x[a-f\\d]+))\\s*$/.test(value);\n    };\n\n    waitingForValidator.onQueueEmpty = function (isValid) {\n      if (activeEditor && shouldBeCanceled) {\n        activeEditor.cancelChanges();\n      }\n\n      callback(isValid); // called when async validators are resolved and beforeChange was not async\n    };\n\n    for (var i = changes.length - 1; i >= 0; i--) {\n      if (changes[i] === null) {\n        changes.splice(i, 1);\n      } else {\n        var _changes$i = _slicedToArray(changes[i], 4),\n            row = _changes$i[0],\n            prop = _changes$i[1],\n            newValue = _changes$i[3];\n\n        var col = datamap.propToCol(prop);\n        var cellProperties = instance.getCellMeta(row, col);\n\n        if (cellProperties.type === 'numeric' && typeof newValue === 'string' && isNumericData(newValue)) {\n          changes[i][3] = getParsedNumber(newValue);\n        }\n        /* eslint-disable no-loop-func */\n\n\n        if (instance.getCellValidator(cellProperties)) {\n          waitingForValidator.addValidatorToQueue();\n          instance.validateCell(changes[i][3], cellProperties, function (index, cellPropertiesReference) {\n            return function (result) {\n              if (typeof result !== 'boolean') {\n                throw new Error('Validation error: result is not boolean');\n              }\n\n              if (result === false && cellPropertiesReference.allowInvalid === false) {\n                shouldBeCanceled = false;\n                changes.splice(index, 1); // cancel the change\n\n                cellPropertiesReference.valid = true; // we cancelled the change, so cell value is still valid\n\n                var cell = instance.getCell(cellPropertiesReference.visualRow, cellPropertiesReference.visualCol);\n\n                if (cell !== null) {\n                  removeClass(cell, tableMeta.invalidCellClassName);\n                } // index -= 1;\n\n              }\n\n              waitingForValidator.removeValidatorFormQueue();\n            };\n          }(i, cellProperties), source);\n        }\n      }\n    }\n\n    waitingForValidator.checkIfQueueIsEmpty();\n  }\n  /**\n   * Internal function to apply changes. Called after validateChanges.\n   *\n   * @private\n   * @param {Array} changes Array in form of [row, prop, oldValue, newValue].\n   * @param {string} source String that identifies how this change will be described in changes array (useful in onChange callback).\n   * @fires Hooks#beforeChangeRender\n   * @fires Hooks#afterChange\n   */\n\n\n  function applyChanges(changes, source) {\n    var i = changes.length - 1;\n\n    if (i < 0) {\n      return;\n    }\n\n    for (; i >= 0; i--) {\n      var skipThisChange = false;\n\n      if (changes[i] === null) {\n        changes.splice(i, 1);\n        /* eslint-disable no-continue */\n\n        continue;\n      }\n\n      if ((changes[i][2] === null || changes[i][2] === void 0) && (changes[i][3] === null || changes[i][3] === void 0)) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n\n      if (tableMeta.allowInsertRow) {\n        while (changes[i][0] > instance.countRows() - 1) {\n          var numberOfCreatedRows = datamap.createRow(void 0, void 0, source);\n\n          if (numberOfCreatedRows >= 1) {\n            metaManager.createRow(null, numberOfCreatedRows);\n          } else {\n            skipThisChange = true;\n            break;\n          }\n        }\n      }\n\n      if (instance.dataType === 'array' && (!tableMeta.columns || tableMeta.columns.length === 0) && tableMeta.allowInsertColumn) {\n        while (datamap.propToCol(changes[i][1]) > instance.countCols() - 1) {\n          var numberOfCreatedColumns = datamap.createCol(void 0, void 0, source);\n\n          if (numberOfCreatedColumns >= 1) {\n            metaManager.createColumn(null, numberOfCreatedColumns);\n          } else {\n            skipThisChange = true;\n            break;\n          }\n        }\n      }\n\n      if (skipThisChange) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n\n      datamap.set(changes[i][0], changes[i][1], changes[i][3]);\n    }\n\n    instance.forceFullRender = true; // used when data was changed\n\n    grid.adjustRowsAndCols();\n    instance.runHooks('beforeChangeRender', changes, source);\n    editorManager.lockEditor();\n\n    instance._refreshBorders(null);\n\n    editorManager.unlockEditor();\n    instance.view.adjustElementsSize();\n    instance.runHooks('afterChange', changes, source || 'edit');\n    var activeEditor = instance.getActiveEditor();\n\n    if (activeEditor && isDefined(activeEditor.refreshValue)) {\n      activeEditor.refreshValue();\n    }\n  }\n  /**\n   * Validate a single cell.\n   *\n   * @param {string|number} value The value to validate.\n   * @param {object} cellProperties The cell meta which corresponds with the value.\n   * @param {Function} callback The callback function.\n   * @param {string} source The string that identifies source of the validation.\n   */\n\n\n  this.validateCell = function (value, cellProperties, callback, source) {\n    var validator = instance.getCellValidator(cellProperties); // the `canBeValidated = false` argument suggests, that the cell passes validation by default.\n\n    /**\n     * @param {boolean} valid Indicates if the validation was successful.\n     * @param {boolean} [canBeValidated=true] Flag which controls the validation process.\n     */\n\n    function done(valid) {\n      var canBeValidated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      // Fixes GH#3903\n      if (!canBeValidated || cellProperties.hidden === true) {\n        callback(valid);\n        return;\n      }\n\n      var col = cellProperties.visualCol;\n      var row = cellProperties.visualRow;\n      var td = instance.getCell(row, col, true);\n\n      if (td && td.nodeName !== 'TH') {\n        var renderableRow = instance.rowIndexMapper.getRenderableFromVisualIndex(row);\n        var renderableColumn = instance.columnIndexMapper.getRenderableFromVisualIndex(col);\n        instance.view.wt.wtSettings.settings.cellRenderer(renderableRow, renderableColumn, td);\n      }\n\n      callback(valid);\n    }\n\n    if (isRegExp(validator)) {\n      validator = function (expression) {\n        return function (cellValue, validatorCallback) {\n          validatorCallback(expression.test(cellValue));\n        };\n      }(validator);\n    }\n\n    if (isFunction(validator)) {\n      // eslint-disable-next-line no-param-reassign\n      value = instance.runHooks('beforeValidate', value, cellProperties.visualRow, cellProperties.prop, source); // To provide consistent behaviour, validation should be always asynchronous\n\n      instance._registerImmediate(function () {\n        validator.call(cellProperties, value, function (valid) {\n          if (!instance) {\n            return;\n          } // eslint-disable-next-line no-param-reassign\n\n\n          valid = instance.runHooks('afterValidate', valid, value, cellProperties.visualRow, cellProperties.prop, source);\n          cellProperties.valid = valid;\n          done(valid);\n          instance.runHooks('postAfterValidate', valid, value, cellProperties.visualRow, cellProperties.prop, source);\n        });\n      });\n    } else {\n      // resolve callback even if validator function was not found\n      instance._registerImmediate(function () {\n        cellProperties.valid = true;\n        done(cellProperties.valid, false);\n      });\n    }\n  };\n  /**\n   * @ignore\n   * @param {number} row The visual row index.\n   * @param {string|number} propOrCol The visual prop or column index.\n   * @param {*} value The cell value.\n   * @returns {Array}\n   */\n\n\n  function setDataInputToArray(row, propOrCol, value) {\n    if (Array.isArray(row)) {\n      // it's an array of changes\n      return row;\n    }\n\n    return [[row, propOrCol, value]];\n  }\n  /**\n   * @description\n   * Set new value to a cell. To change many cells at once (recommended way), pass an array of `changes` in format\n   * `[[row, col, value],...]` as the first argument.\n   *\n   * @memberof Core#\n   * @function setDataAtCell\n   * @param {number|Array} row Visual row index or array of changes in format `[[row, col, value],...]`.\n   * @param {number} [column] Visual column index.\n   * @param {string} [value] New value.\n   * @param {string} [source] String that identifies how this change will be described in the changes array (useful in afterChange or beforeChange callback). Set to 'edit' if left empty.\n   */\n\n\n  this.setDataAtCell = function (row, column, value, source) {\n    var input = setDataInputToArray(row, column, value);\n    var changes = [];\n    var changeSource = source;\n    var i;\n    var ilen;\n    var prop;\n\n    for (i = 0, ilen = input.length; i < ilen; i++) {\n      if (_typeof(input[i]) !== 'object') {\n        throw new Error('Method `setDataAtCell` accepts row number or changes array of arrays as its first parameter');\n      }\n\n      if (typeof input[i][1] !== 'number') {\n        throw new Error('Method `setDataAtCell` accepts row and column number as its parameters. If you want to use object property name, use method `setDataAtRowProp`'); // eslint-disable-line max-len\n      }\n\n      if (input[i][1] >= this.countCols()) {\n        prop = input[i][1];\n      } else {\n        prop = datamap.colToProp(input[i][1]);\n      }\n\n      changes.push([input[i][0], prop, dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);\n    }\n\n    if (!changeSource && _typeof(row) === 'object') {\n      changeSource = column;\n    }\n\n    instance.runHooks('afterSetDataAtCell', changes, changeSource);\n    validateChanges(changes, changeSource, function () {\n      applyChanges(changes, changeSource);\n    });\n  };\n  /**\n   * @description\n   * Set new value to a cell. To change many cells at once (recommended way), pass an array of `changes` in format\n   * `[[row, prop, value],...]` as the first argument.\n   *\n   * @memberof Core#\n   * @function setDataAtRowProp\n   * @param {number|Array} row Visual row index or array of changes in format `[[row, prop, value], ...]`.\n   * @param {string} prop Property name or the source string (e.g. `'first.name'` or `'0'`).\n   * @param {string} value Value to be set.\n   * @param {string} [source] String that identifies how this change will be described in changes array (useful in onChange callback).\n   */\n\n\n  this.setDataAtRowProp = function (row, prop, value, source) {\n    var input = setDataInputToArray(row, prop, value);\n    var changes = [];\n    var changeSource = source;\n    var i;\n    var ilen;\n\n    for (i = 0, ilen = input.length; i < ilen; i++) {\n      changes.push([input[i][0], input[i][1], dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);\n    }\n\n    if (!changeSource && _typeof(row) === 'object') {\n      changeSource = prop;\n    }\n\n    instance.runHooks('afterSetDataAtRowProp', changes, changeSource);\n    validateChanges(changes, changeSource, function () {\n      applyChanges(changes, changeSource);\n    });\n  };\n  /**\n   * Listen to the keyboard input on document body. This allows Handsontable to capture keyboard events and respond\n   * in the right way.\n   *\n   * @memberof Core#\n   * @function listen\n   * @fires Hooks#afterListen\n   */\n\n\n  this.listen = function () {\n    if (instance && !instance.isListening()) {\n      activeGuid = instance.guid;\n      instance.runHooks('afterListen');\n    }\n  };\n  /**\n   * Stop listening to keyboard input on the document body. Calling this method makes the Handsontable inactive for\n   * any keyboard events.\n   *\n   * @memberof Core#\n   * @function unlisten\n   */\n\n\n  this.unlisten = function () {\n    if (this.isListening()) {\n      activeGuid = null;\n      instance.runHooks('afterUnlisten');\n    }\n  };\n  /**\n   * Returns `true` if the current Handsontable instance is listening to keyboard input on document body.\n   *\n   * @memberof Core#\n   * @function isListening\n   * @returns {boolean} `true` if the instance is listening, `false` otherwise.\n   */\n\n\n  this.isListening = function () {\n    return activeGuid === instance.guid;\n  };\n  /**\n   * Destroys the current editor, render the table and prepares the editor of the newly selected cell.\n   *\n   * @memberof Core#\n   * @function destroyEditor\n   * @param {boolean} [revertOriginal=false] If `true`, the previous value will be restored. Otherwise, the edited value will be saved.\n   * @param {boolean} [prepareEditorIfNeeded=true] If `true` the editor under the selected cell will be prepared to open.\n   */\n\n\n  this.destroyEditor = function () {\n    var revertOriginal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    instance._refreshBorders(revertOriginal, prepareEditorIfNeeded);\n  };\n  /**\n   * Populate cells at position with 2D input array (e.g. `[[1, 2], [3, 4]]`). Use `endRow`, `endCol` when you\n   * want to cut input when a certain row is reached.\n   *\n   * Optional `method` argument has the same effect as pasteMode option (see {@link Options#pasteMode}).\n   *\n   * @memberof Core#\n   * @function populateFromArray\n   * @param {number} row Start visual row index.\n   * @param {number} column Start visual column index.\n   * @param {Array} input 2d array.\n   * @param {number} [endRow] End visual row index (use when you want to cut input when certain row is reached).\n   * @param {number} [endCol] End visual column index (use when you want to cut input when certain column is reached).\n   * @param {string} [source=populateFromArray] Used to identify this call in the resulting events (beforeChange, afterChange).\n   * @param {string} [method=overwrite] Populate method, possible values: `'shift_down'`, `'shift_right'`, `'overwrite'`.\n   * @param {string} direction Populate direction, possible values: `'left'`, `'right'`, `'up'`, `'down'`.\n   * @param {Array} deltas The deltas array. A difference between values of adjacent cells.\n   *                       Useful **only** when the type of handled cells is `numeric`.\n   * @returns {object|undefined} Ending td in pasted area (only if any cell was changed).\n   */\n\n\n  this.populateFromArray = function (row, column, input, endRow, endCol, source, method, direction, deltas) {\n    if (!(_typeof(input) === 'object' && _typeof(input[0]) === 'object')) {\n      throw new Error('populateFromArray parameter `input` must be an array of arrays'); // API changed in 0.9-beta2, let's check if you use it correctly\n    }\n\n    var c = typeof endRow === 'number' ? new CellCoords(endRow, endCol) : null;\n    return grid.populateFromArray(new CellCoords(row, column), input, c, source, method, direction, deltas);\n  };\n  /**\n   * Adds/removes data from the column. This method works the same as Array.splice for arrays (see {@link DataMap#spliceCol}).\n   *\n   * @memberof Core#\n   * @function spliceCol\n   * @param {number} column Index of the column in which do you want to do splice.\n   * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n   * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n   * @param {...number} [elements] The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array.\n   * @returns {Array} Returns removed portion of columns.\n   */\n\n\n  this.spliceCol = function (column, index, amount) {\n    var _datamap;\n\n    for (var _len = arguments.length, elements = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      elements[_key - 3] = arguments[_key];\n    }\n\n    return (_datamap = datamap).spliceCol.apply(_datamap, [column, index, amount].concat(elements));\n  };\n  /**\n   * Adds/removes data from the row. This method works the same as Array.splice for arrays (see {@link DataMap#spliceRow}).\n   *\n   * @memberof Core#\n   * @function spliceRow\n   * @param {number} row Index of column in which do you want to do splice.\n   * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n   * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n   * @param {...number} [elements] The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array.\n   * @returns {Array} Returns removed portion of rows.\n   */\n\n\n  this.spliceRow = function (row, index, amount) {\n    var _datamap2;\n\n    for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n      elements[_key2 - 3] = arguments[_key2];\n    }\n\n    return (_datamap2 = datamap).spliceRow.apply(_datamap2, [row, index, amount].concat(elements));\n  };\n  /**\n   * Returns indexes of the currently selected cells as an array of arrays `[[startRow, startCol, endRow, endCol],...]`.\n   *\n   * Start row and start column are the coordinates of the active cell (where the selection was started).\n   *\n   * The version 0.36.0 adds a non-consecutive selection feature. Since this version, the method returns an array of arrays.\n   * Additionally to collect the coordinates of the currently selected area (as it was previously done by the method)\n   * you need to use `getSelectedLast` method.\n   *\n   * @memberof Core#\n   * @function getSelected\n   * @returns {Array[]|undefined} An array of arrays of the selection's coordinates.\n   */\n\n\n  this.getSelected = function () {\n    // https://github.com/handsontable/handsontable/issues/44  //cjl\n    if (selection.isSelected()) {\n      return arrayMap(selection.getSelectedRange(), function (_ref12) {\n        var from = _ref12.from,\n            to = _ref12.to;\n        return [from.row, from.col, to.row, to.col];\n      });\n    }\n  };\n  /**\n   * Returns the last coordinates applied to the table as a an array `[startRow, startCol, endRow, endCol]`.\n   *\n   * @since 0.36.0\n   * @memberof Core#\n   * @function getSelectedLast\n   * @returns {Array|undefined} An array of the selection's coordinates.\n   */\n\n\n  this.getSelectedLast = function () {\n    var selected = this.getSelected();\n    var result;\n\n    if (selected && selected.length > 0) {\n      result = selected[selected.length - 1];\n    }\n\n    return result;\n  };\n  /**\n   * Returns the current selection as an array of CellRange objects.\n   *\n   * The version 0.36.0 adds a non-consecutive selection feature. Since this version, the method returns an array of arrays.\n   * Additionally to collect the coordinates of the currently selected area (as it was previously done by the method)\n   * you need to use `getSelectedRangeLast` method.\n   *\n   * @memberof Core#\n   * @function getSelectedRange\n   * @returns {CellRange[]|undefined} Selected range object or undefined if there is no selection.\n   */\n\n\n  this.getSelectedRange = function () {\n    // https://github.com/handsontable/handsontable/issues/44  //cjl\n    if (selection.isSelected()) {\n      return Array.from(selection.getSelectedRange());\n    }\n  };\n  /**\n   * Returns the last coordinates applied to the table as a CellRange object.\n   *\n   * @memberof Core#\n   * @function getSelectedRangeLast\n   * @since 0.36.0\n   * @returns {CellRange|undefined} Selected range object or undefined` if there is no selection.\n   */\n\n\n  this.getSelectedRangeLast = function () {\n    var selectedRange = this.getSelectedRange();\n    var result;\n\n    if (selectedRange && selectedRange.length > 0) {\n      result = selectedRange[selectedRange.length - 1];\n    }\n\n    return result;\n  };\n  /**\n   * Erases content from cells that have been selected in the table.\n   *\n   * @memberof Core#\n   * @function emptySelectedCells\n   * @param {string} [source] String that identifies how this change will be described in the changes array (useful in afterChange or beforeChange callback). Set to 'edit' if left empty.\n   * @since 0.36.0\n   */\n\n\n  this.emptySelectedCells = function (source) {\n    var _this2 = this;\n\n    if (!selection.isSelected() || this.countRows() === 0 || this.countCols() === 0) {\n      return;\n    }\n\n    var changes = [];\n    arrayEach(selection.getSelectedRange(), function (cellRange) {\n      var topLeft = cellRange.getTopLeftCorner();\n      var bottomRight = cellRange.getBottomRightCorner();\n      rangeEach(topLeft.row, bottomRight.row, function (row) {\n        rangeEach(topLeft.col, bottomRight.col, function (column) {\n          if (!_this2.getCellMeta(row, column).readOnly) {\n            changes.push([row, column, null]);\n          }\n        });\n      });\n    });\n\n    if (changes.length > 0) {\n      this.setDataAtCell(changes, source);\n    }\n  };\n  /**\n   * Checks if the table rendering process was suspended. See explanation in {@link Core#suspendRender}.\n   *\n   * @memberof Core#\n   * @function isRenderSuspended\n   * @since 8.3.0\n   * @returns {boolean}\n   */\n\n\n  this.isRenderSuspended = function () {\n    return this.renderSuspendedCounter > 0;\n  };\n  /**\n   * Suspends the rendering process. It's helpful to wrap the table render\n   * cycles triggered by API calls or UI actions (or both) and call the \"render\"\n   * once in the end. As a result, it improves the performance of wrapped operations.\n   * When the table is in the suspend state, most operations will have no visual\n   * effect until the rendering state is resumed. Resuming the state automatically\n   * invokes the table rendering. To make sure that after executing all operations,\n   * the table will be rendered, it's highly recommended to use the {@link Core#batchRender}\n   * method or {@link Core#batch}, which additionally aggregates the logic execution\n   * that happens behind the table.\n   *\n   * The method is intended to be used by advanced users. Suspending the rendering\n   * process could cause visual glitches when wrongly implemented.\n   *\n   * @memberof Core#\n   * @function suspendRender\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendRender();\n   * hot.alter('insert_row', 5, 45);\n   * hot.alter('insert_col', 10, 40);\n   * hot.setDataAtCell(1, 1, 'John');\n   * hot.setDataAtCell(2, 2, 'Mark');\n   * hot.setDataAtCell(3, 3, 'Ann');\n   * hot.setDataAtCell(4, 4, 'Sophia');\n   * hot.setDataAtCell(5, 5, 'Mia');\n   * hot.selectCell(0, 0);\n   * hot.resumeRender(); // It re-renders the table internally\n   * ```\n   */\n\n\n  this.suspendRender = function () {\n    this.renderSuspendedCounter += 1;\n  };\n  /**\n   * Resumes the rendering process. In combination with the {@link Core#suspendRender}\n   * method it allows aggregating the table render cycles triggered by API calls or UI\n   * actions (or both) and calls the \"render\" once in the end. When the table is in\n   * the suspend state, most operations will have no visual effect until the rendering\n   * state is resumed. Resuming the state automatically invokes the table rendering.\n   *\n   * The method is intended to be used by advanced users. Suspending the rendering\n   * process could cause visual glitches when wrongly implemented.\n   *\n   * @memberof Core#\n   * @function resumeRender\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendRender();\n   * hot.alter('insert_row', 5, 45);\n   * hot.alter('insert_col', 10, 40);\n   * hot.setDataAtCell(1, 1, 'John');\n   * hot.setDataAtCell(2, 2, 'Mark');\n   * hot.setDataAtCell(3, 3, 'Ann');\n   * hot.setDataAtCell(4, 4, 'Sophia');\n   * hot.setDataAtCell(5, 5, 'Mia');\n   * hot.selectCell(0, 0);\n   * hot.resumeRender(); // It re-renders the table internally\n   * ```\n   */\n\n\n  this.resumeRender = function () {\n    var nextValue = this.renderSuspendedCounter - 1;\n    this.renderSuspendedCounter = Math.max(nextValue, 0);\n\n    if (!this.isRenderSuspended() && nextValue === this.renderSuspendedCounter) {\n      if (this.renderCall) {\n        this.render();\n      } else {\n        this._refreshBorders(null);\n      }\n    }\n  };\n  /**\n   * Rerender the table. Calling this method starts the process of recalculating, redrawing and applying the changes\n   * to the DOM. While rendering the table all cell renderers are recalled.\n   *\n   * Calling this method manually is not recommended. Handsontable tries to render itself by choosing the most\n   * optimal moments in its lifecycle.\n   *\n   * @memberof Core#\n   * @function render\n   */\n\n\n  this.render = function () {\n    if (this.view) {\n      this.renderCall = true;\n      this.forceFullRender = true; // used when data was changed\n\n      if (!this.isRenderSuspended()) {\n        editorManager.lockEditor();\n\n        this._refreshBorders(null);\n\n        editorManager.unlockEditor();\n      }\n    }\n  };\n  /**\n   * The method aggregates multi-line API calls into a callback and postpones the\n   * table rendering process. After the execution of the operations, the table is\n   * rendered once. As a result, it improves the performance of wrapped operations.\n   * Without batching, a similar case could trigger multiple table render calls.\n   *\n   * @memberof Core#\n   * @function batchRender\n   * @param {Function} wrappedOperations Batched operations wrapped in a function.\n   * @returns {*} Returns result from the wrappedOperations callback.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.batchRender(() => {\n   *   hot.alter('insert_row', 5, 45);\n   *   hot.alter('insert_col', 10, 40);\n   *   hot.setDataAtCell(1, 1, 'John');\n   *   hot.setDataAtCell(2, 2, 'Mark');\n   *   hot.setDataAtCell(3, 3, 'Ann');\n   *   hot.setDataAtCell(4, 4, 'Sophia');\n   *   hot.setDataAtCell(5, 5, 'Mia');\n   *   hot.selectCell(0, 0);\n   *   // The table will be rendered once after executing the callback\n   * });\n   * ```\n   */\n\n\n  this.batchRender = function (wrappedOperations) {\n    this.suspendRender();\n    var result = wrappedOperations();\n    this.resumeRender();\n    return result;\n  };\n  /**\n   * Checks if the table indexes recalculation process was suspended. See explanation\n   * in {@link Core#suspendExecution}.\n   *\n   * @memberof Core#\n   * @function isExecutionSuspended\n   * @since 8.3.0\n   * @returns {boolean}\n   */\n\n\n  this.isExecutionSuspended = function () {\n    return this.executionSuspendedCounter > 0;\n  };\n  /**\n   * Suspends the execution process. It's helpful to wrap the table logic changes\n   * such as index changes into one call after which the cache is updated. As a result,\n   * it improves the performance of wrapped operations.\n   *\n   * The method is intended to be used by advanced users. Suspending the execution\n   * process could cause visual glitches caused by not updated the internal table cache.\n   *\n   * @memberof Core#\n   * @function suspendExecution\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendExecution();\n   * const filters = hot.getPlugin('filters');\n   *\n   * filters.addCondition(2, 'contains', ['3']);\n   * filters.filter();\n   * hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   * hot.resumeExecution(); // It updates the cache internally\n   * ```\n   */\n\n\n  this.suspendExecution = function () {\n    this.executionSuspendedCounter += 1;\n    this.columnIndexMapper.suspendOperations();\n    this.rowIndexMapper.suspendOperations();\n  };\n  /**\n   * Resumes the execution process. In combination with the {@link Core#suspendExecution}\n   * method it allows aggregating the table logic changes after which the cache is\n   * updated. Resuming the state automatically invokes the table cache updating process.\n   *\n   * The method is intended to be used by advanced users. Suspending the execution\n   * process could cause visual glitches caused by not updated the internal table cache.\n   *\n   * @memberof Core#\n   * @function resumeExecution\n   * @param {boolean} [forceFlushChanges=false] If `true`, the table internal data cache\n   * is recalculated after the execution of the batched operations. For nested\n   * {@link Core#batchExecution} calls, it can be desire to recalculate the table\n   * after each batch.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendExecution();\n   * const filters = hot.getPlugin('filters');\n   *\n   * filters.addCondition(2, 'contains', ['3']);\n   * filters.filter();\n   * hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   * hot.resumeExecution(); // It updates the cache internally\n   * ```\n   */\n\n\n  this.resumeExecution = function () {\n    var forceFlushChanges = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var nextValue = this.executionSuspendedCounter - 1;\n    this.executionSuspendedCounter = Math.max(nextValue, 0);\n\n    if (!this.isExecutionSuspended() && nextValue === this.executionSuspendedCounter || forceFlushChanges) {\n      this.columnIndexMapper.resumeOperations();\n      this.rowIndexMapper.resumeOperations();\n    }\n  };\n  /**\n   * The method aggregates multi-line API calls into a callback and postpones the\n   * table execution process. After the execution of the operations, the internal table\n   * cache is recalculated once. As a result, it improves the performance of wrapped\n   * operations. Without batching, a similar case could trigger multiple table cache rebuilds.\n   *\n   * @memberof Core#\n   * @function batchExecution\n   * @param {Function} wrappedOperations Batched operations wrapped in a function.\n   * @param {boolean} [forceFlushChanges=false] If `true`, the table internal data cache\n   * is recalculated after the execution of the batched operations. For nested calls,\n   * it can be a desire to recalculate the table after each batch.\n   * @returns {*} Returns result from the wrappedOperations callback.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.batchExecution(() => {\n   *   const filters = hot.getPlugin('filters');\n   *\n   *   filters.addCondition(2, 'contains', ['3']);\n   *   filters.filter();\n   *   hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   *   // The table cache will be recalculated once after executing the callback\n   * });\n   * ```\n   */\n\n\n  this.batchExecution = function (wrappedOperations) {\n    var forceFlushChanges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.suspendExecution();\n    var result = wrappedOperations();\n    this.resumeExecution(forceFlushChanges);\n    return result;\n  };\n  /**\n   * It batches the rendering process and index recalculations. The method aggregates\n   * multi-line API calls into a callback and postpones the table rendering process\n   * as well aggregates the table logic changes such as index changes into one call\n   * after which the cache is updated. After the execution of the operations, the\n   * table is rendered, and the cache is updated once. As a result, it improves the\n   * performance of wrapped operations.\n   *\n   * @memberof Core#\n   * @function batch\n   * @param {Function} wrappedOperations Batched operations wrapped in a function.\n   * @returns {*} Returns result from the wrappedOperations callback.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.batch(() => {\n   *   hot.alter('insert_row', 5, 45);\n   *   hot.alter('insert_col', 10, 40);\n   *   hot.setDataAtCell(1, 1, 'x');\n   *   hot.setDataAtCell(2, 2, 'c');\n   *   hot.setDataAtCell(3, 3, 'v');\n   *   hot.setDataAtCell(4, 4, 'b');\n   *   hot.setDataAtCell(5, 5, 'n');\n   *   hot.selectCell(0, 0);\n   *\n   *   const filters = hot.getPlugin('filters');\n   *\n   *   filters.addCondition(2, 'contains', ['3']);\n   *   filters.filter();\n   *   hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   *   // The table will be re-rendered and cache will be recalculated once after executing the callback\n   * });\n   * ```\n   */\n\n\n  this.batch = function (wrappedOperations) {\n    this.suspendRender();\n    this.suspendExecution();\n    var result = wrappedOperations();\n    this.resumeExecution();\n    this.resumeRender();\n    return result;\n  };\n  /**\n   * Updates dimensions of the table. The method compares previous dimensions with the current ones and updates accordingly.\n   *\n   * @memberof Core#\n   * @function refreshDimensions\n   * @fires Hooks#beforeRefreshDimensions\n   * @fires Hooks#afterRefreshDimensions\n   */\n\n\n  this.refreshDimensions = function () {\n    if (!instance.view) {\n      return;\n    }\n\n    var _instance$view$getLas = instance.view.getLastSize(),\n        lastWidth = _instance$view$getLas.width,\n        lastHeight = _instance$view$getLas.height;\n\n    var _instance$rootElement = instance.rootElement.getBoundingClientRect(),\n        width = _instance$rootElement.width,\n        height = _instance$rootElement.height;\n\n    var isSizeChanged = width !== lastWidth || height !== lastHeight;\n    var isResizeBlocked = instance.runHooks('beforeRefreshDimensions', {\n      width: lastWidth,\n      height: lastHeight\n    }, {\n      width: width,\n      height: height\n    }, isSizeChanged) === false;\n\n    if (isResizeBlocked) {\n      return;\n    }\n\n    if (isSizeChanged || instance.view.wt.wtOverlays.scrollableElement === instance.rootWindow) {\n      instance.view.setLastSize(width, height);\n      instance.render();\n    }\n\n    instance.runHooks('afterRefreshDimensions', {\n      width: lastWidth,\n      height: lastHeight\n    }, {\n      width: width,\n      height: height\n    }, isSizeChanged);\n  };\n  /**\n   * Loads new data to Handsontable. Loading new data resets the cell meta.\n   * Since 8.0.0 loading new data also resets states corresponding to rows and columns\n   * (for example, row/column sequence, column width, row height, frozen columns etc.).\n   *\n   * @memberof Core#\n   * @function loadData\n   * @param {Array} data Array of arrays or array of objects containing data.\n   * @param {string} [source] Source of the loadData call.\n   * @fires Hooks#beforeLoadData\n   * @fires Hooks#afterLoadData\n   * @fires Hooks#afterChange\n   */\n\n\n  this.loadData = function (data, source) {\n    if (Array.isArray(tableMeta.dataSchema)) {\n      instance.dataType = 'array';\n    } else if (isFunction(tableMeta.dataSchema)) {\n      instance.dataType = 'function';\n    } else {\n      instance.dataType = 'object';\n    }\n\n    if (datamap) {\n      datamap.destroy();\n    }\n\n    data = instance.runHooks('beforeLoadData', data, firstRun, source);\n    datamap = new DataMap(instance, data, tableMeta);\n\n    if (_typeof(data) === 'object' && data !== null) {\n      if (!(data.push && data.splice)) {\n        // check if data is array. Must use duck-type check so Backbone Collections also pass it\n        // when data is not an array, attempt to make a single-row array of it\n        // eslint-disable-next-line no-param-reassign\n        data = [data];\n      }\n    } else if (data === null) {\n      var dataSchema = datamap.getSchema(); // eslint-disable-next-line no-param-reassign\n\n      data = [];\n      var row;\n      var r = 0;\n      var rlen = 0;\n\n      for (r = 0, rlen = tableMeta.startRows; r < rlen; r++) {\n        if ((instance.dataType === 'object' || instance.dataType === 'function') && tableMeta.dataSchema) {\n          row = deepClone(dataSchema);\n          data.push(row);\n        } else if (instance.dataType === 'array') {\n          row = deepClone(dataSchema[0]);\n          data.push(row);\n        } else {\n          row = [];\n\n          for (var c = 0, clen = tableMeta.startCols; c < clen; c++) {\n            row.push(null);\n          }\n\n          data.push(row);\n        }\n      }\n    } else {\n      throw new Error(\"loadData only accepts array of objects or array of arrays (\".concat(_typeof(data), \" given)\"));\n    }\n\n    if (Array.isArray(data[0])) {\n      instance.dataType = 'array';\n    }\n\n    tableMeta.data = data;\n    datamap.dataSource = data;\n    dataSource.data = data;\n    dataSource.dataType = instance.dataType;\n    dataSource.colToProp = datamap.colToProp.bind(datamap);\n    dataSource.propToCol = datamap.propToCol.bind(datamap);\n    dataSource.countCachedColumns = datamap.countCachedColumns.bind(datamap);\n    metaManager.clearCellsCache();\n    instance.initIndexMappers();\n    grid.adjustRowsAndCols();\n    instance.runHooks('afterLoadData', data, firstRun, source);\n\n    if (firstRun) {\n      firstRun = [null, 'loadData'];\n    } else {\n      instance.runHooks('afterChange', null, 'loadData');\n      instance.render();\n    }\n  };\n  /**\n   * Init index mapper which manage indexes assigned to the data.\n   *\n   * @private\n   */\n\n\n  this.initIndexMappers = function () {\n    var columnsSettings = tableMeta.columns;\n    var finalNrOfColumns = 0; // We will check number of columns when the `columns` property was defined as an array. Columns option may\n    // narrow down or expand displayed dataset in that case.\n\n    if (Array.isArray(columnsSettings)) {\n      finalNrOfColumns = columnsSettings.length;\n    } else if (isFunction(columnsSettings)) {\n      if (instance.dataType === 'array') {\n        var nrOfSourceColumns = this.countSourceCols();\n\n        for (var columnIndex = 0; columnIndex < nrOfSourceColumns; columnIndex += 1) {\n          if (columnsSettings(columnIndex)) {\n            finalNrOfColumns += 1;\n          }\n        } // Extended dataset by the `columns` property? Moved code right from the refactored `countCols` method.\n\n      } else if (instance.dataType === 'object' || instance.dataType === 'function') {\n        finalNrOfColumns = datamap.colToPropCache.length;\n      } // In some cases we need to check columns length from the schema, i.e. `data` may be empty.\n\n    } else if (isDefined(tableMeta.dataSchema)) {\n      var schema = datamap.getSchema(); // Schema may be defined as an array of objects. Each object will define column.\n\n      finalNrOfColumns = Array.isArray(schema) ? schema.length : deepObjectSize(schema);\n    } else {\n      // We init index mappers by length of source data to provide indexes also for skipped indexes.\n      finalNrOfColumns = this.countSourceCols();\n    }\n\n    this.columnIndexMapper.initToLength(finalNrOfColumns);\n    this.rowIndexMapper.initToLength(this.countSourceRows());\n  };\n  /**\n   * Returns the current data object (the same one that was passed by `data` configuration option or `loadData` method,\n   * unless some modifications have been applied (i.e. Sequence of rows/columns was changed, some row/column was skipped).\n   * If that's the case - use the {@link Core#getSourceData} method.).\n   *\n   * Optionally you can provide cell range by defining `row`, `column`, `row2`, `column2` to get only a fragment of table data.\n   *\n   * @memberof Core#\n   * @function getData\n   * @param {number} [row] From visual row index.\n   * @param {number} [column] From visual column index.\n   * @param {number} [row2] To visual row index.\n   * @param {number} [column2] To visual column index.\n   * @returns {Array[]} Array with the data.\n   * @example\n   * ```js\n   * // Get all data (in order how it is rendered in the table).\n   * hot.getData();\n   * // Get data fragment (from top-left 0, 0 to bottom-right 3, 3).\n   * hot.getData(3, 3);\n   * // Get data fragment (from top-left 2, 1 to bottom-right 3, 3).\n   * hot.getData(2, 1, 3, 3);\n   * ```\n   */\n\n\n  this.getData = function (row, column, row2, column2) {\n    if (isUndefined(row)) {\n      return datamap.getAll();\n    }\n\n    return datamap.getRange(new CellCoords(row, column), new CellCoords(row2, column2), datamap.DESTINATION_RENDERER);\n  };\n  /**\n   * Returns a string value of the selected range. Each column is separated by tab, each row is separated by a new\n   * line character (see {@link DataMap#getCopyableText}).\n   *\n   * @memberof Core#\n   * @function getCopyableText\n   * @param {number} startRow From visual row index.\n   * @param {number} startCol From visual column index.\n   * @param {number} endRow To visual row index.\n   * @param {number} endCol To visual column index.\n   * @returns {string}\n   */\n\n\n  this.getCopyableText = function (startRow, startCol, endRow, endCol) {\n    return datamap.getCopyableText(new CellCoords(startRow, startCol), new CellCoords(endRow, endCol));\n  };\n  /**\n   * Returns the data's copyable value at specified `row` and `column` index (see {@link DataMap#getCopyable}).\n   *\n   * @memberof Core#\n   * @function getCopyableData\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {string}\n   */\n\n\n  this.getCopyableData = function (row, column) {\n    return datamap.getCopyable(row, datamap.colToProp(column));\n  };\n  /**\n   * Returns schema provided by constructor settings. If it doesn't exist then it returns the schema based on the data\n   * structure in the first row.\n   *\n   * @memberof Core#\n   * @function getSchema\n   * @returns {object} Schema object.\n   */\n\n\n  this.getSchema = function () {\n    return datamap.getSchema();\n  };\n  /**\n   * Use it if you need to change configuration after initialization. The `settings` argument is an object containing the new\n   * settings, declared the same way as in the initial settings object.\n   *\n   * __Note__, that although the `updateSettings` method doesn't overwrite the previously declared settings, it might reset\n   * the settings made post-initialization. (for example - ignore changes made using the columnResize feature).\n   *\n   * Since 8.0.0 passing `columns` or `data` inside `settings` objects will result in resetting states corresponding to rows and columns\n   * (for example, row/column sequence, column width, row height, frozen columns etc.).\n   *\n   * @memberof Core#\n   * @function updateSettings\n   * @param {object} settings New settings object (see {@link Options}).\n   * @param {boolean} [init=false] Internally used for in initialization mode.\n   * @example\n   * ```js\n   * hot.updateSettings({\n   *    contextMenu: true,\n   *    colHeaders: true,\n   *    fixedRowsTop: 2\n   * });\n   * ```\n   * @fires Hooks#afterCellMetaReset\n   * @fires Hooks#afterUpdateSettings\n   */\n\n\n  this.updateSettings = function (settings) {\n    var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var columnsAsFunc = false;\n    var i;\n    var j;\n\n    if (isDefined(settings.rows)) {\n      throw new Error('The \"rows\" setting is no longer supported. Do you mean startRows, minRows or maxRows?');\n    }\n\n    if (isDefined(settings.cols)) {\n      throw new Error('The \"cols\" setting is no longer supported. Do you mean startCols, minCols or maxCols?');\n    }\n\n    if (isDefined(settings.ganttChart)) {\n      throw new Error('Since 8.0.0 the \"ganttChart\" setting is no longer supported.');\n    } // eslint-disable-next-line no-restricted-syntax\n\n\n    for (i in settings) {\n      if (i === 'data') {\n        /* eslint-disable-next-line no-continue */\n        continue; // loadData will be triggered later\n      } else if (i === 'language') {\n        setLanguage(settings.language);\n        /* eslint-disable-next-line no-continue */\n\n        continue;\n      } else if (i === 'className') {\n        setClassName('className', settings.className);\n      } else if (i === 'tableClassName' && instance.table) {\n        setClassName('tableClassName', settings.tableClassName);\n        instance.view.wt.wtOverlays.syncOverlayTableClassNames();\n      } else if (Hooks.getSingleton().isRegistered(i) || Hooks.getSingleton().isDeprecated(i)) {\n        if (isFunction(settings[i]) || Array.isArray(settings[i])) {\n          settings[i].initialHook = true;\n          instance.addHook(i, settings[i]);\n        }\n      } else if (!init && hasOwnProperty(settings, i)) {\n        // Update settings\n        globalMeta[i] = settings[i];\n      }\n    } // Load data or create data map\n\n\n    if (settings.data === void 0 && tableMeta.data === void 0) {\n      instance.loadData(null, 'updateSettings'); // data source created just now\n    } else if (settings.data !== void 0) {\n      instance.loadData(settings.data, 'updateSettings'); // data source given as option\n    } else if (settings.columns !== void 0) {\n      datamap.createMap(); // The `column` property has changed - dataset may be expanded or narrowed down. The `loadData` do the same.\n\n      instance.initIndexMappers();\n    }\n\n    var clen = instance.countCols();\n    var columnSetting = tableMeta.columns; // Init columns constructors configuration\n\n    if (columnSetting && isFunction(columnSetting)) {\n      columnsAsFunc = true;\n    } // Clear cell meta cache\n\n\n    if (settings.cell !== void 0 || settings.cells !== void 0 || settings.columns !== void 0) {\n      metaManager.clearCache();\n    }\n\n    if (clen > 0) {\n      for (i = 0, j = 0; i < clen; i++) {\n        // Use settings provided by user\n        if (columnSetting) {\n          var column = columnsAsFunc ? columnSetting(i) : columnSetting[j];\n\n          if (column) {\n            metaManager.updateColumnMeta(j, column);\n          }\n        }\n\n        j += 1;\n      }\n    }\n\n    if (isDefined(settings.cell)) {\n      objectEach(settings.cell, function (cell) {\n        instance.setCellMetaObject(cell.row, cell.col, cell);\n      });\n    }\n\n    instance.runHooks('afterCellMetaReset');\n    var currentHeight = instance.rootElement.style.height;\n\n    if (currentHeight !== '') {\n      currentHeight = parseInt(instance.rootElement.style.height, 10);\n    }\n\n    var height = settings.height;\n\n    if (isFunction(height)) {\n      height = height();\n    }\n\n    if (init) {\n      var initialStyle = instance.rootElement.getAttribute('style');\n\n      if (initialStyle) {\n        instance.rootElement.setAttribute('data-initialstyle', instance.rootElement.getAttribute('style'));\n      }\n    }\n\n    if (height === null) {\n      var _initialStyle = instance.rootElement.getAttribute('data-initialstyle');\n\n      if (_initialStyle && (_initialStyle.indexOf('height') > -1 || _initialStyle.indexOf('overflow') > -1)) {\n        instance.rootElement.setAttribute('style', _initialStyle);\n      } else {\n        instance.rootElement.style.height = '';\n        instance.rootElement.style.overflow = '';\n      }\n    } else if (height !== void 0) {\n      instance.rootElement.style.height = isNaN(height) ? \"\".concat(height) : \"\".concat(height, \"px\");\n      instance.rootElement.style.overflow = 'hidden';\n    }\n\n    if (typeof settings.width !== 'undefined') {\n      var width = settings.width;\n\n      if (isFunction(width)) {\n        width = width();\n      }\n\n      instance.rootElement.style.width = isNaN(width) ? \"\".concat(width) : \"\".concat(width, \"px\");\n    }\n\n    if (!init) {\n      if (instance.view) {\n        instance.view.wt.wtViewport.resetHasOversizedColumnHeadersMarked();\n        instance.view.wt.exportSettingsAsClassNames();\n      }\n\n      instance.runHooks('afterUpdateSettings', settings);\n    }\n\n    grid.adjustRowsAndCols();\n\n    if (instance.view && !firstRun) {\n      instance.forceFullRender = true; // used when data was changed\n\n      editorManager.lockEditor();\n\n      instance._refreshBorders(null);\n\n      editorManager.unlockEditor();\n    }\n\n    if (!init && instance.view && (currentHeight === '' || height === '' || height === void 0) && currentHeight !== height) {\n      instance.view.wt.wtOverlays.updateMainScrollableElements();\n    }\n  };\n  /**\n   * Get value from the selected cell.\n   *\n   * @memberof Core#\n   * @function getValue\n   * @returns {*} Value of selected cell.\n   */\n\n\n  this.getValue = function () {\n    var sel = instance.getSelectedLast();\n\n    if (tableMeta.getValue) {\n      if (isFunction(tableMeta.getValue)) {\n        return tableMeta.getValue.call(instance);\n      } else if (sel) {\n        return instance.getData()[sel[0][0]][tableMeta.getValue];\n      }\n    } else if (sel) {\n      return instance.getDataAtCell(sel[0], sel[1]);\n    }\n  };\n  /**\n   * Returns the object settings.\n   *\n   * @memberof Core#\n   * @function getSettings\n   * @returns {object} Object containing the current table settings.\n   */\n\n\n  this.getSettings = function () {\n    return tableMeta;\n  };\n  /**\n   * Clears the data from the table (the table settings remain intact).\n   *\n   * @memberof Core#\n   * @function clear\n   */\n\n\n  this.clear = function () {\n    this.selectAll();\n    this.emptySelectedCells();\n  };\n  /**\n   * Allows altering the table structure by either inserting/removing rows or columns.\n   * This method works with an array data structure only.\n   *\n   * @memberof Core#\n   * @function alter\n   * @param {string} action Possible alter operations:\n   *  * `'insert_row'`\n   *  * `'insert_col'`\n   *  * `'remove_row'`\n   *  * `'remove_col'`.\n   * @param {number|number[]} index Visual index of the row/column before which the new row/column will be\n   *                                inserted/removed or an array of arrays in format `[[index, amount],...]`.\n   * @param {number} [amount=1] Amount of rows/columns to be inserted or removed.\n   * @param {string} [source] Source indicator.\n   * @param {boolean} [keepEmptyRows] Flag for preventing deletion of empty rows.\n   * @example\n   * ```js\n   * // Insert new row above the row at given visual index.\n   * hot.alter('insert_row', 10);\n   * // Insert 3 new columns before 10th column.\n   * hot.alter('insert_col', 10, 3);\n   * // Remove 2 rows starting from 10th row.\n   * hot.alter('remove_row', 10, 2);\n   * // Remove 5 non-contiquous rows (it removes 3 rows from visual index 1 and 2 rows from visual index 5).\n   * hot.alter('remove_row', [[1, 3], [5, 2]]);\n   * ```\n   */\n\n\n  this.alter = function (action, index, amount, source, keepEmptyRows) {\n    grid.alter(action, index, amount, source, keepEmptyRows);\n  };\n  /**\n   * Returns a TD element for the given `row` and `column` arguments, if it is rendered on screen.\n   * Returns `null` if the TD is not rendered on screen (probably because that part of the table is not visible).\n   *\n   * @memberof Core#\n   * @function getCell\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {boolean} [topmost=false] If set to `true`, it returns the TD element from the topmost overlay. For example,\n   * if the wanted cell is in the range of fixed rows, it will return a TD element from the `top` overlay.\n   * @returns {HTMLTableCellElement|null} The cell's TD element.\n   */\n\n\n  this.getCell = function (row, column) {\n    var topmost = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var renderableColumnIndex = column; // Handling also column headers.\n\n    var renderableRowIndex = row; // Handling also row headers.\n\n    if (column >= 0) {\n      if (this.columnIndexMapper.isHidden(this.toPhysicalColumn(column))) {\n        return null;\n      }\n\n      renderableColumnIndex = this.columnIndexMapper.getRenderableFromVisualIndex(column);\n    }\n\n    if (row >= 0) {\n      if (this.rowIndexMapper.isHidden(this.toPhysicalRow(row))) {\n        return null;\n      }\n\n      renderableRowIndex = this.rowIndexMapper.getRenderableFromVisualIndex(row);\n    }\n\n    if (renderableRowIndex === null || renderableColumnIndex === null) {\n      return null;\n    }\n\n    return instance.view.getCellAtCoords(new CellCoords(renderableRowIndex, renderableColumnIndex), topmost);\n  };\n  /**\n   * Returns the coordinates of the cell, provided as a HTML table cell element.\n   *\n   * @memberof Core#\n   * @function getCoords\n   * @param {HTMLTableCellElement} element The HTML Element representing the cell.\n   * @returns {CellCoords|null} Visual coordinates object.\n   * @example\n   * ```js\n   * hot.getCoords(hot.getCell(1, 1));\n   * // it returns CellCoords object instance with props row: 1 and col: 1.\n   * ```\n   */\n\n\n  this.getCoords = function (element) {\n    var renderableCoords = this.view.wt.wtTable.getCoords(element);\n\n    if (renderableCoords === null) {\n      return null;\n    }\n\n    var renderableRow = renderableCoords.row,\n        renderableColumn = renderableCoords.col;\n    var visualRow = renderableRow;\n    var visualColumn = renderableColumn;\n\n    if (renderableRow >= 0) {\n      visualRow = this.rowIndexMapper.getVisualFromRenderableIndex(renderableRow);\n    }\n\n    if (renderableColumn >= 0) {\n      visualColumn = this.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn);\n    }\n\n    return new CellCoords(visualRow, visualColumn);\n  };\n  /**\n   * Returns the property name that corresponds with the given column index (see {@link DataMap#colToProp}).\n   * If the data source is an array of arrays, it returns the columns index.\n   *\n   * @memberof Core#\n   * @function colToProp\n   * @param {number} column Visual column index.\n   * @returns {string|number} Column property or physical column index.\n   */\n\n\n  this.colToProp = function (column) {\n    return datamap.colToProp(column);\n  };\n  /**\n   * Returns column index that corresponds with the given property (see {@link DataMap#propToCol}).\n   *\n   * @memberof Core#\n   * @function propToCol\n   * @param {string|number} prop Property name or physical column index.\n   * @returns {number} Visual column index.\n   */\n\n\n  this.propToCol = function (prop) {\n    return datamap.propToCol(prop);\n  };\n  /**\n   * Translate physical row index into visual.\n   *\n   * This method is useful when you want to retrieve visual row index which can be reordered, moved or trimmed\n   * based on a physical index.\n   *\n   * @memberof Core#\n   * @function toVisualRow\n   * @param {number} row Physical row index.\n   * @returns {number} Returns visual row index.\n   */\n\n\n  this.toVisualRow = function (row) {\n    return _this.rowIndexMapper.getVisualFromPhysicalIndex(row);\n  };\n  /**\n   * Translate physical column index into visual.\n   *\n   * This method is useful when you want to retrieve visual column index which can be reordered, moved or trimmed\n   * based on a physical index.\n   *\n   * @memberof Core#\n   * @function toVisualColumn\n   * @param {number} column Physical column index.\n   * @returns {number} Returns visual column index.\n   */\n\n\n  this.toVisualColumn = function (column) {\n    return _this.columnIndexMapper.getVisualFromPhysicalIndex(column);\n  };\n  /**\n   * Translate visual row index into physical.\n   *\n   * This method is useful when you want to retrieve physical row index based on a visual index which can be\n   * reordered, moved or trimmed.\n   *\n   * @memberof Core#\n   * @function toPhysicalRow\n   * @param {number} row Visual row index.\n   * @returns {number} Returns physical row index.\n   */\n\n\n  this.toPhysicalRow = function (row) {\n    return _this.rowIndexMapper.getPhysicalFromVisualIndex(row);\n  };\n  /**\n   * Translate visual column index into physical.\n   *\n   * This method is useful when you want to retrieve physical column index based on a visual index which can be\n   * reordered, moved or trimmed.\n   *\n   * @memberof Core#\n   * @function toPhysicalColumn\n   * @param {number} column Visual column index.\n   * @returns {number} Returns physical column index.\n   */\n\n\n  this.toPhysicalColumn = function (column) {\n    return _this.columnIndexMapper.getPhysicalFromVisualIndex(column);\n  };\n  /**\n   * @description\n   * Returns the cell value at `row`, `column`.\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtCell\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {*} Data at cell.\n   */\n\n\n  this.getDataAtCell = function (row, column) {\n    return datamap.get(row, datamap.colToProp(column));\n  };\n  /**\n   * Returns value at visual `row` and `prop` indexes (see {@link DataMap#get}).\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtRowProp\n   * @param {number} row Visual row index.\n   * @param {string} prop Property name.\n   * @returns {*} Cell value.\n   */\n\n\n  this.getDataAtRowProp = function (row, prop) {\n    return datamap.get(row, prop);\n  };\n  /**\n   * @description\n   * Returns array of column values from the data source.\n   *\n   * __Note__: If columns were reordered or sorted, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtCol\n   * @param {number} column Visual column index.\n   * @returns {Array} Array of cell values.\n   */\n\n\n  this.getDataAtCol = function (column) {\n    var _ref13;\n\n    return (_ref13 = []).concat.apply(_ref13, _toConsumableArray(datamap.getRange(new CellCoords(0, column), new CellCoords(tableMeta.data.length - 1, column), datamap.DESTINATION_RENDERER)));\n  };\n  /**\n   * Given the object property name (e.g. `'first.name'` or `'0'`), returns an array of column's values from the table data.\n   * You can also provide a column index as the first argument.\n   *\n   * @memberof Core#\n   * @function getDataAtProp\n   * @param {string|number} prop Property name or physical column index.\n   * @returns {Array} Array of cell values.\n   */\n  // TODO: Getting data from `datamap` should work on visual indexes.\n\n\n  this.getDataAtProp = function (prop) {\n    var _ref14;\n\n    var range = datamap.getRange(new CellCoords(0, datamap.propToCol(prop)), new CellCoords(tableMeta.data.length - 1, datamap.propToCol(prop)), datamap.DESTINATION_RENDERER);\n    return (_ref14 = []).concat.apply(_ref14, _toConsumableArray(range));\n  };\n  /**\n   * Returns a clone of the source data object.\n   * Optionally you can provide a cell range by using the `row`, `column`, `row2`, `column2` arguments, to get only a\n   * fragment of the table data.\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceData\n   * @param {number} [row] From physical row index.\n   * @param {number} [column] From physical column index (or visual index, if data type is an array of objects).\n   * @param {number} [row2] To physical row index.\n   * @param {number} [column2] To physical column index (or visual index, if data type is an array of objects).\n   * @returns {Array[]|object[]} The table data.\n   */\n\n\n  this.getSourceData = function (row, column, row2, column2) {\n    var data;\n\n    if (row === void 0) {\n      data = dataSource.getData();\n    } else {\n      data = dataSource.getByRange(new CellCoords(row, column), new CellCoords(row2, column2));\n    }\n\n    return data;\n  };\n  /**\n   * Returns the source data object as an arrays of arrays format even when source data was provided in another format.\n   * Optionally you can provide a cell range by using the `row`, `column`, `row2`, `column2` arguments, to get only a\n   * fragment of the table data.\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceDataArray\n   * @param {number} [row] From physical row index.\n   * @param {number} [column] From physical column index (or visual index, if data type is an array of objects).\n   * @param {number} [row2] To physical row index.\n   * @param {number} [column2] To physical column index (or visual index, if data type is an array of objects).\n   * @returns {Array} An array of arrays.\n   */\n\n\n  this.getSourceDataArray = function (row, column, row2, column2) {\n    var data;\n\n    if (row === void 0) {\n      data = dataSource.getData(true);\n    } else {\n      data = dataSource.getByRange(new CellCoords(row, column), new CellCoords(row2, column2), true);\n    }\n\n    return data;\n  };\n  /**\n   * Returns an array of column values from the data source.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtCol\n   * @param {number} column Visual column index.\n   * @returns {Array} Array of the column's cell values.\n   */\n  // TODO: Getting data from `sourceData` should work always on physical indexes.\n\n\n  this.getSourceDataAtCol = function (column) {\n    return dataSource.getAtColumn(column);\n  };\n  /* eslint-disable jsdoc/require-param */\n\n  /**\n   * Set the provided value in the source data set at the provided coordinates.\n   *\n   * @memberof Core#\n   * @function setSourceDataAtCell\n   * @param {number|Array} row Physical row index or array of changes in format `[[row, prop, value], ...]`.\n   * @param {number|string} column Physical column index / prop name.\n   * @param {*} value The value to be set at the provided coordinates.\n   * @param {string} [source] Source of the change as a string.\n   */\n\n  /* eslint-enable jsdoc/require-param */\n\n\n  this.setSourceDataAtCell = function (row, column, value, source) {\n    var input = setDataInputToArray(row, column, value);\n    var isThereAnySetSourceListener = this.hasHook('afterSetSourceDataAtCell');\n    var changesForHook = [];\n\n    if (isThereAnySetSourceListener) {\n      arrayEach(input, function (_ref15) {\n        var _ref16 = _slicedToArray(_ref15, 3),\n            changeRow = _ref16[0],\n            changeProp = _ref16[1],\n            changeValue = _ref16[2];\n\n        changesForHook.push([changeRow, changeProp, dataSource.getAtCell(changeRow, changeProp), // The previous value.\n        changeValue]);\n      });\n    }\n\n    arrayEach(input, function (_ref17) {\n      var _ref18 = _slicedToArray(_ref17, 3),\n          changeRow = _ref18[0],\n          changeProp = _ref18[1],\n          changeValue = _ref18[2];\n\n      dataSource.setAtCell(changeRow, changeProp, changeValue);\n    });\n\n    if (isThereAnySetSourceListener) {\n      this.runHooks('afterSetSourceDataAtCell', changesForHook, source);\n    }\n\n    this.render();\n    var activeEditor = instance.getActiveEditor();\n\n    if (activeEditor && isDefined(activeEditor.refreshValue)) {\n      activeEditor.refreshValue();\n    }\n  };\n  /**\n   * Returns a single row of the data (array or object, depending on what data format you use).\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtRow\n   * @param {number} row Physical row index.\n   * @returns {Array|object} Single row of data.\n   */\n\n\n  this.getSourceDataAtRow = function (row) {\n    return dataSource.getAtRow(row);\n  };\n  /**\n   * Returns a single value from the data source.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtCell\n   * @param {number} row Physical row index.\n   * @param {number} column Visual column index.\n   * @returns {*} Cell data.\n   */\n  // TODO: Getting data from `sourceData` should work always on physical indexes.\n\n\n  this.getSourceDataAtCell = function (row, column) {\n    return dataSource.getAtCell(row, column);\n  };\n  /**\n   * @description\n   * Returns a single row of the data.\n   *\n   * __Note__: If rows were reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtRow\n   * @param {number} row Visual row index.\n   * @returns {Array} Array of row's cell data.\n   */\n\n\n  this.getDataAtRow = function (row) {\n    var data = datamap.getRange(new CellCoords(row, 0), new CellCoords(row, this.countCols() - 1), datamap.DESTINATION_RENDERER);\n    return data[0] || [];\n  };\n  /**\n   * @description\n   * Returns a data type defined in the Handsontable settings under the `type` key ([Options#type](https://handsontable.com/docs/Options.html#type)).\n   * If there are cells with different types in the selected range, it returns `'mixed'`.\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataType\n   * @param {number} rowFrom From visual row index.\n   * @param {number} columnFrom From visual column index.\n   * @param {number} rowTo To visual row index.\n   * @param {number} columnTo To visual column index.\n   * @returns {string} Cell type (e.q: `'mixed'`, `'text'`, `'numeric'`, `'autocomplete'`).\n   */\n\n\n  this.getDataType = function (rowFrom, columnFrom, rowTo, columnTo) {\n    var _this3 = this;\n\n    var coords = rowFrom === void 0 ? [0, 0, this.countRows(), this.countCols()] : [rowFrom, columnFrom, rowTo, columnTo];\n    var rowStart = coords[0],\n        columnStart = coords[1];\n    var rowEnd = coords[2],\n        columnEnd = coords[3];\n    var previousType = null;\n    var currentType = null;\n\n    if (rowEnd === void 0) {\n      rowEnd = rowStart;\n    }\n\n    if (columnEnd === void 0) {\n      columnEnd = columnStart;\n    }\n\n    var type = 'mixed';\n    rangeEach(Math.max(Math.min(rowStart, rowEnd), 0), Math.max(rowStart, rowEnd), function (row) {\n      var isTypeEqual = true;\n      rangeEach(Math.max(Math.min(columnStart, columnEnd), 0), Math.max(columnStart, columnEnd), function (column) {\n        var cellType = _this3.getCellMeta(row, column);\n\n        currentType = cellType.type;\n\n        if (previousType) {\n          isTypeEqual = previousType === currentType;\n        } else {\n          previousType = currentType;\n        }\n\n        return isTypeEqual;\n      });\n      type = isTypeEqual ? currentType : 'mixed';\n      return isTypeEqual;\n    });\n    return type;\n  };\n  /**\n   * Remove a property defined by the `key` argument from the cell meta object for the provided `row` and `column` coordinates.\n   *\n   * @memberof Core#\n   * @function removeCellMeta\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {string} key Property name.\n   * @fires Hooks#beforeRemoveCellMeta\n   * @fires Hooks#afterRemoveCellMeta\n   */\n\n\n  this.removeCellMeta = function (row, column, key) {\n    var _ref19 = [this.toPhysicalRow(row), this.toPhysicalColumn(column)],\n        physicalRow = _ref19[0],\n        physicalColumn = _ref19[1];\n    var cachedValue = metaManager.getCellMeta(physicalRow, physicalColumn, key);\n    var hookResult = instance.runHooks('beforeRemoveCellMeta', row, column, key, cachedValue);\n\n    if (hookResult !== false) {\n      metaManager.removeCellMeta(physicalRow, physicalColumn, key);\n      instance.runHooks('afterRemoveCellMeta', row, column, key, cachedValue);\n    }\n\n    cachedValue = null;\n  };\n  /**\n   * Removes or adds one or more rows of the cell meta objects to the cell meta collections.\n   *\n   * @since 0.30.0\n   * @memberof Core#\n   * @function spliceCellsMeta\n   * @param {number} visualIndex A visual index that specifies at what position to add/remove items.\n   * @param {number} [deleteAmount=0] The number of items to be removed. If set to 0, no cell meta objects will be removed.\n   * @param {...object} [cellMetaRows] The new cell meta row objects to be added to the cell meta collection.\n   */\n\n\n  this.spliceCellsMeta = function (visualIndex) {\n    var _this4 = this;\n\n    var deleteAmount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    for (var _len3 = arguments.length, cellMetaRows = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      cellMetaRows[_key3 - 2] = arguments[_key3];\n    }\n\n    if (cellMetaRows.length > 0 && !Array.isArray(cellMetaRows[0])) {\n      throw new Error('The 3rd argument (cellMetaRows) has to be passed as an array of cell meta objects array.');\n    }\n\n    if (deleteAmount > 0) {\n      metaManager.removeRow(this.toPhysicalRow(visualIndex), deleteAmount);\n    }\n\n    if (cellMetaRows.length > 0) {\n      arrayEach(cellMetaRows.reverse(), function (cellMetaRow) {\n        metaManager.createRow(_this4.toPhysicalRow(visualIndex));\n        arrayEach(cellMetaRow, function (cellMeta, columnIndex) {\n          return _this4.setCellMetaObject(visualIndex, columnIndex, cellMeta);\n        });\n      });\n    }\n  };\n  /**\n   * Set cell meta data object defined by `prop` to the corresponding params `row` and `column`.\n   *\n   * @memberof Core#\n   * @function setCellMetaObject\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {object} prop Meta object.\n   */\n\n\n  this.setCellMetaObject = function (row, column, prop) {\n    var _this5 = this;\n\n    if (_typeof(prop) === 'object') {\n      objectEach(prop, function (value, key) {\n        _this5.setCellMeta(row, column, key, value);\n      });\n    }\n  };\n  /**\n   * Sets a property defined by the `key` property to the meta object of a cell corresponding to params `row` and `column`.\n   *\n   * @memberof Core#\n   * @function setCellMeta\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {string} key Property name.\n   * @param {string} value Property value.\n   * @fires Hooks#beforeSetCellMeta\n   * @fires Hooks#afterSetCellMeta\n   */\n\n\n  this.setCellMeta = function (row, column, key, value) {\n    var allowSetCellMeta = instance.runHooks('beforeSetCellMeta', row, column, key, value);\n\n    if (allowSetCellMeta === false) {\n      return;\n    }\n\n    var physicalRow = row;\n    var physicalColumn = column;\n\n    if (row < this.countRows()) {\n      physicalRow = this.toPhysicalRow(row);\n    }\n\n    if (column < this.countCols()) {\n      physicalColumn = this.toPhysicalColumn(column);\n    }\n\n    metaManager.setCellMeta(physicalRow, physicalColumn, key, value);\n    instance.runHooks('afterSetCellMeta', row, column, key, value);\n  };\n  /**\n   * Get all the cells meta settings at least once generated in the table (in order of cell initialization).\n   *\n   * @memberof Core#\n   * @function getCellsMeta\n   * @returns {Array} Returns an array of ColumnSettings object instances.\n   */\n\n\n  this.getCellsMeta = function () {\n    return metaManager.getCellsMeta();\n  };\n  /**\n   * Returns the cell properties object for the given `row` and `column` coordinates.\n   *\n   * @memberof Core#\n   * @function getCellMeta\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {object} The cell properties object.\n   * @fires Hooks#beforeGetCellMeta\n   * @fires Hooks#afterGetCellMeta\n   */\n\n\n  this.getCellMeta = function (row, column) {\n    var physicalRow = this.toPhysicalRow(row);\n    var physicalColumn = this.toPhysicalColumn(column);\n\n    if (physicalRow === null) {\n      physicalRow = row;\n    }\n\n    if (physicalColumn === null) {\n      physicalColumn = column;\n    }\n\n    var prop = datamap.colToProp(column);\n    var cellProperties = metaManager.getCellMeta(physicalRow, physicalColumn); // TODO(perf): Add assigning this props and executing below code only once per table render cycle.\n\n    cellProperties.row = physicalRow;\n    cellProperties.col = physicalColumn;\n    cellProperties.visualRow = row;\n    cellProperties.visualCol = column;\n    cellProperties.prop = prop;\n    cellProperties.instance = instance;\n    instance.runHooks('beforeGetCellMeta', row, column, cellProperties); // for `type` added or changed in beforeGetCellMeta\n\n    if (instance.hasHook('beforeGetCellMeta') && hasOwnProperty(cellProperties, 'type')) {\n      metaManager.updateCellMeta(physicalRow, physicalColumn, {\n        type: cellProperties.type\n      });\n    }\n\n    if (cellProperties.cells) {\n      var settings = cellProperties.cells(physicalRow, physicalColumn, prop);\n\n      if (settings) {\n        metaManager.updateCellMeta(physicalRow, physicalColumn, settings);\n      }\n    }\n\n    instance.runHooks('afterGetCellMeta', row, column, cellProperties);\n    return cellProperties;\n  };\n  /**\n   * Returns an array of cell meta objects for specified physical row index.\n   *\n   * @memberof Core#\n   * @function getCellMetaAtRow\n   * @param {number} row Physical row index.\n   * @returns {Array}\n   */\n\n\n  this.getCellMetaAtRow = function (row) {\n    return metaManager.getCellsMetaAtRow(row);\n  };\n  /**\n   * Checks if the data format and config allows user to modify the column structure.\n   *\n   * @memberof Core#\n   * @function isColumnModificationAllowed\n   * @returns {boolean}\n   */\n\n\n  this.isColumnModificationAllowed = function () {\n    return !(instance.dataType === 'object' || tableMeta.columns);\n  };\n\n  var rendererLookup = cellMethodLookupFactory('renderer');\n  /**\n   * Returns the cell renderer function by given `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function getCellRenderer\n   * @param {number|object} row Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {number} column Visual column index.\n   * @returns {Function} The renderer function.\n   * @example\n   * ```js\n   * // Get cell renderer using `row` and `column` coordinates.\n   * hot.getCellRenderer(1, 1);\n   * // Get cell renderer using cell meta object.\n   * hot.getCellRenderer(hot.getCellMeta(1, 1));\n   * ```\n   */\n\n  this.getCellRenderer = function (row, column) {\n    return getRenderer(rendererLookup.call(this, row, column));\n  };\n  /**\n   * Returns the cell editor class by the provided `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function getCellEditor\n   * @param {number} row Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {number} column Visual column index.\n   * @returns {Function} The editor class.\n   * @example\n   * ```js\n   * // Get cell editor class using `row` and `column` coordinates.\n   * hot.getCellEditor(1, 1);\n   * // Get cell editor class using cell meta object.\n   * hot.getCellEditor(hot.getCellMeta(1, 1));\n   * ```\n   */\n\n\n  this.getCellEditor = cellMethodLookupFactory('editor');\n  var validatorLookup = cellMethodLookupFactory('validator');\n  /**\n   * Returns the cell validator by `row` and `column`.\n   *\n   * @memberof Core#\n   * @function getCellValidator\n   * @param {number|object} row Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {number} column Visual column index.\n   * @returns {Function|RegExp|undefined} The validator function.\n   * @example\n   * ```js\n   * // Get cell valiator using `row` and `column` coordinates.\n   * hot.getCellValidator(1, 1);\n   * // Get cell valiator using cell meta object.\n   * hot.getCellValidator(hot.getCellMeta(1, 1));\n   * ```\n   */\n\n  this.getCellValidator = function (row, column) {\n    var validator = validatorLookup.call(this, row, column);\n\n    if (typeof validator === 'string') {\n      validator = getValidator(validator);\n    }\n\n    return validator;\n  };\n  /**\n   * Validates all cells using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   * would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateCells\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateCells((valid) => {\n   *   if (valid) {\n   *     // ... code for validated cells\n   *   }\n   * })\n   * ```\n   */\n\n\n  this.validateCells = function (callback) {\n    this._validateCells(callback);\n  };\n  /**\n   * Validates rows using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   *  would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateRows\n   * @param {Array} [rows] Array of validation target visual row indexes.\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateRows([3, 4, 5], (valid) => {\n   *   if (valid) {\n   *     // ... code for validated rows\n   *   }\n   * })\n   * ```\n   */\n\n\n  this.validateRows = function (rows, callback) {\n    if (!Array.isArray(rows)) {\n      throw new Error('validateRows parameter `rows` must be an array');\n    }\n\n    this._validateCells(callback, rows);\n  };\n  /**\n   * Validates columns using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   *  would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateColumns\n   * @param {Array} [columns] Array of validation target visual columns indexes.\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateColumns([3, 4, 5], (valid) => {\n   *   if (valid) {\n   *     // ... code for validated columns\n   *   }\n   * })\n   * ```\n   */\n\n\n  this.validateColumns = function (columns, callback) {\n    if (!Array.isArray(columns)) {\n      throw new Error('validateColumns parameter `columns` must be an array');\n    }\n\n    this._validateCells(callback, undefined, columns);\n  };\n  /**\n   * Validates all cells using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it would equal `true`.\n   *\n   * Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _validateCells\n   * @param {Function} [callback] The callback function.\n   * @param {Array} [rows] An array of validation target visual row indexes.\n   * @param {Array} [columns] An array of validation target visual column indexes.\n   */\n\n\n  this._validateCells = function (callback, rows, columns) {\n    var waitingForValidator = new ValidatorsQueue();\n\n    if (callback) {\n      waitingForValidator.onQueueEmpty = callback;\n    }\n\n    var i = instance.countRows() - 1;\n\n    while (i >= 0) {\n      if (rows !== undefined && rows.indexOf(i) === -1) {\n        i -= 1;\n        continue;\n      }\n\n      var j = instance.countCols() - 1;\n\n      while (j >= 0) {\n        if (columns !== undefined && columns.indexOf(j) === -1) {\n          j -= 1;\n          continue;\n        }\n\n        waitingForValidator.addValidatorToQueue();\n        instance.validateCell(instance.getDataAtCell(i, j), instance.getCellMeta(i, j), function (result) {\n          if (typeof result !== 'boolean') {\n            throw new Error('Validation error: result is not boolean');\n          }\n\n          if (result === false) {\n            waitingForValidator.valid = false;\n          }\n\n          waitingForValidator.removeValidatorFormQueue();\n        }, 'validateCells');\n        j -= 1;\n      }\n\n      i -= 1;\n    }\n\n    waitingForValidator.checkIfQueueIsEmpty();\n  };\n  /**\n   * Returns an array of row headers' values (if they are enabled). If param `row` was given, it returns the header of the given row as a string.\n   *\n   * @memberof Core#\n   * @function getRowHeader\n   * @param {number} [row] Visual row index.\n   * @fires Hooks#modifyRowHeader\n   * @returns {Array|string|number} Array of header values / single header value.\n   */\n\n\n  this.getRowHeader = function (row) {\n    var rowHeader = tableMeta.rowHeaders;\n    var physicalRow = row;\n\n    if (physicalRow !== void 0) {\n      physicalRow = instance.runHooks('modifyRowHeader', physicalRow);\n    }\n\n    if (physicalRow === void 0) {\n      rowHeader = [];\n      rangeEach(instance.countRows() - 1, function (i) {\n        rowHeader.push(instance.getRowHeader(i));\n      });\n    } else if (Array.isArray(rowHeader) && rowHeader[physicalRow] !== void 0) {\n      rowHeader = rowHeader[physicalRow];\n    } else if (isFunction(rowHeader)) {\n      rowHeader = rowHeader(physicalRow);\n    } else if (rowHeader && typeof rowHeader !== 'string' && typeof rowHeader !== 'number') {\n      rowHeader = physicalRow + 1;\n    }\n\n    return rowHeader;\n  };\n  /**\n   * Returns information about if this table is configured to display row headers.\n   *\n   * @memberof Core#\n   * @function hasRowHeaders\n   * @returns {boolean} `true` if the instance has the row headers enabled, `false` otherwise.\n   */\n\n\n  this.hasRowHeaders = function () {\n    return !!tableMeta.rowHeaders;\n  };\n  /**\n   * Returns information about if this table is configured to display column headers.\n   *\n   * @memberof Core#\n   * @function hasColHeaders\n   * @returns {boolean} `true` if the instance has the column headers enabled, `false` otherwise.\n   */\n\n\n  this.hasColHeaders = function () {\n    if (tableMeta.colHeaders !== void 0 && tableMeta.colHeaders !== null) {\n      // Polymer has empty value = null\n      return !!tableMeta.colHeaders;\n    }\n\n    for (var i = 0, ilen = instance.countCols(); i < ilen; i++) {\n      if (instance.getColHeader(i)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Returns an array of column headers (in string format, if they are enabled). If param `column` is given, it\n   * returns the header at the given column.\n   *\n   * @memberof Core#\n   * @function getColHeader\n   * @param {number} [column] Visual column index.\n   * @fires Hooks#modifyColHeader\n   * @returns {Array|string|number} The column header(s).\n   */\n\n\n  this.getColHeader = function (column) {\n    var columnIndex = instance.runHooks('modifyColHeader', column);\n    var result = tableMeta.colHeaders;\n\n    if (columnIndex === void 0) {\n      var out = [];\n      var ilen = instance.countCols();\n\n      for (var i = 0; i < ilen; i++) {\n        out.push(instance.getColHeader(i));\n      }\n\n      result = out;\n    } else {\n      var translateVisualIndexToColumns = function translateVisualIndexToColumns(visualColumnIndex) {\n        var arr = [];\n        var columnsLen = instance.countCols();\n        var index = 0;\n\n        for (; index < columnsLen; index++) {\n          if (isFunction(tableMeta.columns) && tableMeta.columns(index)) {\n            arr.push(index);\n          }\n        }\n\n        return arr[visualColumnIndex];\n      };\n\n      var physicalColumn = instance.toPhysicalColumn(columnIndex);\n      var prop = translateVisualIndexToColumns(physicalColumn);\n\n      if (tableMeta.colHeaders === false) {\n        result = null;\n      } else if (tableMeta.columns && isFunction(tableMeta.columns) && tableMeta.columns(prop) && tableMeta.columns(prop).title) {\n        result = tableMeta.columns(prop).title;\n      } else if (tableMeta.columns && tableMeta.columns[physicalColumn] && tableMeta.columns[physicalColumn].title) {\n        result = tableMeta.columns[physicalColumn].title;\n      } else if (Array.isArray(tableMeta.colHeaders) && tableMeta.colHeaders[physicalColumn] !== void 0) {\n        result = tableMeta.colHeaders[physicalColumn];\n      } else if (isFunction(tableMeta.colHeaders)) {\n        result = tableMeta.colHeaders(physicalColumn);\n      } else if (tableMeta.colHeaders && typeof tableMeta.colHeaders !== 'string' && typeof tableMeta.colHeaders !== 'number') {\n        result = spreadsheetColumnLabel(columnIndex); // see #1458\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Return column width from settings (no guessing). Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _getColWidthFromSettings\n   * @param {number} col Visual col index.\n   * @returns {number}\n   */\n\n\n  this._getColWidthFromSettings = function (col) {\n    var width; // We currently don't support cell meta objects for headers (negative values)\n\n    if (col >= 0) {\n      var cellProperties = instance.getCellMeta(0, col);\n      width = cellProperties.width;\n    }\n\n    if (width === void 0 || width === tableMeta.width) {\n      width = tableMeta.colWidths;\n    }\n\n    if (width !== void 0 && width !== null) {\n      switch (_typeof(width)) {\n        case 'object':\n          // array\n          width = width[col];\n          break;\n\n        case 'function':\n          width = width(col);\n          break;\n\n        default:\n          break;\n      }\n\n      if (typeof width === 'string') {\n        width = parseInt(width, 10);\n      }\n    }\n\n    return width;\n  };\n  /**\n   * Returns the width of the requested column.\n   *\n   * @memberof Core#\n   * @function getColWidth\n   * @param {number} column Visual column index.\n   * @returns {number} Column width.\n   * @fires Hooks#modifyColWidth\n   */\n\n\n  this.getColWidth = function (column) {\n    var width = instance._getColWidthFromSettings(column);\n\n    width = instance.runHooks('modifyColWidth', width, column);\n\n    if (width === void 0) {\n      width = ViewportColumnsCalculator.DEFAULT_WIDTH;\n    }\n\n    return width;\n  };\n  /**\n   * Return row height from settings (no guessing). Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _getRowHeightFromSettings\n   * @param {number} row Visual row index.\n   * @returns {number}\n   */\n\n\n  this._getRowHeightFromSettings = function (row) {\n    // let cellProperties = instance.getCellMeta(row, 0);\n    // let height = cellProperties.height;\n    //\n    // if (height === void 0 || height === tableMeta.height) {\n    //  height = cellProperties.rowHeights;\n    // }\n    var height = tableMeta.rowHeights;\n\n    if (height !== void 0 && height !== null) {\n      switch (_typeof(height)) {\n        case 'object':\n          // array\n          height = height[row];\n          break;\n\n        case 'function':\n          height = height(row);\n          break;\n\n        default:\n          break;\n      }\n\n      if (typeof height === 'string') {\n        height = parseInt(height, 10);\n      }\n    }\n\n    return height;\n  };\n  /**\n   * Returns the row height.\n   *\n   * @memberof Core#\n   * @function getRowHeight\n   * @param {number} row Visual row index.\n   * @returns {number} The given row's height.\n   * @fires Hooks#modifyRowHeight\n   */\n\n\n  this.getRowHeight = function (row) {\n    var height = instance._getRowHeightFromSettings(row);\n\n    height = instance.runHooks('modifyRowHeight', height, row);\n    return height;\n  };\n  /**\n   * Returns the total number of rows in the data source.\n   *\n   * @memberof Core#\n   * @function countSourceRows\n   * @returns {number} Total number of rows.\n   */\n\n\n  this.countSourceRows = function () {\n    return dataSource.countRows();\n  };\n  /**\n   * Returns the total number of columns in the data source.\n   *\n   * @memberof Core#\n   * @function countSourceCols\n   * @returns {number} Total number of columns.\n   */\n\n\n  this.countSourceCols = function () {\n    return dataSource.countFirstRowKeys();\n  };\n  /**\n   * Returns the total number of visual rows in the table.\n   *\n   * @memberof Core#\n   * @function countRows\n   * @returns {number} Total number of rows.\n   */\n\n\n  this.countRows = function () {\n    return datamap.getLength();\n  };\n  /**\n   * Returns the total number of visible columns in the table.\n   *\n   * @memberof Core#\n   * @function countCols\n   * @returns {number} Total number of columns.\n   */\n\n\n  this.countCols = function () {\n    var maxCols = tableMeta.maxCols;\n    var dataLen = this.columnIndexMapper.getNotTrimmedIndexesLength();\n    return Math.min(maxCols, dataLen);\n  };\n  /**\n   * Returns the number of rendered rows (including rows partially or fully rendered outside viewport).\n   *\n   * @memberof Core#\n   * @function countRenderedRows\n   * @returns {number} Returns -1 if table is not visible.\n   */\n\n\n  this.countRenderedRows = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedRowsCount() : -1;\n  };\n  /**\n   * Returns the number of visible rows (rendered rows that fully fit inside viewport).\n   *\n   * @memberof Core#\n   * @function countVisibleRows\n   * @returns {number} Number of visible rows or -1.\n   */\n\n\n  this.countVisibleRows = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleRowsCount() : -1;\n  };\n  /**\n   * Returns the number of rendered columns (including columns partially or fully rendered outside viewport).\n   *\n   * @memberof Core#\n   * @function countRenderedCols\n   * @returns {number} Returns -1 if table is not visible.\n   */\n\n\n  this.countRenderedCols = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedColumnsCount() : -1;\n  };\n  /**\n   * Returns the number of visible columns. Returns -1 if table is not visible.\n   *\n   * @memberof Core#\n   * @function countVisibleCols\n   * @returns {number} Number of visible columns or -1.\n   */\n\n\n  this.countVisibleCols = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleColumnsCount() : -1;\n  };\n  /**\n   * Returns the number of empty rows. If the optional ending parameter is `true`, returns the\n   * number of empty rows at the bottom of the table.\n   *\n   * @memberof Core#\n   * @function countEmptyRows\n   * @param {boolean} [ending=false] If `true`, will only count empty rows at the end of the data source.\n   * @returns {number} Count empty rows.\n   */\n\n\n  this.countEmptyRows = function () {\n    var ending = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var emptyRows = 0;\n    rangeEachReverse(instance.countRows() - 1, function (visualIndex) {\n      if (instance.isEmptyRow(visualIndex)) {\n        emptyRows += 1;\n      } else if (ending === true) {\n        return false;\n      }\n    });\n    return emptyRows;\n  };\n  /**\n   * Returns the number of empty columns. If the optional ending parameter is `true`, returns the number of empty\n   * columns at right hand edge of the table.\n   *\n   * @memberof Core#\n   * @function countEmptyCols\n   * @param {boolean} [ending=false] If `true`, will only count empty columns at the end of the data source row.\n   * @returns {number} Count empty cols.\n   */\n\n\n  this.countEmptyCols = function () {\n    var ending = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (instance.countRows() < 1) {\n      return 0;\n    }\n\n    var emptyColumns = 0;\n    rangeEachReverse(instance.countCols() - 1, function (visualIndex) {\n      if (instance.isEmptyCol(visualIndex)) {\n        emptyColumns += 1;\n      } else if (ending === true) {\n        return false;\n      }\n    });\n    return emptyColumns;\n  };\n  /**\n   * Check if all cells in the row declared by the `row` argument are empty.\n   *\n   * @memberof Core#\n   * @function isEmptyRow\n   * @param {number} row Visual row index.\n   * @returns {boolean} `true` if the row at the given `row` is empty, `false` otherwise.\n   */\n\n\n  this.isEmptyRow = function (row) {\n    return tableMeta.isEmptyRow.call(instance, row);\n  };\n  /**\n   * Check if all cells in the the column declared by the `column` argument are empty.\n   *\n   * @memberof Core#\n   * @function isEmptyCol\n   * @param {number} column Column index.\n   * @returns {boolean} `true` if the column at the given `col` is empty, `false` otherwise.\n   */\n\n\n  this.isEmptyCol = function (column) {\n    return tableMeta.isEmptyCol.call(instance, column);\n  };\n  /**\n   * Select cell specified by `row` and `column` values or a range of cells finishing at `endRow`, `endCol`. If the table\n   * was configured to support data column properties that properties can be used to making a selection.\n   *\n   * By default, viewport will be scrolled to the selection. After the `selectCell` method had finished, the instance\n   * will be listening to keyboard input on the document.\n   *\n   * @example\n   * ```js\n   * // select a single cell\n   * hot.selectCell(2, 4);\n   * // select a single cell using column property\n   * hot.selectCell(2, 'address');\n   * // select a range of cells\n   * hot.selectCell(2, 4, 3, 5);\n   * // select a range of cells using column properties\n   * hot.selectCell(2, 'address', 3, 'phone_number');\n   * // select a range of cells without scrolling to them\n   * hot.selectCell(2, 'address', 3, 'phone_number', false);\n   * ```\n   *\n   * @memberof Core#\n   * @function selectCell\n   * @param {number} row Visual row index.\n   * @param {number|string} column Visual column index or column property.\n   * @param {number} [endRow] Visual end row index (if selecting a range).\n   * @param {number|string} [endColumn] Visual end column index or column property (if selecting a range).\n   * @param {boolean} [scrollToCell=true] If `true`, the viewport will be scrolled to the selection.\n   * @param {boolean} [changeListener=true] If `false`, Handsontable will not change keyboard events listener to himself.\n   * @returns {boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n\n  this.selectCell = function (row, column, endRow, endColumn) {\n    var scrollToCell = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var changeListener = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n    if (isUndefined(row) || isUndefined(column)) {\n      return false;\n    }\n\n    return this.selectCells([[row, column, endRow, endColumn]], scrollToCell, changeListener);\n  };\n  /**\n   * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n   * finishing at `endRow`, `endColumn`. The method supports two input formats which are the same as that\n   * produces by `getSelected` and `getSelectedRange` methods.\n   *\n   * By default, viewport will be scrolled to selection. After the `selectCells` method had finished, the instance\n   * will be listening to keyboard input on the document.\n   *\n   * @example\n   * ```js\n   * // Using an array of arrays.\n   * hot.selectCells([[1, 1, 2, 2], [3, 3], [6, 2, 0, 2]]);\n   * // Using an array of arrays with defined columns as props.\n   * hot.selectCells([[1, 'id', 2, 'first_name'], [3, 'full_name'], [6, 'last_name', 0, 'first_name']]);\n   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).\n   * const selected = hot.getSelectedRange();\n   *\n   * selected[0].from.row = 0;\n   * selected[0].from.col = 0;\n   *\n   * hot.selectCells(selected);\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectCells\n   * @param {Array[]|CellRange[]} coords Visual coords passed as an array of array (`[[rowStart, columnStart, rowEnd, columnEnd], ...]`)\n   *                                     the same format as `getSelected` method returns or as an CellRange objects\n   *                                     which is the same format what `getSelectedRange` method returns.\n   * @param {boolean} [scrollToCell=true] If `true`, the viewport will be scrolled to the selection.\n   * @param {boolean} [changeListener=true] If `false`, Handsontable will not change keyboard events listener to himself.\n   * @returns {boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n\n  this.selectCells = function () {\n    var coords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [[]];\n    var scrollToCell = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var changeListener = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    if (scrollToCell === false) {\n      preventScrollingToCell = true;\n    }\n\n    var wasSelected = selection.selectCells(coords);\n\n    if (wasSelected && changeListener) {\n      instance.listen();\n    }\n\n    preventScrollingToCell = false;\n    return wasSelected;\n  };\n  /**\n   * Select column specified by `startColumn` visual index, column property or a range of columns finishing at `endColumn`.\n   *\n   * @example\n   * ```js\n   * // Select column using visual index.\n   * hot.selectColumns(1);\n   * // Select column using column property.\n   * hot.selectColumns('id');\n   * // Select range of columns using visual indexes.\n   * hot.selectColumns(1, 4);\n   * // Select range of columns using column properties.\n   * hot.selectColumns('id', 'last_name');\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectColumns\n   * @param {number} startColumn The visual column index from which the selection starts.\n   * @param {number} [endColumn=startColumn] The visual column index to which the selection finishes. If `endColumn`\n   *                                         is not defined the column defined by `startColumn` will be selected.\n   * @returns {boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n\n  this.selectColumns = function (startColumn) {\n    var endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n    return selection.selectColumns(startColumn, endColumn);\n  };\n  /**\n   * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n   *\n   * @example\n   * ```js\n   * // Select row using visual index.\n   * hot.selectRows(1);\n   * // Select range of rows using visual indexes.\n   * hot.selectRows(1, 4);\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectRows\n   * @param {number} startRow The visual row index from which the selection starts.\n   * @param {number} [endRow=startRow] The visual row index to which the selection finishes. If `endRow`\n   *                                   is not defined the row defined by `startRow` will be selected.\n   * @returns {boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n\n  this.selectRows = function (startRow) {\n    var endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n    return selection.selectRows(startRow, endRow);\n  };\n  /**\n   * Deselects the current cell selection on the table.\n   *\n   * @memberof Core#\n   * @function deselectCell\n   */\n\n\n  this.deselectCell = function () {\n    selection.deselect();\n  };\n  /**\n   * Select the whole table. The previous selection will be overwritten.\n   *\n   * @since 0.38.2\n   * @memberof Core#\n   * @function selectAll\n   * @param {boolean} [includeHeaders=true] `true` If the selection should include the row, column and corner headers,\n   * `false` otherwise.\n   */\n\n\n  this.selectAll = function () {\n    var includeHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var includeRowHeaders = includeHeaders && this.hasRowHeaders();\n    var includeColumnHeaders = includeHeaders && this.hasColHeaders();\n    preventScrollingToCell = true;\n    selection.selectAll(includeRowHeaders, includeColumnHeaders);\n    preventScrollingToCell = false;\n  };\n\n  var getIndexToScroll = function getIndexToScroll(indexMapper, visualIndex) {\n    // Looking for a visual index on the right and then (when not found) on the left.\n    return indexMapper.getFirstNotHiddenIndex(visualIndex, 1, true);\n  };\n  /**\n   * Scroll viewport to coordinates specified by the `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function scrollViewportTo\n   * @param {number} [row] Row index. If the last argument isn't defined we treat the index as a visual row index. Otherwise,\n   * we are using the index for numbering only this rows which may be rendered (we don't consider hidden rows).\n   * @param {number} [column] Column index. If the last argument isn't defined we treat the index as a visual column index.\n   * Otherwise, we are using the index for numbering only this columns which may be rendered (we don't consider hidden columns).\n   * @param {boolean} [snapToBottom=false] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @param {boolean} [snapToRight=false] If `true`, viewport is scrolled to show the cell on the right side of the table.\n   * @param {boolean} [considerHiddenIndexes=true] If `true`, we handle visual indexes, otherwise we handle only indexes which\n   * may be rendered when they are in the viewport (we don't consider hidden indexes as they aren't rendered).\n   * @returns {boolean} `true` if scroll was successful, `false` otherwise.\n   */\n\n\n  this.scrollViewportTo = function (row, column) {\n    var snapToBottom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var snapToRight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var considerHiddenIndexes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var snapToTop = !snapToBottom;\n    var snapToLeft = !snapToRight;\n    var renderableRow = row;\n    var renderableColumn = column;\n\n    if (considerHiddenIndexes) {\n      var _isRowInteger = Number.isInteger(row);\n\n      var _isColumnInteger = Number.isInteger(column);\n\n      var visualRowToScroll = _isRowInteger ? getIndexToScroll(this.rowIndexMapper, row) : void 0;\n      var visualColumnToScroll = _isColumnInteger ? getIndexToScroll(this.columnIndexMapper, column) : void 0;\n\n      if (visualRowToScroll === null || visualColumnToScroll === null) {\n        return false;\n      }\n\n      renderableRow = _isRowInteger ? instance.rowIndexMapper.getRenderableFromVisualIndex(visualRowToScroll) : void 0;\n      renderableColumn = _isColumnInteger ? instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumnToScroll) : void 0;\n    }\n\n    var isRowInteger = Number.isInteger(renderableRow);\n    var isColumnInteger = Number.isInteger(renderableColumn);\n\n    if (isRowInteger && isColumnInteger) {\n      return instance.view.scrollViewport(new CellCoords(renderableRow, renderableColumn), snapToTop, snapToRight, snapToBottom, snapToLeft);\n    }\n\n    if (isRowInteger && isColumnInteger === false) {\n      return instance.view.scrollViewportVertically(renderableRow, snapToTop, snapToBottom);\n    }\n\n    if (isColumnInteger && isRowInteger === false) {\n      return instance.view.scrollViewportHorizontally(renderableColumn, snapToRight, snapToLeft);\n    }\n\n    return false;\n  };\n  /**\n   * Removes the table from the DOM and destroys the instance of the Handsontable.\n   *\n   * @memberof Core#\n   * @function destroy\n   * @fires Hooks#afterDestroy\n   */\n\n\n  this.destroy = function () {\n    instance._clearTimeouts();\n\n    instance._clearImmediates();\n\n    if (instance.view) {\n      // in case HT is destroyed before initialization has finished\n      instance.view.destroy();\n    }\n\n    if (dataSource) {\n      dataSource.destroy();\n    }\n\n    dataSource = null;\n    metaManager.clearCache();\n    keyStateStopObserving();\n\n    if (isRootInstance(instance)) {\n      var licenseInfo = this.rootDocument.querySelector('#hot-display-license-info');\n\n      if (licenseInfo) {\n        licenseInfo.parentNode.removeChild(licenseInfo);\n      }\n    }\n\n    empty(instance.rootElement);\n    eventManager.destroy();\n\n    if (editorManager) {\n      editorManager.destroy();\n    } // The plugin's `destroy` method is called as a consequence and it should handle\n    // unregistration of plugin's maps. Some unregistered maps reset the cache.\n\n\n    instance.batchExecution(function () {\n      instance.rowIndexMapper.unregisterAll();\n      instance.columnIndexMapper.unregisterAll();\n      pluginsRegistry.getItems().forEach(function (_ref20) {\n        var _ref21 = _slicedToArray(_ref20, 2),\n            plugin = _ref21[1];\n\n        plugin.destroy();\n      });\n      pluginsRegistry.clear();\n      instance.runHooks('afterDestroy');\n    }, true);\n    Hooks.getSingleton().destroy(instance);\n    objectEach(instance, function (property, key, obj) {\n      // replace instance methods with post mortem\n      if (isFunction(property)) {\n        obj[key] = postMortem(key);\n      } else if (key !== 'guid') {\n        // replace instance properties with null (restores memory)\n        // it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests\n        obj[key] = null;\n      }\n    });\n    instance.isDestroyed = true; // replace private properties with null (restores memory)\n    // it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests\n\n    if (datamap) {\n      datamap.destroy();\n    }\n\n    instance.rowIndexMapper = null;\n    instance.columnIndexMapper = null;\n    datamap = null;\n    grid = null;\n    selection = null;\n    editorManager = null;\n    instance = null;\n  };\n  /**\n   * Replacement for all methods after the Handsontable was destroyed.\n   *\n   * @private\n   * @param {string} method The method name.\n   * @returns {Function}\n   */\n\n\n  function postMortem(method) {\n    return function () {\n      throw new Error(\"The \\\"\".concat(method, \"\\\" method cannot be called because this Handsontable instance has been destroyed\"));\n    };\n  }\n  /**\n   * Returns the active editor class instance.\n   *\n   * @memberof Core#\n   * @function getActiveEditor\n   * @returns {BaseEditor} The active editor instance.\n   */\n\n\n  this.getActiveEditor = function () {\n    return editorManager.getActiveEditor();\n  };\n  /**\n   * Returns plugin instance by provided its name.\n   *\n   * @memberof Core#\n   * @function getPlugin\n   * @param {string} pluginName The plugin name.\n   * @returns {BasePlugin|undefined} The plugin instance or undefined if there is no plugin.\n   */\n\n\n  this.getPlugin = function (pluginName) {\n    var unifiedPluginName = toUpperCaseFirst(pluginName); // Workaround for the UndoRedo plugin which, currently doesn't follow the plugin architecture.\n\n    if (unifiedPluginName === 'UndoRedo') {\n      return this.undoRedo;\n    }\n\n    return pluginsRegistry.getItem(unifiedPluginName);\n  };\n  /**\n   * Returns name of the passed plugin.\n   *\n   * @private\n   * @memberof Core#\n   * @param {BasePlugin} plugin The plugin instance.\n   * @returns {string}\n   */\n\n\n  this.getPluginName = function (plugin) {\n    // Workaround for the UndoRedo plugin which, currently doesn't follow the plugin architecture.\n    if (plugin === this.undoRedo) {\n      return this.undoRedo.constructor.PLUGIN_KEY;\n    }\n\n    return pluginsRegistry.getId(plugin);\n  };\n  /**\n   * Returns the Handsontable instance.\n   *\n   * @memberof Core#\n   * @function getInstance\n   * @returns {Handsontable} The Handsontable instance.\n   */\n\n\n  this.getInstance = function () {\n    return instance;\n  };\n  /**\n   * Adds listener to the specified hook name (only for this Handsontable instance).\n   *\n   * @memberof Core#\n   * @function addHook\n   * @see Hooks#add\n   * @param {string} key Hook name (see {@link Hooks}).\n   * @param {Function|Array} callback Function or array of functions.\n   * @example\n   * ```js\n   * hot.addHook('beforeInit', myCallback);\n   * ```\n   */\n\n\n  this.addHook = function (key, callback) {\n    Hooks.getSingleton().add(key, callback, instance);\n  };\n  /**\n   * Check if for a specified hook name there are added listeners (only for this Handsontable instance). All available\n   * hooks you will find {@link Hooks}.\n   *\n   * @memberof Core#\n   * @function hasHook\n   * @see Hooks#has\n   * @param {string} key Hook name.\n   * @returns {boolean}\n   *\n   * @example\n   * ```js\n   * const hasBeforeInitListeners = hot.hasHook('beforeInit');\n   * ```\n   */\n\n\n  this.hasHook = function (key) {\n    return Hooks.getSingleton().has(key, instance);\n  };\n  /**\n   * Adds listener to specified hook name (only for this Handsontable instance). After the listener is triggered,\n   * it will be automatically removed.\n   *\n   * @memberof Core#\n   * @function addHookOnce\n   * @see Hooks#once\n   * @param {string} key Hook name (see {@link Hooks}).\n   * @param {Function|Array} callback Function or array of functions.\n   * @example\n   * ```js\n   * hot.addHookOnce('beforeInit', myCallback);\n   * ```\n   */\n\n\n  this.addHookOnce = function (key, callback) {\n    Hooks.getSingleton().once(key, callback, instance);\n  };\n  /**\n   * Removes the hook listener previously registered with {@link Core#addHook}.\n   *\n   * @memberof Core#\n   * @function removeHook\n   * @see Hooks#remove\n   * @param {string} key Hook name.\n   * @param {Function} callback Reference to the function which has been registered using {@link Core#addHook}.\n   *\n   * @example\n   * ```js\n   * hot.removeHook('beforeInit', myCallback);\n   * ```\n   */\n\n\n  this.removeHook = function (key, callback) {\n    Hooks.getSingleton().remove(key, callback, instance);\n  };\n  /**\n   * Run the callbacks for the hook provided in the `key` argument using the parameters given in the other arguments.\n   *\n   * @memberof Core#\n   * @function runHooks\n   * @see Hooks#run\n   * @param {string} key Hook name.\n   * @param {*} [p1] Argument passed to the callback.\n   * @param {*} [p2] Argument passed to the callback.\n   * @param {*} [p3] Argument passed to the callback.\n   * @param {*} [p4] Argument passed to the callback.\n   * @param {*} [p5] Argument passed to the callback.\n   * @param {*} [p6] Argument passed to the callback.\n   * @returns {*}\n   *\n   * @example\n   * ```js\n   * // Run built-in hook\n   * hot.runHooks('beforeInit');\n   * // Run custom hook\n   * hot.runHooks('customAction', 10, 'foo');\n   * ```\n   */\n\n\n  this.runHooks = function (key, p1, p2, p3, p4, p5, p6) {\n    return Hooks.getSingleton().run(instance, key, p1, p2, p3, p4, p5, p6);\n  };\n  /**\n   * Get language phrase for specified dictionary key.\n   *\n   * @memberof Core#\n   * @function getTranslatedPhrase\n   * @since 0.35.0\n   * @param {string} dictionaryKey Constant which is dictionary key.\n   * @param {*} extraArguments Arguments which will be handled by formatters.\n   * @returns {string}\n   */\n\n\n  this.getTranslatedPhrase = function (dictionaryKey, extraArguments) {\n    return getTranslatedPhrase(tableMeta.language, dictionaryKey, extraArguments);\n  };\n  /**\n   * Converts instance into outerHTML of HTMLTableElement.\n   *\n   * @memberof Core#\n   * @function toHTML\n   * @since 7.1.0\n   * @returns {string}\n   */\n\n\n  this.toHTML = function () {\n    return instanceToHTML(_this);\n  };\n  /**\n   * Converts instance into HTMLTableElement.\n   *\n   * @memberof Core#\n   * @function toTableElement\n   * @since 7.1.0\n   * @returns {HTMLTableElement}\n   */\n\n\n  this.toTableElement = function () {\n    var tempElement = _this.rootDocument.createElement('div');\n\n    tempElement.insertAdjacentHTML('afterbegin', instanceToHTML(_this));\n    return tempElement.firstElementChild;\n  };\n\n  this.timeouts = [];\n  /**\n   * Sets timeout. Purpose of this method is to clear all known timeouts when `destroy` method is called.\n   *\n   * @param {number|Function} handle Handler returned from setTimeout or function to execute (it will be automatically wraped\n   *                                 by setTimeout function).\n   * @param {number} [delay=0] If first argument is passed as a function this argument set delay of the execution of that function.\n   * @private\n   */\n\n  this._registerTimeout = function (handle) {\n    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var handleFunc = handle;\n\n    if (typeof handleFunc === 'function') {\n      handleFunc = setTimeout(handleFunc, delay);\n    }\n\n    this.timeouts.push(handleFunc);\n  };\n  /**\n   * Clears all known timeouts.\n   *\n   * @private\n   */\n\n\n  this._clearTimeouts = function () {\n    arrayEach(this.timeouts, function (handler) {\n      clearTimeout(handler);\n    });\n  };\n\n  this.immediates = [];\n  /**\n   * Execute function execution to the next event loop cycle. Purpose of this method is to clear all known timeouts when `destroy` method is called.\n   *\n   * @param {Function} callback Function to be delayed in execution.\n   * @private\n   */\n\n  this._registerImmediate = function (callback) {\n    this.immediates.push(setImmediate(callback));\n  };\n  /**\n   * Clears all known timeouts.\n   *\n   * @private\n   */\n\n\n  this._clearImmediates = function () {\n    arrayEach(this.immediates, function (handler) {\n      clearImmediate(handler);\n    });\n  };\n  /**\n   * Refresh selection borders. This is temporary method relic after selection rewrite.\n   *\n   * @private\n   * @param {boolean} [revertOriginal=false] If `true`, the previous value will be restored. Otherwise, the edited value will be saved.\n   * @param {boolean} [prepareEditorIfNeeded=true] If `true` the editor under the selected cell will be prepared to open.\n   */\n\n\n  this._refreshBorders = function () {\n    var revertOriginal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    editorManager.destroyEditor(revertOriginal);\n    instance.view.render();\n\n    if (prepareEditorIfNeeded && selection.isSelected()) {\n      editorManager.prepareEditor();\n    }\n  };\n\n  getPluginsNames().forEach(function (pluginName) {\n    var PluginClass = getPlugin(pluginName);\n    pluginsRegistry.addItem(pluginName, new PluginClass(_this));\n  });\n  Hooks.getSingleton().run(instance, 'construct');\n}"]},"metadata":{},"sourceType":"module"}