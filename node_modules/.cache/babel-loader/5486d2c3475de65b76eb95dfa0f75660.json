{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { stopImmediatePropagation } from \"../../helpers/dom/event.mjs\";\nimport { CellCoords, CellRange } from \"../../3rdparty/walkontable/src/index.mjs\";\nimport MergedCellsCollection from \"./cellsCollection.mjs\";\nimport MergedCellCoords from \"./cellCoords.mjs\";\nimport AutofillCalculations from \"./calculations/autofill.mjs\";\nimport SelectionCalculations from \"./calculations/selection.mjs\";\nimport toggleMergeItem from \"./contextMenuItem/toggleMerge.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { isObject, clone } from \"../../helpers/object.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { applySpanProperties } from \"./utils.mjs\";\nHooks.getSingleton().register('beforeMergeCells');\nHooks.getSingleton().register('afterMergeCells');\nHooks.getSingleton().register('beforeUnmergeCells');\nHooks.getSingleton().register('afterUnmergeCells');\nexport var PLUGIN_KEY = 'mergeCells';\nexport var PLUGIN_PRIORITY = 150;\nvar privatePool = new WeakMap();\n/**\r\n * @plugin MergeCells\r\n *\r\n * @description\r\n * Plugin, which allows merging cells in the table (using the initial configuration, API or context menu).\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * const hot = new Handsontable(document.getElementById('example'), {\r\n *  data: getData(),\r\n *  mergeCells: [\r\n *    {row: 0, col: 3, rowspan: 3, colspan: 3},\r\n *    {row: 2, col: 6, rowspan: 2, colspan: 2},\r\n *    {row: 4, col: 8, rowspan: 3, colspan: 3}\r\n *  ],\r\n * ```\r\n */\n\nexport var MergeCells = /*#__PURE__*/function (_BasePlugin) {\n  _inherits(MergeCells, _BasePlugin);\n\n  var _super = _createSuper(MergeCells);\n\n  function MergeCells(hotInstance) {\n    var _this;\n\n    _classCallCheck(this, MergeCells);\n\n    _this = _super.call(this, hotInstance);\n    privatePool.set(_assertThisInitialized(_this), {\n      lastDesiredCoords: null\n    });\n    /**\r\n     * A container for all the merged cells.\r\n     *\r\n     * @private\r\n     * @type {MergedCellsCollection}\r\n     */\n\n    _this.mergedCellsCollection = null;\n    /**\r\n     * Instance of the class responsible for all the autofill-related calculations.\r\n     *\r\n     * @private\r\n     * @type {AutofillCalculations}\r\n     */\n\n    _this.autofillCalculations = null;\n    /**\r\n     * Instance of the class responsible for the selection-related calculations.\r\n     *\r\n     * @private\r\n     * @type {SelectionCalculations}\r\n     */\n\n    _this.selectionCalculations = null;\n    return _this;\n  }\n  /**\r\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\r\n   * hook and if it returns `true` than the {@link MergeCells#enablePlugin} method is called.\r\n   *\r\n   * @returns {boolean}\r\n   */\n\n\n  _createClass(MergeCells, [{\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      return !!this.hot.getSettings()[PLUGIN_KEY];\n    }\n    /**\r\n     * Enables the plugin functionality for this Handsontable instance.\r\n     */\n\n  }, {\n    key: \"enablePlugin\",\n    value: function enablePlugin() {\n      var _this2 = this;\n\n      if (this.enabled) {\n        return;\n      }\n\n      this.mergedCellsCollection = new MergedCellsCollection(this);\n      this.autofillCalculations = new AutofillCalculations(this);\n      this.selectionCalculations = new SelectionCalculations(this);\n      this.addHook('afterInit', function () {\n        return _this2.onAfterInit.apply(_this2, arguments);\n      });\n      this.addHook('beforeKeyDown', function () {\n        return _this2.onBeforeKeyDown.apply(_this2, arguments);\n      });\n      this.addHook('modifyTransformStart', function () {\n        return _this2.onModifyTransformStart.apply(_this2, arguments);\n      });\n      this.addHook('afterModifyTransformStart', function () {\n        return _this2.onAfterModifyTransformStart.apply(_this2, arguments);\n      });\n      this.addHook('modifyTransformEnd', function () {\n        return _this2.onModifyTransformEnd.apply(_this2, arguments);\n      });\n      this.addHook('modifyGetCellCoords', function () {\n        return _this2.onModifyGetCellCoords.apply(_this2, arguments);\n      });\n      this.addHook('beforeSetRangeStart', function () {\n        return _this2.onBeforeSetRangeStart.apply(_this2, arguments);\n      });\n      this.addHook('beforeSetRangeStartOnly', function () {\n        return _this2.onBeforeSetRangeStart.apply(_this2, arguments);\n      });\n      this.addHook('beforeSetRangeEnd', function () {\n        return _this2.onBeforeSetRangeEnd.apply(_this2, arguments);\n      });\n      this.addHook('afterIsMultipleSelection', function () {\n        return _this2.onAfterIsMultipleSelection.apply(_this2, arguments);\n      });\n      this.addHook('afterRenderer', function () {\n        return _this2.onAfterRenderer.apply(_this2, arguments);\n      });\n      this.addHook('afterContextMenuDefaultOptions', function () {\n        return _this2.addMergeActionsToContextMenu.apply(_this2, arguments);\n      });\n      this.addHook('afterGetCellMeta', function () {\n        return _this2.onAfterGetCellMeta.apply(_this2, arguments);\n      });\n      this.addHook('afterViewportRowCalculatorOverride', function () {\n        return _this2.onAfterViewportRowCalculatorOverride.apply(_this2, arguments);\n      });\n      this.addHook('afterViewportColumnCalculatorOverride', function () {\n        return _this2.onAfterViewportColumnCalculatorOverride.apply(_this2, arguments);\n      });\n      this.addHook('modifyAutofillRange', function () {\n        return _this2.onModifyAutofillRange.apply(_this2, arguments);\n      });\n      this.addHook('afterCreateCol', function () {\n        return _this2.onAfterCreateCol.apply(_this2, arguments);\n      });\n      this.addHook('afterRemoveCol', function () {\n        return _this2.onAfterRemoveCol.apply(_this2, arguments);\n      });\n      this.addHook('afterCreateRow', function () {\n        return _this2.onAfterCreateRow.apply(_this2, arguments);\n      });\n      this.addHook('afterRemoveRow', function () {\n        return _this2.onAfterRemoveRow.apply(_this2, arguments);\n      });\n      this.addHook('afterChange', function () {\n        return _this2.onAfterChange.apply(_this2, arguments);\n      });\n      this.addHook('beforeDrawBorders', function () {\n        return _this2.onBeforeDrawAreaBorders.apply(_this2, arguments);\n      });\n      this.addHook('afterDrawSelection', function () {\n        return _this2.onAfterDrawSelection.apply(_this2, arguments);\n      });\n      this.addHook('beforeRemoveCellClassNames', function () {\n        return _this2.onBeforeRemoveCellClassNames.apply(_this2, arguments);\n      });\n      this.addHook('beforeUndoStackChange', function (action, source) {\n        if (source === 'MergeCells') {\n          return false;\n        }\n      });\n\n      _get(_getPrototypeOf(MergeCells.prototype), \"enablePlugin\", this).call(this);\n    }\n    /**\r\n     * Disables the plugin functionality for this Handsontable instance.\r\n     */\n\n  }, {\n    key: \"disablePlugin\",\n    value: function disablePlugin() {\n      this.clearCollections();\n      this.hot.render();\n\n      _get(_getPrototypeOf(MergeCells.prototype), \"disablePlugin\", this).call(this);\n    }\n    /**\r\n     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.\r\n     */\n\n  }, {\n    key: \"updatePlugin\",\n    value: function updatePlugin() {\n      var settings = this.hot.getSettings()[PLUGIN_KEY];\n      this.disablePlugin();\n      this.enablePlugin();\n      this.generateFromSettings(settings);\n\n      _get(_getPrototypeOf(MergeCells.prototype), \"updatePlugin\", this).call(this);\n    }\n    /**\r\n     * Validates a single setting object, represented by a single merged cell information object.\r\n     *\r\n     * @private\r\n     * @param {object} setting An object with `row`, `col`, `rowspan` and `colspan` properties.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"validateSetting\",\n    value: function validateSetting(setting) {\n      var valid = true;\n\n      if (!setting) {\n        return false;\n      }\n\n      if (MergedCellCoords.containsNegativeValues(setting)) {\n        warn(MergedCellCoords.NEGATIVE_VALUES_WARNING(setting));\n        valid = false;\n      } else if (MergedCellCoords.isOutOfBounds(setting, this.hot.countRows(), this.hot.countCols())) {\n        warn(MergedCellCoords.IS_OUT_OF_BOUNDS_WARNING(setting));\n        valid = false;\n      } else if (MergedCellCoords.isSingleCell(setting)) {\n        warn(MergedCellCoords.IS_SINGLE_CELL(setting));\n        valid = false;\n      } else if (MergedCellCoords.containsZeroSpan(setting)) {\n        warn(MergedCellCoords.ZERO_SPAN_WARNING(setting));\n        valid = false;\n      }\n\n      return valid;\n    }\n    /**\r\n     * Generates the merged cells from the settings provided to the plugin.\r\n     *\r\n     * @private\r\n     * @param {Array|boolean} settings The settings provided to the plugin.\r\n     */\n\n  }, {\n    key: \"generateFromSettings\",\n    value: function generateFromSettings(settings) {\n      var _this3 = this;\n\n      if (Array.isArray(settings)) {\n        var _this$hot;\n\n        var populationArgumentsList = [];\n        arrayEach(settings, function (setting) {\n          if (!_this3.validateSetting(setting)) {\n            return;\n          }\n\n          var highlight = new CellCoords(setting.row, setting.col);\n          var rangeEnd = new CellCoords(setting.row + setting.rowspan - 1, setting.col + setting.colspan - 1);\n          var mergeRange = new CellRange(highlight, highlight, rangeEnd);\n          populationArgumentsList.push(_this3.mergeRange(mergeRange, true, true));\n        }); // remove 'empty' setting objects, caused by improper merge range declarations\n\n        populationArgumentsList = populationArgumentsList.filter(function (value) {\n          return value !== true;\n        });\n        var bulkPopulationData = this.getBulkCollectionData(populationArgumentsList);\n\n        (_this$hot = this.hot).populateFromArray.apply(_this$hot, _toConsumableArray(bulkPopulationData));\n      }\n    }\n    /**\r\n     * Generates a bulk set of all the data to be populated to fill the data \"under\" the added merged cells.\r\n     *\r\n     * @private\r\n     * @param {Array} populationArgumentsList Array in a form of `[row, column, dataUnderCollection]`.\r\n     * @returns {Array} Array in a form of `[row, column, dataOfAllCollections]`.\r\n     */\n\n  }, {\n    key: \"getBulkCollectionData\",\n    value: function getBulkCollectionData(populationArgumentsList) {\n      var _this$hot2;\n\n      var populationDataRange = this.getBulkCollectionDataRange(populationArgumentsList);\n\n      var dataAtRange = (_this$hot2 = this.hot).getData.apply(_this$hot2, _toConsumableArray(populationDataRange));\n\n      var newDataAtRange = dataAtRange.splice(0);\n      arrayEach(populationArgumentsList, function (mergedCellArguments) {\n        var _mergedCellArguments = _slicedToArray(mergedCellArguments, 3),\n            mergedCellRowIndex = _mergedCellArguments[0],\n            mergedCellColumnIndex = _mergedCellArguments[1],\n            mergedCellData = _mergedCellArguments[2];\n\n        arrayEach(mergedCellData, function (mergedCellRow, rowIndex) {\n          arrayEach(mergedCellRow, function (mergedCellElement, columnIndex) {\n            newDataAtRange[mergedCellRowIndex - populationDataRange[0] + rowIndex][mergedCellColumnIndex - populationDataRange[1] + columnIndex] = mergedCellElement; // eslint-disable-line max-len\n          });\n        });\n      });\n      return [populationDataRange[0], populationDataRange[1], newDataAtRange];\n    }\n    /**\r\n     * Gets the range of combined data ranges provided in a form of an array of arrays ([row, column, dataUnderCollection]).\r\n     *\r\n     * @private\r\n     * @param {Array} populationArgumentsList Array containing argument lists for the `populateFromArray` method - row, column and data for population.\r\n     * @returns {Array[]} Start and end coordinates of the merged cell range. (in a form of [rowIndex, columnIndex]).\r\n     */\n\n  }, {\n    key: \"getBulkCollectionDataRange\",\n    value: function getBulkCollectionDataRange(populationArgumentsList) {\n      var start = [0, 0];\n      var end = [0, 0];\n      var mergedCellRow = null;\n      var mergedCellColumn = null;\n      var mergedCellData = null;\n      arrayEach(populationArgumentsList, function (mergedCellArguments) {\n        mergedCellRow = mergedCellArguments[0];\n        mergedCellColumn = mergedCellArguments[1];\n        mergedCellData = mergedCellArguments[2];\n        start[0] = Math.min(mergedCellRow, start[0]);\n        start[1] = Math.min(mergedCellColumn, start[1]);\n        end[0] = Math.max(mergedCellRow + mergedCellData.length - 1, end[0]);\n        end[1] = Math.max(mergedCellColumn + mergedCellData[0].length - 1, end[1]);\n      });\n      return [].concat(start, end);\n    }\n    /**\r\n     * Clears the merged cells from the merged cell container.\r\n     */\n\n  }, {\n    key: \"clearCollections\",\n    value: function clearCollections() {\n      this.mergedCellsCollection.clear();\n    }\n    /**\r\n     * Returns `true` if a range is mergeable.\r\n     *\r\n     * @private\r\n     * @param {object} newMergedCellInfo Merged cell information object to test.\r\n     * @param {boolean} [auto=false] `true` if triggered at initialization.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"canMergeRange\",\n    value: function canMergeRange(newMergedCellInfo) {\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return auto ? true : this.validateSetting(newMergedCellInfo);\n    }\n    /**\r\n     * Merge or unmerge, based on last selected range.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: \"toggleMergeOnSelection\",\n    value: function toggleMergeOnSelection() {\n      var currentRange = this.hot.getSelectedRangeLast();\n\n      if (!currentRange) {\n        return;\n      }\n\n      currentRange.setDirection('NW-SE');\n      var from = currentRange.from,\n          to = currentRange.to;\n      this.toggleMerge(currentRange);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\r\n     * Merges the selection provided as a cell range.\r\n     *\r\n     * @param {CellRange} [cellRange] Selection cell range.\r\n     */\n\n  }, {\n    key: \"mergeSelection\",\n    value: function mergeSelection() {\n      var cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n\n      if (!cellRange) {\n        return;\n      }\n\n      cellRange.setDirection('NW-SE');\n      var from = cellRange.from,\n          to = cellRange.to;\n      this.unmergeRange(cellRange, true);\n      this.mergeRange(cellRange);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\r\n     * Unmerges the selection provided as a cell range.\r\n     *\r\n     * @param {CellRange} [cellRange] Selection cell range.\r\n     */\n\n  }, {\n    key: \"unmergeSelection\",\n    value: function unmergeSelection() {\n      var cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n\n      if (!cellRange) {\n        return;\n      }\n\n      var from = cellRange.from,\n          to = cellRange.to;\n      this.unmergeRange(cellRange, true);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\r\n     * Merges cells in the provided cell range.\r\n     *\r\n     * @private\r\n     * @param {CellRange} cellRange Cell range to merge.\r\n     * @param {boolean} [auto=false] `true` if is called automatically, e.g. At initialization.\r\n     * @param {boolean} [preventPopulation=false] `true`, if the method should not run `populateFromArray` at the end, but rather return its arguments.\r\n     * @returns {Array|boolean} Returns an array of [row, column, dataUnderCollection] if preventPopulation is set to true. If the the merging process went successful, it returns `true`, otherwise - `false`.\r\n     * @fires Hooks#beforeMergeCells\r\n     * @fires Hooks#afterMergeCells\r\n     */\n\n  }, {\n    key: \"mergeRange\",\n    value: function mergeRange(cellRange) {\n      var _this4 = this;\n\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var preventPopulation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var topLeft = cellRange.getTopLeftCorner();\n      var bottomRight = cellRange.getBottomRightCorner();\n      var mergeParent = {\n        row: topLeft.row,\n        col: topLeft.col,\n        rowspan: bottomRight.row - topLeft.row + 1,\n        colspan: bottomRight.col - topLeft.col + 1\n      };\n      var clearedData = [];\n      var populationInfo = null;\n\n      if (!this.canMergeRange(mergeParent, auto)) {\n        return false;\n      }\n\n      this.hot.runHooks('beforeMergeCells', cellRange, auto);\n      rangeEach(0, mergeParent.rowspan - 1, function (i) {\n        rangeEach(0, mergeParent.colspan - 1, function (j) {\n          var clearedValue = null;\n\n          if (!clearedData[i]) {\n            clearedData[i] = [];\n          }\n\n          if (i === 0 && j === 0) {\n            clearedValue = _this4.hot.getDataAtCell(mergeParent.row, mergeParent.col);\n          } else {\n            _this4.hot.setCellMeta(mergeParent.row + i, mergeParent.col + j, 'hidden', true);\n          }\n\n          clearedData[i][j] = clearedValue;\n        });\n      });\n      this.hot.setCellMeta(mergeParent.row, mergeParent.col, 'spanned', true);\n      var mergedCellAdded = this.mergedCellsCollection.add(mergeParent);\n\n      if (mergedCellAdded) {\n        if (preventPopulation) {\n          populationInfo = [mergeParent.row, mergeParent.col, clearedData];\n        } else {\n          this.hot.populateFromArray(mergeParent.row, mergeParent.col, clearedData, void 0, void 0, this.pluginName);\n        }\n\n        this.hot.runHooks('afterMergeCells', cellRange, mergeParent, auto);\n        return populationInfo;\n      }\n\n      return true;\n    }\n    /**\r\n     * Unmerges the selection provided as a cell range. If no cell range is provided, it uses the current selection.\r\n     *\r\n     * @private\r\n     * @param {CellRange} cellRange Selection cell range.\r\n     * @param {boolean} [auto=false] `true` if called automatically by the plugin.\r\n     *\r\n     * @fires Hooks#beforeUnmergeCells\r\n     * @fires Hooks#afterUnmergeCells\r\n     */\n\n  }, {\n    key: \"unmergeRange\",\n    value: function unmergeRange(cellRange) {\n      var _this5 = this;\n\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var mergedCells = this.mergedCellsCollection.getWithinRange(cellRange);\n\n      if (!mergedCells) {\n        return;\n      }\n\n      this.hot.runHooks('beforeUnmergeCells', cellRange, auto);\n      arrayEach(mergedCells, function (currentCollection) {\n        _this5.mergedCellsCollection.remove(currentCollection.row, currentCollection.col);\n\n        rangeEach(0, currentCollection.rowspan - 1, function (i) {\n          rangeEach(0, currentCollection.colspan - 1, function (j) {\n            _this5.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, 'hidden');\n          });\n        });\n\n        _this5.hot.removeCellMeta(currentCollection.row, currentCollection.col, 'spanned');\n      });\n      this.hot.runHooks('afterUnmergeCells', cellRange, auto);\n      this.hot.render();\n    }\n    /**\r\n     * Merges or unmerges, based on the cell range provided as `cellRange`.\r\n     *\r\n     * @private\r\n     * @param {CellRange} cellRange The cell range to merge or unmerged.\r\n     */\n\n  }, {\n    key: \"toggleMerge\",\n    value: function toggleMerge(cellRange) {\n      var mergedCell = this.mergedCellsCollection.get(cellRange.from.row, cellRange.from.col);\n      var mergedCellCoversWholeRange = mergedCell.row === cellRange.from.row && mergedCell.col === cellRange.from.col && mergedCell.row + mergedCell.rowspan - 1 === cellRange.to.row && mergedCell.col + mergedCell.colspan - 1 === cellRange.to.col;\n\n      if (mergedCellCoversWholeRange) {\n        this.unmergeRange(cellRange);\n      } else {\n        this.mergeSelection(cellRange);\n      }\n    }\n    /**\r\n     * Merges the specified range.\r\n     *\r\n     * @param {number} startRow Start row of the merged cell.\r\n     * @param {number} startColumn Start column of the merged cell.\r\n     * @param {number} endRow End row of the merged cell.\r\n     * @param {number} endColumn End column of the merged cell.\r\n     * @fires Hooks#beforeMergeCells\r\n     * @fires Hooks#afterMergeCells\r\n     */\n\n  }, {\n    key: \"merge\",\n    value: function merge(startRow, startColumn, endRow, endColumn) {\n      var start = new CellCoords(startRow, startColumn);\n      var end = new CellCoords(endRow, endColumn);\n      this.mergeRange(new CellRange(start, start, end));\n    }\n    /**\r\n     * Unmerges the merged cell in the provided range.\r\n     *\r\n     * @param {number} startRow Start row of the merged cell.\r\n     * @param {number} startColumn Start column of the merged cell.\r\n     * @param {number} endRow End row of the merged cell.\r\n     * @param {number} endColumn End column of the merged cell.\r\n     * @fires Hooks#beforeUnmergeCells\r\n     * @fires Hooks#afterUnmergeCells\r\n     */\n\n  }, {\n    key: \"unmerge\",\n    value: function unmerge(startRow, startColumn, endRow, endColumn) {\n      var start = new CellCoords(startRow, startColumn);\n      var end = new CellCoords(endRow, endColumn);\n      this.unmergeRange(new CellRange(start, start, end));\n    }\n    /**\r\n     * `afterInit` hook callback.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: \"onAfterInit\",\n    value: function onAfterInit() {\n      this.generateFromSettings(this.hot.getSettings()[PLUGIN_KEY]);\n      this.hot.render();\n    }\n    /**\r\n     * `beforeKeyDown` hook callback.\r\n     *\r\n     * @private\r\n     * @param {KeyboardEvent} event The `keydown` event object.\r\n     */\n\n  }, {\n    key: \"onBeforeKeyDown\",\n    value: function onBeforeKeyDown(event) {\n      var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;\n\n      if (ctrlDown && event.keyCode === 77) {\n        // CTRL + M\n        this.toggleMerge(this.hot.getSelectedRangeLast());\n        this.hot.render();\n        stopImmediatePropagation(event);\n      }\n    }\n    /**\r\n     * Modifies the information on whether the current selection contains multiple cells. The `afterIsMultipleSelection` hook callback.\r\n     *\r\n     * @private\r\n     * @param {boolean} isMultiple Determines whether the current selection contains multiple cells.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"onAfterIsMultipleSelection\",\n    value: function onAfterIsMultipleSelection(isMultiple) {\n      if (isMultiple) {\n        var mergedCells = this.mergedCellsCollection.mergedCells;\n        var selectionRange = this.hot.getSelectedRangeLast();\n\n        for (var group = 0; group < mergedCells.length; group += 1) {\n          if (selectionRange.from.row === mergedCells[group].row && selectionRange.from.col === mergedCells[group].col && selectionRange.to.row === mergedCells[group].row + mergedCells[group].rowspan - 1 && selectionRange.to.col === mergedCells[group].col + mergedCells[group].colspan - 1) {\n            return false;\n          }\n        }\n      }\n\n      return isMultiple;\n    }\n    /**\r\n     * `modifyTransformStart` hook callback.\r\n     *\r\n     * @private\r\n     * @param {object} delta The transformation delta.\r\n     */\n\n  }, {\n    key: \"onModifyTransformStart\",\n    value: function onModifyTransformStart(delta) {\n      var priv = privatePool.get(this);\n      var currentlySelectedRange = this.hot.getSelectedRangeLast();\n      var newDelta = {\n        row: delta.row,\n        col: delta.col\n      };\n      var nextPosition = null;\n      var currentPosition = new CellCoords(currentlySelectedRange.highlight.row, currentlySelectedRange.highlight.col);\n      var mergedParent = this.mergedCellsCollection.get(currentPosition.row, currentPosition.col);\n\n      if (!priv.lastDesiredCoords) {\n        priv.lastDesiredCoords = new CellCoords(null, null);\n      }\n\n      if (mergedParent) {\n        // only merge selected\n        var mergeTopLeft = new CellCoords(mergedParent.row, mergedParent.col);\n        var mergeBottomRight = new CellCoords(mergedParent.row + mergedParent.rowspan - 1, mergedParent.col + mergedParent.colspan - 1);\n        var mergeRange = new CellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight);\n\n        if (!mergeRange.includes(priv.lastDesiredCoords)) {\n          priv.lastDesiredCoords = new CellCoords(null, null); // reset outdated version of lastDesiredCoords\n        }\n\n        newDelta.row = priv.lastDesiredCoords.row ? priv.lastDesiredCoords.row - currentPosition.row : newDelta.row;\n        newDelta.col = priv.lastDesiredCoords.col ? priv.lastDesiredCoords.col - currentPosition.col : newDelta.col;\n\n        if (delta.row > 0) {\n          // moving down\n          newDelta.row = mergedParent.row + mergedParent.rowspan - 1 - currentPosition.row + delta.row;\n        } else if (delta.row < 0) {\n          // moving up\n          newDelta.row = currentPosition.row - mergedParent.row + delta.row;\n        }\n\n        if (delta.col > 0) {\n          // moving right\n          newDelta.col = mergedParent.col + mergedParent.colspan - 1 - currentPosition.col + delta.col;\n        } else if (delta.col < 0) {\n          // moving left\n          newDelta.col = currentPosition.col - mergedParent.col + delta.col;\n        }\n      }\n\n      nextPosition = new CellCoords(currentlySelectedRange.highlight.row + newDelta.row, currentlySelectedRange.highlight.col + newDelta.col);\n      var nextPositionMergedCell = this.mergedCellsCollection.get(nextPosition.row, nextPosition.col);\n\n      if (nextPositionMergedCell) {\n        // skipping the invisible cells in the merge range\n        var firstRenderableCoords = this.mergedCellsCollection.getFirstRenderableCoords(nextPositionMergedCell.row, nextPositionMergedCell.col);\n        priv.lastDesiredCoords = nextPosition;\n        newDelta = {\n          row: firstRenderableCoords.row - currentPosition.row,\n          col: firstRenderableCoords.col - currentPosition.col\n        };\n      }\n\n      if (newDelta.row !== 0) {\n        delta.row = newDelta.row;\n      }\n\n      if (newDelta.col !== 0) {\n        delta.col = newDelta.col;\n      }\n    }\n    /**\r\n     * `modifyTransformEnd` hook callback. Needed to handle \"jumping over\" merged merged cells, while selecting.\r\n     *\r\n     * @private\r\n     * @param {object} delta The transformation delta.\r\n     */\n\n  }, {\n    key: \"onModifyTransformEnd\",\n    value: function onModifyTransformEnd(delta) {\n      var _this6 = this;\n\n      var currentSelectionRange = this.hot.getSelectedRangeLast();\n      var newDelta = clone(delta);\n      var newSelectionRange = this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, delta);\n      var tempDelta = clone(newDelta);\n      var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(newSelectionRange, true);\n\n      do {\n        tempDelta = clone(newDelta);\n        this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, newDelta);\n        arrayEach(mergedCellsWithinRange, function (mergedCell) {\n          _this6.selectionCalculations.snapDelta(newDelta, currentSelectionRange, mergedCell);\n        });\n      } while (newDelta.row !== tempDelta.row || newDelta.col !== tempDelta.col);\n\n      delta.row = newDelta.row;\n      delta.col = newDelta.col;\n    }\n    /**\r\n     * `modifyGetCellCoords` hook callback. Swaps the `getCell` coords with the merged parent coords.\r\n     *\r\n     * @private\r\n     * @param {number} row Row index.\r\n     * @param {number} column Visual column index.\r\n     * @returns {Array|undefined} Visual coordinates of the merge.\r\n     */\n\n  }, {\n    key: \"onModifyGetCellCoords\",\n    value: function onModifyGetCellCoords(row, column) {\n      if (row < 0 || column < 0) {\n        return;\n      }\n\n      var mergeParent = this.mergedCellsCollection.get(row, column);\n\n      if (!mergeParent) {\n        return;\n      }\n\n      var mergeRow = mergeParent.row,\n          mergeColumn = mergeParent.col,\n          colspan = mergeParent.colspan,\n          rowspan = mergeParent.rowspan;\n      return [// Most top-left merged cell coords.\n      mergeRow, mergeColumn, // Most bottom-right merged cell coords.\n      mergeRow + rowspan - 1, mergeColumn + colspan - 1];\n    }\n    /**\r\n     * `afterContextMenuDefaultOptions` hook callback.\r\n     *\r\n     * @private\r\n     * @param {object} defaultOptions The default context menu options.\r\n     */\n\n  }, {\n    key: \"addMergeActionsToContextMenu\",\n    value: function addMergeActionsToContextMenu(defaultOptions) {\n      defaultOptions.items.push({\n        name: '---------'\n      }, toggleMergeItem(this));\n    }\n    /**\r\n     * `afterRenderer` hook callback.\r\n     *\r\n     * @private\r\n     * @param {HTMLElement} TD The cell to be modified.\r\n     * @param {number} row Row index.\r\n     * @param {number} col Visual column index.\r\n     */\n\n  }, {\n    key: \"onAfterRenderer\",\n    value: function onAfterRenderer(TD, row, col) {\n      var mergedCell = this.mergedCellsCollection.get(row, col); // We shouldn't override data in the collection.\n\n      var mergedCellCopy = isObject(mergedCell) ? clone(mergedCell) : void 0;\n\n      if (isObject(mergedCellCopy)) {\n        var _this$hot3 = this.hot,\n            rowMapper = _this$hot3.rowIndexMapper,\n            columnMapper = _this$hot3.columnIndexMapper;\n        var mergeRow = mergedCellCopy.row,\n            mergeColumn = mergedCellCopy.col,\n            colspan = mergedCellCopy.colspan,\n            rowspan = mergedCellCopy.rowspan;\n\n        var _this$translateMerged = this.translateMergedCellToRenderable(mergeRow, rowspan, mergeColumn, colspan),\n            _this$translateMerged2 = _slicedToArray(_this$translateMerged, 2),\n            lastMergedRowIndex = _this$translateMerged2[0],\n            lastMergedColumnIndex = _this$translateMerged2[1];\n\n        var renderedRowIndex = rowMapper.getRenderableFromVisualIndex(row);\n        var renderedColumnIndex = columnMapper.getRenderableFromVisualIndex(col);\n        var maxRowSpan = lastMergedRowIndex - renderedRowIndex + 1; // Number of rendered columns.\n\n        var maxColSpan = lastMergedColumnIndex - renderedColumnIndex + 1; // Number of rendered columns.\n        // We just try to determine some values basing on the actual number of rendered indexes (some columns may be hidden).\n\n        mergedCellCopy.row = rowMapper.getFirstNotHiddenIndex(mergedCellCopy.row, 1); // We just try to determine some values basing on the actual number of rendered indexes (some columns may be hidden).\n\n        mergedCellCopy.col = columnMapper.getFirstNotHiddenIndex(mergedCellCopy.col, 1); // The `rowSpan` property for a `TD` element should be at most equal to number of rendered rows in the merge area.\n\n        mergedCellCopy.rowspan = Math.min(mergedCellCopy.rowspan, maxRowSpan); // The `colSpan` property for a `TD` element should be at most equal to number of rendered columns in the merge area.\n\n        mergedCellCopy.colspan = Math.min(mergedCellCopy.colspan, maxColSpan);\n      }\n\n      applySpanProperties(TD, mergedCellCopy, row, col);\n    }\n    /**\r\n     * `beforeSetRangeStart` and `beforeSetRangeStartOnly` hook callback.\r\n     * A selection within merge area should be rewritten to the start of merge area.\r\n     *\r\n     * @private\r\n     * @param {object} coords Cell coords.\r\n     */\n\n  }, {\n    key: \"onBeforeSetRangeStart\",\n    value: function onBeforeSetRangeStart(coords) {\n      // TODO: It is a workaround, but probably this hook may be needed. Every selection on the merge area\n      // could set start point of the selection to the start of the merge area. However, logic inside `expandByRange` need\n      // an initial start point. Click on the merge cell when there are some hidden indexes break the logic in some cases.\n      // Please take a look at #7010 for more information. I'm not sure if selection directions are calculated properly\n      // and what was idea for flipping direction inside `expandByRange` method.\n      if (this.mergedCellsCollection.isFirstRenderableMergedCell(coords.row, coords.col)) {\n        var mergeParent = this.mergedCellsCollection.get(coords.row, coords.col);\n        var _ref = [mergeParent.row, mergeParent.col];\n        coords.row = _ref[0];\n        coords.col = _ref[1];\n      }\n    }\n    /**\r\n     * `beforeSetRangeEnd` hook callback.\r\n     * While selecting cells with keyboard or mouse, make sure that rectangular area is expanded to the extent of the merged cell.\r\n     *\r\n     * Note: Please keep in mind that callback may modify both start and end range coordinates by the reference.\r\n     *\r\n     * @private\r\n     * @param {object} coords Cell coords.\r\n     */\n\n  }, {\n    key: \"onBeforeSetRangeEnd\",\n    value: function onBeforeSetRangeEnd(coords) {\n      var selRange = this.hot.getSelectedRangeLast();\n      selRange.highlight = new CellCoords(selRange.highlight.row, selRange.highlight.col); // clone in case we will modify its reference\n\n      selRange.to = coords;\n      var rangeExpanded = false;\n\n      if (this.hot.selection.isSelectedByColumnHeader() || this.hot.selection.isSelectedByRowHeader()) {\n        return;\n      }\n\n      do {\n        rangeExpanded = false;\n\n        for (var i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {\n          var cellInfo = this.mergedCellsCollection.mergedCells[i];\n          var mergedCellRange = cellInfo.getRange();\n\n          if (selRange.expandByRange(mergedCellRange)) {\n            coords.row = selRange.to.row;\n            coords.col = selRange.to.col;\n            rangeExpanded = true;\n          }\n        }\n      } while (rangeExpanded);\n    }\n    /**\r\n     * The `afterGetCellMeta` hook callback.\r\n     *\r\n     * @private\r\n     * @param {number} row Row index.\r\n     * @param {number} col Column index.\r\n     * @param {object} cellProperties The cell properties object.\r\n     */\n\n  }, {\n    key: \"onAfterGetCellMeta\",\n    value: function onAfterGetCellMeta(row, col, cellProperties) {\n      var mergeParent = this.mergedCellsCollection.get(row, col);\n\n      if (mergeParent) {\n        if (mergeParent.row !== row || mergeParent.col !== col) {\n          cellProperties.copyable = false;\n        } else {\n          cellProperties.rowspan = mergeParent.rowspan;\n          cellProperties.colspan = mergeParent.colspan;\n        }\n      }\n    }\n    /**\r\n     * `afterViewportRowCalculatorOverride` hook callback.\r\n     *\r\n     * @private\r\n     * @param {object} calc The row calculator object.\r\n     */\n\n  }, {\n    key: \"onAfterViewportRowCalculatorOverride\",\n    value: function onAfterViewportRowCalculatorOverride(calc) {\n      var nrOfColumns = this.hot.countCols();\n      this.modifyViewportRowStart(calc, nrOfColumns);\n      this.modifyViewportRowEnd(calc, nrOfColumns);\n    }\n    /**\r\n     * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.\r\n     *\r\n     * @private\r\n     * @param {object} calc The row calculator object.\r\n     * @param {number} nrOfColumns Number of visual columns.\r\n     */\n\n  }, {\n    key: \"modifyViewportRowStart\",\n    value: function modifyViewportRowStart(calc, nrOfColumns) {\n      var rowMapper = this.hot.rowIndexMapper;\n      var visualStartRow = rowMapper.getVisualFromRenderableIndex(calc.startRow);\n\n      for (var visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {\n        var mergeParentForViewportStart = this.mergedCellsCollection.get(visualStartRow, visualColumnIndex);\n\n        if (isObject(mergeParentForViewportStart)) {\n          var renderableIndexAtMergeStart = rowMapper.getRenderableFromVisualIndex(rowMapper.getFirstNotHiddenIndex(mergeParentForViewportStart.row, 1)); // Merge start is out of the viewport (i.e. when we scrolled to the bottom and we can see just part of a merge).\n\n          if (renderableIndexAtMergeStart < calc.startRow) {\n            // We extend viewport when some rows have been merged.\n            calc.startRow = renderableIndexAtMergeStart; // We are looking for next merges inside already extended viewport (starting again from row equal to 0).\n\n            this.modifyViewportRowStart(calc, nrOfColumns); // recursively search upwards\n\n            return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n          }\n        }\n      }\n    }\n    /**\r\n     *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.\r\n     *\r\n     * @private\r\n     * @param {object} calc The row calculator object.\r\n     * @param {number} nrOfColumns Number of visual columns.\r\n     */\n\n  }, {\n    key: \"modifyViewportRowEnd\",\n    value: function modifyViewportRowEnd(calc, nrOfColumns) {\n      var rowMapper = this.hot.rowIndexMapper;\n      var visualEndRow = rowMapper.getVisualFromRenderableIndex(calc.endRow);\n\n      for (var visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {\n        var mergeParentForViewportEnd = this.mergedCellsCollection.get(visualEndRow, visualColumnIndex);\n\n        if (isObject(mergeParentForViewportEnd)) {\n          var mergeEnd = mergeParentForViewportEnd.row + mergeParentForViewportEnd.rowspan - 1;\n          var renderableIndexAtMergeEnd = rowMapper.getRenderableFromVisualIndex(rowMapper.getFirstNotHiddenIndex(mergeEnd, -1)); // Merge end is out of the viewport.\n\n          if (renderableIndexAtMergeEnd > calc.endRow) {\n            // We extend the viewport when some rows have been merged.\n            calc.endRow = renderableIndexAtMergeEnd; // We are looking for next merges inside already extended viewport (starting again from row equal to 0).\n\n            this.modifyViewportRowEnd(calc, nrOfColumns); // recursively search upwards\n\n            return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n          }\n        }\n      }\n    }\n    /**\r\n     * `afterViewportColumnCalculatorOverride` hook callback.\r\n     *\r\n     * @private\r\n     * @param {object} calc The column calculator object.\r\n     */\n\n  }, {\n    key: \"onAfterViewportColumnCalculatorOverride\",\n    value: function onAfterViewportColumnCalculatorOverride(calc) {\n      var nrOfRows = this.hot.countRows();\n      this.modifyViewportColumnStart(calc, nrOfRows);\n      this.modifyViewportColumnEnd(calc, nrOfRows);\n    }\n    /**\r\n     * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.\r\n     *\r\n     * @private\r\n     * @param {object} calc The column calculator object.\r\n     * @param {number} nrOfRows Number of visual rows.\r\n     */\n\n  }, {\n    key: \"modifyViewportColumnStart\",\n    value: function modifyViewportColumnStart(calc, nrOfRows) {\n      var columnMapper = this.hot.columnIndexMapper;\n      var visualStartCol = columnMapper.getVisualFromRenderableIndex(calc.startColumn);\n\n      for (var visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {\n        var mergeParentForViewportStart = this.mergedCellsCollection.get(visualRowIndex, visualStartCol);\n\n        if (isObject(mergeParentForViewportStart)) {\n          var renderableIndexAtMergeStart = columnMapper.getRenderableFromVisualIndex(columnMapper.getFirstNotHiddenIndex(mergeParentForViewportStart.col, 1)); // Merge start is out of the viewport (i.e. when we scrolled to the right and we can see just part of a merge).\n\n          if (renderableIndexAtMergeStart < calc.startColumn) {\n            // We extend viewport when some columns have been merged.\n            calc.startColumn = renderableIndexAtMergeStart; // We are looking for next merges inside already extended viewport (starting again from column equal to 0).\n\n            this.modifyViewportColumnStart(calc, nrOfRows); // recursively search upwards\n\n            return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n          }\n        }\n      }\n    }\n    /**\r\n     *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.\r\n     *\r\n     * @private\r\n     * @param {object} calc The column calculator object.\r\n     * @param {number} nrOfRows Number of visual rows.\r\n     */\n\n  }, {\n    key: \"modifyViewportColumnEnd\",\n    value: function modifyViewportColumnEnd(calc, nrOfRows) {\n      var columnMapper = this.hot.columnIndexMapper;\n      var visualEndCol = columnMapper.getVisualFromRenderableIndex(calc.endColumn);\n\n      for (var visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {\n        var mergeParentForViewportEnd = this.mergedCellsCollection.get(visualRowIndex, visualEndCol);\n\n        if (isObject(mergeParentForViewportEnd)) {\n          var mergeEnd = mergeParentForViewportEnd.col + mergeParentForViewportEnd.colspan - 1;\n          var renderableIndexAtMergeEnd = columnMapper.getRenderableFromVisualIndex(columnMapper.getFirstNotHiddenIndex(mergeEnd, -1)); // Merge end is out of the viewport.\n\n          if (renderableIndexAtMergeEnd > calc.endColumn) {\n            // We extend the viewport when some columns have been merged.\n            calc.endColumn = renderableIndexAtMergeEnd; // We are looking for next merges inside already extended viewport (starting again from column equal to 0).\n\n            this.modifyViewportColumnEnd(calc, nrOfRows); // recursively search upwards\n\n            return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n          }\n        }\n      }\n    }\n    /**\r\n     * Translates merged cell coordinates to renderable indexes.\r\n     *\r\n     * @private\r\n     * @param {number} parentRow Visual row index.\r\n     * @param {number} rowspan Rowspan which describes shift which will be applied to parent row\r\n     *                         to calculate renderable index which points to the most bottom\r\n     *                         index position. Pass rowspan as `0` to calculate the most top\r\n     *                         index position.\r\n     * @param {number} parentColumn Visual column index.\r\n     * @param {number} colspan Colspan which describes shift which will be applied to parent column\r\n     *                         to calculate renderable index which points to the most right\r\n     *                         index position. Pass colspan as `0` to calculate the most left\r\n     *                         index position.\r\n     * @returns {number[]}\r\n     */\n\n  }, {\n    key: \"translateMergedCellToRenderable\",\n    value: function translateMergedCellToRenderable(parentRow, rowspan, parentColumn, colspan) {\n      var _this$hot4 = this.hot,\n          rowMapper = _this$hot4.rowIndexMapper,\n          columnMapper = _this$hot4.columnIndexMapper;\n      var firstNonHiddenRow;\n      var firstNonHiddenColumn;\n\n      if (rowspan === 0) {\n        firstNonHiddenRow = rowMapper.getFirstNotHiddenIndex(parentRow, 1);\n      } else {\n        firstNonHiddenRow = rowMapper.getFirstNotHiddenIndex(parentRow + rowspan - 1, -1);\n      }\n\n      if (colspan === 0) {\n        firstNonHiddenColumn = columnMapper.getFirstNotHiddenIndex(parentColumn, 1);\n      } else {\n        firstNonHiddenColumn = columnMapper.getFirstNotHiddenIndex(parentColumn + colspan - 1, -1);\n      }\n\n      var renderableRow = parentRow >= 0 ? rowMapper.getRenderableFromVisualIndex(firstNonHiddenRow) : parentRow;\n      var renderableColumn = parentColumn >= 0 ? columnMapper.getRenderableFromVisualIndex(firstNonHiddenColumn) : parentColumn;\n      return [renderableRow, renderableColumn];\n    }\n    /**\r\n     * The `modifyAutofillRange` hook callback.\r\n     *\r\n     * @private\r\n     * @param {Array} drag The drag area coordinates.\r\n     * @param {Array} select The selection information.\r\n     * @returns {Array} The new drag area.\r\n     */\n\n  }, {\n    key: \"onModifyAutofillRange\",\n    value: function onModifyAutofillRange(drag, select) {\n      this.autofillCalculations.correctSelectionAreaSize(select);\n      var dragDirection = this.autofillCalculations.getDirection(select, drag);\n      var dragArea = drag;\n\n      if (this.autofillCalculations.dragAreaOverlapsCollections(select, dragArea, dragDirection)) {\n        dragArea = select;\n        return dragArea;\n      }\n\n      var mergedCellsWithinSelectionArea = this.mergedCellsCollection.getWithinRange({\n        from: {\n          row: select[0],\n          col: select[1]\n        },\n        to: {\n          row: select[2],\n          col: select[3]\n        }\n      });\n\n      if (!mergedCellsWithinSelectionArea) {\n        return dragArea;\n      }\n\n      dragArea = this.autofillCalculations.snapDragArea(select, dragArea, dragDirection, mergedCellsWithinSelectionArea);\n      return dragArea;\n    }\n    /**\r\n     * `afterCreateCol` hook callback.\r\n     *\r\n     * @private\r\n     * @param {number} column Column index.\r\n     * @param {number} count Number of created columns.\r\n     */\n\n  }, {\n    key: \"onAfterCreateCol\",\n    value: function onAfterCreateCol(column, count) {\n      this.mergedCellsCollection.shiftCollections('right', column, count);\n    }\n    /**\r\n     * `afterRemoveCol` hook callback.\r\n     *\r\n     * @private\r\n     * @param {number} column Column index.\r\n     * @param {number} count Number of removed columns.\r\n     */\n\n  }, {\n    key: \"onAfterRemoveCol\",\n    value: function onAfterRemoveCol(column, count) {\n      this.mergedCellsCollection.shiftCollections('left', column, count);\n    }\n    /**\r\n     * `afterCreateRow` hook callback.\r\n     *\r\n     * @private\r\n     * @param {number} row Row index.\r\n     * @param {number} count Number of created rows.\r\n     * @param {string} source Source of change.\r\n     */\n\n  }, {\n    key: \"onAfterCreateRow\",\n    value: function onAfterCreateRow(row, count, source) {\n      if (source === 'auto') {\n        return;\n      }\n\n      this.mergedCellsCollection.shiftCollections('down', row, count);\n    }\n    /**\r\n     * `afterRemoveRow` hook callback.\r\n     *\r\n     * @private\r\n     * @param {number} row Row index.\r\n     * @param {number} count Number of removed rows.\r\n     */\n\n  }, {\n    key: \"onAfterRemoveRow\",\n    value: function onAfterRemoveRow(row, count) {\n      this.mergedCellsCollection.shiftCollections('up', row, count);\n    }\n    /**\r\n     * `afterChange` hook callback. Used to propagate merged cells after using Autofill.\r\n     *\r\n     * @private\r\n     * @param {Array} changes The changes array.\r\n     * @param {string} source Determines the source of the change.\r\n     */\n\n  }, {\n    key: \"onAfterChange\",\n    value: function onAfterChange(changes, source) {\n      if (source !== 'Autofill.fill') {\n        return;\n      }\n\n      this.autofillCalculations.recreateAfterDataPopulation(changes);\n    }\n    /**\r\n     * `beforeDrawAreaBorders` hook callback.\r\n     *\r\n     * @private\r\n     * @param {Array} corners Visual coordinates of the area corners.\r\n     * @param {string} className Class name for the area.\r\n     */\n\n  }, {\n    key: \"onBeforeDrawAreaBorders\",\n    value: function onBeforeDrawAreaBorders(corners, className) {\n      if (className && className === 'area') {\n        var selectedRange = this.hot.getSelectedRangeLast();\n        var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(selectedRange);\n        arrayEach(mergedCellsWithinRange, function (mergedCell) {\n          if (selectedRange.getBottomRightCorner().row === mergedCell.getLastRow() && selectedRange.getBottomRightCorner().col === mergedCell.getLastColumn()) {\n            corners[2] = mergedCell.row;\n            corners[3] = mergedCell.col;\n          }\n        });\n      }\n    }\n    /**\r\n     * `afterModifyTransformStart` hook callback. Fixes a problem with navigating through merged cells at the edges of the table\r\n     * with the ENTER/SHIFT+ENTER/TAB/SHIFT+TAB keys.\r\n     *\r\n     * @private\r\n     * @param {CellCoords} coords Coordinates of the to-be-selected cell.\r\n     * @param {number} rowTransformDir Row transformation direction (negative value = up, 0 = none, positive value = down).\r\n     * @param {number} colTransformDir Column transformation direction (negative value = up, 0 = none, positive value = down).\r\n     */\n\n  }, {\n    key: \"onAfterModifyTransformStart\",\n    value: function onAfterModifyTransformStart(coords, rowTransformDir, colTransformDir) {\n      if (!this.enabled) {\n        return;\n      }\n\n      var mergedCellAtCoords = this.mergedCellsCollection.get(coords.row, coords.col);\n\n      if (!mergedCellAtCoords) {\n        return;\n      }\n\n      var goingDown = rowTransformDir > 0;\n      var goingUp = rowTransformDir < 0;\n      var goingLeft = colTransformDir < 0;\n      var goingRight = colTransformDir > 0;\n      var mergedCellOnBottomEdge = mergedCellAtCoords.row + mergedCellAtCoords.rowspan - 1 === this.hot.countRows() - 1;\n      var mergedCellOnTopEdge = mergedCellAtCoords.row === 0;\n      var mergedCellOnRightEdge = mergedCellAtCoords.col + mergedCellAtCoords.colspan - 1 === this.hot.countCols() - 1;\n      var mergedCellOnLeftEdge = mergedCellAtCoords.col === 0;\n\n      if (goingDown && mergedCellOnBottomEdge || goingUp && mergedCellOnTopEdge || goingRight && mergedCellOnRightEdge || goingLeft && mergedCellOnLeftEdge) {\n        coords.row = mergedCellAtCoords.row;\n        coords.col = mergedCellAtCoords.col;\n      }\n    }\n    /**\r\n     * `afterDrawSelection` hook callback. Used to add the additional class name for the entirely-selected merged cells.\r\n     *\r\n     * @private\r\n     * @param {number} currentRow Visual row index of the currently processed cell.\r\n     * @param {number} currentColumn Visual column index of the currently cell.\r\n     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\r\n     * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.\r\n     * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.\r\n     */\n\n  }, {\n    key: \"onAfterDrawSelection\",\n    value: function onAfterDrawSelection(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n      // Nothing's selected (hook might be triggered by the custom borders)\n      if (!cornersOfSelection) {\n        return;\n      }\n\n      return this.selectionCalculations.getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel);\n    }\n    /**\r\n     * `beforeRemoveCellClassNames` hook callback. Used to remove additional class name from all cells in the table.\r\n     *\r\n     * @private\r\n     * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\r\n     */\n\n  }, {\n    key: \"onBeforeRemoveCellClassNames\",\n    value: function onBeforeRemoveCellClassNames() {\n      return this.selectionCalculations.getSelectedMergedCellClassNameToRemove();\n    }\n  }], [{\n    key: \"PLUGIN_KEY\",\n    get: function get() {\n      return PLUGIN_KEY;\n    }\n  }, {\n    key: \"PLUGIN_PRIORITY\",\n    get: function get() {\n      return PLUGIN_PRIORITY;\n    }\n  }]);\n\n  return MergeCells;\n}(BasePlugin);","map":{"version":3,"sources":["C:/Users/ssaez1/technip-repositories/isotracker/isotracker-react/node_modules/handsontable/plugins/mergeCells/mergeCells.mjs"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","_i","_arr","_n","_d","_s","_e","call","next","done","push","value","length","err","Array","isArray","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","o","minLen","_arrayLikeToArray","n","Object","toString","slice","name","from","test","iter","len","arr2","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","_get","property","receiver","Reflect","get","base","_superPropBase","desc","getOwnPropertyDescriptor","object","hasOwnProperty","_getPrototypeOf","_inherits","subClass","superClass","create","_setPrototypeOf","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","construct","arguments","apply","_possibleConstructorReturn","self","_assertThisInitialized","ReferenceError","sham","Proxy","Boolean","valueOf","e","getPrototypeOf","BasePlugin","Hooks","stopImmediatePropagation","CellCoords","CellRange","MergedCellsCollection","MergedCellCoords","AutofillCalculations","SelectionCalculations","toggleMergeItem","arrayEach","isObject","clone","warn","rangeEach","applySpanProperties","getSingleton","register","PLUGIN_KEY","PLUGIN_PRIORITY","privatePool","WeakMap","MergeCells","_BasePlugin","_super","hotInstance","_this","set","lastDesiredCoords","mergedCellsCollection","autofillCalculations","selectionCalculations","isEnabled","hot","getSettings","enablePlugin","_this2","enabled","addHook","onAfterInit","onBeforeKeyDown","onModifyTransformStart","onAfterModifyTransformStart","onModifyTransformEnd","onModifyGetCellCoords","onBeforeSetRangeStart","onBeforeSetRangeEnd","onAfterIsMultipleSelection","onAfterRenderer","addMergeActionsToContextMenu","onAfterGetCellMeta","onAfterViewportRowCalculatorOverride","onAfterViewportColumnCalculatorOverride","onModifyAutofillRange","onAfterCreateCol","onAfterRemoveCol","onAfterCreateRow","onAfterRemoveRow","onAfterChange","onBeforeDrawAreaBorders","onAfterDrawSelection","onBeforeRemoveCellClassNames","action","source","disablePlugin","clearCollections","render","updatePlugin","settings","generateFromSettings","validateSetting","setting","valid","containsNegativeValues","NEGATIVE_VALUES_WARNING","isOutOfBounds","countRows","countCols","IS_OUT_OF_BOUNDS_WARNING","isSingleCell","IS_SINGLE_CELL","containsZeroSpan","ZERO_SPAN_WARNING","_this3","_this$hot","populationArgumentsList","highlight","row","col","rangeEnd","rowspan","colspan","mergeRange","filter","bulkPopulationData","getBulkCollectionData","populateFromArray","_this$hot2","populationDataRange","getBulkCollectionDataRange","dataAtRange","getData","newDataAtRange","splice","mergedCellArguments","_mergedCellArguments","mergedCellRowIndex","mergedCellColumnIndex","mergedCellData","mergedCellRow","rowIndex","mergedCellElement","columnIndex","start","end","mergedCellColumn","Math","min","max","concat","clear","canMergeRange","newMergedCellInfo","auto","undefined","toggleMergeOnSelection","currentRange","getSelectedRangeLast","setDirection","to","toggleMerge","selectCell","mergeSelection","cellRange","unmergeRange","unmergeSelection","_this4","preventPopulation","topLeft","getTopLeftCorner","bottomRight","getBottomRightCorner","mergeParent","clearedData","populationInfo","runHooks","j","clearedValue","getDataAtCell","setCellMeta","mergedCellAdded","add","pluginName","_this5","mergedCells","getWithinRange","currentCollection","remove","removeCellMeta","mergedCell","mergedCellCoversWholeRange","merge","startRow","startColumn","endRow","endColumn","unmerge","event","ctrlDown","ctrlKey","metaKey","altKey","keyCode","isMultiple","selectionRange","group","delta","priv","currentlySelectedRange","newDelta","nextPosition","currentPosition","mergedParent","mergeTopLeft","mergeBottomRight","includes","nextPositionMergedCell","firstRenderableCoords","getFirstRenderableCoords","_this6","currentSelectionRange","newSelectionRange","getUpdatedSelectionRange","tempDelta","mergedCellsWithinRange","snapDelta","column","mergeRow","mergeColumn","defaultOptions","items","TD","mergedCellCopy","_this$hot3","rowMapper","rowIndexMapper","columnMapper","columnIndexMapper","_this$translateMerged","translateMergedCellToRenderable","_this$translateMerged2","lastMergedRowIndex","lastMergedColumnIndex","renderedRowIndex","getRenderableFromVisualIndex","renderedColumnIndex","maxRowSpan","maxColSpan","getFirstNotHiddenIndex","coords","isFirstRenderableMergedCell","_ref","selRange","rangeExpanded","selection","isSelectedByColumnHeader","isSelectedByRowHeader","cellInfo","mergedCellRange","getRange","expandByRange","cellProperties","copyable","calc","nrOfColumns","modifyViewportRowStart","modifyViewportRowEnd","visualStartRow","getVisualFromRenderableIndex","visualColumnIndex","mergeParentForViewportStart","renderableIndexAtMergeStart","visualEndRow","mergeParentForViewportEnd","mergeEnd","renderableIndexAtMergeEnd","nrOfRows","modifyViewportColumnStart","modifyViewportColumnEnd","visualStartCol","visualRowIndex","visualEndCol","parentRow","parentColumn","_this$hot4","firstNonHiddenRow","firstNonHiddenColumn","renderableRow","renderableColumn","drag","select","correctSelectionAreaSize","dragDirection","getDirection","dragArea","dragAreaOverlapsCollections","mergedCellsWithinSelectionArea","snapDragArea","count","shiftCollections","changes","recreateAfterDataPopulation","corners","className","selectedRange","getLastRow","getLastColumn","rowTransformDir","colTransformDir","mergedCellAtCoords","goingDown","goingUp","goingLeft","goingRight","mergedCellOnBottomEdge","mergedCellOnTopEdge","mergedCellOnRightEdge","mergedCellOnLeftEdge","currentRow","currentColumn","cornersOfSelection","layerLevel","getSelectedMergedCellClassName","getSelectedMergedCellClassNameToRemove"],"mappings":"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","sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\r\n\r\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\r\n\r\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\r\n\r\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\r\n\r\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\r\n\r\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\r\n\r\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\r\n\r\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\r\n\r\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\r\n\r\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\r\n\r\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\r\n\r\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\r\n\r\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\r\n\r\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\r\n\r\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\r\n\r\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\r\n\r\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\r\n\r\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\r\n\r\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\r\n\r\nimport \"core-js/modules/es.array.iterator.js\";\r\nimport \"core-js/modules/es.object.to-string.js\";\r\nimport \"core-js/modules/es.string.iterator.js\";\r\nimport \"core-js/modules/es.weak-map.js\";\r\nimport \"core-js/modules/web.dom-collections.iterator.js\";\r\nimport \"core-js/modules/es.array.filter.js\";\r\nimport \"core-js/modules/es.array.splice.js\";\r\nimport \"core-js/modules/es.array.concat.js\";\r\nimport \"core-js/modules/es.array.includes.js\";\r\nimport \"core-js/modules/es.string.includes.js\";\r\nimport \"core-js/modules/es.object.set-prototype-of.js\";\r\nimport \"core-js/modules/es.object.get-prototype-of.js\";\r\nimport \"core-js/modules/es.reflect.construct.js\";\r\nimport \"core-js/modules/es.reflect.get.js\";\r\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\r\nimport \"core-js/modules/es.symbol.js\";\r\nimport \"core-js/modules/es.symbol.description.js\";\r\nimport \"core-js/modules/es.symbol.iterator.js\";\r\nimport \"core-js/modules/es.array.from.js\";\r\nimport \"core-js/modules/es.array.slice.js\";\r\nimport \"core-js/modules/es.function.name.js\";\r\nimport { BasePlugin } from \"../base/index.mjs\";\r\nimport Hooks from \"../../pluginHooks.mjs\";\r\nimport { stopImmediatePropagation } from \"../../helpers/dom/event.mjs\";\r\nimport { CellCoords, CellRange } from \"../../3rdparty/walkontable/src/index.mjs\";\r\nimport MergedCellsCollection from \"./cellsCollection.mjs\";\r\nimport MergedCellCoords from \"./cellCoords.mjs\";\r\nimport AutofillCalculations from \"./calculations/autofill.mjs\";\r\nimport SelectionCalculations from \"./calculations/selection.mjs\";\r\nimport toggleMergeItem from \"./contextMenuItem/toggleMerge.mjs\";\r\nimport { arrayEach } from \"../../helpers/array.mjs\";\r\nimport { isObject, clone } from \"../../helpers/object.mjs\";\r\nimport { warn } from \"../../helpers/console.mjs\";\r\nimport { rangeEach } from \"../../helpers/number.mjs\";\r\nimport { applySpanProperties } from \"./utils.mjs\";\r\nHooks.getSingleton().register('beforeMergeCells');\r\nHooks.getSingleton().register('afterMergeCells');\r\nHooks.getSingleton().register('beforeUnmergeCells');\r\nHooks.getSingleton().register('afterUnmergeCells');\r\nexport var PLUGIN_KEY = 'mergeCells';\r\nexport var PLUGIN_PRIORITY = 150;\r\nvar privatePool = new WeakMap();\r\n/**\r\n * @plugin MergeCells\r\n *\r\n * @description\r\n * Plugin, which allows merging cells in the table (using the initial configuration, API or context menu).\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * const hot = new Handsontable(document.getElementById('example'), {\r\n *  data: getData(),\r\n *  mergeCells: [\r\n *    {row: 0, col: 3, rowspan: 3, colspan: 3},\r\n *    {row: 2, col: 6, rowspan: 2, colspan: 2},\r\n *    {row: 4, col: 8, rowspan: 3, colspan: 3}\r\n *  ],\r\n * ```\r\n */\r\n\r\nexport var MergeCells = /*#__PURE__*/function (_BasePlugin) {\r\n  _inherits(MergeCells, _BasePlugin);\r\n\r\n  var _super = _createSuper(MergeCells);\r\n\r\n  function MergeCells(hotInstance) {\r\n    var _this;\r\n\r\n    _classCallCheck(this, MergeCells);\r\n\r\n    _this = _super.call(this, hotInstance);\r\n    privatePool.set(_assertThisInitialized(_this), {\r\n      lastDesiredCoords: null\r\n    });\r\n    /**\r\n     * A container for all the merged cells.\r\n     *\r\n     * @private\r\n     * @type {MergedCellsCollection}\r\n     */\r\n\r\n    _this.mergedCellsCollection = null;\r\n    /**\r\n     * Instance of the class responsible for all the autofill-related calculations.\r\n     *\r\n     * @private\r\n     * @type {AutofillCalculations}\r\n     */\r\n\r\n    _this.autofillCalculations = null;\r\n    /**\r\n     * Instance of the class responsible for the selection-related calculations.\r\n     *\r\n     * @private\r\n     * @type {SelectionCalculations}\r\n     */\r\n\r\n    _this.selectionCalculations = null;\r\n    return _this;\r\n  }\r\n  /**\r\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\r\n   * hook and if it returns `true` than the {@link MergeCells#enablePlugin} method is called.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n\r\n\r\n  _createClass(MergeCells, [{\r\n    key: \"isEnabled\",\r\n    value: function isEnabled() {\r\n      return !!this.hot.getSettings()[PLUGIN_KEY];\r\n    }\r\n    /**\r\n     * Enables the plugin functionality for this Handsontable instance.\r\n     */\r\n\r\n  }, {\r\n    key: \"enablePlugin\",\r\n    value: function enablePlugin() {\r\n      var _this2 = this;\r\n\r\n      if (this.enabled) {\r\n        return;\r\n      }\r\n\r\n      this.mergedCellsCollection = new MergedCellsCollection(this);\r\n      this.autofillCalculations = new AutofillCalculations(this);\r\n      this.selectionCalculations = new SelectionCalculations(this);\r\n      this.addHook('afterInit', function () {\r\n        return _this2.onAfterInit.apply(_this2, arguments);\r\n      });\r\n      this.addHook('beforeKeyDown', function () {\r\n        return _this2.onBeforeKeyDown.apply(_this2, arguments);\r\n      });\r\n      this.addHook('modifyTransformStart', function () {\r\n        return _this2.onModifyTransformStart.apply(_this2, arguments);\r\n      });\r\n      this.addHook('afterModifyTransformStart', function () {\r\n        return _this2.onAfterModifyTransformStart.apply(_this2, arguments);\r\n      });\r\n      this.addHook('modifyTransformEnd', function () {\r\n        return _this2.onModifyTransformEnd.apply(_this2, arguments);\r\n      });\r\n      this.addHook('modifyGetCellCoords', function () {\r\n        return _this2.onModifyGetCellCoords.apply(_this2, arguments);\r\n      });\r\n      this.addHook('beforeSetRangeStart', function () {\r\n        return _this2.onBeforeSetRangeStart.apply(_this2, arguments);\r\n      });\r\n      this.addHook('beforeSetRangeStartOnly', function () {\r\n        return _this2.onBeforeSetRangeStart.apply(_this2, arguments);\r\n      });\r\n      this.addHook('beforeSetRangeEnd', function () {\r\n        return _this2.onBeforeSetRangeEnd.apply(_this2, arguments);\r\n      });\r\n      this.addHook('afterIsMultipleSelection', function () {\r\n        return _this2.onAfterIsMultipleSelection.apply(_this2, arguments);\r\n      });\r\n      this.addHook('afterRenderer', function () {\r\n        return _this2.onAfterRenderer.apply(_this2, arguments);\r\n      });\r\n      this.addHook('afterContextMenuDefaultOptions', function () {\r\n        return _this2.addMergeActionsToContextMenu.apply(_this2, arguments);\r\n      });\r\n      this.addHook('afterGetCellMeta', function () {\r\n        return _this2.onAfterGetCellMeta.apply(_this2, arguments);\r\n      });\r\n      this.addHook('afterViewportRowCalculatorOverride', function () {\r\n        return _this2.onAfterViewportRowCalculatorOverride.apply(_this2, arguments);\r\n      });\r\n      this.addHook('afterViewportColumnCalculatorOverride', function () {\r\n        return _this2.onAfterViewportColumnCalculatorOverride.apply(_this2, arguments);\r\n      });\r\n      this.addHook('modifyAutofillRange', function () {\r\n        return _this2.onModifyAutofillRange.apply(_this2, arguments);\r\n      });\r\n      this.addHook('afterCreateCol', function () {\r\n        return _this2.onAfterCreateCol.apply(_this2, arguments);\r\n      });\r\n      this.addHook('afterRemoveCol', function () {\r\n        return _this2.onAfterRemoveCol.apply(_this2, arguments);\r\n      });\r\n      this.addHook('afterCreateRow', function () {\r\n        return _this2.onAfterCreateRow.apply(_this2, arguments);\r\n      });\r\n      this.addHook('afterRemoveRow', function () {\r\n        return _this2.onAfterRemoveRow.apply(_this2, arguments);\r\n      });\r\n      this.addHook('afterChange', function () {\r\n        return _this2.onAfterChange.apply(_this2, arguments);\r\n      });\r\n      this.addHook('beforeDrawBorders', function () {\r\n        return _this2.onBeforeDrawAreaBorders.apply(_this2, arguments);\r\n      });\r\n      this.addHook('afterDrawSelection', function () {\r\n        return _this2.onAfterDrawSelection.apply(_this2, arguments);\r\n      });\r\n      this.addHook('beforeRemoveCellClassNames', function () {\r\n        return _this2.onBeforeRemoveCellClassNames.apply(_this2, arguments);\r\n      });\r\n      this.addHook('beforeUndoStackChange', function (action, source) {\r\n        if (source === 'MergeCells') {\r\n          return false;\r\n        }\r\n      });\r\n\r\n      _get(_getPrototypeOf(MergeCells.prototype), \"enablePlugin\", this).call(this);\r\n    }\r\n    /**\r\n     * Disables the plugin functionality for this Handsontable instance.\r\n     */\r\n\r\n  }, {\r\n    key: \"disablePlugin\",\r\n    value: function disablePlugin() {\r\n      this.clearCollections();\r\n      this.hot.render();\r\n\r\n      _get(_getPrototypeOf(MergeCells.prototype), \"disablePlugin\", this).call(this);\r\n    }\r\n    /**\r\n     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.\r\n     */\r\n\r\n  }, {\r\n    key: \"updatePlugin\",\r\n    value: function updatePlugin() {\r\n      var settings = this.hot.getSettings()[PLUGIN_KEY];\r\n      this.disablePlugin();\r\n      this.enablePlugin();\r\n      this.generateFromSettings(settings);\r\n\r\n      _get(_getPrototypeOf(MergeCells.prototype), \"updatePlugin\", this).call(this);\r\n    }\r\n    /**\r\n     * Validates a single setting object, represented by a single merged cell information object.\r\n     *\r\n     * @private\r\n     * @param {object} setting An object with `row`, `col`, `rowspan` and `colspan` properties.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"validateSetting\",\r\n    value: function validateSetting(setting) {\r\n      var valid = true;\r\n\r\n      if (!setting) {\r\n        return false;\r\n      }\r\n\r\n      if (MergedCellCoords.containsNegativeValues(setting)) {\r\n        warn(MergedCellCoords.NEGATIVE_VALUES_WARNING(setting));\r\n        valid = false;\r\n      } else if (MergedCellCoords.isOutOfBounds(setting, this.hot.countRows(), this.hot.countCols())) {\r\n        warn(MergedCellCoords.IS_OUT_OF_BOUNDS_WARNING(setting));\r\n        valid = false;\r\n      } else if (MergedCellCoords.isSingleCell(setting)) {\r\n        warn(MergedCellCoords.IS_SINGLE_CELL(setting));\r\n        valid = false;\r\n      } else if (MergedCellCoords.containsZeroSpan(setting)) {\r\n        warn(MergedCellCoords.ZERO_SPAN_WARNING(setting));\r\n        valid = false;\r\n      }\r\n\r\n      return valid;\r\n    }\r\n    /**\r\n     * Generates the merged cells from the settings provided to the plugin.\r\n     *\r\n     * @private\r\n     * @param {Array|boolean} settings The settings provided to the plugin.\r\n     */\r\n\r\n  }, {\r\n    key: \"generateFromSettings\",\r\n    value: function generateFromSettings(settings) {\r\n      var _this3 = this;\r\n\r\n      if (Array.isArray(settings)) {\r\n        var _this$hot;\r\n\r\n        var populationArgumentsList = [];\r\n        arrayEach(settings, function (setting) {\r\n          if (!_this3.validateSetting(setting)) {\r\n            return;\r\n          }\r\n\r\n          var highlight = new CellCoords(setting.row, setting.col);\r\n          var rangeEnd = new CellCoords(setting.row + setting.rowspan - 1, setting.col + setting.colspan - 1);\r\n          var mergeRange = new CellRange(highlight, highlight, rangeEnd);\r\n          populationArgumentsList.push(_this3.mergeRange(mergeRange, true, true));\r\n        }); // remove 'empty' setting objects, caused by improper merge range declarations\r\n\r\n        populationArgumentsList = populationArgumentsList.filter(function (value) {\r\n          return value !== true;\r\n        });\r\n        var bulkPopulationData = this.getBulkCollectionData(populationArgumentsList);\r\n\r\n        (_this$hot = this.hot).populateFromArray.apply(_this$hot, _toConsumableArray(bulkPopulationData));\r\n      }\r\n    }\r\n    /**\r\n     * Generates a bulk set of all the data to be populated to fill the data \"under\" the added merged cells.\r\n     *\r\n     * @private\r\n     * @param {Array} populationArgumentsList Array in a form of `[row, column, dataUnderCollection]`.\r\n     * @returns {Array} Array in a form of `[row, column, dataOfAllCollections]`.\r\n     */\r\n\r\n  }, {\r\n    key: \"getBulkCollectionData\",\r\n    value: function getBulkCollectionData(populationArgumentsList) {\r\n      var _this$hot2;\r\n\r\n      var populationDataRange = this.getBulkCollectionDataRange(populationArgumentsList);\r\n\r\n      var dataAtRange = (_this$hot2 = this.hot).getData.apply(_this$hot2, _toConsumableArray(populationDataRange));\r\n\r\n      var newDataAtRange = dataAtRange.splice(0);\r\n      arrayEach(populationArgumentsList, function (mergedCellArguments) {\r\n        var _mergedCellArguments = _slicedToArray(mergedCellArguments, 3),\r\n            mergedCellRowIndex = _mergedCellArguments[0],\r\n            mergedCellColumnIndex = _mergedCellArguments[1],\r\n            mergedCellData = _mergedCellArguments[2];\r\n\r\n        arrayEach(mergedCellData, function (mergedCellRow, rowIndex) {\r\n          arrayEach(mergedCellRow, function (mergedCellElement, columnIndex) {\r\n            newDataAtRange[mergedCellRowIndex - populationDataRange[0] + rowIndex][mergedCellColumnIndex - populationDataRange[1] + columnIndex] = mergedCellElement; // eslint-disable-line max-len\r\n          });\r\n        });\r\n      });\r\n      return [populationDataRange[0], populationDataRange[1], newDataAtRange];\r\n    }\r\n    /**\r\n     * Gets the range of combined data ranges provided in a form of an array of arrays ([row, column, dataUnderCollection]).\r\n     *\r\n     * @private\r\n     * @param {Array} populationArgumentsList Array containing argument lists for the `populateFromArray` method - row, column and data for population.\r\n     * @returns {Array[]} Start and end coordinates of the merged cell range. (in a form of [rowIndex, columnIndex]).\r\n     */\r\n\r\n  }, {\r\n    key: \"getBulkCollectionDataRange\",\r\n    value: function getBulkCollectionDataRange(populationArgumentsList) {\r\n      var start = [0, 0];\r\n      var end = [0, 0];\r\n      var mergedCellRow = null;\r\n      var mergedCellColumn = null;\r\n      var mergedCellData = null;\r\n      arrayEach(populationArgumentsList, function (mergedCellArguments) {\r\n        mergedCellRow = mergedCellArguments[0];\r\n        mergedCellColumn = mergedCellArguments[1];\r\n        mergedCellData = mergedCellArguments[2];\r\n        start[0] = Math.min(mergedCellRow, start[0]);\r\n        start[1] = Math.min(mergedCellColumn, start[1]);\r\n        end[0] = Math.max(mergedCellRow + mergedCellData.length - 1, end[0]);\r\n        end[1] = Math.max(mergedCellColumn + mergedCellData[0].length - 1, end[1]);\r\n      });\r\n      return [].concat(start, end);\r\n    }\r\n    /**\r\n     * Clears the merged cells from the merged cell container.\r\n     */\r\n\r\n  }, {\r\n    key: \"clearCollections\",\r\n    value: function clearCollections() {\r\n      this.mergedCellsCollection.clear();\r\n    }\r\n    /**\r\n     * Returns `true` if a range is mergeable.\r\n     *\r\n     * @private\r\n     * @param {object} newMergedCellInfo Merged cell information object to test.\r\n     * @param {boolean} [auto=false] `true` if triggered at initialization.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"canMergeRange\",\r\n    value: function canMergeRange(newMergedCellInfo) {\r\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n      return auto ? true : this.validateSetting(newMergedCellInfo);\r\n    }\r\n    /**\r\n     * Merge or unmerge, based on last selected range.\r\n     *\r\n     * @private\r\n     */\r\n\r\n  }, {\r\n    key: \"toggleMergeOnSelection\",\r\n    value: function toggleMergeOnSelection() {\r\n      var currentRange = this.hot.getSelectedRangeLast();\r\n\r\n      if (!currentRange) {\r\n        return;\r\n      }\r\n\r\n      currentRange.setDirection('NW-SE');\r\n      var from = currentRange.from,\r\n          to = currentRange.to;\r\n      this.toggleMerge(currentRange);\r\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\r\n    }\r\n    /**\r\n     * Merges the selection provided as a cell range.\r\n     *\r\n     * @param {CellRange} [cellRange] Selection cell range.\r\n     */\r\n\r\n  }, {\r\n    key: \"mergeSelection\",\r\n    value: function mergeSelection() {\r\n      var cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\r\n\r\n      if (!cellRange) {\r\n        return;\r\n      }\r\n\r\n      cellRange.setDirection('NW-SE');\r\n      var from = cellRange.from,\r\n          to = cellRange.to;\r\n      this.unmergeRange(cellRange, true);\r\n      this.mergeRange(cellRange);\r\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\r\n    }\r\n    /**\r\n     * Unmerges the selection provided as a cell range.\r\n     *\r\n     * @param {CellRange} [cellRange] Selection cell range.\r\n     */\r\n\r\n  }, {\r\n    key: \"unmergeSelection\",\r\n    value: function unmergeSelection() {\r\n      var cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\r\n\r\n      if (!cellRange) {\r\n        return;\r\n      }\r\n\r\n      var from = cellRange.from,\r\n          to = cellRange.to;\r\n      this.unmergeRange(cellRange, true);\r\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\r\n    }\r\n    /**\r\n     * Merges cells in the provided cell range.\r\n     *\r\n     * @private\r\n     * @param {CellRange} cellRange Cell range to merge.\r\n     * @param {boolean} [auto=false] `true` if is called automatically, e.g. At initialization.\r\n     * @param {boolean} [preventPopulation=false] `true`, if the method should not run `populateFromArray` at the end, but rather return its arguments.\r\n     * @returns {Array|boolean} Returns an array of [row, column, dataUnderCollection] if preventPopulation is set to true. If the the merging process went successful, it returns `true`, otherwise - `false`.\r\n     * @fires Hooks#beforeMergeCells\r\n     * @fires Hooks#afterMergeCells\r\n     */\r\n\r\n  }, {\r\n    key: \"mergeRange\",\r\n    value: function mergeRange(cellRange) {\r\n      var _this4 = this;\r\n\r\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n      var preventPopulation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n      var topLeft = cellRange.getTopLeftCorner();\r\n      var bottomRight = cellRange.getBottomRightCorner();\r\n      var mergeParent = {\r\n        row: topLeft.row,\r\n        col: topLeft.col,\r\n        rowspan: bottomRight.row - topLeft.row + 1,\r\n        colspan: bottomRight.col - topLeft.col + 1\r\n      };\r\n      var clearedData = [];\r\n      var populationInfo = null;\r\n\r\n      if (!this.canMergeRange(mergeParent, auto)) {\r\n        return false;\r\n      }\r\n\r\n      this.hot.runHooks('beforeMergeCells', cellRange, auto);\r\n      rangeEach(0, mergeParent.rowspan - 1, function (i) {\r\n        rangeEach(0, mergeParent.colspan - 1, function (j) {\r\n          var clearedValue = null;\r\n\r\n          if (!clearedData[i]) {\r\n            clearedData[i] = [];\r\n          }\r\n\r\n          if (i === 0 && j === 0) {\r\n            clearedValue = _this4.hot.getDataAtCell(mergeParent.row, mergeParent.col);\r\n          } else {\r\n            _this4.hot.setCellMeta(mergeParent.row + i, mergeParent.col + j, 'hidden', true);\r\n          }\r\n\r\n          clearedData[i][j] = clearedValue;\r\n        });\r\n      });\r\n      this.hot.setCellMeta(mergeParent.row, mergeParent.col, 'spanned', true);\r\n      var mergedCellAdded = this.mergedCellsCollection.add(mergeParent);\r\n\r\n      if (mergedCellAdded) {\r\n        if (preventPopulation) {\r\n          populationInfo = [mergeParent.row, mergeParent.col, clearedData];\r\n        } else {\r\n          this.hot.populateFromArray(mergeParent.row, mergeParent.col, clearedData, void 0, void 0, this.pluginName);\r\n        }\r\n\r\n        this.hot.runHooks('afterMergeCells', cellRange, mergeParent, auto);\r\n        return populationInfo;\r\n      }\r\n\r\n      return true;\r\n    }\r\n    /**\r\n     * Unmerges the selection provided as a cell range. If no cell range is provided, it uses the current selection.\r\n     *\r\n     * @private\r\n     * @param {CellRange} cellRange Selection cell range.\r\n     * @param {boolean} [auto=false] `true` if called automatically by the plugin.\r\n     *\r\n     * @fires Hooks#beforeUnmergeCells\r\n     * @fires Hooks#afterUnmergeCells\r\n     */\r\n\r\n  }, {\r\n    key: \"unmergeRange\",\r\n    value: function unmergeRange(cellRange) {\r\n      var _this5 = this;\r\n\r\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n      var mergedCells = this.mergedCellsCollection.getWithinRange(cellRange);\r\n\r\n      if (!mergedCells) {\r\n        return;\r\n      }\r\n\r\n      this.hot.runHooks('beforeUnmergeCells', cellRange, auto);\r\n      arrayEach(mergedCells, function (currentCollection) {\r\n        _this5.mergedCellsCollection.remove(currentCollection.row, currentCollection.col);\r\n\r\n        rangeEach(0, currentCollection.rowspan - 1, function (i) {\r\n          rangeEach(0, currentCollection.colspan - 1, function (j) {\r\n            _this5.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, 'hidden');\r\n          });\r\n        });\r\n\r\n        _this5.hot.removeCellMeta(currentCollection.row, currentCollection.col, 'spanned');\r\n      });\r\n      this.hot.runHooks('afterUnmergeCells', cellRange, auto);\r\n      this.hot.render();\r\n    }\r\n    /**\r\n     * Merges or unmerges, based on the cell range provided as `cellRange`.\r\n     *\r\n     * @private\r\n     * @param {CellRange} cellRange The cell range to merge or unmerged.\r\n     */\r\n\r\n  }, {\r\n    key: \"toggleMerge\",\r\n    value: function toggleMerge(cellRange) {\r\n      var mergedCell = this.mergedCellsCollection.get(cellRange.from.row, cellRange.from.col);\r\n      var mergedCellCoversWholeRange = mergedCell.row === cellRange.from.row && mergedCell.col === cellRange.from.col && mergedCell.row + mergedCell.rowspan - 1 === cellRange.to.row && mergedCell.col + mergedCell.colspan - 1 === cellRange.to.col;\r\n\r\n      if (mergedCellCoversWholeRange) {\r\n        this.unmergeRange(cellRange);\r\n      } else {\r\n        this.mergeSelection(cellRange);\r\n      }\r\n    }\r\n    /**\r\n     * Merges the specified range.\r\n     *\r\n     * @param {number} startRow Start row of the merged cell.\r\n     * @param {number} startColumn Start column of the merged cell.\r\n     * @param {number} endRow End row of the merged cell.\r\n     * @param {number} endColumn End column of the merged cell.\r\n     * @fires Hooks#beforeMergeCells\r\n     * @fires Hooks#afterMergeCells\r\n     */\r\n\r\n  }, {\r\n    key: \"merge\",\r\n    value: function merge(startRow, startColumn, endRow, endColumn) {\r\n      var start = new CellCoords(startRow, startColumn);\r\n      var end = new CellCoords(endRow, endColumn);\r\n      this.mergeRange(new CellRange(start, start, end));\r\n    }\r\n    /**\r\n     * Unmerges the merged cell in the provided range.\r\n     *\r\n     * @param {number} startRow Start row of the merged cell.\r\n     * @param {number} startColumn Start column of the merged cell.\r\n     * @param {number} endRow End row of the merged cell.\r\n     * @param {number} endColumn End column of the merged cell.\r\n     * @fires Hooks#beforeUnmergeCells\r\n     * @fires Hooks#afterUnmergeCells\r\n     */\r\n\r\n  }, {\r\n    key: \"unmerge\",\r\n    value: function unmerge(startRow, startColumn, endRow, endColumn) {\r\n      var start = new CellCoords(startRow, startColumn);\r\n      var end = new CellCoords(endRow, endColumn);\r\n      this.unmergeRange(new CellRange(start, start, end));\r\n    }\r\n    /**\r\n     * `afterInit` hook callback.\r\n     *\r\n     * @private\r\n     */\r\n\r\n  }, {\r\n    key: \"onAfterInit\",\r\n    value: function onAfterInit() {\r\n      this.generateFromSettings(this.hot.getSettings()[PLUGIN_KEY]);\r\n      this.hot.render();\r\n    }\r\n    /**\r\n     * `beforeKeyDown` hook callback.\r\n     *\r\n     * @private\r\n     * @param {KeyboardEvent} event The `keydown` event object.\r\n     */\r\n\r\n  }, {\r\n    key: \"onBeforeKeyDown\",\r\n    value: function onBeforeKeyDown(event) {\r\n      var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;\r\n\r\n      if (ctrlDown && event.keyCode === 77) {\r\n        // CTRL + M\r\n        this.toggleMerge(this.hot.getSelectedRangeLast());\r\n        this.hot.render();\r\n        stopImmediatePropagation(event);\r\n      }\r\n    }\r\n    /**\r\n     * Modifies the information on whether the current selection contains multiple cells. The `afterIsMultipleSelection` hook callback.\r\n     *\r\n     * @private\r\n     * @param {boolean} isMultiple Determines whether the current selection contains multiple cells.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"onAfterIsMultipleSelection\",\r\n    value: function onAfterIsMultipleSelection(isMultiple) {\r\n      if (isMultiple) {\r\n        var mergedCells = this.mergedCellsCollection.mergedCells;\r\n        var selectionRange = this.hot.getSelectedRangeLast();\r\n\r\n        for (var group = 0; group < mergedCells.length; group += 1) {\r\n          if (selectionRange.from.row === mergedCells[group].row && selectionRange.from.col === mergedCells[group].col && selectionRange.to.row === mergedCells[group].row + mergedCells[group].rowspan - 1 && selectionRange.to.col === mergedCells[group].col + mergedCells[group].colspan - 1) {\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n\r\n      return isMultiple;\r\n    }\r\n    /**\r\n     * `modifyTransformStart` hook callback.\r\n     *\r\n     * @private\r\n     * @param {object} delta The transformation delta.\r\n     */\r\n\r\n  }, {\r\n    key: \"onModifyTransformStart\",\r\n    value: function onModifyTransformStart(delta) {\r\n      var priv = privatePool.get(this);\r\n      var currentlySelectedRange = this.hot.getSelectedRangeLast();\r\n      var newDelta = {\r\n        row: delta.row,\r\n        col: delta.col\r\n      };\r\n      var nextPosition = null;\r\n      var currentPosition = new CellCoords(currentlySelectedRange.highlight.row, currentlySelectedRange.highlight.col);\r\n      var mergedParent = this.mergedCellsCollection.get(currentPosition.row, currentPosition.col);\r\n\r\n      if (!priv.lastDesiredCoords) {\r\n        priv.lastDesiredCoords = new CellCoords(null, null);\r\n      }\r\n\r\n      if (mergedParent) {\r\n        // only merge selected\r\n        var mergeTopLeft = new CellCoords(mergedParent.row, mergedParent.col);\r\n        var mergeBottomRight = new CellCoords(mergedParent.row + mergedParent.rowspan - 1, mergedParent.col + mergedParent.colspan - 1);\r\n        var mergeRange = new CellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight);\r\n\r\n        if (!mergeRange.includes(priv.lastDesiredCoords)) {\r\n          priv.lastDesiredCoords = new CellCoords(null, null); // reset outdated version of lastDesiredCoords\r\n        }\r\n\r\n        newDelta.row = priv.lastDesiredCoords.row ? priv.lastDesiredCoords.row - currentPosition.row : newDelta.row;\r\n        newDelta.col = priv.lastDesiredCoords.col ? priv.lastDesiredCoords.col - currentPosition.col : newDelta.col;\r\n\r\n        if (delta.row > 0) {\r\n          // moving down\r\n          newDelta.row = mergedParent.row + mergedParent.rowspan - 1 - currentPosition.row + delta.row;\r\n        } else if (delta.row < 0) {\r\n          // moving up\r\n          newDelta.row = currentPosition.row - mergedParent.row + delta.row;\r\n        }\r\n\r\n        if (delta.col > 0) {\r\n          // moving right\r\n          newDelta.col = mergedParent.col + mergedParent.colspan - 1 - currentPosition.col + delta.col;\r\n        } else if (delta.col < 0) {\r\n          // moving left\r\n          newDelta.col = currentPosition.col - mergedParent.col + delta.col;\r\n        }\r\n      }\r\n\r\n      nextPosition = new CellCoords(currentlySelectedRange.highlight.row + newDelta.row, currentlySelectedRange.highlight.col + newDelta.col);\r\n      var nextPositionMergedCell = this.mergedCellsCollection.get(nextPosition.row, nextPosition.col);\r\n\r\n      if (nextPositionMergedCell) {\r\n        // skipping the invisible cells in the merge range\r\n        var firstRenderableCoords = this.mergedCellsCollection.getFirstRenderableCoords(nextPositionMergedCell.row, nextPositionMergedCell.col);\r\n        priv.lastDesiredCoords = nextPosition;\r\n        newDelta = {\r\n          row: firstRenderableCoords.row - currentPosition.row,\r\n          col: firstRenderableCoords.col - currentPosition.col\r\n        };\r\n      }\r\n\r\n      if (newDelta.row !== 0) {\r\n        delta.row = newDelta.row;\r\n      }\r\n\r\n      if (newDelta.col !== 0) {\r\n        delta.col = newDelta.col;\r\n      }\r\n    }\r\n    /**\r\n     * `modifyTransformEnd` hook callback. Needed to handle \"jumping over\" merged merged cells, while selecting.\r\n     *\r\n     * @private\r\n     * @param {object} delta The transformation delta.\r\n     */\r\n\r\n  }, {\r\n    key: \"onModifyTransformEnd\",\r\n    value: function onModifyTransformEnd(delta) {\r\n      var _this6 = this;\r\n\r\n      var currentSelectionRange = this.hot.getSelectedRangeLast();\r\n      var newDelta = clone(delta);\r\n      var newSelectionRange = this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, delta);\r\n      var tempDelta = clone(newDelta);\r\n      var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(newSelectionRange, true);\r\n\r\n      do {\r\n        tempDelta = clone(newDelta);\r\n        this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, newDelta);\r\n        arrayEach(mergedCellsWithinRange, function (mergedCell) {\r\n          _this6.selectionCalculations.snapDelta(newDelta, currentSelectionRange, mergedCell);\r\n        });\r\n      } while (newDelta.row !== tempDelta.row || newDelta.col !== tempDelta.col);\r\n\r\n      delta.row = newDelta.row;\r\n      delta.col = newDelta.col;\r\n    }\r\n    /**\r\n     * `modifyGetCellCoords` hook callback. Swaps the `getCell` coords with the merged parent coords.\r\n     *\r\n     * @private\r\n     * @param {number} row Row index.\r\n     * @param {number} column Visual column index.\r\n     * @returns {Array|undefined} Visual coordinates of the merge.\r\n     */\r\n\r\n  }, {\r\n    key: \"onModifyGetCellCoords\",\r\n    value: function onModifyGetCellCoords(row, column) {\r\n      if (row < 0 || column < 0) {\r\n        return;\r\n      }\r\n\r\n      var mergeParent = this.mergedCellsCollection.get(row, column);\r\n\r\n      if (!mergeParent) {\r\n        return;\r\n      }\r\n\r\n      var mergeRow = mergeParent.row,\r\n          mergeColumn = mergeParent.col,\r\n          colspan = mergeParent.colspan,\r\n          rowspan = mergeParent.rowspan;\r\n      return [// Most top-left merged cell coords.\r\n      mergeRow, mergeColumn, // Most bottom-right merged cell coords.\r\n      mergeRow + rowspan - 1, mergeColumn + colspan - 1];\r\n    }\r\n    /**\r\n     * `afterContextMenuDefaultOptions` hook callback.\r\n     *\r\n     * @private\r\n     * @param {object} defaultOptions The default context menu options.\r\n     */\r\n\r\n  }, {\r\n    key: \"addMergeActionsToContextMenu\",\r\n    value: function addMergeActionsToContextMenu(defaultOptions) {\r\n      defaultOptions.items.push({\r\n        name: '---------'\r\n      }, toggleMergeItem(this));\r\n    }\r\n    /**\r\n     * `afterRenderer` hook callback.\r\n     *\r\n     * @private\r\n     * @param {HTMLElement} TD The cell to be modified.\r\n     * @param {number} row Row index.\r\n     * @param {number} col Visual column index.\r\n     */\r\n\r\n  }, {\r\n    key: \"onAfterRenderer\",\r\n    value: function onAfterRenderer(TD, row, col) {\r\n      var mergedCell = this.mergedCellsCollection.get(row, col); // We shouldn't override data in the collection.\r\n\r\n      var mergedCellCopy = isObject(mergedCell) ? clone(mergedCell) : void 0;\r\n\r\n      if (isObject(mergedCellCopy)) {\r\n        var _this$hot3 = this.hot,\r\n            rowMapper = _this$hot3.rowIndexMapper,\r\n            columnMapper = _this$hot3.columnIndexMapper;\r\n        var mergeRow = mergedCellCopy.row,\r\n            mergeColumn = mergedCellCopy.col,\r\n            colspan = mergedCellCopy.colspan,\r\n            rowspan = mergedCellCopy.rowspan;\r\n\r\n        var _this$translateMerged = this.translateMergedCellToRenderable(mergeRow, rowspan, mergeColumn, colspan),\r\n            _this$translateMerged2 = _slicedToArray(_this$translateMerged, 2),\r\n            lastMergedRowIndex = _this$translateMerged2[0],\r\n            lastMergedColumnIndex = _this$translateMerged2[1];\r\n\r\n        var renderedRowIndex = rowMapper.getRenderableFromVisualIndex(row);\r\n        var renderedColumnIndex = columnMapper.getRenderableFromVisualIndex(col);\r\n        var maxRowSpan = lastMergedRowIndex - renderedRowIndex + 1; // Number of rendered columns.\r\n\r\n        var maxColSpan = lastMergedColumnIndex - renderedColumnIndex + 1; // Number of rendered columns.\r\n        // We just try to determine some values basing on the actual number of rendered indexes (some columns may be hidden).\r\n\r\n        mergedCellCopy.row = rowMapper.getFirstNotHiddenIndex(mergedCellCopy.row, 1); // We just try to determine some values basing on the actual number of rendered indexes (some columns may be hidden).\r\n\r\n        mergedCellCopy.col = columnMapper.getFirstNotHiddenIndex(mergedCellCopy.col, 1); // The `rowSpan` property for a `TD` element should be at most equal to number of rendered rows in the merge area.\r\n\r\n        mergedCellCopy.rowspan = Math.min(mergedCellCopy.rowspan, maxRowSpan); // The `colSpan` property for a `TD` element should be at most equal to number of rendered columns in the merge area.\r\n\r\n        mergedCellCopy.colspan = Math.min(mergedCellCopy.colspan, maxColSpan);\r\n      }\r\n\r\n      applySpanProperties(TD, mergedCellCopy, row, col);\r\n    }\r\n    /**\r\n     * `beforeSetRangeStart` and `beforeSetRangeStartOnly` hook callback.\r\n     * A selection within merge area should be rewritten to the start of merge area.\r\n     *\r\n     * @private\r\n     * @param {object} coords Cell coords.\r\n     */\r\n\r\n  }, {\r\n    key: \"onBeforeSetRangeStart\",\r\n    value: function onBeforeSetRangeStart(coords) {\r\n      // TODO: It is a workaround, but probably this hook may be needed. Every selection on the merge area\r\n      // could set start point of the selection to the start of the merge area. However, logic inside `expandByRange` need\r\n      // an initial start point. Click on the merge cell when there are some hidden indexes break the logic in some cases.\r\n      // Please take a look at #7010 for more information. I'm not sure if selection directions are calculated properly\r\n      // and what was idea for flipping direction inside `expandByRange` method.\r\n      if (this.mergedCellsCollection.isFirstRenderableMergedCell(coords.row, coords.col)) {\r\n        var mergeParent = this.mergedCellsCollection.get(coords.row, coords.col);\r\n        var _ref = [mergeParent.row, mergeParent.col];\r\n        coords.row = _ref[0];\r\n        coords.col = _ref[1];\r\n      }\r\n    }\r\n    /**\r\n     * `beforeSetRangeEnd` hook callback.\r\n     * While selecting cells with keyboard or mouse, make sure that rectangular area is expanded to the extent of the merged cell.\r\n     *\r\n     * Note: Please keep in mind that callback may modify both start and end range coordinates by the reference.\r\n     *\r\n     * @private\r\n     * @param {object} coords Cell coords.\r\n     */\r\n\r\n  }, {\r\n    key: \"onBeforeSetRangeEnd\",\r\n    value: function onBeforeSetRangeEnd(coords) {\r\n      var selRange = this.hot.getSelectedRangeLast();\r\n      selRange.highlight = new CellCoords(selRange.highlight.row, selRange.highlight.col); // clone in case we will modify its reference\r\n\r\n      selRange.to = coords;\r\n      var rangeExpanded = false;\r\n\r\n      if (this.hot.selection.isSelectedByColumnHeader() || this.hot.selection.isSelectedByRowHeader()) {\r\n        return;\r\n      }\r\n\r\n      do {\r\n        rangeExpanded = false;\r\n\r\n        for (var i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {\r\n          var cellInfo = this.mergedCellsCollection.mergedCells[i];\r\n          var mergedCellRange = cellInfo.getRange();\r\n\r\n          if (selRange.expandByRange(mergedCellRange)) {\r\n            coords.row = selRange.to.row;\r\n            coords.col = selRange.to.col;\r\n            rangeExpanded = true;\r\n          }\r\n        }\r\n      } while (rangeExpanded);\r\n    }\r\n    /**\r\n     * The `afterGetCellMeta` hook callback.\r\n     *\r\n     * @private\r\n     * @param {number} row Row index.\r\n     * @param {number} col Column index.\r\n     * @param {object} cellProperties The cell properties object.\r\n     */\r\n\r\n  }, {\r\n    key: \"onAfterGetCellMeta\",\r\n    value: function onAfterGetCellMeta(row, col, cellProperties) {\r\n      var mergeParent = this.mergedCellsCollection.get(row, col);\r\n\r\n      if (mergeParent) {\r\n        if (mergeParent.row !== row || mergeParent.col !== col) {\r\n          cellProperties.copyable = false;\r\n        } else {\r\n          cellProperties.rowspan = mergeParent.rowspan;\r\n          cellProperties.colspan = mergeParent.colspan;\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * `afterViewportRowCalculatorOverride` hook callback.\r\n     *\r\n     * @private\r\n     * @param {object} calc The row calculator object.\r\n     */\r\n\r\n  }, {\r\n    key: \"onAfterViewportRowCalculatorOverride\",\r\n    value: function onAfterViewportRowCalculatorOverride(calc) {\r\n      var nrOfColumns = this.hot.countCols();\r\n      this.modifyViewportRowStart(calc, nrOfColumns);\r\n      this.modifyViewportRowEnd(calc, nrOfColumns);\r\n    }\r\n    /**\r\n     * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.\r\n     *\r\n     * @private\r\n     * @param {object} calc The row calculator object.\r\n     * @param {number} nrOfColumns Number of visual columns.\r\n     */\r\n\r\n  }, {\r\n    key: \"modifyViewportRowStart\",\r\n    value: function modifyViewportRowStart(calc, nrOfColumns) {\r\n      var rowMapper = this.hot.rowIndexMapper;\r\n      var visualStartRow = rowMapper.getVisualFromRenderableIndex(calc.startRow);\r\n\r\n      for (var visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {\r\n        var mergeParentForViewportStart = this.mergedCellsCollection.get(visualStartRow, visualColumnIndex);\r\n\r\n        if (isObject(mergeParentForViewportStart)) {\r\n          var renderableIndexAtMergeStart = rowMapper.getRenderableFromVisualIndex(rowMapper.getFirstNotHiddenIndex(mergeParentForViewportStart.row, 1)); // Merge start is out of the viewport (i.e. when we scrolled to the bottom and we can see just part of a merge).\r\n\r\n          if (renderableIndexAtMergeStart < calc.startRow) {\r\n            // We extend viewport when some rows have been merged.\r\n            calc.startRow = renderableIndexAtMergeStart; // We are looking for next merges inside already extended viewport (starting again from row equal to 0).\r\n\r\n            this.modifyViewportRowStart(calc, nrOfColumns); // recursively search upwards\r\n\r\n            return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.\r\n     *\r\n     * @private\r\n     * @param {object} calc The row calculator object.\r\n     * @param {number} nrOfColumns Number of visual columns.\r\n     */\r\n\r\n  }, {\r\n    key: \"modifyViewportRowEnd\",\r\n    value: function modifyViewportRowEnd(calc, nrOfColumns) {\r\n      var rowMapper = this.hot.rowIndexMapper;\r\n      var visualEndRow = rowMapper.getVisualFromRenderableIndex(calc.endRow);\r\n\r\n      for (var visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {\r\n        var mergeParentForViewportEnd = this.mergedCellsCollection.get(visualEndRow, visualColumnIndex);\r\n\r\n        if (isObject(mergeParentForViewportEnd)) {\r\n          var mergeEnd = mergeParentForViewportEnd.row + mergeParentForViewportEnd.rowspan - 1;\r\n          var renderableIndexAtMergeEnd = rowMapper.getRenderableFromVisualIndex(rowMapper.getFirstNotHiddenIndex(mergeEnd, -1)); // Merge end is out of the viewport.\r\n\r\n          if (renderableIndexAtMergeEnd > calc.endRow) {\r\n            // We extend the viewport when some rows have been merged.\r\n            calc.endRow = renderableIndexAtMergeEnd; // We are looking for next merges inside already extended viewport (starting again from row equal to 0).\r\n\r\n            this.modifyViewportRowEnd(calc, nrOfColumns); // recursively search upwards\r\n\r\n            return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * `afterViewportColumnCalculatorOverride` hook callback.\r\n     *\r\n     * @private\r\n     * @param {object} calc The column calculator object.\r\n     */\r\n\r\n  }, {\r\n    key: \"onAfterViewportColumnCalculatorOverride\",\r\n    value: function onAfterViewportColumnCalculatorOverride(calc) {\r\n      var nrOfRows = this.hot.countRows();\r\n      this.modifyViewportColumnStart(calc, nrOfRows);\r\n      this.modifyViewportColumnEnd(calc, nrOfRows);\r\n    }\r\n    /**\r\n     * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.\r\n     *\r\n     * @private\r\n     * @param {object} calc The column calculator object.\r\n     * @param {number} nrOfRows Number of visual rows.\r\n     */\r\n\r\n  }, {\r\n    key: \"modifyViewportColumnStart\",\r\n    value: function modifyViewportColumnStart(calc, nrOfRows) {\r\n      var columnMapper = this.hot.columnIndexMapper;\r\n      var visualStartCol = columnMapper.getVisualFromRenderableIndex(calc.startColumn);\r\n\r\n      for (var visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {\r\n        var mergeParentForViewportStart = this.mergedCellsCollection.get(visualRowIndex, visualStartCol);\r\n\r\n        if (isObject(mergeParentForViewportStart)) {\r\n          var renderableIndexAtMergeStart = columnMapper.getRenderableFromVisualIndex(columnMapper.getFirstNotHiddenIndex(mergeParentForViewportStart.col, 1)); // Merge start is out of the viewport (i.e. when we scrolled to the right and we can see just part of a merge).\r\n\r\n          if (renderableIndexAtMergeStart < calc.startColumn) {\r\n            // We extend viewport when some columns have been merged.\r\n            calc.startColumn = renderableIndexAtMergeStart; // We are looking for next merges inside already extended viewport (starting again from column equal to 0).\r\n\r\n            this.modifyViewportColumnStart(calc, nrOfRows); // recursively search upwards\r\n\r\n            return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.\r\n     *\r\n     * @private\r\n     * @param {object} calc The column calculator object.\r\n     * @param {number} nrOfRows Number of visual rows.\r\n     */\r\n\r\n  }, {\r\n    key: \"modifyViewportColumnEnd\",\r\n    value: function modifyViewportColumnEnd(calc, nrOfRows) {\r\n      var columnMapper = this.hot.columnIndexMapper;\r\n      var visualEndCol = columnMapper.getVisualFromRenderableIndex(calc.endColumn);\r\n\r\n      for (var visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {\r\n        var mergeParentForViewportEnd = this.mergedCellsCollection.get(visualRowIndex, visualEndCol);\r\n\r\n        if (isObject(mergeParentForViewportEnd)) {\r\n          var mergeEnd = mergeParentForViewportEnd.col + mergeParentForViewportEnd.colspan - 1;\r\n          var renderableIndexAtMergeEnd = columnMapper.getRenderableFromVisualIndex(columnMapper.getFirstNotHiddenIndex(mergeEnd, -1)); // Merge end is out of the viewport.\r\n\r\n          if (renderableIndexAtMergeEnd > calc.endColumn) {\r\n            // We extend the viewport when some columns have been merged.\r\n            calc.endColumn = renderableIndexAtMergeEnd; // We are looking for next merges inside already extended viewport (starting again from column equal to 0).\r\n\r\n            this.modifyViewportColumnEnd(calc, nrOfRows); // recursively search upwards\r\n\r\n            return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Translates merged cell coordinates to renderable indexes.\r\n     *\r\n     * @private\r\n     * @param {number} parentRow Visual row index.\r\n     * @param {number} rowspan Rowspan which describes shift which will be applied to parent row\r\n     *                         to calculate renderable index which points to the most bottom\r\n     *                         index position. Pass rowspan as `0` to calculate the most top\r\n     *                         index position.\r\n     * @param {number} parentColumn Visual column index.\r\n     * @param {number} colspan Colspan which describes shift which will be applied to parent column\r\n     *                         to calculate renderable index which points to the most right\r\n     *                         index position. Pass colspan as `0` to calculate the most left\r\n     *                         index position.\r\n     * @returns {number[]}\r\n     */\r\n\r\n  }, {\r\n    key: \"translateMergedCellToRenderable\",\r\n    value: function translateMergedCellToRenderable(parentRow, rowspan, parentColumn, colspan) {\r\n      var _this$hot4 = this.hot,\r\n          rowMapper = _this$hot4.rowIndexMapper,\r\n          columnMapper = _this$hot4.columnIndexMapper;\r\n      var firstNonHiddenRow;\r\n      var firstNonHiddenColumn;\r\n\r\n      if (rowspan === 0) {\r\n        firstNonHiddenRow = rowMapper.getFirstNotHiddenIndex(parentRow, 1);\r\n      } else {\r\n        firstNonHiddenRow = rowMapper.getFirstNotHiddenIndex(parentRow + rowspan - 1, -1);\r\n      }\r\n\r\n      if (colspan === 0) {\r\n        firstNonHiddenColumn = columnMapper.getFirstNotHiddenIndex(parentColumn, 1);\r\n      } else {\r\n        firstNonHiddenColumn = columnMapper.getFirstNotHiddenIndex(parentColumn + colspan - 1, -1);\r\n      }\r\n\r\n      var renderableRow = parentRow >= 0 ? rowMapper.getRenderableFromVisualIndex(firstNonHiddenRow) : parentRow;\r\n      var renderableColumn = parentColumn >= 0 ? columnMapper.getRenderableFromVisualIndex(firstNonHiddenColumn) : parentColumn;\r\n      return [renderableRow, renderableColumn];\r\n    }\r\n    /**\r\n     * The `modifyAutofillRange` hook callback.\r\n     *\r\n     * @private\r\n     * @param {Array} drag The drag area coordinates.\r\n     * @param {Array} select The selection information.\r\n     * @returns {Array} The new drag area.\r\n     */\r\n\r\n  }, {\r\n    key: \"onModifyAutofillRange\",\r\n    value: function onModifyAutofillRange(drag, select) {\r\n      this.autofillCalculations.correctSelectionAreaSize(select);\r\n      var dragDirection = this.autofillCalculations.getDirection(select, drag);\r\n      var dragArea = drag;\r\n\r\n      if (this.autofillCalculations.dragAreaOverlapsCollections(select, dragArea, dragDirection)) {\r\n        dragArea = select;\r\n        return dragArea;\r\n      }\r\n\r\n      var mergedCellsWithinSelectionArea = this.mergedCellsCollection.getWithinRange({\r\n        from: {\r\n          row: select[0],\r\n          col: select[1]\r\n        },\r\n        to: {\r\n          row: select[2],\r\n          col: select[3]\r\n        }\r\n      });\r\n\r\n      if (!mergedCellsWithinSelectionArea) {\r\n        return dragArea;\r\n      }\r\n\r\n      dragArea = this.autofillCalculations.snapDragArea(select, dragArea, dragDirection, mergedCellsWithinSelectionArea);\r\n      return dragArea;\r\n    }\r\n    /**\r\n     * `afterCreateCol` hook callback.\r\n     *\r\n     * @private\r\n     * @param {number} column Column index.\r\n     * @param {number} count Number of created columns.\r\n     */\r\n\r\n  }, {\r\n    key: \"onAfterCreateCol\",\r\n    value: function onAfterCreateCol(column, count) {\r\n      this.mergedCellsCollection.shiftCollections('right', column, count);\r\n    }\r\n    /**\r\n     * `afterRemoveCol` hook callback.\r\n     *\r\n     * @private\r\n     * @param {number} column Column index.\r\n     * @param {number} count Number of removed columns.\r\n     */\r\n\r\n  }, {\r\n    key: \"onAfterRemoveCol\",\r\n    value: function onAfterRemoveCol(column, count) {\r\n      this.mergedCellsCollection.shiftCollections('left', column, count);\r\n    }\r\n    /**\r\n     * `afterCreateRow` hook callback.\r\n     *\r\n     * @private\r\n     * @param {number} row Row index.\r\n     * @param {number} count Number of created rows.\r\n     * @param {string} source Source of change.\r\n     */\r\n\r\n  }, {\r\n    key: \"onAfterCreateRow\",\r\n    value: function onAfterCreateRow(row, count, source) {\r\n      if (source === 'auto') {\r\n        return;\r\n      }\r\n\r\n      this.mergedCellsCollection.shiftCollections('down', row, count);\r\n    }\r\n    /**\r\n     * `afterRemoveRow` hook callback.\r\n     *\r\n     * @private\r\n     * @param {number} row Row index.\r\n     * @param {number} count Number of removed rows.\r\n     */\r\n\r\n  }, {\r\n    key: \"onAfterRemoveRow\",\r\n    value: function onAfterRemoveRow(row, count) {\r\n      this.mergedCellsCollection.shiftCollections('up', row, count);\r\n    }\r\n    /**\r\n     * `afterChange` hook callback. Used to propagate merged cells after using Autofill.\r\n     *\r\n     * @private\r\n     * @param {Array} changes The changes array.\r\n     * @param {string} source Determines the source of the change.\r\n     */\r\n\r\n  }, {\r\n    key: \"onAfterChange\",\r\n    value: function onAfterChange(changes, source) {\r\n      if (source !== 'Autofill.fill') {\r\n        return;\r\n      }\r\n\r\n      this.autofillCalculations.recreateAfterDataPopulation(changes);\r\n    }\r\n    /**\r\n     * `beforeDrawAreaBorders` hook callback.\r\n     *\r\n     * @private\r\n     * @param {Array} corners Visual coordinates of the area corners.\r\n     * @param {string} className Class name for the area.\r\n     */\r\n\r\n  }, {\r\n    key: \"onBeforeDrawAreaBorders\",\r\n    value: function onBeforeDrawAreaBorders(corners, className) {\r\n      if (className && className === 'area') {\r\n        var selectedRange = this.hot.getSelectedRangeLast();\r\n        var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(selectedRange);\r\n        arrayEach(mergedCellsWithinRange, function (mergedCell) {\r\n          if (selectedRange.getBottomRightCorner().row === mergedCell.getLastRow() && selectedRange.getBottomRightCorner().col === mergedCell.getLastColumn()) {\r\n            corners[2] = mergedCell.row;\r\n            corners[3] = mergedCell.col;\r\n          }\r\n        });\r\n      }\r\n    }\r\n    /**\r\n     * `afterModifyTransformStart` hook callback. Fixes a problem with navigating through merged cells at the edges of the table\r\n     * with the ENTER/SHIFT+ENTER/TAB/SHIFT+TAB keys.\r\n     *\r\n     * @private\r\n     * @param {CellCoords} coords Coordinates of the to-be-selected cell.\r\n     * @param {number} rowTransformDir Row transformation direction (negative value = up, 0 = none, positive value = down).\r\n     * @param {number} colTransformDir Column transformation direction (negative value = up, 0 = none, positive value = down).\r\n     */\r\n\r\n  }, {\r\n    key: \"onAfterModifyTransformStart\",\r\n    value: function onAfterModifyTransformStart(coords, rowTransformDir, colTransformDir) {\r\n      if (!this.enabled) {\r\n        return;\r\n      }\r\n\r\n      var mergedCellAtCoords = this.mergedCellsCollection.get(coords.row, coords.col);\r\n\r\n      if (!mergedCellAtCoords) {\r\n        return;\r\n      }\r\n\r\n      var goingDown = rowTransformDir > 0;\r\n      var goingUp = rowTransformDir < 0;\r\n      var goingLeft = colTransformDir < 0;\r\n      var goingRight = colTransformDir > 0;\r\n      var mergedCellOnBottomEdge = mergedCellAtCoords.row + mergedCellAtCoords.rowspan - 1 === this.hot.countRows() - 1;\r\n      var mergedCellOnTopEdge = mergedCellAtCoords.row === 0;\r\n      var mergedCellOnRightEdge = mergedCellAtCoords.col + mergedCellAtCoords.colspan - 1 === this.hot.countCols() - 1;\r\n      var mergedCellOnLeftEdge = mergedCellAtCoords.col === 0;\r\n\r\n      if (goingDown && mergedCellOnBottomEdge || goingUp && mergedCellOnTopEdge || goingRight && mergedCellOnRightEdge || goingLeft && mergedCellOnLeftEdge) {\r\n        coords.row = mergedCellAtCoords.row;\r\n        coords.col = mergedCellAtCoords.col;\r\n      }\r\n    }\r\n    /**\r\n     * `afterDrawSelection` hook callback. Used to add the additional class name for the entirely-selected merged cells.\r\n     *\r\n     * @private\r\n     * @param {number} currentRow Visual row index of the currently processed cell.\r\n     * @param {number} currentColumn Visual column index of the currently cell.\r\n     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\r\n     * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.\r\n     * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.\r\n     */\r\n\r\n  }, {\r\n    key: \"onAfterDrawSelection\",\r\n    value: function onAfterDrawSelection(currentRow, currentColumn, cornersOfSelection, layerLevel) {\r\n      // Nothing's selected (hook might be triggered by the custom borders)\r\n      if (!cornersOfSelection) {\r\n        return;\r\n      }\r\n\r\n      return this.selectionCalculations.getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel);\r\n    }\r\n    /**\r\n     * `beforeRemoveCellClassNames` hook callback. Used to remove additional class name from all cells in the table.\r\n     *\r\n     * @private\r\n     * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\r\n     */\r\n\r\n  }, {\r\n    key: \"onBeforeRemoveCellClassNames\",\r\n    value: function onBeforeRemoveCellClassNames() {\r\n      return this.selectionCalculations.getSelectedMergedCellClassNameToRemove();\r\n    }\r\n  }], [{\r\n    key: \"PLUGIN_KEY\",\r\n    get: function get() {\r\n      return PLUGIN_KEY;\r\n    }\r\n  }, {\r\n    key: \"PLUGIN_PRIORITY\",\r\n    get: function get() {\r\n      return PLUGIN_PRIORITY;\r\n    }\r\n  }]);\r\n\r\n  return MergeCells;\r\n}(BasePlugin);"]},"metadata":{},"sourceType":"module"}