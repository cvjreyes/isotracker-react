{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { hasClass, index, offset, removeClass, removeTextNodes, overlayContainsElement, closest, outerWidth, innerHeight, isVisible as _isVisible } from \"./../../../helpers/dom/element.mjs\";\nimport { isFunction } from \"./../../../helpers/function.mjs\";\nimport CellCoords from \"./cell/coords.mjs\";\nimport ColumnFilter from \"./filter/column.mjs\";\nimport RowFilter from \"./filter/row.mjs\";\nimport { Renderer } from \"./renderer/index.mjs\";\nimport ColumnUtils from \"./utils/column.mjs\";\nimport RowUtils from \"./utils/row.mjs\";\nimport { isOverlayTypeOf } from \"./overlay/registerer.mjs\";\nimport { CLONE_TOP, CLONE_BOTTOM, CLONE_LEFT, CLONE_TOP_LEFT_CORNER, CLONE_BOTTOM_LEFT_CORNER } from \"./overlay/constants.mjs\";\n/**\r\n *\r\n */\n\nvar Table = /*#__PURE__*/function () {\n  /**\r\n   * @param {Walkontable} wotInstance The Walkontable instance.\r\n   * @param {HTMLTableElement} table An element to the Walkontable generated table is injected.\r\n   */\n  function Table(wotInstance, table) {\n    var _this = this;\n\n    _classCallCheck(this, Table);\n    /**\r\n     * Indicates if this instance is of type `MasterTable` (i.e. It is NOT an overlay).\r\n     *\r\n     * @type {boolean}\r\n     */\n\n\n    this.isMaster = !wotInstance.cloneOverlay; // \"instanceof\" operator isn't used, because it caused a circular reference in Webpack\n\n    this.wot = wotInstance; // legacy support\n\n    this.instance = this.wot;\n    this.TABLE = table;\n    this.TBODY = null;\n    this.THEAD = null;\n    this.COLGROUP = null;\n    this.tableOffset = 0;\n    this.holderOffset = 0;\n    /**\r\n     * Indicates if the table has height bigger than 0px.\r\n     *\r\n     * @type {boolean}\r\n     */\n\n    this.hasTableHeight = true;\n    /**\r\n     * Indicates if the table has width bigger than 0px.\r\n     *\r\n     * @type {boolean}\r\n     */\n\n    this.hasTableWidth = true;\n    /**\r\n     * Indicates if the table is visible. By visible, it means that the holder\r\n     * element has CSS 'display' property different than 'none'.\r\n     *\r\n     * @type {boolean}\r\n     */\n\n    this.isTableVisible = false;\n    removeTextNodes(this.TABLE);\n    this.spreader = this.createSpreader(this.TABLE);\n    this.hider = this.createHider(this.spreader);\n    this.holder = this.createHolder(this.hider);\n    this.wtRootElement = this.holder.parentNode;\n\n    if (this.isMaster) {\n      this.alignOverlaysWithTrimmingContainer();\n    }\n\n    this.fixTableDomTree();\n    this.rowFilter = null;\n    this.columnFilter = null;\n    this.correctHeaderWidth = false;\n    var origRowHeaderWidth = this.wot.wtSettings.settings.rowHeaderWidth; // Fix for jumping row headers (https://github.com/handsontable/handsontable/issues/3850)\n\n    this.wot.wtSettings.settings.rowHeaderWidth = function () {\n      return _this._modifyRowHeaderWidth(origRowHeaderWidth);\n    };\n\n    this.rowUtils = new RowUtils(this.wot);\n    this.columnUtils = new ColumnUtils(this.wot);\n    this.tableRenderer = new Renderer({\n      TABLE: this.TABLE,\n      THEAD: this.THEAD,\n      COLGROUP: this.COLGROUP,\n      TBODY: this.TBODY,\n      rowUtils: this.rowUtils,\n      columnUtils: this.columnUtils,\n      cellRenderer: this.wot.wtSettings.settings.cellRenderer\n    });\n  }\n  /**\r\n   * Returns a boolean that is true if this intance of Table represents a specific overlay, identified by the overlay name.\r\n   * For MasterTable, it returns false.\r\n   *\r\n   * @param {string} overlayTypeName The overlay type.\r\n   * @returns {boolean}\r\n   */\n\n\n  _createClass(Table, [{\n    key: \"is\",\n    value: function is(overlayTypeName) {\n      return isOverlayTypeOf(this.wot.cloneOverlay, overlayTypeName);\n    }\n    /**\r\n     *\r\n     */\n\n  }, {\n    key: \"fixTableDomTree\",\n    value: function fixTableDomTree() {\n      var rootDocument = this.wot.rootDocument;\n      this.TBODY = this.TABLE.querySelector('tbody');\n\n      if (!this.TBODY) {\n        this.TBODY = rootDocument.createElement('tbody');\n        this.TABLE.appendChild(this.TBODY);\n      }\n\n      this.THEAD = this.TABLE.querySelector('thead');\n\n      if (!this.THEAD) {\n        this.THEAD = rootDocument.createElement('thead');\n        this.TABLE.insertBefore(this.THEAD, this.TBODY);\n      }\n\n      this.COLGROUP = this.TABLE.querySelector('colgroup');\n\n      if (!this.COLGROUP) {\n        this.COLGROUP = rootDocument.createElement('colgroup');\n        this.TABLE.insertBefore(this.COLGROUP, this.THEAD);\n      }\n\n      if (this.wot.getSetting('columnHeaders').length && !this.THEAD.childNodes.length) {\n        this.THEAD.appendChild(rootDocument.createElement('TR'));\n      }\n    }\n    /**\r\n     * @param {HTMLTableElement} table An element to process.\r\n     * @returns {HTMLElement}\r\n     */\n\n  }, {\n    key: \"createSpreader\",\n    value: function createSpreader(table) {\n      var parent = table.parentNode;\n      var spreader;\n\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        spreader = this.wot.rootDocument.createElement('div');\n        spreader.className = 'wtSpreader';\n\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(spreader, table);\n        }\n\n        spreader.appendChild(table);\n      }\n\n      spreader.style.position = 'relative';\n      return spreader;\n    }\n    /**\r\n     * @param {HTMLElement} spreader An element to the hider element is injected.\r\n     * @returns {HTMLElement}\r\n     */\n\n  }, {\n    key: \"createHider\",\n    value: function createHider(spreader) {\n      var parent = spreader.parentNode;\n      var hider;\n\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        hider = this.wot.rootDocument.createElement('div');\n        hider.className = 'wtHider';\n\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(hider, spreader);\n        }\n\n        hider.appendChild(spreader);\n      }\n\n      return hider;\n    }\n    /**\r\n     *\r\n     * @param {HTMLElement} hider An element to the holder element is injected.\r\n     * @returns {HTMLElement}\r\n     */\n\n  }, {\n    key: \"createHolder\",\n    value: function createHolder(hider) {\n      var parent = hider.parentNode;\n      var holder;\n\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        holder = this.wot.rootDocument.createElement('div');\n        holder.style.position = 'relative';\n        holder.className = 'wtHolder';\n\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(holder, hider);\n        }\n\n        if (this.isMaster) {\n          holder.parentNode.className += 'ht_master handsontable';\n        }\n\n        holder.appendChild(hider);\n      }\n\n      return holder;\n    }\n    /**\r\n     * Redraws the table.\r\n     *\r\n     * @param {boolean} [fastDraw=false] If TRUE, will try to avoid full redraw and only update the border positions.\r\n     *                                   If FALSE or UNDEFINED, will perform a full redraw.\r\n     * @returns {Table}\r\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var wot = this.wot;\n      var wtOverlays = wot.wtOverlays,\n          wtViewport = wot.wtViewport;\n      var totalRows = wot.getSetting('totalRows');\n      var totalColumns = wot.getSetting('totalColumns');\n      var rowHeaders = wot.getSetting('rowHeaders');\n      var rowHeadersCount = rowHeaders.length;\n      var columnHeaders = wot.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      var syncScroll = false;\n      var runFastDraw = fastDraw;\n\n      if (this.isMaster) {\n        this.holderOffset = offset(this.holder);\n        runFastDraw = wtViewport.createRenderCalculators(runFastDraw);\n\n        if (rowHeadersCount && !wot.getSetting('fixedColumnsLeft')) {\n          var leftScrollPos = wtOverlays.leftOverlay.getScrollPosition();\n          var previousState = this.correctHeaderWidth;\n          this.correctHeaderWidth = leftScrollPos > 0;\n\n          if (previousState !== this.correctHeaderWidth) {\n            runFastDraw = false;\n          }\n        }\n      }\n\n      if (this.isMaster) {\n        syncScroll = wtOverlays.prepareOverlays();\n      }\n\n      if (runFastDraw) {\n        if (this.isMaster) {\n          // in case we only scrolled without redraw, update visible rows information in oldRowsCalculator\n          wtViewport.createVisibleCalculators();\n        }\n\n        if (wtOverlays) {\n          wtOverlays.refresh(true);\n        }\n      } else {\n        if (this.isMaster) {\n          this.tableOffset = offset(this.TABLE);\n        } else {\n          this.tableOffset = this.wot.cloneSource.wtTable.tableOffset;\n        }\n\n        var startRow = totalRows > 0 ? this.getFirstRenderedRow() : 0;\n        var startColumn = totalColumns > 0 ? this.getFirstRenderedColumn() : 0;\n        this.rowFilter = new RowFilter(startRow, totalRows, columnHeadersCount);\n        this.columnFilter = new ColumnFilter(startColumn, totalColumns, rowHeadersCount);\n        var performRedraw = true; // Only master table rendering can be skipped\n\n        if (this.isMaster) {\n          this.alignOverlaysWithTrimmingContainer();\n          var skipRender = {};\n          this.wot.getSetting('beforeDraw', true, skipRender);\n          performRedraw = skipRender.skipRender !== true;\n        }\n\n        if (performRedraw) {\n          this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);\n\n          if (this.is(CLONE_BOTTOM) || this.is(CLONE_BOTTOM_LEFT_CORNER)) {\n            // do NOT render headers on the bottom or bottom-left corner overlay\n            this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);\n          }\n\n          this.resetOversizedRows();\n          this.tableRenderer.setViewportSize(this.getRenderedRowsCount(), this.getRenderedColumnsCount()).setFilters(this.rowFilter, this.columnFilter).render();\n          var workspaceWidth;\n\n          if (this.isMaster) {\n            workspaceWidth = this.wot.wtViewport.getWorkspaceWidth();\n            this.wot.wtViewport.containerWidth = null;\n            this.markOversizedColumnHeaders();\n          }\n\n          this.adjustColumnHeaderHeights();\n\n          if (this.isMaster || this.is(CLONE_BOTTOM)) {\n            this.markOversizedRows();\n          }\n\n          if (this.isMaster) {\n            this.wot.wtViewport.createVisibleCalculators();\n            this.wot.wtOverlays.refresh(false);\n            this.wot.wtOverlays.applyToDOM();\n            var hiderWidth = outerWidth(this.hider);\n            var tableWidth = outerWidth(this.TABLE);\n\n            if (hiderWidth !== 0 && tableWidth !== hiderWidth) {\n              // Recalculate the column widths, if width changes made in the overlays removed the scrollbar, thus changing the viewport width.\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n\n            if (workspaceWidth !== this.wot.wtViewport.getWorkspaceWidth()) {\n              // workspace width changed though to shown/hidden vertical scrollbar. Let's reapply stretching\n              this.wot.wtViewport.containerWidth = null;\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n\n            this.wot.getSetting('onDraw', true);\n          } else if (this.is(CLONE_BOTTOM)) {\n            this.wot.cloneSource.wtOverlays.adjustElementsSize();\n          }\n        }\n      }\n\n      if (this.isMaster) {\n        var positionChanged = wtOverlays.topOverlay.resetFixedPosition();\n\n        if (wtOverlays.bottomOverlay.clone) {\n          positionChanged = wtOverlays.bottomOverlay.resetFixedPosition() || positionChanged;\n        }\n\n        positionChanged = wtOverlays.leftOverlay.resetFixedPosition() || positionChanged;\n\n        if (wtOverlays.topLeftCornerOverlay) {\n          wtOverlays.topLeftCornerOverlay.resetFixedPosition();\n        }\n\n        if (wtOverlays.bottomLeftCornerOverlay && wtOverlays.bottomLeftCornerOverlay.clone) {\n          wtOverlays.bottomLeftCornerOverlay.resetFixedPosition();\n        }\n\n        if (positionChanged) {\n          // It refreshes the cells borders caused by a 1px shift (introduced by overlays which add or\n          // remove `innerBorderTop` and `innerBorderLeft` CSS classes to the DOM element. This happens\n          // when there is a switch between rendering from 0 to N rows/columns and vice versa).\n          wtOverlays.refreshAll();\n          wtOverlays.adjustElementsSize();\n        }\n      }\n\n      this.refreshSelections(runFastDraw);\n\n      if (syncScroll) {\n        wtOverlays.syncScrollWithMaster();\n      }\n\n      wot.drawn = true;\n      return this;\n    }\n    /**\r\n     * @param {number} col The visual column index.\r\n     */\n\n  }, {\n    key: \"markIfOversizedColumnHeader\",\n    value: function markIfOversizedColumnHeader(col) {\n      var sourceColIndex = this.wot.wtTable.columnFilter.renderedToSource(col);\n      var level = this.wot.getSetting('columnHeaders').length;\n      var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;\n      var previousColHeaderHeight;\n      var currentHeader;\n      var currentHeaderHeight;\n      var columnHeaderHeightSetting = this.wot.getSetting('columnHeaderHeight') || [];\n\n      while (level) {\n        level -= 1;\n        previousColHeaderHeight = this.wot.wtTable.getColumnHeaderHeight(level);\n        currentHeader = this.wot.wtTable.getColumnHeader(sourceColIndex, level);\n\n        if (!currentHeader) {\n          /* eslint-disable no-continue */\n          continue;\n        }\n\n        currentHeaderHeight = innerHeight(currentHeader);\n\n        if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;\n        }\n\n        if (Array.isArray(columnHeaderHeightSetting)) {\n          if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== void 0) {\n            this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];\n          }\n        } else if (!isNaN(columnHeaderHeightSetting)) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;\n        }\n\n        if (this.wot.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting; // eslint-disable-line max-len\n        }\n      }\n    }\n    /**\r\n     *\r\n     */\n\n  }, {\n    key: \"adjustColumnHeaderHeights\",\n    value: function adjustColumnHeaderHeights() {\n      var wot = this.wot;\n      var children = wot.wtTable.THEAD.childNodes;\n      var oversizedColumnHeaders = wot.wtViewport.oversizedColumnHeaders;\n      var columnHeaders = wot.getSetting('columnHeaders');\n\n      for (var i = 0, len = columnHeaders.length; i < len; i++) {\n        if (oversizedColumnHeaders[i]) {\n          if (!children[i] || children[i].childNodes.length === 0) {\n            return;\n          }\n\n          children[i].childNodes[0].style.height = \"\".concat(oversizedColumnHeaders[i], \"px\");\n        }\n      }\n    }\n    /**\r\n     * Resets cache of row heights. The cache should be cached for each render cycle in a case\r\n     * when new cell values have content which increases/decreases cell height.\r\n     */\n\n  }, {\n    key: \"resetOversizedRows\",\n    value: function resetOversizedRows() {\n      var wot = this.wot;\n\n      if (!this.isMaster && !this.is(CLONE_BOTTOM)) {\n        return;\n      }\n\n      if (!wot.getSetting('externalRowCalculator')) {\n        var rowsToRender = this.getRenderedRowsCount(); // Reset the oversized row cache for rendered rows\n\n        for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {\n          var sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);\n\n          if (wot.wtViewport.oversizedRows && wot.wtViewport.oversizedRows[sourceRow]) {\n            wot.wtViewport.oversizedRows[sourceRow] = void 0;\n          }\n        }\n      }\n    }\n    /**\r\n     * @param {string} className The CSS class name to remove from the table cells.\r\n     */\n\n  }, {\n    key: \"removeClassFromCells\",\n    value: function removeClassFromCells(className) {\n      var nodes = this.TABLE.querySelectorAll(\".\".concat(className));\n\n      for (var i = 0, len = nodes.length; i < len; i++) {\n        removeClass(nodes[i], className);\n      }\n    }\n    /**\r\n     * Refresh the table selection by re-rendering Selection instances connected with that instance.\r\n     *\r\n     * @param {boolean} fastDraw If fast drawing is enabled than additionally className clearing is applied.\r\n     */\n\n  }, {\n    key: \"refreshSelections\",\n    value: function refreshSelections(fastDraw) {\n      var wot = this.wot;\n\n      if (!wot.selections) {\n        return;\n      }\n\n      var highlights = Array.from(wot.selections);\n      var len = highlights.length;\n\n      if (fastDraw) {\n        var classesToRemove = [];\n\n        for (var i = 0; i < len; i++) {\n          var _highlights$i$setting = highlights[i].settings,\n              highlightHeaderClassName = _highlights$i$setting.highlightHeaderClassName,\n              highlightRowClassName = _highlights$i$setting.highlightRowClassName,\n              highlightColumnClassName = _highlights$i$setting.highlightColumnClassName;\n          var classNames = highlights[i].classNames;\n          var classNamesLength = classNames.length;\n\n          for (var j = 0; j < classNamesLength; j++) {\n            if (!classesToRemove.includes(classNames[j])) {\n              classesToRemove.push(classNames[j]);\n            }\n          }\n\n          if (highlightHeaderClassName && !classesToRemove.includes(highlightHeaderClassName)) {\n            classesToRemove.push(highlightHeaderClassName);\n          }\n\n          if (highlightRowClassName && !classesToRemove.includes(highlightRowClassName)) {\n            classesToRemove.push(highlightRowClassName);\n          }\n\n          if (highlightColumnClassName && !classesToRemove.includes(highlightColumnClassName)) {\n            classesToRemove.push(highlightColumnClassName);\n          }\n        }\n\n        var additionalClassesToRemove = wot.getSetting('onBeforeRemoveCellClassNames');\n\n        if (Array.isArray(additionalClassesToRemove)) {\n          for (var _i = 0; _i < additionalClassesToRemove.length; _i++) {\n            classesToRemove.push(additionalClassesToRemove[_i]);\n          }\n        }\n\n        var classesToRemoveLength = classesToRemove.length;\n\n        for (var _i2 = 0; _i2 < classesToRemoveLength; _i2++) {\n          // there was no rerender, so we need to remove classNames by ourselves\n          this.removeClassFromCells(classesToRemove[_i2]);\n        }\n      }\n\n      for (var _i3 = 0; _i3 < len; _i3++) {\n        highlights[_i3].draw(wot, fastDraw);\n      }\n    }\n    /**\r\n     * Get cell element at coords.\r\n     * Negative coords.row or coords.col are used to retrieve header cells. If there are multiple header levels, the\r\n     * negative value corresponds to the distance from the working area. For example, when there are 3 levels of column\r\n     * headers, coords.col=-1 corresponds to the most inner header element, while coords.col=-3 corresponds to the\r\n     * outmost header element.\r\n     *\r\n     * In case an element for the coords is not rendered, the method returns an error code.\r\n     * To produce the error code, the input parameters are validated in the order in which they\r\n     * are given. Thus, if both the row and the column coords are out of the rendered bounds,\r\n     * the method returns the error code for the row.\r\n     *\r\n     * @param {CellCoords} coords The cell coordinates.\r\n     * @returns {HTMLElement|number} HTMLElement on success or Number one of the exit codes on error:\r\n     *  -1 row before viewport\r\n     *  -2 row after viewport\r\n     *  -3 column before viewport\r\n     *  -4 column after viewport.\r\n     */\n\n  }, {\n    key: \"getCell\",\n    value: function getCell(coords) {\n      var row = coords.row;\n      var column = coords.col;\n      var hookResult = this.wot.getSetting('onModifyGetCellCoords', row, column);\n\n      if (hookResult && Array.isArray(hookResult)) {\n        var _hookResult = _slicedToArray(hookResult, 2);\n\n        row = _hookResult[0];\n        column = _hookResult[1];\n      }\n\n      if (this.isRowBeforeRenderedRows(row)) {\n        // row before rendered rows\n        return -1;\n      } else if (this.isRowAfterRenderedRows(row)) {\n        // row after rendered rows\n        return -2;\n      } else if (this.isColumnBeforeRenderedColumns(column)) {\n        // column before rendered columns\n        return -3;\n      } else if (this.isColumnAfterRenderedColumns(column)) {\n        // column after rendered columns\n        return -4;\n      }\n\n      var TR;\n\n      if (row < 0) {\n        TR = this.THEAD.childNodes[this.rowFilter.sourceRowToVisibleColHeadedRow(row)];\n      } else {\n        TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n      }\n\n      if (!TR && row >= 0) {\n        throw new Error('TR was expected to be rendered but is not');\n      }\n\n      var TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];\n\n      if (!TD && column >= 0) {\n        throw new Error('TD or TH was expected to be rendered but is not');\n      }\n\n      return TD;\n    }\n    /**\r\n     * GetColumnHeader.\r\n     *\r\n     * @param {number} col Column index.\r\n     * @param {number} [level=0] Header level (0 = most distant to the table).\r\n     * @returns {object} HTMLElement on success or undefined on error.\r\n     */\n\n  }, {\n    key: \"getColumnHeader\",\n    value: function getColumnHeader(col) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var TR = this.THEAD.childNodes[level];\n      return TR === null || TR === void 0 ? void 0 : TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];\n    }\n    /**\r\n     * Gets all columns headers (TH elements) from the table.\r\n     *\r\n     * @param {number} column A source column index.\r\n     * @returns {HTMLTableCellElement[]}\r\n     */\n\n  }, {\n    key: \"getColumnHeaders\",\n    value: function getColumnHeaders(column) {\n      var THs = [];\n      var visibleColumn = this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column);\n      this.THEAD.childNodes.forEach(function (TR) {\n        var TH = TR.childNodes[visibleColumn];\n\n        if (TH) {\n          THs.push(TH);\n        }\n      });\n      return THs;\n    }\n    /**\r\n     * GetRowHeader.\r\n     *\r\n     * @param {number} row Row index.\r\n     * @param {number} [level=0] Header level (0 = most distant to the table).\r\n     * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have row headers`.\r\n     */\n\n  }, {\n    key: \"getRowHeader\",\n    value: function getRowHeader(row) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {\n        return;\n      }\n\n      var rowHeadersCount = this.wot.getSetting('rowHeaders').length;\n\n      if (level >= rowHeadersCount) {\n        return;\n      }\n\n      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n      return TR === null || TR === void 0 ? void 0 : TR.childNodes[level];\n    }\n    /**\r\n     * Gets all rows headers (TH elements) from the table.\r\n     *\r\n     * @param {number} row A source row index.\r\n     * @returns {HTMLTableCellElement[]}\r\n     */\n\n  }, {\n    key: \"getRowHeaders\",\n    value: function getRowHeaders(row) {\n      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {\n        return [];\n      }\n\n      var THs = [];\n      var rowHeadersCount = this.wot.getSetting('rowHeaders').length;\n\n      for (var renderedRowIndex = 0; renderedRowIndex < rowHeadersCount; renderedRowIndex++) {\n        var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n        var TH = TR === null || TR === void 0 ? void 0 : TR.childNodes[renderedRowIndex];\n\n        if (TH) {\n          THs.push(TH);\n        }\n      }\n\n      return THs;\n    }\n    /**\r\n     * Returns cell coords object for a given TD (or a child element of a TD element).\r\n     *\r\n     * @param {HTMLTableCellElement} TD A cell DOM element (or a child of one).\r\n     * @returns {CellCoords|null} The coordinates of the provided TD element (or the closest TD element) or null, if the provided element is not applicable.\r\n     */\n\n  }, {\n    key: \"getCoords\",\n    value: function getCoords(TD) {\n      var cellElement = TD;\n\n      if (cellElement.nodeName !== 'TD' && cellElement.nodeName !== 'TH') {\n        cellElement = closest(cellElement, ['TD', 'TH']);\n      }\n\n      if (cellElement === null) {\n        return null;\n      }\n\n      var TR = cellElement.parentNode;\n      var CONTAINER = TR.parentNode;\n      var row = index(TR);\n      var col = cellElement.cellIndex;\n\n      if (overlayContainsElement(CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_TOP, cellElement, this.wtRootElement)) {\n        if (CONTAINER.nodeName === 'THEAD') {\n          row -= CONTAINER.childNodes.length;\n        }\n      } else if (overlayContainsElement(CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM, cellElement, this.wtRootElement)) {\n        var totalRows = this.wot.getSetting('totalRows');\n        row = totalRows - CONTAINER.childNodes.length + row;\n      } else if (CONTAINER === this.THEAD) {\n        row = this.rowFilter.visibleColHeadedRowToSourceRow(row);\n      } else {\n        row = this.rowFilter.renderedToSource(row);\n      }\n\n      if (overlayContainsElement(CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_LEFT, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement)) {\n        col = this.columnFilter.offsettedTH(col);\n      } else {\n        col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);\n      }\n\n      return new CellCoords(row, col);\n    }\n    /**\r\n     * Check if any of the rendered rows is higher than expected, and if so, cache them.\r\n     */\n\n  }, {\n    key: \"markOversizedRows\",\n    value: function markOversizedRows() {\n      if (this.wot.getSetting('externalRowCalculator')) {\n        return;\n      }\n\n      var rowCount = this.TBODY.childNodes.length;\n      var expectedTableHeight = rowCount * this.wot.wtSettings.settings.defaultRowHeight;\n      var actualTableHeight = innerHeight(this.TBODY) - 1;\n      var previousRowHeight;\n      var rowInnerHeight;\n      var sourceRowIndex;\n      var currentTr;\n      var rowHeader;\n\n      if (expectedTableHeight === actualTableHeight && !this.wot.getSetting('fixedRowsBottom')) {\n        // If the actual table height equals rowCount * default single row height, no row is oversized -> no need to iterate over them\n        return;\n      }\n\n      while (rowCount) {\n        rowCount -= 1;\n        sourceRowIndex = this.rowFilter.renderedToSource(rowCount);\n        previousRowHeight = this.getRowHeight(sourceRowIndex);\n        currentTr = this.getTrForRow(sourceRowIndex);\n        rowHeader = currentTr.querySelector('th');\n\n        if (rowHeader) {\n          rowInnerHeight = innerHeight(rowHeader);\n        } else {\n          rowInnerHeight = innerHeight(currentTr) - 1;\n        }\n\n        if (!previousRowHeight && this.wot.wtSettings.settings.defaultRowHeight < rowInnerHeight || previousRowHeight < rowInnerHeight) {\n          rowInnerHeight += 1;\n          this.wot.wtViewport.oversizedRows[sourceRowIndex] = rowInnerHeight;\n        }\n      }\n    }\n    /**\r\n     * @param {number} row The visual row index.\r\n     * @returns {HTMLTableElement}\r\n     */\n\n  }, {\n    key: \"getTrForRow\",\n    value: function getTrForRow(row) {\n      return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n    }\n    /**\r\n     * Checks if the column index (negative value from -1 to N) is rendered.\r\n     *\r\n     * @param {number} column The column index (negative value from -1 to N).\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isColumnHeaderRendered\",\n    value: function isColumnHeaderRendered(column) {\n      if (column >= 0) {\n        return false;\n      }\n\n      var rowHeaders = this.wot.getSetting('rowHeaders');\n      var rowHeadersCount = rowHeaders.length;\n      return Math.abs(column) <= rowHeadersCount;\n    }\n    /**\r\n     * Checks if the row index (negative value from -1 to N) is rendered.\r\n     *\r\n     * @param {number} row The row index (negative value from -1 to N).\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isRowHeaderRendered\",\n    value: function isRowHeaderRendered(row) {\n      if (row >= 0) {\n        return false;\n      }\n\n      var columnHeaders = this.wot.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      return Math.abs(row) <= columnHeadersCount;\n    }\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n\n    /**\r\n     * Check if the given row index is lower than the index of the first row that\r\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\r\n     *\r\n     * Negative row index is used to check the columns' headers.\r\n     *\r\n     *  Headers\r\n     *           +--------------+                                     │\r\n     *       -3  │    │    │    │                                     │\r\n     *           +--------------+                                     │\r\n     *       -2  │    │    │    │                                     │ TRUE\r\n     *           +--------------+                                     │\r\n     *       -1  │    │    │    │                                     │\r\n     *  Cells  +==================+                                   │\r\n     *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │\r\n     *           +--------------+      the master overlay do       ---+ first rendered row (index 1)\r\n     *        1  │ A2 │ B2 │ C2 │      not render the first row.      │\r\n     *           +--------------+                                     │ FALSE\r\n     *        2  │ A3 │ B3 │ C3 │                                     │\r\n     *           +--------------+                                  ---+ last rendered row\r\n     *                                                                │\r\n     *                                                                │ FALSE\r\n     *\r\n     * @param {number} row The visual row index.\r\n     * @memberof Table#\r\n     * @function isRowBeforeRenderedRows\r\n     * @returns {boolean}\r\n     */\n\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  }, {\n    key: \"isRowBeforeRenderedRows\",\n    value: function isRowBeforeRenderedRows(row) {\n      var first = this.getFirstRenderedRow(); // Check the headers only in case when the first rendered row is -1 or 0.\n      // This is an indication that the overlay is placed on the most top position.\n\n      if (row < 0 && first <= 0) {\n        return !this.isRowHeaderRendered(row);\n      }\n\n      return row < first;\n    }\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n\n    /**\r\n     * Check if the given column index is greater than the index of the last column that\r\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\r\n     *\r\n     * The negative row index is used to check the columns' headers. However,\r\n     * keep in mind that for negative indexes, the method always returns FALSE as\r\n     * it is not possible to render headers partially. The \"after\" index can not be\r\n     * lower than -1.\r\n     *\r\n     *  Headers\r\n     *           +--------------+                                     │\r\n     *       -3  │    │    │    │                                     │\r\n     *           +--------------+                                     │\r\n     *       -2  │    │    │    │                                     │ FALSE\r\n     *           +--------------+                                     │\r\n     *       -1  │    │    │    │                                     │\r\n     *  Cells  +==================+                                   │\r\n     *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │\r\n     *           +--------------+      the master overlay do       ---+ first rendered row (index 1)\r\n     *        1  │ A2 │ B2 │ C2 │      not render the first rows      │\r\n     *           +--------------+                                     │ FALSE\r\n     *        2  │ A3 │ B3 │ C3 │                                     │\r\n     *           +--------------+                                  ---+ last rendered row\r\n     *                                                                │\r\n     *                                                                │ TRUE\r\n     *\r\n     * @param {number} row The visual row index.\r\n     * @memberof Table#\r\n     * @function isRowAfterRenderedRows\r\n     * @returns {boolean}\r\n     */\n\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  }, {\n    key: \"isRowAfterRenderedRows\",\n    value: function isRowAfterRenderedRows(row) {\n      return row > this.getLastRenderedRow();\n    }\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n\n    /**\r\n     * Check if the given column index is lower than the index of the first column that\r\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\r\n     *\r\n     * Negative column index is used to check the rows' headers.\r\n     *\r\n     *                            For fixedColumnsLeft: 1 the master overlay\r\n     *                            do not render this first columns.\r\n     *  Headers    -3   -2   -1    |\r\n     *           +----+----+----║┄ ┄ +------+------+\r\n     *           │    │    │    ║    │  B1  │  C1  │\r\n     *           +--------------║┄ ┄ --------------│\r\n     *           │    │    │    ║    │  B2  │  C2  │\r\n     *           +--------------║┄ ┄ --------------│\r\n     *           │    │    │    ║    │  B3  │  C3  │\r\n     *           +----+----+----║┄ ┄ +------+------+\r\n     *                               ╷             ╷\r\n     *      -------------------------+-------------+---------------->\r\n     *          TRUE             first    FALSE   last         FALSE\r\n     *                           rendered         rendered\r\n     *                           column           column\r\n     *\r\n     * @param {number} column The visual column index.\r\n     * @memberof Table#\r\n     * @function isColumnBeforeRenderedColumns\r\n     * @returns {boolean}\r\n     */\n\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  }, {\n    key: \"isColumnBeforeRenderedColumns\",\n    value: function isColumnBeforeRenderedColumns(column) {\n      var first = this.getFirstRenderedColumn(); // Check the headers only in case when the first rendered column is -1 or 0.\n      // This is an indication that the overlay is placed on the most left position.\n\n      if (column < 0 && first <= 0) {\n        return !this.isColumnHeaderRendered(column);\n      }\n\n      return column < first;\n    }\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n\n    /**\r\n     * Check if the given column index is greater than the index of the last column that\r\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\r\n     *\r\n     * The negative column index is used to check the rows' headers. However,\r\n     * keep in mind that for negative indexes, the method always returns FALSE as\r\n     * it is not possible to render headers partially. The \"after\" index can not be\r\n     * lower than -1.\r\n     *\r\n     *                            For fixedColumnsLeft: 1 the master overlay\r\n     *                            do not render this first columns.\r\n     *  Headers    -3   -2   -1    |\r\n     *           +----+----+----║┄ ┄ +------+------+\r\n     *           │    │    │    ║    │  B1  │  C1  │\r\n     *           +--------------║┄ ┄ --------------│\r\n     *           │    │    │    ║    │  B2  │  C2  │\r\n     *           +--------------║┄ ┄ --------------│\r\n     *           │    │    │    ║    │  B3  │  C3  │\r\n     *           +----+----+----║┄ ┄ +------+------+\r\n     *                               ╷             ╷\r\n     *      -------------------------+-------------+---------------->\r\n     *          FALSE             first    FALSE   last         TRUE\r\n     *                           rendered         rendered\r\n     *                           column           column\r\n     *\r\n     * @param {number} column The visual column index.\r\n     * @memberof Table#\r\n     * @function isColumnAfterRenderedColumns\r\n     * @returns {boolean}\r\n     */\n\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  }, {\n    key: \"isColumnAfterRenderedColumns\",\n    value: function isColumnAfterRenderedColumns(column) {\n      return this.columnFilter && column > this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"isColumnAfterViewport\",\n    value: function isColumnAfterViewport(column) {\n      return this.columnFilter && column > this.getLastVisibleColumn();\n    }\n  }, {\n    key: \"isRowAfterViewport\",\n    value: function isRowAfterViewport(row) {\n      return this.rowFilter && row > this.getLastVisibleRow();\n    }\n  }, {\n    key: \"isColumnBeforeViewport\",\n    value: function isColumnBeforeViewport(column) {\n      return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;\n    }\n  }, {\n    key: \"isLastRowFullyVisible\",\n    value: function isLastRowFullyVisible() {\n      return this.getLastVisibleRow() === this.getLastRenderedRow();\n    }\n  }, {\n    key: \"isLastColumnFullyVisible\",\n    value: function isLastColumnFullyVisible() {\n      return this.getLastVisibleColumn() === this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"allRowsInViewport\",\n    value: function allRowsInViewport() {\n      return this.wot.getSetting('totalRows') === this.getVisibleRowsCount();\n    }\n  }, {\n    key: \"allColumnsInViewport\",\n    value: function allColumnsInViewport() {\n      return this.wot.getSetting('totalColumns') === this.getVisibleColumnsCount();\n    }\n    /**\r\n     * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height.\r\n     *\r\n     * @param {number} sourceRow The physical row index.\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getRowHeight\",\n    value: function getRowHeight(sourceRow) {\n      return this.rowUtils.getHeight(sourceRow);\n    }\n    /**\r\n     * @param {number} level The column level.\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getColumnHeaderHeight\",\n    value: function getColumnHeaderHeight(level) {\n      return this.columnUtils.getHeaderHeight(level);\n    }\n    /**\r\n     * @param {number} sourceColumn The physical column index.\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getColumnWidth\",\n    value: function getColumnWidth(sourceColumn) {\n      return this.columnUtils.getWidth(sourceColumn);\n    }\n    /**\r\n     * @param {number} sourceColumn The physical column index.\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getStretchedColumnWidth\",\n    value: function getStretchedColumnWidth(sourceColumn) {\n      return this.columnUtils.getStretchedColumnWidth(sourceColumn);\n    }\n    /**\r\n     * Checks if the table has defined size. It returns `true` when the table has width and height\r\n     * set bigger than `0px`.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"hasDefinedSize\",\n    value: function hasDefinedSize() {\n      return this.hasTableHeight && this.hasTableWidth;\n    }\n    /**\r\n     * Checks if the table is visible. It returns `true` when the holder element (or its parents)\r\n     * has CSS 'display' property different than 'none'.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      return _isVisible(this.TABLE);\n    }\n    /**\r\n     * Modify row header widths provided by user in class contructor.\r\n     *\r\n     * @private\r\n     * @param {Function} rowHeaderWidthFactory The function which can provide default width values for rows..\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"_modifyRowHeaderWidth\",\n    value: function _modifyRowHeaderWidth(rowHeaderWidthFactory) {\n      var widths = isFunction(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;\n\n      if (Array.isArray(widths)) {\n        widths = _toConsumableArray(widths);\n        widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);\n      } else {\n        widths = this._correctRowHeaderWidth(widths);\n      }\n\n      return widths;\n    }\n    /**\r\n     * Correct row header width if necessary.\r\n     *\r\n     * @private\r\n     * @param {number} width The width to process.\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"_correctRowHeaderWidth\",\n    value: function _correctRowHeaderWidth(width) {\n      var rowHeaderWidth = width;\n\n      if (typeof width !== 'number') {\n        rowHeaderWidth = this.wot.getSetting('defaultColumnWidth');\n      }\n\n      if (this.correctHeaderWidth) {\n        rowHeaderWidth += 1;\n      }\n\n      return rowHeaderWidth;\n    }\n  }]);\n\n  return Table;\n}();\n\nexport default Table;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/3rdparty/walkontable/src/table.mjs"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Array","from","isArray","_arrayLikeToArray","_slicedToArray","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","o","minLen","n","Object","prototype","toString","call","slice","constructor","name","test","len","length","arr2","_i","_arr","_n","_d","_s","_e","next","done","push","value","err","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","hasClass","index","offset","removeClass","removeTextNodes","overlayContainsElement","closest","outerWidth","innerHeight","isVisible","_isVisible","isFunction","CellCoords","ColumnFilter","RowFilter","Renderer","ColumnUtils","RowUtils","isOverlayTypeOf","CLONE_TOP","CLONE_BOTTOM","CLONE_LEFT","CLONE_TOP_LEFT_CORNER","CLONE_BOTTOM_LEFT_CORNER","Table","wotInstance","table","_this","isMaster","cloneOverlay","wot","TABLE","TBODY","THEAD","COLGROUP","tableOffset","holderOffset","hasTableHeight","hasTableWidth","isTableVisible","spreader","createSpreader","hider","createHider","holder","createHolder","wtRootElement","parentNode","alignOverlaysWithTrimmingContainer","fixTableDomTree","rowFilter","columnFilter","correctHeaderWidth","origRowHeaderWidth","wtSettings","settings","rowHeaderWidth","_modifyRowHeaderWidth","rowUtils","columnUtils","tableRenderer","cellRenderer","is","overlayTypeName","rootDocument","querySelector","createElement","appendChild","insertBefore","getSetting","childNodes","parent","nodeType","Node","ELEMENT_NODE","className","style","position","draw","fastDraw","arguments","undefined","wtOverlays","wtViewport","totalRows","totalColumns","rowHeaders","rowHeadersCount","columnHeaders","columnHeadersCount","syncScroll","runFastDraw","createRenderCalculators","leftScrollPos","leftOverlay","getScrollPosition","previousState","prepareOverlays","createVisibleCalculators","refresh","cloneSource","wtTable","startRow","getFirstRenderedRow","startColumn","getFirstRenderedColumn","performRedraw","skipRender","setHeaderContentRenderers","resetOversizedRows","setViewportSize","getRenderedRowsCount","getRenderedColumnsCount","setFilters","render","workspaceWidth","getWorkspaceWidth","containerWidth","markOversizedColumnHeaders","adjustColumnHeaderHeights","markOversizedRows","applyToDOM","hiderWidth","tableWidth","calculateWidths","renderer","colGroup","adjustElementsSize","positionChanged","topOverlay","resetFixedPosition","bottomOverlay","clone","topLeftCornerOverlay","bottomLeftCornerOverlay","refreshAll","refreshSelections","syncScrollWithMaster","drawn","markIfOversizedColumnHeader","col","sourceColIndex","renderedToSource","level","defaultRowHeight","previousColHeaderHeight","currentHeader","currentHeaderHeight","columnHeaderHeightSetting","getColumnHeaderHeight","getColumnHeader","oversizedColumnHeaders","isNaN","children","height","concat","rowsToRender","visibleRowIndex","sourceRow","oversizedRows","removeClassFromCells","nodes","querySelectorAll","selections","highlights","classesToRemove","_highlights$i$setting","highlightHeaderClassName","highlightRowClassName","highlightColumnClassName","classNames","classNamesLength","j","includes","additionalClassesToRemove","classesToRemoveLength","_i2","_i3","getCell","coords","row","column","hookResult","_hookResult","isRowBeforeRenderedRows","isRowAfterRenderedRows","isColumnBeforeRenderedColumns","isColumnAfterRenderedColumns","TR","sourceRowToVisibleColHeadedRow","sourceToRendered","Error","TD","sourceColumnToVisibleRowHeadedColumn","getColumnHeaders","THs","visibleColumn","forEach","TH","getRowHeader","getRowHeaders","renderedRowIndex","getCoords","cellElement","nodeName","CONTAINER","cellIndex","visibleColHeadedRowToSourceRow","offsettedTH","visibleRowHeadedColumnToSourceColumn","rowCount","expectedTableHeight","actualTableHeight","previousRowHeight","rowInnerHeight","sourceRowIndex","currentTr","rowHeader","getRowHeight","getTrForRow","isColumnHeaderRendered","Math","abs","isRowHeaderRendered","first","getLastRenderedRow","getLastRenderedColumn","isColumnAfterViewport","getLastVisibleColumn","isRowAfterViewport","getLastVisibleRow","isColumnBeforeViewport","isLastRowFullyVisible","isLastColumnFullyVisible","allRowsInViewport","getVisibleRowsCount","allColumnsInViewport","getVisibleColumnsCount","getHeight","getHeaderHeight","getColumnWidth","sourceColumn","getWidth","getStretchedColumnWidth","hasDefinedSize","rowHeaderWidthFactory","widths","_correctRowHeaderWidth","width"],"mappings":"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","sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\r\n\r\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\r\n\r\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\r\n\r\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\r\n\r\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\r\n\r\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\r\n\r\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\r\n\r\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\r\n\r\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\r\n\r\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\r\n\r\nimport \"core-js/modules/es.array.from.js\";\r\nimport \"core-js/modules/es.string.iterator.js\";\r\nimport \"core-js/modules/es.array.includes.js\";\r\nimport \"core-js/modules/web.dom-collections.for-each.js\";\r\nimport \"core-js/modules/es.symbol.js\";\r\nimport \"core-js/modules/es.symbol.description.js\";\r\nimport \"core-js/modules/es.object.to-string.js\";\r\nimport \"core-js/modules/es.symbol.iterator.js\";\r\nimport \"core-js/modules/es.array.iterator.js\";\r\nimport \"core-js/modules/web.dom-collections.iterator.js\";\r\nimport \"core-js/modules/es.array.slice.js\";\r\nimport \"core-js/modules/es.function.name.js\";\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport { hasClass, index, offset, removeClass, removeTextNodes, overlayContainsElement, closest, outerWidth, innerHeight, isVisible as _isVisible } from \"./../../../helpers/dom/element.mjs\";\r\nimport { isFunction } from \"./../../../helpers/function.mjs\";\r\nimport CellCoords from \"./cell/coords.mjs\";\r\nimport ColumnFilter from \"./filter/column.mjs\";\r\nimport RowFilter from \"./filter/row.mjs\";\r\nimport { Renderer } from \"./renderer/index.mjs\";\r\nimport ColumnUtils from \"./utils/column.mjs\";\r\nimport RowUtils from \"./utils/row.mjs\";\r\nimport { isOverlayTypeOf } from \"./overlay/registerer.mjs\";\r\nimport { CLONE_TOP, CLONE_BOTTOM, CLONE_LEFT, CLONE_TOP_LEFT_CORNER, CLONE_BOTTOM_LEFT_CORNER } from \"./overlay/constants.mjs\";\r\n/**\r\n *\r\n */\r\n\r\nvar Table = /*#__PURE__*/function () {\r\n  /**\r\n   * @param {Walkontable} wotInstance The Walkontable instance.\r\n   * @param {HTMLTableElement} table An element to the Walkontable generated table is injected.\r\n   */\r\n  function Table(wotInstance, table) {\r\n    var _this = this;\r\n\r\n    _classCallCheck(this, Table);\r\n\r\n    /**\r\n     * Indicates if this instance is of type `MasterTable` (i.e. It is NOT an overlay).\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    this.isMaster = !wotInstance.cloneOverlay; // \"instanceof\" operator isn't used, because it caused a circular reference in Webpack\r\n\r\n    this.wot = wotInstance; // legacy support\r\n\r\n    this.instance = this.wot;\r\n    this.TABLE = table;\r\n    this.TBODY = null;\r\n    this.THEAD = null;\r\n    this.COLGROUP = null;\r\n    this.tableOffset = 0;\r\n    this.holderOffset = 0;\r\n    /**\r\n     * Indicates if the table has height bigger than 0px.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n\r\n    this.hasTableHeight = true;\r\n    /**\r\n     * Indicates if the table has width bigger than 0px.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n\r\n    this.hasTableWidth = true;\r\n    /**\r\n     * Indicates if the table is visible. By visible, it means that the holder\r\n     * element has CSS 'display' property different than 'none'.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n\r\n    this.isTableVisible = false;\r\n    removeTextNodes(this.TABLE);\r\n    this.spreader = this.createSpreader(this.TABLE);\r\n    this.hider = this.createHider(this.spreader);\r\n    this.holder = this.createHolder(this.hider);\r\n    this.wtRootElement = this.holder.parentNode;\r\n\r\n    if (this.isMaster) {\r\n      this.alignOverlaysWithTrimmingContainer();\r\n    }\r\n\r\n    this.fixTableDomTree();\r\n    this.rowFilter = null;\r\n    this.columnFilter = null;\r\n    this.correctHeaderWidth = false;\r\n    var origRowHeaderWidth = this.wot.wtSettings.settings.rowHeaderWidth; // Fix for jumping row headers (https://github.com/handsontable/handsontable/issues/3850)\r\n\r\n    this.wot.wtSettings.settings.rowHeaderWidth = function () {\r\n      return _this._modifyRowHeaderWidth(origRowHeaderWidth);\r\n    };\r\n\r\n    this.rowUtils = new RowUtils(this.wot);\r\n    this.columnUtils = new ColumnUtils(this.wot);\r\n    this.tableRenderer = new Renderer({\r\n      TABLE: this.TABLE,\r\n      THEAD: this.THEAD,\r\n      COLGROUP: this.COLGROUP,\r\n      TBODY: this.TBODY,\r\n      rowUtils: this.rowUtils,\r\n      columnUtils: this.columnUtils,\r\n      cellRenderer: this.wot.wtSettings.settings.cellRenderer\r\n    });\r\n  }\r\n  /**\r\n   * Returns a boolean that is true if this intance of Table represents a specific overlay, identified by the overlay name.\r\n   * For MasterTable, it returns false.\r\n   *\r\n   * @param {string} overlayTypeName The overlay type.\r\n   * @returns {boolean}\r\n   */\r\n\r\n\r\n  _createClass(Table, [{\r\n    key: \"is\",\r\n    value: function is(overlayTypeName) {\r\n      return isOverlayTypeOf(this.wot.cloneOverlay, overlayTypeName);\r\n    }\r\n    /**\r\n     *\r\n     */\r\n\r\n  }, {\r\n    key: \"fixTableDomTree\",\r\n    value: function fixTableDomTree() {\r\n      var rootDocument = this.wot.rootDocument;\r\n      this.TBODY = this.TABLE.querySelector('tbody');\r\n\r\n      if (!this.TBODY) {\r\n        this.TBODY = rootDocument.createElement('tbody');\r\n        this.TABLE.appendChild(this.TBODY);\r\n      }\r\n\r\n      this.THEAD = this.TABLE.querySelector('thead');\r\n\r\n      if (!this.THEAD) {\r\n        this.THEAD = rootDocument.createElement('thead');\r\n        this.TABLE.insertBefore(this.THEAD, this.TBODY);\r\n      }\r\n\r\n      this.COLGROUP = this.TABLE.querySelector('colgroup');\r\n\r\n      if (!this.COLGROUP) {\r\n        this.COLGROUP = rootDocument.createElement('colgroup');\r\n        this.TABLE.insertBefore(this.COLGROUP, this.THEAD);\r\n      }\r\n\r\n      if (this.wot.getSetting('columnHeaders').length && !this.THEAD.childNodes.length) {\r\n        this.THEAD.appendChild(rootDocument.createElement('TR'));\r\n      }\r\n    }\r\n    /**\r\n     * @param {HTMLTableElement} table An element to process.\r\n     * @returns {HTMLElement}\r\n     */\r\n\r\n  }, {\r\n    key: \"createSpreader\",\r\n    value: function createSpreader(table) {\r\n      var parent = table.parentNode;\r\n      var spreader;\r\n\r\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\r\n        spreader = this.wot.rootDocument.createElement('div');\r\n        spreader.className = 'wtSpreader';\r\n\r\n        if (parent) {\r\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\r\n          parent.insertBefore(spreader, table);\r\n        }\r\n\r\n        spreader.appendChild(table);\r\n      }\r\n\r\n      spreader.style.position = 'relative';\r\n      return spreader;\r\n    }\r\n    /**\r\n     * @param {HTMLElement} spreader An element to the hider element is injected.\r\n     * @returns {HTMLElement}\r\n     */\r\n\r\n  }, {\r\n    key: \"createHider\",\r\n    value: function createHider(spreader) {\r\n      var parent = spreader.parentNode;\r\n      var hider;\r\n\r\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\r\n        hider = this.wot.rootDocument.createElement('div');\r\n        hider.className = 'wtHider';\r\n\r\n        if (parent) {\r\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\r\n          parent.insertBefore(hider, spreader);\r\n        }\r\n\r\n        hider.appendChild(spreader);\r\n      }\r\n\r\n      return hider;\r\n    }\r\n    /**\r\n     *\r\n     * @param {HTMLElement} hider An element to the holder element is injected.\r\n     * @returns {HTMLElement}\r\n     */\r\n\r\n  }, {\r\n    key: \"createHolder\",\r\n    value: function createHolder(hider) {\r\n      var parent = hider.parentNode;\r\n      var holder;\r\n\r\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\r\n        holder = this.wot.rootDocument.createElement('div');\r\n        holder.style.position = 'relative';\r\n        holder.className = 'wtHolder';\r\n\r\n        if (parent) {\r\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\r\n          parent.insertBefore(holder, hider);\r\n        }\r\n\r\n        if (this.isMaster) {\r\n          holder.parentNode.className += 'ht_master handsontable';\r\n        }\r\n\r\n        holder.appendChild(hider);\r\n      }\r\n\r\n      return holder;\r\n    }\r\n    /**\r\n     * Redraws the table.\r\n     *\r\n     * @param {boolean} [fastDraw=false] If TRUE, will try to avoid full redraw and only update the border positions.\r\n     *                                   If FALSE or UNDEFINED, will perform a full redraw.\r\n     * @returns {Table}\r\n     */\r\n\r\n  }, {\r\n    key: \"draw\",\r\n    value: function draw() {\r\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\r\n      var wot = this.wot;\r\n      var wtOverlays = wot.wtOverlays,\r\n          wtViewport = wot.wtViewport;\r\n      var totalRows = wot.getSetting('totalRows');\r\n      var totalColumns = wot.getSetting('totalColumns');\r\n      var rowHeaders = wot.getSetting('rowHeaders');\r\n      var rowHeadersCount = rowHeaders.length;\r\n      var columnHeaders = wot.getSetting('columnHeaders');\r\n      var columnHeadersCount = columnHeaders.length;\r\n      var syncScroll = false;\r\n      var runFastDraw = fastDraw;\r\n\r\n      if (this.isMaster) {\r\n        this.holderOffset = offset(this.holder);\r\n        runFastDraw = wtViewport.createRenderCalculators(runFastDraw);\r\n\r\n        if (rowHeadersCount && !wot.getSetting('fixedColumnsLeft')) {\r\n          var leftScrollPos = wtOverlays.leftOverlay.getScrollPosition();\r\n          var previousState = this.correctHeaderWidth;\r\n          this.correctHeaderWidth = leftScrollPos > 0;\r\n\r\n          if (previousState !== this.correctHeaderWidth) {\r\n            runFastDraw = false;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (this.isMaster) {\r\n        syncScroll = wtOverlays.prepareOverlays();\r\n      }\r\n\r\n      if (runFastDraw) {\r\n        if (this.isMaster) {\r\n          // in case we only scrolled without redraw, update visible rows information in oldRowsCalculator\r\n          wtViewport.createVisibleCalculators();\r\n        }\r\n\r\n        if (wtOverlays) {\r\n          wtOverlays.refresh(true);\r\n        }\r\n      } else {\r\n        if (this.isMaster) {\r\n          this.tableOffset = offset(this.TABLE);\r\n        } else {\r\n          this.tableOffset = this.wot.cloneSource.wtTable.tableOffset;\r\n        }\r\n\r\n        var startRow = totalRows > 0 ? this.getFirstRenderedRow() : 0;\r\n        var startColumn = totalColumns > 0 ? this.getFirstRenderedColumn() : 0;\r\n        this.rowFilter = new RowFilter(startRow, totalRows, columnHeadersCount);\r\n        this.columnFilter = new ColumnFilter(startColumn, totalColumns, rowHeadersCount);\r\n        var performRedraw = true; // Only master table rendering can be skipped\r\n\r\n        if (this.isMaster) {\r\n          this.alignOverlaysWithTrimmingContainer();\r\n          var skipRender = {};\r\n          this.wot.getSetting('beforeDraw', true, skipRender);\r\n          performRedraw = skipRender.skipRender !== true;\r\n        }\r\n\r\n        if (performRedraw) {\r\n          this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);\r\n\r\n          if (this.is(CLONE_BOTTOM) || this.is(CLONE_BOTTOM_LEFT_CORNER)) {\r\n            // do NOT render headers on the bottom or bottom-left corner overlay\r\n            this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);\r\n          }\r\n\r\n          this.resetOversizedRows();\r\n          this.tableRenderer.setViewportSize(this.getRenderedRowsCount(), this.getRenderedColumnsCount()).setFilters(this.rowFilter, this.columnFilter).render();\r\n          var workspaceWidth;\r\n\r\n          if (this.isMaster) {\r\n            workspaceWidth = this.wot.wtViewport.getWorkspaceWidth();\r\n            this.wot.wtViewport.containerWidth = null;\r\n            this.markOversizedColumnHeaders();\r\n          }\r\n\r\n          this.adjustColumnHeaderHeights();\r\n\r\n          if (this.isMaster || this.is(CLONE_BOTTOM)) {\r\n            this.markOversizedRows();\r\n          }\r\n\r\n          if (this.isMaster) {\r\n            this.wot.wtViewport.createVisibleCalculators();\r\n            this.wot.wtOverlays.refresh(false);\r\n            this.wot.wtOverlays.applyToDOM();\r\n            var hiderWidth = outerWidth(this.hider);\r\n            var tableWidth = outerWidth(this.TABLE);\r\n\r\n            if (hiderWidth !== 0 && tableWidth !== hiderWidth) {\r\n              // Recalculate the column widths, if width changes made in the overlays removed the scrollbar, thus changing the viewport width.\r\n              this.columnUtils.calculateWidths();\r\n              this.tableRenderer.renderer.colGroup.render();\r\n            }\r\n\r\n            if (workspaceWidth !== this.wot.wtViewport.getWorkspaceWidth()) {\r\n              // workspace width changed though to shown/hidden vertical scrollbar. Let's reapply stretching\r\n              this.wot.wtViewport.containerWidth = null;\r\n              this.columnUtils.calculateWidths();\r\n              this.tableRenderer.renderer.colGroup.render();\r\n            }\r\n\r\n            this.wot.getSetting('onDraw', true);\r\n          } else if (this.is(CLONE_BOTTOM)) {\r\n            this.wot.cloneSource.wtOverlays.adjustElementsSize();\r\n          }\r\n        }\r\n      }\r\n\r\n      if (this.isMaster) {\r\n        var positionChanged = wtOverlays.topOverlay.resetFixedPosition();\r\n\r\n        if (wtOverlays.bottomOverlay.clone) {\r\n          positionChanged = wtOverlays.bottomOverlay.resetFixedPosition() || positionChanged;\r\n        }\r\n\r\n        positionChanged = wtOverlays.leftOverlay.resetFixedPosition() || positionChanged;\r\n\r\n        if (wtOverlays.topLeftCornerOverlay) {\r\n          wtOverlays.topLeftCornerOverlay.resetFixedPosition();\r\n        }\r\n\r\n        if (wtOverlays.bottomLeftCornerOverlay && wtOverlays.bottomLeftCornerOverlay.clone) {\r\n          wtOverlays.bottomLeftCornerOverlay.resetFixedPosition();\r\n        }\r\n\r\n        if (positionChanged) {\r\n          // It refreshes the cells borders caused by a 1px shift (introduced by overlays which add or\r\n          // remove `innerBorderTop` and `innerBorderLeft` CSS classes to the DOM element. This happens\r\n          // when there is a switch between rendering from 0 to N rows/columns and vice versa).\r\n          wtOverlays.refreshAll();\r\n          wtOverlays.adjustElementsSize();\r\n        }\r\n      }\r\n\r\n      this.refreshSelections(runFastDraw);\r\n\r\n      if (syncScroll) {\r\n        wtOverlays.syncScrollWithMaster();\r\n      }\r\n\r\n      wot.drawn = true;\r\n      return this;\r\n    }\r\n    /**\r\n     * @param {number} col The visual column index.\r\n     */\r\n\r\n  }, {\r\n    key: \"markIfOversizedColumnHeader\",\r\n    value: function markIfOversizedColumnHeader(col) {\r\n      var sourceColIndex = this.wot.wtTable.columnFilter.renderedToSource(col);\r\n      var level = this.wot.getSetting('columnHeaders').length;\r\n      var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;\r\n      var previousColHeaderHeight;\r\n      var currentHeader;\r\n      var currentHeaderHeight;\r\n      var columnHeaderHeightSetting = this.wot.getSetting('columnHeaderHeight') || [];\r\n\r\n      while (level) {\r\n        level -= 1;\r\n        previousColHeaderHeight = this.wot.wtTable.getColumnHeaderHeight(level);\r\n        currentHeader = this.wot.wtTable.getColumnHeader(sourceColIndex, level);\r\n\r\n        if (!currentHeader) {\r\n          /* eslint-disable no-continue */\r\n          continue;\r\n        }\r\n\r\n        currentHeaderHeight = innerHeight(currentHeader);\r\n\r\n        if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {\r\n          this.wot.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;\r\n        }\r\n\r\n        if (Array.isArray(columnHeaderHeightSetting)) {\r\n          if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== void 0) {\r\n            this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];\r\n          }\r\n        } else if (!isNaN(columnHeaderHeightSetting)) {\r\n          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;\r\n        }\r\n\r\n        if (this.wot.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {\r\n          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting; // eslint-disable-line max-len\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     *\r\n     */\r\n\r\n  }, {\r\n    key: \"adjustColumnHeaderHeights\",\r\n    value: function adjustColumnHeaderHeights() {\r\n      var wot = this.wot;\r\n      var children = wot.wtTable.THEAD.childNodes;\r\n      var oversizedColumnHeaders = wot.wtViewport.oversizedColumnHeaders;\r\n      var columnHeaders = wot.getSetting('columnHeaders');\r\n\r\n      for (var i = 0, len = columnHeaders.length; i < len; i++) {\r\n        if (oversizedColumnHeaders[i]) {\r\n          if (!children[i] || children[i].childNodes.length === 0) {\r\n            return;\r\n          }\r\n\r\n          children[i].childNodes[0].style.height = \"\".concat(oversizedColumnHeaders[i], \"px\");\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Resets cache of row heights. The cache should be cached for each render cycle in a case\r\n     * when new cell values have content which increases/decreases cell height.\r\n     */\r\n\r\n  }, {\r\n    key: \"resetOversizedRows\",\r\n    value: function resetOversizedRows() {\r\n      var wot = this.wot;\r\n\r\n      if (!this.isMaster && !this.is(CLONE_BOTTOM)) {\r\n        return;\r\n      }\r\n\r\n      if (!wot.getSetting('externalRowCalculator')) {\r\n        var rowsToRender = this.getRenderedRowsCount(); // Reset the oversized row cache for rendered rows\r\n\r\n        for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {\r\n          var sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);\r\n\r\n          if (wot.wtViewport.oversizedRows && wot.wtViewport.oversizedRows[sourceRow]) {\r\n            wot.wtViewport.oversizedRows[sourceRow] = void 0;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * @param {string} className The CSS class name to remove from the table cells.\r\n     */\r\n\r\n  }, {\r\n    key: \"removeClassFromCells\",\r\n    value: function removeClassFromCells(className) {\r\n      var nodes = this.TABLE.querySelectorAll(\".\".concat(className));\r\n\r\n      for (var i = 0, len = nodes.length; i < len; i++) {\r\n        removeClass(nodes[i], className);\r\n      }\r\n    }\r\n    /**\r\n     * Refresh the table selection by re-rendering Selection instances connected with that instance.\r\n     *\r\n     * @param {boolean} fastDraw If fast drawing is enabled than additionally className clearing is applied.\r\n     */\r\n\r\n  }, {\r\n    key: \"refreshSelections\",\r\n    value: function refreshSelections(fastDraw) {\r\n      var wot = this.wot;\r\n\r\n      if (!wot.selections) {\r\n        return;\r\n      }\r\n\r\n      var highlights = Array.from(wot.selections);\r\n      var len = highlights.length;\r\n\r\n      if (fastDraw) {\r\n        var classesToRemove = [];\r\n\r\n        for (var i = 0; i < len; i++) {\r\n          var _highlights$i$setting = highlights[i].settings,\r\n              highlightHeaderClassName = _highlights$i$setting.highlightHeaderClassName,\r\n              highlightRowClassName = _highlights$i$setting.highlightRowClassName,\r\n              highlightColumnClassName = _highlights$i$setting.highlightColumnClassName;\r\n          var classNames = highlights[i].classNames;\r\n          var classNamesLength = classNames.length;\r\n\r\n          for (var j = 0; j < classNamesLength; j++) {\r\n            if (!classesToRemove.includes(classNames[j])) {\r\n              classesToRemove.push(classNames[j]);\r\n            }\r\n          }\r\n\r\n          if (highlightHeaderClassName && !classesToRemove.includes(highlightHeaderClassName)) {\r\n            classesToRemove.push(highlightHeaderClassName);\r\n          }\r\n\r\n          if (highlightRowClassName && !classesToRemove.includes(highlightRowClassName)) {\r\n            classesToRemove.push(highlightRowClassName);\r\n          }\r\n\r\n          if (highlightColumnClassName && !classesToRemove.includes(highlightColumnClassName)) {\r\n            classesToRemove.push(highlightColumnClassName);\r\n          }\r\n        }\r\n\r\n        var additionalClassesToRemove = wot.getSetting('onBeforeRemoveCellClassNames');\r\n\r\n        if (Array.isArray(additionalClassesToRemove)) {\r\n          for (var _i = 0; _i < additionalClassesToRemove.length; _i++) {\r\n            classesToRemove.push(additionalClassesToRemove[_i]);\r\n          }\r\n        }\r\n\r\n        var classesToRemoveLength = classesToRemove.length;\r\n\r\n        for (var _i2 = 0; _i2 < classesToRemoveLength; _i2++) {\r\n          // there was no rerender, so we need to remove classNames by ourselves\r\n          this.removeClassFromCells(classesToRemove[_i2]);\r\n        }\r\n      }\r\n\r\n      for (var _i3 = 0; _i3 < len; _i3++) {\r\n        highlights[_i3].draw(wot, fastDraw);\r\n      }\r\n    }\r\n    /**\r\n     * Get cell element at coords.\r\n     * Negative coords.row or coords.col are used to retrieve header cells. If there are multiple header levels, the\r\n     * negative value corresponds to the distance from the working area. For example, when there are 3 levels of column\r\n     * headers, coords.col=-1 corresponds to the most inner header element, while coords.col=-3 corresponds to the\r\n     * outmost header element.\r\n     *\r\n     * In case an element for the coords is not rendered, the method returns an error code.\r\n     * To produce the error code, the input parameters are validated in the order in which they\r\n     * are given. Thus, if both the row and the column coords are out of the rendered bounds,\r\n     * the method returns the error code for the row.\r\n     *\r\n     * @param {CellCoords} coords The cell coordinates.\r\n     * @returns {HTMLElement|number} HTMLElement on success or Number one of the exit codes on error:\r\n     *  -1 row before viewport\r\n     *  -2 row after viewport\r\n     *  -3 column before viewport\r\n     *  -4 column after viewport.\r\n     */\r\n\r\n  }, {\r\n    key: \"getCell\",\r\n    value: function getCell(coords) {\r\n      var row = coords.row;\r\n      var column = coords.col;\r\n      var hookResult = this.wot.getSetting('onModifyGetCellCoords', row, column);\r\n\r\n      if (hookResult && Array.isArray(hookResult)) {\r\n        var _hookResult = _slicedToArray(hookResult, 2);\r\n\r\n        row = _hookResult[0];\r\n        column = _hookResult[1];\r\n      }\r\n\r\n      if (this.isRowBeforeRenderedRows(row)) {\r\n        // row before rendered rows\r\n        return -1;\r\n      } else if (this.isRowAfterRenderedRows(row)) {\r\n        // row after rendered rows\r\n        return -2;\r\n      } else if (this.isColumnBeforeRenderedColumns(column)) {\r\n        // column before rendered columns\r\n        return -3;\r\n      } else if (this.isColumnAfterRenderedColumns(column)) {\r\n        // column after rendered columns\r\n        return -4;\r\n      }\r\n\r\n      var TR;\r\n\r\n      if (row < 0) {\r\n        TR = this.THEAD.childNodes[this.rowFilter.sourceRowToVisibleColHeadedRow(row)];\r\n      } else {\r\n        TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\r\n      }\r\n\r\n      if (!TR && row >= 0) {\r\n        throw new Error('TR was expected to be rendered but is not');\r\n      }\r\n\r\n      var TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];\r\n\r\n      if (!TD && column >= 0) {\r\n        throw new Error('TD or TH was expected to be rendered but is not');\r\n      }\r\n\r\n      return TD;\r\n    }\r\n    /**\r\n     * GetColumnHeader.\r\n     *\r\n     * @param {number} col Column index.\r\n     * @param {number} [level=0] Header level (0 = most distant to the table).\r\n     * @returns {object} HTMLElement on success or undefined on error.\r\n     */\r\n\r\n  }, {\r\n    key: \"getColumnHeader\",\r\n    value: function getColumnHeader(col) {\r\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\r\n      var TR = this.THEAD.childNodes[level];\r\n      return TR === null || TR === void 0 ? void 0 : TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];\r\n    }\r\n    /**\r\n     * Gets all columns headers (TH elements) from the table.\r\n     *\r\n     * @param {number} column A source column index.\r\n     * @returns {HTMLTableCellElement[]}\r\n     */\r\n\r\n  }, {\r\n    key: \"getColumnHeaders\",\r\n    value: function getColumnHeaders(column) {\r\n      var THs = [];\r\n      var visibleColumn = this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column);\r\n      this.THEAD.childNodes.forEach(function (TR) {\r\n        var TH = TR.childNodes[visibleColumn];\r\n\r\n        if (TH) {\r\n          THs.push(TH);\r\n        }\r\n      });\r\n      return THs;\r\n    }\r\n    /**\r\n     * GetRowHeader.\r\n     *\r\n     * @param {number} row Row index.\r\n     * @param {number} [level=0] Header level (0 = most distant to the table).\r\n     * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have row headers`.\r\n     */\r\n\r\n  }, {\r\n    key: \"getRowHeader\",\r\n    value: function getRowHeader(row) {\r\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\r\n\r\n      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {\r\n        return;\r\n      }\r\n\r\n      var rowHeadersCount = this.wot.getSetting('rowHeaders').length;\r\n\r\n      if (level >= rowHeadersCount) {\r\n        return;\r\n      }\r\n\r\n      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\r\n      return TR === null || TR === void 0 ? void 0 : TR.childNodes[level];\r\n    }\r\n    /**\r\n     * Gets all rows headers (TH elements) from the table.\r\n     *\r\n     * @param {number} row A source row index.\r\n     * @returns {HTMLTableCellElement[]}\r\n     */\r\n\r\n  }, {\r\n    key: \"getRowHeaders\",\r\n    value: function getRowHeaders(row) {\r\n      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {\r\n        return [];\r\n      }\r\n\r\n      var THs = [];\r\n      var rowHeadersCount = this.wot.getSetting('rowHeaders').length;\r\n\r\n      for (var renderedRowIndex = 0; renderedRowIndex < rowHeadersCount; renderedRowIndex++) {\r\n        var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\r\n        var TH = TR === null || TR === void 0 ? void 0 : TR.childNodes[renderedRowIndex];\r\n\r\n        if (TH) {\r\n          THs.push(TH);\r\n        }\r\n      }\r\n\r\n      return THs;\r\n    }\r\n    /**\r\n     * Returns cell coords object for a given TD (or a child element of a TD element).\r\n     *\r\n     * @param {HTMLTableCellElement} TD A cell DOM element (or a child of one).\r\n     * @returns {CellCoords|null} The coordinates of the provided TD element (or the closest TD element) or null, if the provided element is not applicable.\r\n     */\r\n\r\n  }, {\r\n    key: \"getCoords\",\r\n    value: function getCoords(TD) {\r\n      var cellElement = TD;\r\n\r\n      if (cellElement.nodeName !== 'TD' && cellElement.nodeName !== 'TH') {\r\n        cellElement = closest(cellElement, ['TD', 'TH']);\r\n      }\r\n\r\n      if (cellElement === null) {\r\n        return null;\r\n      }\r\n\r\n      var TR = cellElement.parentNode;\r\n      var CONTAINER = TR.parentNode;\r\n      var row = index(TR);\r\n      var col = cellElement.cellIndex;\r\n\r\n      if (overlayContainsElement(CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_TOP, cellElement, this.wtRootElement)) {\r\n        if (CONTAINER.nodeName === 'THEAD') {\r\n          row -= CONTAINER.childNodes.length;\r\n        }\r\n      } else if (overlayContainsElement(CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM, cellElement, this.wtRootElement)) {\r\n        var totalRows = this.wot.getSetting('totalRows');\r\n        row = totalRows - CONTAINER.childNodes.length + row;\r\n      } else if (CONTAINER === this.THEAD) {\r\n        row = this.rowFilter.visibleColHeadedRowToSourceRow(row);\r\n      } else {\r\n        row = this.rowFilter.renderedToSource(row);\r\n      }\r\n\r\n      if (overlayContainsElement(CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_LEFT, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement)) {\r\n        col = this.columnFilter.offsettedTH(col);\r\n      } else {\r\n        col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);\r\n      }\r\n\r\n      return new CellCoords(row, col);\r\n    }\r\n    /**\r\n     * Check if any of the rendered rows is higher than expected, and if so, cache them.\r\n     */\r\n\r\n  }, {\r\n    key: \"markOversizedRows\",\r\n    value: function markOversizedRows() {\r\n      if (this.wot.getSetting('externalRowCalculator')) {\r\n        return;\r\n      }\r\n\r\n      var rowCount = this.TBODY.childNodes.length;\r\n      var expectedTableHeight = rowCount * this.wot.wtSettings.settings.defaultRowHeight;\r\n      var actualTableHeight = innerHeight(this.TBODY) - 1;\r\n      var previousRowHeight;\r\n      var rowInnerHeight;\r\n      var sourceRowIndex;\r\n      var currentTr;\r\n      var rowHeader;\r\n\r\n      if (expectedTableHeight === actualTableHeight && !this.wot.getSetting('fixedRowsBottom')) {\r\n        // If the actual table height equals rowCount * default single row height, no row is oversized -> no need to iterate over them\r\n        return;\r\n      }\r\n\r\n      while (rowCount) {\r\n        rowCount -= 1;\r\n        sourceRowIndex = this.rowFilter.renderedToSource(rowCount);\r\n        previousRowHeight = this.getRowHeight(sourceRowIndex);\r\n        currentTr = this.getTrForRow(sourceRowIndex);\r\n        rowHeader = currentTr.querySelector('th');\r\n\r\n        if (rowHeader) {\r\n          rowInnerHeight = innerHeight(rowHeader);\r\n        } else {\r\n          rowInnerHeight = innerHeight(currentTr) - 1;\r\n        }\r\n\r\n        if (!previousRowHeight && this.wot.wtSettings.settings.defaultRowHeight < rowInnerHeight || previousRowHeight < rowInnerHeight) {\r\n          rowInnerHeight += 1;\r\n          this.wot.wtViewport.oversizedRows[sourceRowIndex] = rowInnerHeight;\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * @param {number} row The visual row index.\r\n     * @returns {HTMLTableElement}\r\n     */\r\n\r\n  }, {\r\n    key: \"getTrForRow\",\r\n    value: function getTrForRow(row) {\r\n      return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\r\n    }\r\n    /**\r\n     * Checks if the column index (negative value from -1 to N) is rendered.\r\n     *\r\n     * @param {number} column The column index (negative value from -1 to N).\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isColumnHeaderRendered\",\r\n    value: function isColumnHeaderRendered(column) {\r\n      if (column >= 0) {\r\n        return false;\r\n      }\r\n\r\n      var rowHeaders = this.wot.getSetting('rowHeaders');\r\n      var rowHeadersCount = rowHeaders.length;\r\n      return Math.abs(column) <= rowHeadersCount;\r\n    }\r\n    /**\r\n     * Checks if the row index (negative value from -1 to N) is rendered.\r\n     *\r\n     * @param {number} row The row index (negative value from -1 to N).\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isRowHeaderRendered\",\r\n    value: function isRowHeaderRendered(row) {\r\n      if (row >= 0) {\r\n        return false;\r\n      }\r\n\r\n      var columnHeaders = this.wot.getSetting('columnHeaders');\r\n      var columnHeadersCount = columnHeaders.length;\r\n      return Math.abs(row) <= columnHeadersCount;\r\n    }\r\n    /* eslint-disable jsdoc/require-description-complete-sentence */\r\n\r\n    /**\r\n     * Check if the given row index is lower than the index of the first row that\r\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\r\n     *\r\n     * Negative row index is used to check the columns' headers.\r\n     *\r\n     *  Headers\r\n     *           +--------------+                                     │\r\n     *       -3  │    │    │    │                                     │\r\n     *           +--------------+                                     │\r\n     *       -2  │    │    │    │                                     │ TRUE\r\n     *           +--------------+                                     │\r\n     *       -1  │    │    │    │                                     │\r\n     *  Cells  +==================+                                   │\r\n     *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │\r\n     *           +--------------+      the master overlay do       ---+ first rendered row (index 1)\r\n     *        1  │ A2 │ B2 │ C2 │      not render the first row.      │\r\n     *           +--------------+                                     │ FALSE\r\n     *        2  │ A3 │ B3 │ C3 │                                     │\r\n     *           +--------------+                                  ---+ last rendered row\r\n     *                                                                │\r\n     *                                                                │ FALSE\r\n     *\r\n     * @param {number} row The visual row index.\r\n     * @memberof Table#\r\n     * @function isRowBeforeRenderedRows\r\n     * @returns {boolean}\r\n     */\r\n\r\n    /* eslint-enable jsdoc/require-description-complete-sentence */\r\n\r\n  }, {\r\n    key: \"isRowBeforeRenderedRows\",\r\n    value: function isRowBeforeRenderedRows(row) {\r\n      var first = this.getFirstRenderedRow(); // Check the headers only in case when the first rendered row is -1 or 0.\r\n      // This is an indication that the overlay is placed on the most top position.\r\n\r\n      if (row < 0 && first <= 0) {\r\n        return !this.isRowHeaderRendered(row);\r\n      }\r\n\r\n      return row < first;\r\n    }\r\n    /* eslint-disable jsdoc/require-description-complete-sentence */\r\n\r\n    /**\r\n     * Check if the given column index is greater than the index of the last column that\r\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\r\n     *\r\n     * The negative row index is used to check the columns' headers. However,\r\n     * keep in mind that for negative indexes, the method always returns FALSE as\r\n     * it is not possible to render headers partially. The \"after\" index can not be\r\n     * lower than -1.\r\n     *\r\n     *  Headers\r\n     *           +--------------+                                     │\r\n     *       -3  │    │    │    │                                     │\r\n     *           +--------------+                                     │\r\n     *       -2  │    │    │    │                                     │ FALSE\r\n     *           +--------------+                                     │\r\n     *       -1  │    │    │    │                                     │\r\n     *  Cells  +==================+                                   │\r\n     *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │\r\n     *           +--------------+      the master overlay do       ---+ first rendered row (index 1)\r\n     *        1  │ A2 │ B2 │ C2 │      not render the first rows      │\r\n     *           +--------------+                                     │ FALSE\r\n     *        2  │ A3 │ B3 │ C3 │                                     │\r\n     *           +--------------+                                  ---+ last rendered row\r\n     *                                                                │\r\n     *                                                                │ TRUE\r\n     *\r\n     * @param {number} row The visual row index.\r\n     * @memberof Table#\r\n     * @function isRowAfterRenderedRows\r\n     * @returns {boolean}\r\n     */\r\n\r\n    /* eslint-enable jsdoc/require-description-complete-sentence */\r\n\r\n  }, {\r\n    key: \"isRowAfterRenderedRows\",\r\n    value: function isRowAfterRenderedRows(row) {\r\n      return row > this.getLastRenderedRow();\r\n    }\r\n    /* eslint-disable jsdoc/require-description-complete-sentence */\r\n\r\n    /**\r\n     * Check if the given column index is lower than the index of the first column that\r\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\r\n     *\r\n     * Negative column index is used to check the rows' headers.\r\n     *\r\n     *                            For fixedColumnsLeft: 1 the master overlay\r\n     *                            do not render this first columns.\r\n     *  Headers    -3   -2   -1    |\r\n     *           +----+----+----║┄ ┄ +------+------+\r\n     *           │    │    │    ║    │  B1  │  C1  │\r\n     *           +--------------║┄ ┄ --------------│\r\n     *           │    │    │    ║    │  B2  │  C2  │\r\n     *           +--------------║┄ ┄ --------------│\r\n     *           │    │    │    ║    │  B3  │  C3  │\r\n     *           +----+----+----║┄ ┄ +------+------+\r\n     *                               ╷             ╷\r\n     *      -------------------------+-------------+---------------->\r\n     *          TRUE             first    FALSE   last         FALSE\r\n     *                           rendered         rendered\r\n     *                           column           column\r\n     *\r\n     * @param {number} column The visual column index.\r\n     * @memberof Table#\r\n     * @function isColumnBeforeRenderedColumns\r\n     * @returns {boolean}\r\n     */\r\n\r\n    /* eslint-enable jsdoc/require-description-complete-sentence */\r\n\r\n  }, {\r\n    key: \"isColumnBeforeRenderedColumns\",\r\n    value: function isColumnBeforeRenderedColumns(column) {\r\n      var first = this.getFirstRenderedColumn(); // Check the headers only in case when the first rendered column is -1 or 0.\r\n      // This is an indication that the overlay is placed on the most left position.\r\n\r\n      if (column < 0 && first <= 0) {\r\n        return !this.isColumnHeaderRendered(column);\r\n      }\r\n\r\n      return column < first;\r\n    }\r\n    /* eslint-disable jsdoc/require-description-complete-sentence */\r\n\r\n    /**\r\n     * Check if the given column index is greater than the index of the last column that\r\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\r\n     *\r\n     * The negative column index is used to check the rows' headers. However,\r\n     * keep in mind that for negative indexes, the method always returns FALSE as\r\n     * it is not possible to render headers partially. The \"after\" index can not be\r\n     * lower than -1.\r\n     *\r\n     *                            For fixedColumnsLeft: 1 the master overlay\r\n     *                            do not render this first columns.\r\n     *  Headers    -3   -2   -1    |\r\n     *           +----+----+----║┄ ┄ +------+------+\r\n     *           │    │    │    ║    │  B1  │  C1  │\r\n     *           +--------------║┄ ┄ --------------│\r\n     *           │    │    │    ║    │  B2  │  C2  │\r\n     *           +--------------║┄ ┄ --------------│\r\n     *           │    │    │    ║    │  B3  │  C3  │\r\n     *           +----+----+----║┄ ┄ +------+------+\r\n     *                               ╷             ╷\r\n     *      -------------------------+-------------+---------------->\r\n     *          FALSE             first    FALSE   last         TRUE\r\n     *                           rendered         rendered\r\n     *                           column           column\r\n     *\r\n     * @param {number} column The visual column index.\r\n     * @memberof Table#\r\n     * @function isColumnAfterRenderedColumns\r\n     * @returns {boolean}\r\n     */\r\n\r\n    /* eslint-enable jsdoc/require-description-complete-sentence */\r\n\r\n  }, {\r\n    key: \"isColumnAfterRenderedColumns\",\r\n    value: function isColumnAfterRenderedColumns(column) {\r\n      return this.columnFilter && column > this.getLastRenderedColumn();\r\n    }\r\n  }, {\r\n    key: \"isColumnAfterViewport\",\r\n    value: function isColumnAfterViewport(column) {\r\n      return this.columnFilter && column > this.getLastVisibleColumn();\r\n    }\r\n  }, {\r\n    key: \"isRowAfterViewport\",\r\n    value: function isRowAfterViewport(row) {\r\n      return this.rowFilter && row > this.getLastVisibleRow();\r\n    }\r\n  }, {\r\n    key: \"isColumnBeforeViewport\",\r\n    value: function isColumnBeforeViewport(column) {\r\n      return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;\r\n    }\r\n  }, {\r\n    key: \"isLastRowFullyVisible\",\r\n    value: function isLastRowFullyVisible() {\r\n      return this.getLastVisibleRow() === this.getLastRenderedRow();\r\n    }\r\n  }, {\r\n    key: \"isLastColumnFullyVisible\",\r\n    value: function isLastColumnFullyVisible() {\r\n      return this.getLastVisibleColumn() === this.getLastRenderedColumn();\r\n    }\r\n  }, {\r\n    key: \"allRowsInViewport\",\r\n    value: function allRowsInViewport() {\r\n      return this.wot.getSetting('totalRows') === this.getVisibleRowsCount();\r\n    }\r\n  }, {\r\n    key: \"allColumnsInViewport\",\r\n    value: function allColumnsInViewport() {\r\n      return this.wot.getSetting('totalColumns') === this.getVisibleColumnsCount();\r\n    }\r\n    /**\r\n     * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height.\r\n     *\r\n     * @param {number} sourceRow The physical row index.\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getRowHeight\",\r\n    value: function getRowHeight(sourceRow) {\r\n      return this.rowUtils.getHeight(sourceRow);\r\n    }\r\n    /**\r\n     * @param {number} level The column level.\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getColumnHeaderHeight\",\r\n    value: function getColumnHeaderHeight(level) {\r\n      return this.columnUtils.getHeaderHeight(level);\r\n    }\r\n    /**\r\n     * @param {number} sourceColumn The physical column index.\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getColumnWidth\",\r\n    value: function getColumnWidth(sourceColumn) {\r\n      return this.columnUtils.getWidth(sourceColumn);\r\n    }\r\n    /**\r\n     * @param {number} sourceColumn The physical column index.\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getStretchedColumnWidth\",\r\n    value: function getStretchedColumnWidth(sourceColumn) {\r\n      return this.columnUtils.getStretchedColumnWidth(sourceColumn);\r\n    }\r\n    /**\r\n     * Checks if the table has defined size. It returns `true` when the table has width and height\r\n     * set bigger than `0px`.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"hasDefinedSize\",\r\n    value: function hasDefinedSize() {\r\n      return this.hasTableHeight && this.hasTableWidth;\r\n    }\r\n    /**\r\n     * Checks if the table is visible. It returns `true` when the holder element (or its parents)\r\n     * has CSS 'display' property different than 'none'.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isVisible\",\r\n    value: function isVisible() {\r\n      return _isVisible(this.TABLE);\r\n    }\r\n    /**\r\n     * Modify row header widths provided by user in class contructor.\r\n     *\r\n     * @private\r\n     * @param {Function} rowHeaderWidthFactory The function which can provide default width values for rows..\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"_modifyRowHeaderWidth\",\r\n    value: function _modifyRowHeaderWidth(rowHeaderWidthFactory) {\r\n      var widths = isFunction(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;\r\n\r\n      if (Array.isArray(widths)) {\r\n        widths = _toConsumableArray(widths);\r\n        widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);\r\n      } else {\r\n        widths = this._correctRowHeaderWidth(widths);\r\n      }\r\n\r\n      return widths;\r\n    }\r\n    /**\r\n     * Correct row header width if necessary.\r\n     *\r\n     * @private\r\n     * @param {number} width The width to process.\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"_correctRowHeaderWidth\",\r\n    value: function _correctRowHeaderWidth(width) {\r\n      var rowHeaderWidth = width;\r\n\r\n      if (typeof width !== 'number') {\r\n        rowHeaderWidth = this.wot.getSetting('defaultColumnWidth');\r\n      }\r\n\r\n      if (this.correctHeaderWidth) {\r\n        rowHeaderWidth += 1;\r\n      }\r\n\r\n      return rowHeaderWidth;\r\n    }\r\n  }]);\r\n\r\n  return Table;\r\n}();\r\n\r\nexport default Table;"]},"metadata":{},"sourceType":"module"}