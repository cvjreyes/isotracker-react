{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { WORKING_SPACE_TOP, WORKING_SPACE_BOTTOM } from \"./constants.mjs\";\nimport ViewSizeSet from \"./viewSizeSet.mjs\";\n/**\r\n * Executive model for each table renderer. It's responsible for injecting DOM nodes in a\r\n * specified order and adjusting the number of elements in the root node.\r\n *\r\n * Only this class have rights to juggling DOM elements within the root node (see render method).\r\n *\r\n * @class {OrderView}\r\n */\n\nvar OrderView = /*#__PURE__*/function () {\n  function OrderView(rootNode, nodesPool, childNodeType) {\n    _classCallCheck(this, OrderView);\n    /**\r\n     * The root node to manage with.\r\n     *\r\n     * @type {HTMLElement}\r\n     */\n\n\n    this.rootNode = rootNode;\n    /**\r\n     * Factory for newly created DOM elements.\r\n     *\r\n     * @type {Function}\r\n     */\n\n    this.nodesPool = nodesPool;\n    /**\r\n     * Holder for sizing and positioning of the view.\r\n     *\r\n     * @type {ViewSizeSet}\r\n     */\n\n    this.sizeSet = new ViewSizeSet();\n    /**\r\n     * Node type which the order view will manage while rendering the DOM elements.\r\n     *\r\n     * @type {string}\r\n     */\n\n    this.childNodeType = childNodeType.toUpperCase();\n    /**\r\n     * The visual index of currently processed row.\r\n     *\r\n     * @type {number}\r\n     */\n\n    this.visualIndex = 0;\n    /**\r\n     * The list of DOM elements which are rendered for this render cycle.\r\n     *\r\n     * @type {HTMLElement[]}\r\n     */\n\n    this.collectedNodes = [];\n  }\n  /**\r\n   * Sets the size for rendered elements. It can be a size for rows, cells or size for row\r\n   * headers etc. It depends for what table renderer this instance was created.\r\n   *\r\n   * @param {number} size The size.\r\n   * @returns {OrderView}\r\n   */\n\n\n  _createClass(OrderView, [{\n    key: \"setSize\",\n    value: function setSize(size) {\n      this.sizeSet.setSize(size);\n      return this;\n    }\n    /**\r\n     * Sets the offset for rendered elements. The offset describes the shift between 0 and\r\n     * the first rendered element according to the scroll position.\r\n     *\r\n     * @param {number} offset The offset.\r\n     * @returns {OrderView}\r\n     */\n\n  }, {\n    key: \"setOffset\",\n    value: function setOffset(offset) {\n      this.sizeSet.setOffset(offset);\n      return this;\n    }\n    /**\r\n     * Checks if this instance of the view shares the root node with another instance. This happens only once when\r\n     * a row (TR) as a root node is managed by two OrderView instances. If this happens another DOM injection\r\n     * algorithm is performed to achieve consistent order.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isSharedViewSet\",\n    value: function isSharedViewSet() {\n      return this.sizeSet.isShared();\n    }\n    /**\r\n     * Returns rendered DOM element based on visual index.\r\n     *\r\n     * @param {number} visualIndex The visual index.\r\n     * @returns {HTMLElement}\r\n     */\n\n  }, {\n    key: \"getNode\",\n    value: function getNode(visualIndex) {\n      return visualIndex < this.collectedNodes.length ? this.collectedNodes[visualIndex] : null;\n    }\n    /**\r\n     * Returns currently processed DOM element.\r\n     *\r\n     * @returns {HTMLElement}\r\n     */\n\n  }, {\n    key: \"getCurrentNode\",\n    value: function getCurrentNode() {\n      var length = this.collectedNodes.length;\n      return length > 0 ? this.collectedNodes[length - 1] : null;\n    }\n    /**\r\n     * Returns rendered child count for this instance.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getRenderedChildCount\",\n    value: function getRenderedChildCount() {\n      var rootNode = this.rootNode,\n          sizeSet = this.sizeSet;\n      var childElementCount = 0;\n\n      if (this.isSharedViewSet()) {\n        var element = rootNode.firstElementChild;\n\n        while (element) {\n          if (element.tagName === this.childNodeType) {\n            childElementCount += 1;\n          } else if (sizeSet.isPlaceOn(WORKING_SPACE_TOP)) {\n            break;\n          }\n\n          element = element.nextElementSibling;\n        }\n      } else {\n        childElementCount = rootNode.childElementCount;\n      }\n\n      return childElementCount;\n    }\n    /**\r\n     * Setups and prepares all necessary properties and start the rendering process.\r\n     * This method has to be called only once (at the start) for the render cycle.\r\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.collectedNodes.length = 0;\n      this.visualIndex = 0;\n      var rootNode = this.rootNode,\n          sizeSet = this.sizeSet;\n      var isShared = this.isSharedViewSet();\n\n      var _sizeSet$getViewSize = sizeSet.getViewSize(),\n          nextSize = _sizeSet$getViewSize.nextSize;\n\n      var childElementCount = this.getRenderedChildCount();\n\n      while (childElementCount < nextSize) {\n        var newNode = this.nodesPool();\n\n        if (!isShared || isShared && sizeSet.isPlaceOn(WORKING_SPACE_BOTTOM)) {\n          rootNode.appendChild(newNode);\n        } else {\n          rootNode.insertBefore(newNode, rootNode.firstChild);\n        }\n\n        childElementCount += 1;\n      }\n\n      var isSharedPlacedOnTop = isShared && sizeSet.isPlaceOn(WORKING_SPACE_TOP);\n\n      while (childElementCount > nextSize) {\n        rootNode.removeChild(isSharedPlacedOnTop ? rootNode.firstChild : rootNode.lastChild);\n        childElementCount -= 1;\n      }\n    }\n    /**\r\n     * Renders the DOM element based on visual index (which is calculated internally).\r\n     * This method has to be called as many times as the size count is met (to cover all previously rendered DOM elements).\r\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var rootNode = this.rootNode,\n          sizeSet = this.sizeSet;\n      var visualIndex = this.visualIndex;\n\n      if (this.isSharedViewSet() && sizeSet.isPlaceOn(WORKING_SPACE_BOTTOM)) {\n        visualIndex += sizeSet.sharedSize.nextSize;\n      }\n\n      var node = rootNode.childNodes[visualIndex];\n\n      if (node.tagName !== this.childNodeType) {\n        var newNode = this.nodesPool();\n        rootNode.replaceChild(newNode, node);\n        node = newNode;\n      }\n\n      this.collectedNodes.push(node);\n      this.visualIndex += 1;\n    }\n    /**\r\n     * Ends the render process.\r\n     * This method has to be called only once (at the end) for the render cycle.\r\n     */\n\n  }, {\n    key: \"end\",\n    value: function end() {}\n  }]);\n\n  return OrderView;\n}();\n\nexport { OrderView as default };","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/3rdparty/walkontable/src/utils/orderView/view.mjs"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","WORKING_SPACE_TOP","WORKING_SPACE_BOTTOM","ViewSizeSet","OrderView","rootNode","nodesPool","childNodeType","sizeSet","toUpperCase","visualIndex","collectedNodes","value","setSize","size","setOffset","offset","isSharedViewSet","isShared","getNode","getCurrentNode","getRenderedChildCount","childElementCount","element","firstElementChild","tagName","isPlaceOn","nextElementSibling","start","_sizeSet$getViewSize","getViewSize","nextSize","newNode","appendChild","insertBefore","firstChild","isSharedPlacedOnTop","removeChild","lastChild","render","sharedSize","node","childNodes","replaceChild","push","end","default"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport { WORKING_SPACE_TOP, WORKING_SPACE_BOTTOM } from \"./constants.mjs\";\r\nimport ViewSizeSet from \"./viewSizeSet.mjs\";\r\n/**\r\n * Executive model for each table renderer. It's responsible for injecting DOM nodes in a\r\n * specified order and adjusting the number of elements in the root node.\r\n *\r\n * Only this class have rights to juggling DOM elements within the root node (see render method).\r\n *\r\n * @class {OrderView}\r\n */\r\n\r\nvar OrderView = /*#__PURE__*/function () {\r\n  function OrderView(rootNode, nodesPool, childNodeType) {\r\n    _classCallCheck(this, OrderView);\r\n\r\n    /**\r\n     * The root node to manage with.\r\n     *\r\n     * @type {HTMLElement}\r\n     */\r\n    this.rootNode = rootNode;\r\n    /**\r\n     * Factory for newly created DOM elements.\r\n     *\r\n     * @type {Function}\r\n     */\r\n\r\n    this.nodesPool = nodesPool;\r\n    /**\r\n     * Holder for sizing and positioning of the view.\r\n     *\r\n     * @type {ViewSizeSet}\r\n     */\r\n\r\n    this.sizeSet = new ViewSizeSet();\r\n    /**\r\n     * Node type which the order view will manage while rendering the DOM elements.\r\n     *\r\n     * @type {string}\r\n     */\r\n\r\n    this.childNodeType = childNodeType.toUpperCase();\r\n    /**\r\n     * The visual index of currently processed row.\r\n     *\r\n     * @type {number}\r\n     */\r\n\r\n    this.visualIndex = 0;\r\n    /**\r\n     * The list of DOM elements which are rendered for this render cycle.\r\n     *\r\n     * @type {HTMLElement[]}\r\n     */\r\n\r\n    this.collectedNodes = [];\r\n  }\r\n  /**\r\n   * Sets the size for rendered elements. It can be a size for rows, cells or size for row\r\n   * headers etc. It depends for what table renderer this instance was created.\r\n   *\r\n   * @param {number} size The size.\r\n   * @returns {OrderView}\r\n   */\r\n\r\n\r\n  _createClass(OrderView, [{\r\n    key: \"setSize\",\r\n    value: function setSize(size) {\r\n      this.sizeSet.setSize(size);\r\n      return this;\r\n    }\r\n    /**\r\n     * Sets the offset for rendered elements. The offset describes the shift between 0 and\r\n     * the first rendered element according to the scroll position.\r\n     *\r\n     * @param {number} offset The offset.\r\n     * @returns {OrderView}\r\n     */\r\n\r\n  }, {\r\n    key: \"setOffset\",\r\n    value: function setOffset(offset) {\r\n      this.sizeSet.setOffset(offset);\r\n      return this;\r\n    }\r\n    /**\r\n     * Checks if this instance of the view shares the root node with another instance. This happens only once when\r\n     * a row (TR) as a root node is managed by two OrderView instances. If this happens another DOM injection\r\n     * algorithm is performed to achieve consistent order.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isSharedViewSet\",\r\n    value: function isSharedViewSet() {\r\n      return this.sizeSet.isShared();\r\n    }\r\n    /**\r\n     * Returns rendered DOM element based on visual index.\r\n     *\r\n     * @param {number} visualIndex The visual index.\r\n     * @returns {HTMLElement}\r\n     */\r\n\r\n  }, {\r\n    key: \"getNode\",\r\n    value: function getNode(visualIndex) {\r\n      return visualIndex < this.collectedNodes.length ? this.collectedNodes[visualIndex] : null;\r\n    }\r\n    /**\r\n     * Returns currently processed DOM element.\r\n     *\r\n     * @returns {HTMLElement}\r\n     */\r\n\r\n  }, {\r\n    key: \"getCurrentNode\",\r\n    value: function getCurrentNode() {\r\n      var length = this.collectedNodes.length;\r\n      return length > 0 ? this.collectedNodes[length - 1] : null;\r\n    }\r\n    /**\r\n     * Returns rendered child count for this instance.\r\n     *\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getRenderedChildCount\",\r\n    value: function getRenderedChildCount() {\r\n      var rootNode = this.rootNode,\r\n          sizeSet = this.sizeSet;\r\n      var childElementCount = 0;\r\n\r\n      if (this.isSharedViewSet()) {\r\n        var element = rootNode.firstElementChild;\r\n\r\n        while (element) {\r\n          if (element.tagName === this.childNodeType) {\r\n            childElementCount += 1;\r\n          } else if (sizeSet.isPlaceOn(WORKING_SPACE_TOP)) {\r\n            break;\r\n          }\r\n\r\n          element = element.nextElementSibling;\r\n        }\r\n      } else {\r\n        childElementCount = rootNode.childElementCount;\r\n      }\r\n\r\n      return childElementCount;\r\n    }\r\n    /**\r\n     * Setups and prepares all necessary properties and start the rendering process.\r\n     * This method has to be called only once (at the start) for the render cycle.\r\n     */\r\n\r\n  }, {\r\n    key: \"start\",\r\n    value: function start() {\r\n      this.collectedNodes.length = 0;\r\n      this.visualIndex = 0;\r\n      var rootNode = this.rootNode,\r\n          sizeSet = this.sizeSet;\r\n      var isShared = this.isSharedViewSet();\r\n\r\n      var _sizeSet$getViewSize = sizeSet.getViewSize(),\r\n          nextSize = _sizeSet$getViewSize.nextSize;\r\n\r\n      var childElementCount = this.getRenderedChildCount();\r\n\r\n      while (childElementCount < nextSize) {\r\n        var newNode = this.nodesPool();\r\n\r\n        if (!isShared || isShared && sizeSet.isPlaceOn(WORKING_SPACE_BOTTOM)) {\r\n          rootNode.appendChild(newNode);\r\n        } else {\r\n          rootNode.insertBefore(newNode, rootNode.firstChild);\r\n        }\r\n\r\n        childElementCount += 1;\r\n      }\r\n\r\n      var isSharedPlacedOnTop = isShared && sizeSet.isPlaceOn(WORKING_SPACE_TOP);\r\n\r\n      while (childElementCount > nextSize) {\r\n        rootNode.removeChild(isSharedPlacedOnTop ? rootNode.firstChild : rootNode.lastChild);\r\n        childElementCount -= 1;\r\n      }\r\n    }\r\n    /**\r\n     * Renders the DOM element based on visual index (which is calculated internally).\r\n     * This method has to be called as many times as the size count is met (to cover all previously rendered DOM elements).\r\n     */\r\n\r\n  }, {\r\n    key: \"render\",\r\n    value: function render() {\r\n      var rootNode = this.rootNode,\r\n          sizeSet = this.sizeSet;\r\n      var visualIndex = this.visualIndex;\r\n\r\n      if (this.isSharedViewSet() && sizeSet.isPlaceOn(WORKING_SPACE_BOTTOM)) {\r\n        visualIndex += sizeSet.sharedSize.nextSize;\r\n      }\r\n\r\n      var node = rootNode.childNodes[visualIndex];\r\n\r\n      if (node.tagName !== this.childNodeType) {\r\n        var newNode = this.nodesPool();\r\n        rootNode.replaceChild(newNode, node);\r\n        node = newNode;\r\n      }\r\n\r\n      this.collectedNodes.push(node);\r\n      this.visualIndex += 1;\r\n    }\r\n    /**\r\n     * Ends the render process.\r\n     * This method has to be called only once (at the end) for the render cycle.\r\n     */\r\n\r\n  }, {\r\n    key: \"end\",\r\n    value: function end() {}\r\n  }]);\r\n\r\n  return OrderView;\r\n}();\r\n\r\nexport { OrderView as default };"]},"metadata":{},"sourceType":"module"}