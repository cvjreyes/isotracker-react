{"ast":null,"code":"/**\r\n * Traverses the tree nodes and calls a callback when no hidden node is found. The callback\r\n * is called with visual column index then.\r\n *\r\n * @param {TreeNode} node A tree node to traverse.\r\n * @param {Function} callback The callback function which will be called for each node.\r\n */\nexport function traverseHiddenNodeColumnIndexes(node, callback) {\n  node.walkDown(function (_ref) {\n    var data = _ref.data,\n        childs = _ref.childs;\n\n    if (!data.isHidden) {\n      callback(data.columnIndex);\n\n      if (childs.length === 0) {\n        for (var i = 1; i < data.colspan; i++) {\n          callback(data.columnIndex + i);\n        }\n      }\n    }\n  });\n}\n/**\r\n * A tree helper for retrieving a data from the first child.\r\n *\r\n * @param {TreeNode} node A tree node to check.\r\n * @param {string} propertyName A name of the property whose value you want to get.\r\n * @returns {*}\r\n */\n\nexport function getFirstChildProperty(_ref2, propertyName) {\n  var childs = _ref2.childs;\n\n  if (childs.length === 0) {\n    return;\n  }\n\n  return childs[0].data[propertyName];\n}\n/**\r\n * A tree helper which checks if passed node has the same original colspan as its\r\n * first child. In that case the node is treated as \"mirrored\" or \"reflected\" every\r\n * action performed on one of that nodes should be reflected to other \"mirrored\" node.\r\n *\r\n * In that case nodes A1 and A2 are \"reflected\"\r\n *   +----+----+----+----+\r\n *   | A1      | B1      |\r\n *   +----+----+----+----+\r\n *   | A2      | B2 | B3 |\r\n *   +----+----+----+----+.\r\n *\r\n * @param {TreeNode} node A tree node to check.\r\n * @returns {boolean}\r\n */\n\nexport function isNodeReflectsFirstChildColspan(node) {\n  return getFirstChildProperty(node, 'origColspan') === node.data.origColspan;\n}","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/utils/tree.mjs"],"names":["traverseHiddenNodeColumnIndexes","node","callback","walkDown","_ref","data","childs","isHidden","columnIndex","length","i","colspan","getFirstChildProperty","_ref2","propertyName","isNodeReflectsFirstChildColspan","origColspan"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,+BAAT,CAAyCC,IAAzC,EAA+CC,QAA/C,EAAyD;AAC9DD,EAAAA,IAAI,CAACE,QAAL,CAAc,UAAUC,IAAV,EAAgB;AAC5B,QAAIC,IAAI,GAAGD,IAAI,CAACC,IAAhB;AAAA,QACIC,MAAM,GAAGF,IAAI,CAACE,MADlB;;AAGA,QAAI,CAACD,IAAI,CAACE,QAAV,EAAoB;AAClBL,MAAAA,QAAQ,CAACG,IAAI,CAACG,WAAN,CAAR;;AAEA,UAAIF,MAAM,CAACG,MAAP,KAAkB,CAAtB,EAAyB;AACvB,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,IAAI,CAACM,OAAzB,EAAkCD,CAAC,EAAnC,EAAuC;AACrCR,UAAAA,QAAQ,CAACG,IAAI,CAACG,WAAL,GAAmBE,CAApB,CAAR;AACD;AACF;AACF;AACF,GAbD;AAcD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASE,qBAAT,CAA+BC,KAA/B,EAAsCC,YAAtC,EAAoD;AACzD,MAAIR,MAAM,GAAGO,KAAK,CAACP,MAAnB;;AAEA,MAAIA,MAAM,CAACG,MAAP,KAAkB,CAAtB,EAAyB;AACvB;AACD;;AAED,SAAOH,MAAM,CAAC,CAAD,CAAN,CAAUD,IAAV,CAAeS,YAAf,CAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,+BAAT,CAAyCd,IAAzC,EAA+C;AACpD,SAAOW,qBAAqB,CAACX,IAAD,EAAO,aAAP,CAArB,KAA+CA,IAAI,CAACI,IAAL,CAAUW,WAAhE;AACD","sourcesContent":["/**\r\n * Traverses the tree nodes and calls a callback when no hidden node is found. The callback\r\n * is called with visual column index then.\r\n *\r\n * @param {TreeNode} node A tree node to traverse.\r\n * @param {Function} callback The callback function which will be called for each node.\r\n */\r\nexport function traverseHiddenNodeColumnIndexes(node, callback) {\r\n  node.walkDown(function (_ref) {\r\n    var data = _ref.data,\r\n        childs = _ref.childs;\r\n\r\n    if (!data.isHidden) {\r\n      callback(data.columnIndex);\r\n\r\n      if (childs.length === 0) {\r\n        for (var i = 1; i < data.colspan; i++) {\r\n          callback(data.columnIndex + i);\r\n        }\r\n      }\r\n    }\r\n  });\r\n}\r\n/**\r\n * A tree helper for retrieving a data from the first child.\r\n *\r\n * @param {TreeNode} node A tree node to check.\r\n * @param {string} propertyName A name of the property whose value you want to get.\r\n * @returns {*}\r\n */\r\n\r\nexport function getFirstChildProperty(_ref2, propertyName) {\r\n  var childs = _ref2.childs;\r\n\r\n  if (childs.length === 0) {\r\n    return;\r\n  }\r\n\r\n  return childs[0].data[propertyName];\r\n}\r\n/**\r\n * A tree helper which checks if passed node has the same original colspan as its\r\n * first child. In that case the node is treated as \"mirrored\" or \"reflected\" every\r\n * action performed on one of that nodes should be reflected to other \"mirrored\" node.\r\n *\r\n * In that case nodes A1 and A2 are \"reflected\"\r\n *   +----+----+----+----+\r\n *   | A1      | B1      |\r\n *   +----+----+----+----+\r\n *   | A2      | B2 | B3 |\r\n *   +----+----+----+----+.\r\n *\r\n * @param {TreeNode} node A tree node to check.\r\n * @returns {boolean}\r\n */\r\n\r\nexport function isNodeReflectsFirstChildColspan(node) {\r\n  return getFirstChildProperty(node, 'origColspan') === node.data.origColspan;\r\n}"]},"metadata":{},"sourceType":"module"}