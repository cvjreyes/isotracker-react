{"ast":null,"code":"import { hasOwnProperty, isObject, objectEach, inherit } from \"../../helpers/object.mjs\";\nimport { getCellType } from \"../../cellTypes/registry.mjs\";\n/**\n * Expands \"type\" property of the meta object to single values. For example `type: 'numeric'` sets\n * \"renderer\", \"editor\", \"validator\" properties to specific functions designed for numeric values.\n * If \"type\" is passed as an object that object will be returned, excluding properties that\n * already exist in the \"metaObject\" if passed.\n *\n * @param {object|string} type Type to expand;.\n * @param {object|undefined} [metaObject] Source meta object.\n * @returns {object|undefined}\n */\n\nexport function expandMetaType(type, metaObject) {\n  var validType = typeof type === 'string' ? getCellType(type) : type;\n\n  if (!isObject(validType)) {\n    return;\n  }\n\n  var preventSourceOverwrite = isObject(metaObject);\n  var expandedType = {};\n  objectEach(validType, function (value, property) {\n    if (property !== 'CELL_TYPE' && (!preventSourceOverwrite || preventSourceOverwrite && !hasOwnProperty(metaObject, property))) {\n      expandedType[property] = value;\n    }\n  });\n  return expandedType;\n}\n/**\n * Creates new class which extends properties from TableMeta layer class.\n *\n * @param {TableMeta} TableMeta The TableMeta which the new ColumnMeta is created from.\n * @param {string[]} [conflictList] List of the properties which are conflicted with the column meta layer.\n *                                  Conflicted properties are overwritten by `undefined` value, to separate them\n *                                  from the TableMeta layer.\n * @returns {ColumnMeta} Returns constructor ready to initialize with `new` operator.\n */\n\nexport function columnFactory(TableMeta) {\n  var conflictList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : []; // Do not use ES6 \"class extends\" syntax here. It seems that the babel produces code\n  // which drastically decreases the performance of the ColumnMeta class creation.\n\n  /**\n   * Base \"class\" for column meta.\n   */\n\n  function ColumnMeta() {}\n\n  inherit(ColumnMeta, TableMeta); // Clear conflict settings\n\n  for (var i = 0; i < conflictList.length; i++) {\n    ColumnMeta.prototype[conflictList[i]] = void 0;\n  }\n\n  return ColumnMeta;\n}\n/**\n * Helper which checks if the provided argument is an unsigned number.\n *\n * @param {*} value Value to check.\n * @returns {boolean}\n */\n\nexport function isUnsignedNumber(value) {\n  return Number.isInteger(value) && value >= 0;\n}\n/**\n * Function which makes assertion by custom condition. Function throws an error when assertion doesn't meet the spec.\n *\n * @param {Function} condition Function with custom logic. The condition has to return boolean values.\n * @param {string} errorMessage String which describes assertion error.\n */\n\nexport function assert(condition, errorMessage) {\n  if (!condition()) {\n    throw new Error(\"Assertion failed: \".concat(errorMessage));\n  }\n}\n/**\n * Check if given variable is null or undefined.\n *\n * @param {*} variable Variable to check.\n * @returns {boolean}\n */\n\nexport function isNullish(variable) {\n  return variable === null || variable === void 0;\n}","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/dataMap/metaManager/utils.mjs"],"names":["hasOwnProperty","isObject","objectEach","inherit","getCellType","expandMetaType","type","metaObject","validType","preventSourceOverwrite","expandedType","value","property","columnFactory","TableMeta","conflictList","arguments","length","undefined","ColumnMeta","i","prototype","isUnsignedNumber","Number","isInteger","assert","condition","errorMessage","Error","concat","isNullish","variable"],"mappings":"AAEA,SAASA,cAAT,EAAyBC,QAAzB,EAAmCC,UAAnC,EAA+CC,OAA/C,QAA8D,0BAA9D;AACA,SAASC,WAAT,QAA4B,8BAA5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,cAAT,CAAwBC,IAAxB,EAA8BC,UAA9B,EAA0C;AAC/C,MAAIC,SAAS,GAAG,OAAOF,IAAP,KAAgB,QAAhB,GAA2BF,WAAW,CAACE,IAAD,CAAtC,GAA+CA,IAA/D;;AAEA,MAAI,CAACL,QAAQ,CAACO,SAAD,CAAb,EAA0B;AACxB;AACD;;AAED,MAAIC,sBAAsB,GAAGR,QAAQ,CAACM,UAAD,CAArC;AACA,MAAIG,YAAY,GAAG,EAAnB;AACAR,EAAAA,UAAU,CAACM,SAAD,EAAY,UAAUG,KAAV,EAAiBC,QAAjB,EAA2B;AAC/C,QAAIA,QAAQ,KAAK,WAAb,KAA6B,CAACH,sBAAD,IAA2BA,sBAAsB,IAAI,CAACT,cAAc,CAACO,UAAD,EAAaK,QAAb,CAAjG,CAAJ,EAA8H;AAC5HF,MAAAA,YAAY,CAACE,QAAD,CAAZ,GAAyBD,KAAzB;AACD;AACF,GAJS,CAAV;AAKA,SAAOD,YAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASG,aAAT,CAAuBC,SAAvB,EAAkC;AACvC,MAAIC,YAAY,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAvF,CADuC,CAGvC;AACA;;AAEA;AACF;AACA;;AACE,WAASG,UAAT,GAAsB,CAAE;;AAExBhB,EAAAA,OAAO,CAACgB,UAAD,EAAaL,SAAb,CAAP,CAXuC,CAWP;;AAEhC,OAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,YAAY,CAACE,MAAjC,EAAyCG,CAAC,EAA1C,EAA8C;AAC5CD,IAAAA,UAAU,CAACE,SAAX,CAAqBN,YAAY,CAACK,CAAD,CAAjC,IAAwC,KAAK,CAA7C;AACD;;AAED,SAAOD,UAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASG,gBAAT,CAA0BX,KAA1B,EAAiC;AACtC,SAAOY,MAAM,CAACC,SAAP,CAAiBb,KAAjB,KAA2BA,KAAK,IAAI,CAA3C;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASc,MAAT,CAAgBC,SAAhB,EAA2BC,YAA3B,EAAyC;AAC9C,MAAI,CAACD,SAAS,EAAd,EAAkB;AAChB,UAAM,IAAIE,KAAJ,CAAU,qBAAqBC,MAArB,CAA4BF,YAA5B,CAAV,CAAN;AACD;AACF;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASG,SAAT,CAAmBC,QAAnB,EAA6B;AAClC,SAAOA,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAA9C;AACD","sourcesContent":["import \"core-js/modules/es.number.is-integer.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport { hasOwnProperty, isObject, objectEach, inherit } from \"../../helpers/object.mjs\";\nimport { getCellType } from \"../../cellTypes/registry.mjs\";\n/**\n * Expands \"type\" property of the meta object to single values. For example `type: 'numeric'` sets\n * \"renderer\", \"editor\", \"validator\" properties to specific functions designed for numeric values.\n * If \"type\" is passed as an object that object will be returned, excluding properties that\n * already exist in the \"metaObject\" if passed.\n *\n * @param {object|string} type Type to expand;.\n * @param {object|undefined} [metaObject] Source meta object.\n * @returns {object|undefined}\n */\n\nexport function expandMetaType(type, metaObject) {\n  var validType = typeof type === 'string' ? getCellType(type) : type;\n\n  if (!isObject(validType)) {\n    return;\n  }\n\n  var preventSourceOverwrite = isObject(metaObject);\n  var expandedType = {};\n  objectEach(validType, function (value, property) {\n    if (property !== 'CELL_TYPE' && (!preventSourceOverwrite || preventSourceOverwrite && !hasOwnProperty(metaObject, property))) {\n      expandedType[property] = value;\n    }\n  });\n  return expandedType;\n}\n/**\n * Creates new class which extends properties from TableMeta layer class.\n *\n * @param {TableMeta} TableMeta The TableMeta which the new ColumnMeta is created from.\n * @param {string[]} [conflictList] List of the properties which are conflicted with the column meta layer.\n *                                  Conflicted properties are overwritten by `undefined` value, to separate them\n *                                  from the TableMeta layer.\n * @returns {ColumnMeta} Returns constructor ready to initialize with `new` operator.\n */\n\nexport function columnFactory(TableMeta) {\n  var conflictList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  // Do not use ES6 \"class extends\" syntax here. It seems that the babel produces code\n  // which drastically decreases the performance of the ColumnMeta class creation.\n\n  /**\n   * Base \"class\" for column meta.\n   */\n  function ColumnMeta() {}\n\n  inherit(ColumnMeta, TableMeta); // Clear conflict settings\n\n  for (var i = 0; i < conflictList.length; i++) {\n    ColumnMeta.prototype[conflictList[i]] = void 0;\n  }\n\n  return ColumnMeta;\n}\n/**\n * Helper which checks if the provided argument is an unsigned number.\n *\n * @param {*} value Value to check.\n * @returns {boolean}\n */\n\nexport function isUnsignedNumber(value) {\n  return Number.isInteger(value) && value >= 0;\n}\n/**\n * Function which makes assertion by custom condition. Function throws an error when assertion doesn't meet the spec.\n *\n * @param {Function} condition Function with custom logic. The condition has to return boolean values.\n * @param {string} errorMessage String which describes assertion error.\n */\n\nexport function assert(condition, errorMessage) {\n  if (!condition()) {\n    throw new Error(\"Assertion failed: \".concat(errorMessage));\n  }\n}\n/**\n * Check if given variable is null or undefined.\n *\n * @param {*} variable Variable to check.\n * @returns {boolean}\n */\n\nexport function isNullish(variable) {\n  return variable === null || variable === void 0;\n}"]},"metadata":{},"sourceType":"module"}