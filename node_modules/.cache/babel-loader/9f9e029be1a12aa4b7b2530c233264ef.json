{"ast":null,"code":"var _excluded = [\"row\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n\n  _classApplyDescriptorSet(receiver, descriptor, value);\n\n  return value;\n}\n\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n\n    descriptor.value = value;\n  }\n}\n\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\n\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n\n  return privateMap.get(receiver);\n}\n\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n\n  return descriptor.value;\n}\n\nimport { arrayMap, arrayReduce } from \"../../../helpers/array.mjs\";\nimport SourceSettings from \"./sourceSettings.mjs\";\nimport HeadersTree from \"./headersTree.mjs\";\nimport { triggerNodeModification as _triggerNodeModification } from \"./nodeModifiers/index.mjs\";\nimport { generateMatrix } from \"./matrixGenerator.mjs\";\n/**\n * The state manager is a source of truth for nested headers configuration.\n * The state generation process is divided into three stages.\n *\n *   +---------------------+  1. User-defined configuration normalization;\n *   │                     │  The source settings class normalizes and shares API for\n *   │   SourceSettings    │  raw settings passed by the developer. It is only consumed by\n *   │                     │  the header tree module.\n *   +---------------------+\n *             │\n *            \\│/\n *   +---------------------+  2. Building a tree structure for validation and easier node manipulation;\n *   │                     │  The header tree generates a tree based on source settings for future\n *   │     HeadersTree     │  node manipulation (such as collapsible columns feature). While generating a tree\n *   │                     │  the source settings is checked to see if the configuration has overlapping headers.\n *   +---------------------+  If `true` the colspan matrix generation is skipped, overlapped headers are not supported.\n *             │\n *            \\│/\n *   +---------------------+  3. Matrix generation;\n *   │                     │  Based on built trees the matrix generation is performed. That part of code\n *   │  matrix generation  │  generates an array structure similar to normalized data from the SourceSettings\n *   │                     │  but with the difference that this structure contains column settings which changed\n *   +---------------------+  during runtime (after the tree manipulation) e.q after collapse or expand column.\n *                            That settings describes how the TH element should be modified (colspan attribute,\n *                            CSS classes, etc) for a specific column and layer level.\n *\n * @class StateManager\n * @plugin NestedHeaders\n */\n\nvar _sourceSettings = /*#__PURE__*/new WeakMap();\n\nvar _headersTree = /*#__PURE__*/new WeakMap();\n\nvar _stateMatrix = /*#__PURE__*/new WeakMap();\n\nvar StateManager = /*#__PURE__*/function () {\n  function StateManager() {\n    _classCallCheck(this, StateManager);\n\n    _sourceSettings.set(this, {\n      writable: true,\n      value: new SourceSettings()\n    });\n\n    _headersTree.set(this, {\n      writable: true,\n      value: new HeadersTree(_classPrivateFieldGet(this, _sourceSettings))\n    });\n\n    _stateMatrix.set(this, {\n      writable: true,\n      value: [[]]\n    });\n  }\n\n  _createClass(StateManager, [{\n    key: \"setState\",\n    value:\n    /**\n     * Sets a new state for the nested headers plugin based on settings passed\n     * directly to the plugin.\n     *\n     * @param {Array[]} nestedHeadersSettings The user-defined settings.\n     * @returns {boolean} Returns `true` if the settings are processed correctly, `false` otherwise.\n     */\n    function setState(nestedHeadersSettings) {\n      _classPrivateFieldGet(this, _sourceSettings).setData(nestedHeadersSettings);\n\n      var hasError = false;\n\n      try {\n        _classPrivateFieldGet(this, _headersTree).buildTree();\n      } catch (ex) {\n        _classPrivateFieldGet(this, _headersTree).clear();\n\n        _classPrivateFieldGet(this, _sourceSettings).clear();\n\n        hasError = true;\n      }\n\n      _classPrivateFieldSet(this, _stateMatrix, generateMatrix(_classPrivateFieldGet(this, _headersTree).getRoots()));\n\n      return hasError;\n    }\n    /**\n     * Sets columns limit to the state will be trimmed. All headers (colspans) which\n     * overlap the column limit will be reduced to keep the structure solid.\n     *\n     * @param {number} columnsCount The number of columns to limit to.\n     */\n\n  }, {\n    key: \"setColumnsLimit\",\n    value: function setColumnsLimit(columnsCount) {\n      _classPrivateFieldGet(this, _sourceSettings).setColumnsLimit(columnsCount);\n    }\n    /**\n     * Merges settings with current plugin state.\n     *\n     * By default only foreign keys are merged with source state and passed to the tree. But only\n     * known keys are exported to matrix.\n     *\n     * @param {object[]} settings An array of objects to merge with the current source settings.\n     *                            It is a requirement that every object has `row` and `col` properties\n     *                            which points to the specific header settings object.\n     */\n\n  }, {\n    key: \"mergeStateWith\",\n    value: function mergeStateWith(settings) {\n      var _this = this;\n\n      var transformedSettings = arrayMap(settings, function (_ref) {\n        var row = _ref.row,\n            rest = _objectWithoutProperties(_ref, _excluded);\n\n        return _objectSpread({\n          row: row < 0 ? _this.rowCoordsToLevel(row) : row\n        }, rest);\n      });\n\n      _classPrivateFieldGet(this, _sourceSettings).mergeWith(transformedSettings);\n\n      _classPrivateFieldGet(this, _headersTree).buildTree();\n\n      _classPrivateFieldSet(this, _stateMatrix, generateMatrix(_classPrivateFieldGet(this, _headersTree).getRoots()));\n    }\n    /**\n     * Maps the current state with a callback. For each header settings the callback function\n     * is called. If the function returns value that value is merged with the state.\n     *\n     * By default only foreign keys are merged with source state and passed to the tree. But only\n     * known keys are exported to matrix.\n     *\n     * @param {Function} callback A function that is called for every header source settings.\n     *                            Each time the callback is called, the returned value extends\n     *                            header settings.\n     */\n\n  }, {\n    key: \"mapState\",\n    value: function mapState(callback) {\n      _classPrivateFieldGet(this, _sourceSettings).map(callback);\n\n      _classPrivateFieldGet(this, _headersTree).buildTree();\n\n      _classPrivateFieldSet(this, _stateMatrix, generateMatrix(_classPrivateFieldGet(this, _headersTree).getRoots()));\n    }\n    /**\n     * Maps the current tree nodes with a callback. For each node the callback function\n     * is called. If the function returns value that value is added to returned array.\n     *\n     * @param {Function} callback A function that is called for every tree node.\n     *                            Each time the callback is called, the returned value is\n     *                            added to returned array.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"mapNodes\",\n    value: function mapNodes(callback) {\n      return arrayReduce(_classPrivateFieldGet(this, _headersTree).getRoots(), function (acc, rootNode) {\n        rootNode.walkDown(function (node) {\n          var result = callback(node.data);\n\n          if (result !== void 0) {\n            acc.push(result);\n          }\n        });\n        return acc;\n      }, []);\n    }\n    /**\n     * Triggers an action (e.g. \"collapse\") from the NodeModifiers module. The module\n     * modifies a tree structure in such a way as to obtain the correct structure consistent with the\n     * called action.\n     *\n     * @param {string} action An action name to trigger.\n     * @param {number} headerLevel Header level index (there is support for negative and positive values).\n     * @param {number} columnIndex A visual column index.\n     * @returns {object|undefined}\n     */\n\n  }, {\n    key: \"triggerNodeModification\",\n    value: function triggerNodeModification(action, headerLevel, columnIndex) {\n      if (headerLevel < 0) {\n        headerLevel = this.rowCoordsToLevel(headerLevel);\n      }\n\n      var nodeToProcess = _classPrivateFieldGet(this, _headersTree).getNode(headerLevel, columnIndex);\n\n      var actionResult;\n\n      if (nodeToProcess) {\n        actionResult = _triggerNodeModification(action, nodeToProcess, columnIndex); // TODO (perf-tip): Trigger matrix generation once after multiple node modifications.\n\n        _classPrivateFieldSet(this, _stateMatrix, generateMatrix(_classPrivateFieldGet(this, _headersTree).getRoots()));\n      }\n\n      return actionResult;\n    }\n    /**\n     * Triggers an action (e.g. \"hide-column\") from the NodeModifiers module. The action is\n     * triggered starting from the lowest header. The module modifies a tree structure in\n     * such a way as to obtain the correct structure consistent with the called action.\n     *\n     * @param {string} action An action name to trigger.\n     * @param {number} columnIndex A visual column index.\n     * @returns {object|undefined}\n     */\n\n  }, {\n    key: \"triggerColumnModification\",\n    value: function triggerColumnModification(action, columnIndex) {\n      return this.triggerNodeModification(action, -1, columnIndex);\n    }\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n\n    /**\n     * @memberof StateManager#\n     * @function rowCoordsToLevel\n     *\n     * Translates row coordinates into header level. The row coordinates counts from -1 to -N\n     * and describes headers counting from most closest to most distant from the table.\n     * The header levels are counted from 0 to N where 0 describes most distant header\n     * from the table.\n     *\n     *  Row coords             Header level\n     *           +--------------+\n     *       -3  │ A1 │ A1      │  0\n     *           +--------------+\n     *       -2  │ B1 │ B2 │ B3 │  1\n     *           +--------------+\n     *       -1  │ C1 │ C2 │ C3 │  2\n     *           +==============+\n     *           │    │    │    │\n     *           +--------------+\n     *           │    │    │    │\n     *\n     * @param {number} rowIndex A visual row index.\n     * @returns {number} Returns unsigned number.\n     */\n\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  }, {\n    key: \"rowCoordsToLevel\",\n    value: function rowCoordsToLevel(rowIndex) {\n      var layersCount = Math.max(this.getLayersCount(), 1);\n      var highestPossibleLevel = layersCount - 1;\n      var lowestPossibleLevel = 0;\n      return Math.min(Math.max(rowIndex + layersCount, lowestPossibleLevel), highestPossibleLevel);\n    }\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n\n    /**\n     * @memberof StateManager#\n     * @function levelToRowCoords\n     *\n     * Translates header level into row coordinates. The row coordinates counts from -1 to -N\n     * and describes headers counting from most closest to most distant from the table.\n     * The header levels are counted from 0 to N where 0 describes most distant header\n     * from the table.\n     *\n     *  Header level            Row coords\n     *           +--------------+\n     *        0  │ A1 │ A1      │  -3\n     *           +--------------+\n     *        1  │ B1 │ B2 │ B3 │  -2\n     *           +--------------+\n     *        2  │ C1 │ C2 │ C3 │  -1\n     *           +==============+\n     *           │    │    │    │\n     *           +--------------+\n     *           │    │    │    │\n     *\n     * @param {number} headerLevel Header level index.\n     * @returns {number} Returns negative number.\n     */\n\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  }, {\n    key: \"levelToRowCoords\",\n    value: function levelToRowCoords(headerLevel) {\n      var layersCount = Math.max(this.getLayersCount(), 1);\n      var highestPossibleRow = -1;\n      var lowestPossibleRow = -layersCount;\n      return Math.min(Math.max(headerLevel - layersCount, lowestPossibleRow), highestPossibleRow);\n    }\n    /**\n     * Gets column header settings for a specified column and header index. The returned object contains\n     * all information necessary for header renderers. It contains header label, colspan length, or hidden\n     * flag.\n     *\n     * @param {number} headerLevel Header level (there is support for negative and positive values).\n     * @param {number} columnIndex A visual column index.\n     * @returns {object|null}\n     */\n\n  }, {\n    key: \"getHeaderSettings\",\n    value: function getHeaderSettings(headerLevel, columnIndex) {\n      var _classPrivateFieldGet2, _classPrivateFieldGet3;\n\n      if (headerLevel < 0) {\n        headerLevel = this.rowCoordsToLevel(headerLevel);\n      }\n\n      if (headerLevel >= this.getLayersCount()) {\n        return null;\n      }\n\n      return (_classPrivateFieldGet2 = (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _stateMatrix)[headerLevel]) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3[columnIndex]) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : null;\n    }\n    /**\n     * Gets tree data that is connected to the column header. The returned object contains all information\n     * necessary for modifying tree structure (column collapsing, hiding, etc.). It contains a header\n     * label, colspan length, or visual column index that indicates which column index the node is rendered from.\n     *\n     * @param {number} headerLevel Header level (there is support for negative and positive values).\n     * @param {number} columnIndex A visual column index.\n     * @returns {object|null}\n     */\n\n  }, {\n    key: \"getHeaderTreeNodeData\",\n    value: function getHeaderTreeNodeData(headerLevel, columnIndex) {\n      if (headerLevel < 0) {\n        headerLevel = this.rowCoordsToLevel(headerLevel);\n      }\n\n      var node = _classPrivateFieldGet(this, _headersTree).getNode(headerLevel, columnIndex);\n\n      if (!node) {\n        return null;\n      }\n\n      return _objectSpread({}, node.data);\n    }\n    /**\n     * The method is helpful in cases where the column index targets in-between currently\n     * collapsed column. In that case, the method returns the left-most column index\n     * where the nested header begins.\n     *\n     * @param {number} headerLevel Header level (there is support for negative and positive values).\n     * @param {number} columnIndex A visual column index.\n     * @returns {number}\n     */\n\n  }, {\n    key: \"findLeftMostColumnIndex\",\n    value: function findLeftMostColumnIndex(headerLevel, columnIndex) {\n      var _this$getHeaderSettin;\n\n      var _ref2 = (_this$getHeaderSettin = this.getHeaderSettings(headerLevel, columnIndex)) !== null && _this$getHeaderSettin !== void 0 ? _this$getHeaderSettin : {\n        isRoot: true\n      },\n          isRoot = _ref2.isRoot;\n\n      if (isRoot) {\n        return columnIndex;\n      }\n\n      var stepBackColumn = columnIndex - 1;\n\n      do {\n        var _this$getHeaderSettin2;\n\n        var _ref3 = (_this$getHeaderSettin2 = this.getHeaderSettings(headerLevel, stepBackColumn)) !== null && _this$getHeaderSettin2 !== void 0 ? _this$getHeaderSettin2 : {\n          isRoot: true\n        },\n            isRootNode = _ref3.isRoot;\n\n        if (isRootNode) {\n          break;\n        }\n\n        stepBackColumn -= 1;\n      } while (columnIndex >= 0);\n\n      return stepBackColumn;\n    }\n    /**\n     * Gets a total number of headers levels.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getLayersCount\",\n    value: function getLayersCount() {\n      return _classPrivateFieldGet(this, _sourceSettings).getLayersCount();\n    }\n    /**\n     * Gets a total number of columns count.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getColumnsCount\",\n    value: function getColumnsCount() {\n      return _classPrivateFieldGet(this, _sourceSettings).getColumnsCount();\n    }\n    /**\n     * Clears the column state manager to the initial state.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      _classPrivateFieldSet(this, _stateMatrix, []);\n\n      _classPrivateFieldGet(this, _sourceSettings).clear();\n\n      _classPrivateFieldGet(this, _headersTree).clear();\n    }\n  }]);\n\n  return StateManager;\n}();\n\nexport { StateManager as default };","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/plugins/nestedHeaders/stateManager/index.mjs"],"names":["_excluded","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","_objectWithoutProperties","excluded","_objectWithoutPropertiesLoose","sourceSymbolKeys","indexOf","prototype","propertyIsEnumerable","call","sourceKeys","_classCallCheck","instance","Constructor","TypeError","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","_classPrivateFieldSet","receiver","privateMap","_classExtractFieldDescriptor","_classApplyDescriptorSet","set","_classPrivateFieldGet","_classApplyDescriptorGet","action","has","get","arrayMap","arrayReduce","SourceSettings","HeadersTree","triggerNodeModification","_triggerNodeModification","generateMatrix","_sourceSettings","WeakMap","_headersTree","_stateMatrix","StateManager","setState","nestedHeadersSettings","setData","hasError","buildTree","ex","clear","getRoots","setColumnsLimit","columnsCount","mergeStateWith","settings","_this","transformedSettings","_ref","row","rest","rowCoordsToLevel","mergeWith","mapState","callback","map","mapNodes","acc","rootNode","walkDown","node","result","data","headerLevel","columnIndex","nodeToProcess","getNode","actionResult","triggerColumnModification","rowIndex","layersCount","Math","max","getLayersCount","highestPossibleLevel","lowestPossibleLevel","min","levelToRowCoords","highestPossibleRow","lowestPossibleRow","getHeaderSettings","_classPrivateFieldGet2","_classPrivateFieldGet3","getHeaderTreeNodeData","findLeftMostColumnIndex","_this$getHeaderSettin","_ref2","isRoot","stepBackColumn","_this$getHeaderSettin2","_ref3","isRootNode","getColumnsCount","default"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptors.js\";\nvar _excluded = [\"row\"];\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.weak-map.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\n\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\n\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\n\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nimport { arrayMap, arrayReduce } from \"../../../helpers/array.mjs\";\nimport SourceSettings from \"./sourceSettings.mjs\";\nimport HeadersTree from \"./headersTree.mjs\";\nimport { triggerNodeModification as _triggerNodeModification } from \"./nodeModifiers/index.mjs\";\nimport { generateMatrix } from \"./matrixGenerator.mjs\";\n/**\n * The state manager is a source of truth for nested headers configuration.\n * The state generation process is divided into three stages.\n *\n *   +---------------------+  1. User-defined configuration normalization;\n *   │                     │  The source settings class normalizes and shares API for\n *   │   SourceSettings    │  raw settings passed by the developer. It is only consumed by\n *   │                     │  the header tree module.\n *   +---------------------+\n *             │\n *            \\│/\n *   +---------------------+  2. Building a tree structure for validation and easier node manipulation;\n *   │                     │  The header tree generates a tree based on source settings for future\n *   │     HeadersTree     │  node manipulation (such as collapsible columns feature). While generating a tree\n *   │                     │  the source settings is checked to see if the configuration has overlapping headers.\n *   +---------------------+  If `true` the colspan matrix generation is skipped, overlapped headers are not supported.\n *             │\n *            \\│/\n *   +---------------------+  3. Matrix generation;\n *   │                     │  Based on built trees the matrix generation is performed. That part of code\n *   │  matrix generation  │  generates an array structure similar to normalized data from the SourceSettings\n *   │                     │  but with the difference that this structure contains column settings which changed\n *   +---------------------+  during runtime (after the tree manipulation) e.q after collapse or expand column.\n *                            That settings describes how the TH element should be modified (colspan attribute,\n *                            CSS classes, etc) for a specific column and layer level.\n *\n * @class StateManager\n * @plugin NestedHeaders\n */\n\nvar _sourceSettings = /*#__PURE__*/new WeakMap();\n\nvar _headersTree = /*#__PURE__*/new WeakMap();\n\nvar _stateMatrix = /*#__PURE__*/new WeakMap();\n\nvar StateManager = /*#__PURE__*/function () {\n  function StateManager() {\n    _classCallCheck(this, StateManager);\n\n    _sourceSettings.set(this, {\n      writable: true,\n      value: new SourceSettings()\n    });\n\n    _headersTree.set(this, {\n      writable: true,\n      value: new HeadersTree(_classPrivateFieldGet(this, _sourceSettings))\n    });\n\n    _stateMatrix.set(this, {\n      writable: true,\n      value: [[]]\n    });\n  }\n\n  _createClass(StateManager, [{\n    key: \"setState\",\n    value:\n    /**\n     * Sets a new state for the nested headers plugin based on settings passed\n     * directly to the plugin.\n     *\n     * @param {Array[]} nestedHeadersSettings The user-defined settings.\n     * @returns {boolean} Returns `true` if the settings are processed correctly, `false` otherwise.\n     */\n    function setState(nestedHeadersSettings) {\n      _classPrivateFieldGet(this, _sourceSettings).setData(nestedHeadersSettings);\n\n      var hasError = false;\n\n      try {\n        _classPrivateFieldGet(this, _headersTree).buildTree();\n      } catch (ex) {\n        _classPrivateFieldGet(this, _headersTree).clear();\n\n        _classPrivateFieldGet(this, _sourceSettings).clear();\n\n        hasError = true;\n      }\n\n      _classPrivateFieldSet(this, _stateMatrix, generateMatrix(_classPrivateFieldGet(this, _headersTree).getRoots()));\n\n      return hasError;\n    }\n    /**\n     * Sets columns limit to the state will be trimmed. All headers (colspans) which\n     * overlap the column limit will be reduced to keep the structure solid.\n     *\n     * @param {number} columnsCount The number of columns to limit to.\n     */\n\n  }, {\n    key: \"setColumnsLimit\",\n    value: function setColumnsLimit(columnsCount) {\n      _classPrivateFieldGet(this, _sourceSettings).setColumnsLimit(columnsCount);\n    }\n    /**\n     * Merges settings with current plugin state.\n     *\n     * By default only foreign keys are merged with source state and passed to the tree. But only\n     * known keys are exported to matrix.\n     *\n     * @param {object[]} settings An array of objects to merge with the current source settings.\n     *                            It is a requirement that every object has `row` and `col` properties\n     *                            which points to the specific header settings object.\n     */\n\n  }, {\n    key: \"mergeStateWith\",\n    value: function mergeStateWith(settings) {\n      var _this = this;\n\n      var transformedSettings = arrayMap(settings, function (_ref) {\n        var row = _ref.row,\n            rest = _objectWithoutProperties(_ref, _excluded);\n\n        return _objectSpread({\n          row: row < 0 ? _this.rowCoordsToLevel(row) : row\n        }, rest);\n      });\n\n      _classPrivateFieldGet(this, _sourceSettings).mergeWith(transformedSettings);\n\n      _classPrivateFieldGet(this, _headersTree).buildTree();\n\n      _classPrivateFieldSet(this, _stateMatrix, generateMatrix(_classPrivateFieldGet(this, _headersTree).getRoots()));\n    }\n    /**\n     * Maps the current state with a callback. For each header settings the callback function\n     * is called. If the function returns value that value is merged with the state.\n     *\n     * By default only foreign keys are merged with source state and passed to the tree. But only\n     * known keys are exported to matrix.\n     *\n     * @param {Function} callback A function that is called for every header source settings.\n     *                            Each time the callback is called, the returned value extends\n     *                            header settings.\n     */\n\n  }, {\n    key: \"mapState\",\n    value: function mapState(callback) {\n      _classPrivateFieldGet(this, _sourceSettings).map(callback);\n\n      _classPrivateFieldGet(this, _headersTree).buildTree();\n\n      _classPrivateFieldSet(this, _stateMatrix, generateMatrix(_classPrivateFieldGet(this, _headersTree).getRoots()));\n    }\n    /**\n     * Maps the current tree nodes with a callback. For each node the callback function\n     * is called. If the function returns value that value is added to returned array.\n     *\n     * @param {Function} callback A function that is called for every tree node.\n     *                            Each time the callback is called, the returned value is\n     *                            added to returned array.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"mapNodes\",\n    value: function mapNodes(callback) {\n      return arrayReduce(_classPrivateFieldGet(this, _headersTree).getRoots(), function (acc, rootNode) {\n        rootNode.walkDown(function (node) {\n          var result = callback(node.data);\n\n          if (result !== void 0) {\n            acc.push(result);\n          }\n        });\n        return acc;\n      }, []);\n    }\n    /**\n     * Triggers an action (e.g. \"collapse\") from the NodeModifiers module. The module\n     * modifies a tree structure in such a way as to obtain the correct structure consistent with the\n     * called action.\n     *\n     * @param {string} action An action name to trigger.\n     * @param {number} headerLevel Header level index (there is support for negative and positive values).\n     * @param {number} columnIndex A visual column index.\n     * @returns {object|undefined}\n     */\n\n  }, {\n    key: \"triggerNodeModification\",\n    value: function triggerNodeModification(action, headerLevel, columnIndex) {\n      if (headerLevel < 0) {\n        headerLevel = this.rowCoordsToLevel(headerLevel);\n      }\n\n      var nodeToProcess = _classPrivateFieldGet(this, _headersTree).getNode(headerLevel, columnIndex);\n\n      var actionResult;\n\n      if (nodeToProcess) {\n        actionResult = _triggerNodeModification(action, nodeToProcess, columnIndex); // TODO (perf-tip): Trigger matrix generation once after multiple node modifications.\n\n        _classPrivateFieldSet(this, _stateMatrix, generateMatrix(_classPrivateFieldGet(this, _headersTree).getRoots()));\n      }\n\n      return actionResult;\n    }\n    /**\n     * Triggers an action (e.g. \"hide-column\") from the NodeModifiers module. The action is\n     * triggered starting from the lowest header. The module modifies a tree structure in\n     * such a way as to obtain the correct structure consistent with the called action.\n     *\n     * @param {string} action An action name to trigger.\n     * @param {number} columnIndex A visual column index.\n     * @returns {object|undefined}\n     */\n\n  }, {\n    key: \"triggerColumnModification\",\n    value: function triggerColumnModification(action, columnIndex) {\n      return this.triggerNodeModification(action, -1, columnIndex);\n    }\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n\n    /**\n     * @memberof StateManager#\n     * @function rowCoordsToLevel\n     *\n     * Translates row coordinates into header level. The row coordinates counts from -1 to -N\n     * and describes headers counting from most closest to most distant from the table.\n     * The header levels are counted from 0 to N where 0 describes most distant header\n     * from the table.\n     *\n     *  Row coords             Header level\n     *           +--------------+\n     *       -3  │ A1 │ A1      │  0\n     *           +--------------+\n     *       -2  │ B1 │ B2 │ B3 │  1\n     *           +--------------+\n     *       -1  │ C1 │ C2 │ C3 │  2\n     *           +==============+\n     *           │    │    │    │\n     *           +--------------+\n     *           │    │    │    │\n     *\n     * @param {number} rowIndex A visual row index.\n     * @returns {number} Returns unsigned number.\n     */\n\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  }, {\n    key: \"rowCoordsToLevel\",\n    value: function rowCoordsToLevel(rowIndex) {\n      var layersCount = Math.max(this.getLayersCount(), 1);\n      var highestPossibleLevel = layersCount - 1;\n      var lowestPossibleLevel = 0;\n      return Math.min(Math.max(rowIndex + layersCount, lowestPossibleLevel), highestPossibleLevel);\n    }\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n\n    /**\n     * @memberof StateManager#\n     * @function levelToRowCoords\n     *\n     * Translates header level into row coordinates. The row coordinates counts from -1 to -N\n     * and describes headers counting from most closest to most distant from the table.\n     * The header levels are counted from 0 to N where 0 describes most distant header\n     * from the table.\n     *\n     *  Header level            Row coords\n     *           +--------------+\n     *        0  │ A1 │ A1      │  -3\n     *           +--------------+\n     *        1  │ B1 │ B2 │ B3 │  -2\n     *           +--------------+\n     *        2  │ C1 │ C2 │ C3 │  -1\n     *           +==============+\n     *           │    │    │    │\n     *           +--------------+\n     *           │    │    │    │\n     *\n     * @param {number} headerLevel Header level index.\n     * @returns {number} Returns negative number.\n     */\n\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  }, {\n    key: \"levelToRowCoords\",\n    value: function levelToRowCoords(headerLevel) {\n      var layersCount = Math.max(this.getLayersCount(), 1);\n      var highestPossibleRow = -1;\n      var lowestPossibleRow = -layersCount;\n      return Math.min(Math.max(headerLevel - layersCount, lowestPossibleRow), highestPossibleRow);\n    }\n    /**\n     * Gets column header settings for a specified column and header index. The returned object contains\n     * all information necessary for header renderers. It contains header label, colspan length, or hidden\n     * flag.\n     *\n     * @param {number} headerLevel Header level (there is support for negative and positive values).\n     * @param {number} columnIndex A visual column index.\n     * @returns {object|null}\n     */\n\n  }, {\n    key: \"getHeaderSettings\",\n    value: function getHeaderSettings(headerLevel, columnIndex) {\n      var _classPrivateFieldGet2, _classPrivateFieldGet3;\n\n      if (headerLevel < 0) {\n        headerLevel = this.rowCoordsToLevel(headerLevel);\n      }\n\n      if (headerLevel >= this.getLayersCount()) {\n        return null;\n      }\n\n      return (_classPrivateFieldGet2 = (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _stateMatrix)[headerLevel]) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3[columnIndex]) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : null;\n    }\n    /**\n     * Gets tree data that is connected to the column header. The returned object contains all information\n     * necessary for modifying tree structure (column collapsing, hiding, etc.). It contains a header\n     * label, colspan length, or visual column index that indicates which column index the node is rendered from.\n     *\n     * @param {number} headerLevel Header level (there is support for negative and positive values).\n     * @param {number} columnIndex A visual column index.\n     * @returns {object|null}\n     */\n\n  }, {\n    key: \"getHeaderTreeNodeData\",\n    value: function getHeaderTreeNodeData(headerLevel, columnIndex) {\n      if (headerLevel < 0) {\n        headerLevel = this.rowCoordsToLevel(headerLevel);\n      }\n\n      var node = _classPrivateFieldGet(this, _headersTree).getNode(headerLevel, columnIndex);\n\n      if (!node) {\n        return null;\n      }\n\n      return _objectSpread({}, node.data);\n    }\n    /**\n     * The method is helpful in cases where the column index targets in-between currently\n     * collapsed column. In that case, the method returns the left-most column index\n     * where the nested header begins.\n     *\n     * @param {number} headerLevel Header level (there is support for negative and positive values).\n     * @param {number} columnIndex A visual column index.\n     * @returns {number}\n     */\n\n  }, {\n    key: \"findLeftMostColumnIndex\",\n    value: function findLeftMostColumnIndex(headerLevel, columnIndex) {\n      var _this$getHeaderSettin;\n\n      var _ref2 = (_this$getHeaderSettin = this.getHeaderSettings(headerLevel, columnIndex)) !== null && _this$getHeaderSettin !== void 0 ? _this$getHeaderSettin : {\n        isRoot: true\n      },\n          isRoot = _ref2.isRoot;\n\n      if (isRoot) {\n        return columnIndex;\n      }\n\n      var stepBackColumn = columnIndex - 1;\n\n      do {\n        var _this$getHeaderSettin2;\n\n        var _ref3 = (_this$getHeaderSettin2 = this.getHeaderSettings(headerLevel, stepBackColumn)) !== null && _this$getHeaderSettin2 !== void 0 ? _this$getHeaderSettin2 : {\n          isRoot: true\n        },\n            isRootNode = _ref3.isRoot;\n\n        if (isRootNode) {\n          break;\n        }\n\n        stepBackColumn -= 1;\n      } while (columnIndex >= 0);\n\n      return stepBackColumn;\n    }\n    /**\n     * Gets a total number of headers levels.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getLayersCount\",\n    value: function getLayersCount() {\n      return _classPrivateFieldGet(this, _sourceSettings).getLayersCount();\n    }\n    /**\n     * Gets a total number of columns count.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getColumnsCount\",\n    value: function getColumnsCount() {\n      return _classPrivateFieldGet(this, _sourceSettings).getColumnsCount();\n    }\n    /**\n     * Clears the column state manager to the initial state.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      _classPrivateFieldSet(this, _stateMatrix, []);\n\n      _classPrivateFieldGet(this, _sourceSettings).clear();\n\n      _classPrivateFieldGet(this, _headersTree).clear();\n    }\n  }]);\n\n  return StateManager;\n}();\n\nexport { StateManager as default };"]},"metadata":{},"sourceType":"module"}