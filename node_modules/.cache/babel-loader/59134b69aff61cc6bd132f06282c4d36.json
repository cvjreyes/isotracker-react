{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { CellRange } from \"./../3rdparty/walkontable/src/index.mjs\";\n/**\r\n * The SelectionRange class is a simple CellRanges collection designed for easy manipulation of the multiple\r\n * consecutive and non-consecutive selections.\r\n *\r\n * @class SelectionRange\r\n * @util\r\n */\n\nvar SelectionRange = /*#__PURE__*/function () {\n  function SelectionRange() {\n    _classCallCheck(this, SelectionRange);\n    /**\r\n     * List of all CellRanges added to the class instance.\r\n     *\r\n     * @type {CellRange[]}\r\n     */\n\n\n    this.ranges = [];\n  }\n  /**\r\n   * Check if selected range is empty.\r\n   *\r\n   * @returns {boolean}\r\n   */\n\n\n  _createClass(SelectionRange, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.size() === 0;\n    }\n    /**\r\n     * Set coordinates to the class instance. It clears all previously added coordinates and push `coords`\r\n     * to the collection.\r\n     *\r\n     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\r\n     * @returns {SelectionRange}\r\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(coords) {\n      this.clear();\n      this.ranges.push(new CellRange(coords));\n      return this;\n    }\n    /**\r\n     * Add coordinates to the class instance. The new coordinates are added to the end of the range collection.\r\n     *\r\n     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\r\n     * @returns {SelectionRange}\r\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(coords) {\n      this.ranges.push(new CellRange(coords));\n      return this;\n    }\n    /**\r\n     * Removes from the stack the last added coordinates.\r\n     *\r\n     * @returns {SelectionRange}\r\n     */\n\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      this.ranges.pop();\n      return this;\n    }\n    /**\r\n     * Get last added coordinates from ranges, it returns a CellRange instance.\r\n     *\r\n     * @returns {CellRange|undefined}\r\n     */\n\n  }, {\n    key: \"current\",\n    value: function current() {\n      return this.peekByIndex(0);\n    }\n    /**\r\n     * Get previously added coordinates from ranges, it returns a CellRange instance.\r\n     *\r\n     * @returns {CellRange|undefined}\r\n     */\n\n  }, {\n    key: \"previous\",\n    value: function previous() {\n      return this.peekByIndex(-1);\n    }\n    /**\r\n     * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\r\n     * the coords object is within selection range.\r\n     *\r\n     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"includes\",\n    value: function includes(coords) {\n      return this.ranges.some(function (cellRange) {\n        return cellRange.includes(coords);\n      });\n    }\n    /**\r\n     * Clear collection.\r\n     *\r\n     * @returns {SelectionRange}\r\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.ranges.length = 0;\n      return this;\n    }\n    /**\r\n     * Get count of added all coordinates added to the selection.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this.ranges.length;\n    }\n    /**\r\n     * Peek the coordinates based on the offset where that coordinate resides in the collection.\r\n     *\r\n     * @param {number} [offset=0] An offset where the coordinate will be retrieved from.\r\n     * @returns {CellRange|undefined}\r\n     */\n\n  }, {\n    key: \"peekByIndex\",\n    value: function peekByIndex() {\n      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var rangeIndex = this.size() + offset - 1;\n      var cellRange;\n\n      if (rangeIndex >= 0) {\n        cellRange = this.ranges[rangeIndex];\n      }\n\n      return cellRange;\n    }\n  }, {\n    key: Symbol.iterator,\n    value: function value() {\n      return this.ranges[Symbol.iterator]();\n    }\n  }]);\n\n  return SelectionRange;\n}();\n\nexport default SelectionRange;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/selection/range.mjs"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","CellRange","SelectionRange","ranges","value","isEmpty","size","set","coords","clear","push","add","pop","current","peekByIndex","previous","includes","some","cellRange","offset","arguments","undefined","rangeIndex","Symbol","iterator"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.includes.js\";\r\nimport \"core-js/modules/es.string.includes.js\";\r\nimport \"core-js/modules/es.symbol.iterator.js\";\r\nimport \"core-js/modules/es.array.iterator.js\";\r\nimport \"core-js/modules/es.object.to-string.js\";\r\nimport \"core-js/modules/es.string.iterator.js\";\r\nimport \"core-js/modules/web.dom-collections.iterator.js\";\r\nimport \"core-js/modules/es.symbol.js\";\r\nimport \"core-js/modules/es.symbol.description.js\";\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport { CellRange } from \"./../3rdparty/walkontable/src/index.mjs\";\r\n/**\r\n * The SelectionRange class is a simple CellRanges collection designed for easy manipulation of the multiple\r\n * consecutive and non-consecutive selections.\r\n *\r\n * @class SelectionRange\r\n * @util\r\n */\r\n\r\nvar SelectionRange = /*#__PURE__*/function () {\r\n  function SelectionRange() {\r\n    _classCallCheck(this, SelectionRange);\r\n\r\n    /**\r\n     * List of all CellRanges added to the class instance.\r\n     *\r\n     * @type {CellRange[]}\r\n     */\r\n    this.ranges = [];\r\n  }\r\n  /**\r\n   * Check if selected range is empty.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n\r\n\r\n  _createClass(SelectionRange, [{\r\n    key: \"isEmpty\",\r\n    value: function isEmpty() {\r\n      return this.size() === 0;\r\n    }\r\n    /**\r\n     * Set coordinates to the class instance. It clears all previously added coordinates and push `coords`\r\n     * to the collection.\r\n     *\r\n     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\r\n     * @returns {SelectionRange}\r\n     */\r\n\r\n  }, {\r\n    key: \"set\",\r\n    value: function set(coords) {\r\n      this.clear();\r\n      this.ranges.push(new CellRange(coords));\r\n      return this;\r\n    }\r\n    /**\r\n     * Add coordinates to the class instance. The new coordinates are added to the end of the range collection.\r\n     *\r\n     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\r\n     * @returns {SelectionRange}\r\n     */\r\n\r\n  }, {\r\n    key: \"add\",\r\n    value: function add(coords) {\r\n      this.ranges.push(new CellRange(coords));\r\n      return this;\r\n    }\r\n    /**\r\n     * Removes from the stack the last added coordinates.\r\n     *\r\n     * @returns {SelectionRange}\r\n     */\r\n\r\n  }, {\r\n    key: \"pop\",\r\n    value: function pop() {\r\n      this.ranges.pop();\r\n      return this;\r\n    }\r\n    /**\r\n     * Get last added coordinates from ranges, it returns a CellRange instance.\r\n     *\r\n     * @returns {CellRange|undefined}\r\n     */\r\n\r\n  }, {\r\n    key: \"current\",\r\n    value: function current() {\r\n      return this.peekByIndex(0);\r\n    }\r\n    /**\r\n     * Get previously added coordinates from ranges, it returns a CellRange instance.\r\n     *\r\n     * @returns {CellRange|undefined}\r\n     */\r\n\r\n  }, {\r\n    key: \"previous\",\r\n    value: function previous() {\r\n      return this.peekByIndex(-1);\r\n    }\r\n    /**\r\n     * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\r\n     * the coords object is within selection range.\r\n     *\r\n     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"includes\",\r\n    value: function includes(coords) {\r\n      return this.ranges.some(function (cellRange) {\r\n        return cellRange.includes(coords);\r\n      });\r\n    }\r\n    /**\r\n     * Clear collection.\r\n     *\r\n     * @returns {SelectionRange}\r\n     */\r\n\r\n  }, {\r\n    key: \"clear\",\r\n    value: function clear() {\r\n      this.ranges.length = 0;\r\n      return this;\r\n    }\r\n    /**\r\n     * Get count of added all coordinates added to the selection.\r\n     *\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"size\",\r\n    value: function size() {\r\n      return this.ranges.length;\r\n    }\r\n    /**\r\n     * Peek the coordinates based on the offset where that coordinate resides in the collection.\r\n     *\r\n     * @param {number} [offset=0] An offset where the coordinate will be retrieved from.\r\n     * @returns {CellRange|undefined}\r\n     */\r\n\r\n  }, {\r\n    key: \"peekByIndex\",\r\n    value: function peekByIndex() {\r\n      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\r\n      var rangeIndex = this.size() + offset - 1;\r\n      var cellRange;\r\n\r\n      if (rangeIndex >= 0) {\r\n        cellRange = this.ranges[rangeIndex];\r\n      }\r\n\r\n      return cellRange;\r\n    }\r\n  }, {\r\n    key: Symbol.iterator,\r\n    value: function value() {\r\n      return this.ranges[Symbol.iterator]();\r\n    }\r\n  }]);\r\n\r\n  return SelectionRange;\r\n}();\r\n\r\nexport default SelectionRange;"]},"metadata":{},"sourceType":"module"}