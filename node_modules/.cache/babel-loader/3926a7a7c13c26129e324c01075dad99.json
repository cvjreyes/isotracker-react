{"ast":null,"code":"import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.concat\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.array.map\";\nimport \"core-js/modules/es.array.slice\";\nimport \"core-js/modules/es.function.name\";\nimport \"core-js/modules/es.object.freeze\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.for-each\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nvar _templateObject;\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { isUndefined } from \"../../../helpers/mixed.mjs\";\nimport { warn } from \"../../../helpers/console.mjs\";\nimport { toSingleLine } from \"../../../helpers/templateLiteralTag.mjs\";\nimport { CellCoords } from \"../../../3rdparty/walkontable/src/index.mjs\";\n/**\r\n * Helper class for the row-move-related operations.\r\n *\r\n * @class RowMoveController\r\n * @plugin NestedRows\r\n * @private\r\n */\n\nvar RowMoveController = /*#__PURE__*/function () {\n  function RowMoveController(plugin) {\n    _classCallCheck(this, RowMoveController);\n    /**\r\n     * Reference to the Nested Rows plugin instance.\r\n     *\r\n     * @type {NestedRows}\r\n     */\n\n\n    this.plugin = plugin;\n    /**\r\n     * Reference to the Handsontable instance.\r\n     *\r\n     * @type {Handsontable.Core}\r\n     */\n\n    this.hot = plugin.hot;\n    /**\r\n     * Reference to the Data Manager class instance.\r\n     *\r\n     * @type {DataManager}\r\n     */\n\n    this.dataManager = plugin.dataManager;\n    /**\r\n     * Reference to the Collapsing UI class instance.\r\n     *\r\n     * @type {CollapsingUI}\r\n     */\n\n    this.collapsingUI = plugin.collapsingUI;\n  }\n  /**\r\n   * `beforeRowMove` hook callback.\r\n   *\r\n   * @param {Array} rows Array of visual row indexes to be moved.\r\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements\r\n   *   will be placed after the moving action. To check the visualization of the final index, please take a look at\r\n   *   [documentation](/docs/demo-moving.html).\r\n   * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we\r\n   *   are going to drop the moved elements. To check visualization of drop index please take a look at\r\n   *   [documentation](/docs/demo-moving.html).\r\n   * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.\r\n   * @fires Hooks#afterRowMove\r\n   * @returns {boolean}\r\n   */\n\n\n  _createClass(RowMoveController, [{\n    key: \"onBeforeRowMove\",\n    value: function onBeforeRowMove(rows, finalIndex, dropIndex, movePossible) {\n      var _this = this;\n\n      var improperUsage = this.displayAPICompatibilityWarning({\n        rows: rows,\n        finalIndex: finalIndex,\n        dropIndex: dropIndex,\n        movePossible: movePossible\n      });\n\n      if (improperUsage) {\n        return false;\n      }\n\n      this.movedToCollapsed = false;\n      var dropToLastRow = dropIndex === this.hot.countRows();\n      var physicalDropIndex = dropToLastRow ? this.hot.countSourceRows() : this.dataManager.translateTrimmedRow(dropIndex);\n      var allowMove = true;\n      var physicalStartIndexes = rows.map(function (rowIndex) {\n        // Don't do the logic for the rest of the rows, as it's bound to fail anyway.\n        if (!allowMove) {\n          return false;\n        }\n\n        var physicalRowIndex = _this.dataManager.translateTrimmedRow(rowIndex);\n\n        allowMove = _this.shouldAllowMoving(physicalRowIndex, physicalDropIndex);\n        return physicalRowIndex;\n      });\n      var willDataChange = physicalStartIndexes.indexOf(physicalDropIndex) === -1;\n\n      if (!allowMove || !willDataChange) {\n        return false;\n      }\n\n      var baseParent = this.getBaseParent(physicalStartIndexes);\n      var targetParent = this.getTargetParent(dropToLastRow, physicalDropIndex);\n      var sameParent = baseParent === targetParent;\n      this.movedToCollapsed = this.collapsingUI.areChildrenCollapsed(targetParent); // Stash the current state of collapsed rows\n\n      this.collapsingUI.collapsedRowsStash.stash();\n      this.shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent);\n      this.moveRows(physicalStartIndexes, physicalDropIndex, targetParent);\n      this.dataManager.updateWithData(this.dataManager.getRawSourceData());\n      this.moveCellsMeta(physicalStartIndexes, physicalDropIndex);\n      this.collapsingUI.collapsedRowsStash.applyStash(false); // TODO: Trying to mock real work of the `ManualRowMove` plugin. It was blocked by returning `false` below.\n\n      this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, movePossible && this.isRowOrderChanged(rows, finalIndex)); // Not necessary - added to keep compatibility with other plugins (namely: columnSummary).\n\n      this.hot.render();\n      this.selectCells(rows, dropIndex);\n      return false;\n    }\n    /**\r\n     * Display a `dragRows`/`moveRows` method compatibility warning if needed.\r\n     *\r\n     * @param {object} beforeMoveRowHookArgs A set of arguments from the `beforeMoveRow` hook.\r\n     * @returns {boolean} `true` if is a result of an improper usage of the moving API.\r\n     */\n\n  }, {\n    key: \"displayAPICompatibilityWarning\",\n    value: function displayAPICompatibilityWarning(beforeMoveRowHookArgs) {\n      var rows = beforeMoveRowHookArgs.rows,\n          finalIndex = beforeMoveRowHookArgs.finalIndex,\n          dropIndex = beforeMoveRowHookArgs.dropIndex,\n          movePossible = beforeMoveRowHookArgs.movePossible;\n      var shouldTerminate = false;\n\n      if (isUndefined(dropIndex)) {\n        warn(toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows \\n      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead.\"], [\"Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows\\\\x20\\n      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead.\"])))); // TODO: Trying to mock real work of the `ManualRowMove` plugin. It was blocked by returning `false` below.\n\n        this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, false);\n        shouldTerminate = true;\n      }\n\n      return shouldTerminate;\n    }\n    /**\r\n     * Check if the moving action should be allowed.\r\n     *\r\n     * @param {number} physicalRowIndex Physical start row index.\r\n     * @param {number} physicalDropIndex Physical drop index.\r\n     * @returns {boolean} `true` if it should continue with the moving action.\r\n     */\n\n  }, {\n    key: \"shouldAllowMoving\",\n    value: function shouldAllowMoving(physicalRowIndex, physicalDropIndex) {\n      /*\r\n         We can't move rows when any of them is:\r\n         - a parent\r\n         - a top-level element\r\n         - is being moved to the top level\r\n         - is being moved to the position of any of the moved rows (not changing position)\r\n      */\n      return !(this.dataManager.isParent(physicalRowIndex) || this.dataManager.isRowHighestLevel(physicalRowIndex) || physicalRowIndex === physicalDropIndex || physicalDropIndex === 0);\n    }\n    /**\r\n     * Get the base row parent.\r\n     *\r\n     * @param {number} physicalStartIndexes Physical start row index.\r\n     * @returns {object|null} The base row parent.\r\n     */\n\n  }, {\n    key: \"getBaseParent\",\n    value: function getBaseParent(physicalStartIndexes) {\n      return this.dataManager.getRowParent(physicalStartIndexes[0]);\n    }\n    /**\r\n     * Get the target row parent.\r\n     *\r\n     * @param {boolean} dropToLastRow `true` if the row is moved to the last row of the table.\r\n     * @param {number} physicalDropIndex Physical drop row index.\r\n     * @returns {object|null} The target row parent.\r\n     */\n\n  }, {\n    key: \"getTargetParent\",\n    value: function getTargetParent(dropToLastRow, physicalDropIndex) {\n      var targetParent = this.dataManager.getRowParent(dropToLastRow ? physicalDropIndex - 1 : physicalDropIndex); // If we try to move an element to the place of a top-level parent, snap the element to the previous top-level\n      // parent's children instead\n\n      if (targetParent === null || targetParent === void 0) {\n        targetParent = this.dataManager.getRowParent(physicalDropIndex - 1);\n      }\n\n      return targetParent;\n    }\n    /**\r\n     * Shift the cached collapsible rows position according to the move action.\r\n     *\r\n     * @param {number[]} physicalStartIndexes Physical start row indexes.\r\n     * @param {number} physicalDropIndex Physical drop index.\r\n     * @param {boolean} sameParent `true` if the row's being moved between siblings of the same parent.\r\n     */\n\n  }, {\n    key: \"shiftCollapsibleParentsLocations\",\n    value: function shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent) {\n      if (!sameParent) {\n        if (Math.max.apply(Math, _toConsumableArray(physicalStartIndexes)) <= physicalDropIndex) {\n          this.collapsingUI.collapsedRowsStash.shiftStash(physicalStartIndexes[0], physicalDropIndex, -1 * physicalStartIndexes.length);\n        } else {\n          this.collapsingUI.collapsedRowsStash.shiftStash(physicalDropIndex, physicalStartIndexes[0], physicalStartIndexes.length);\n        }\n      }\n    }\n    /**\r\n     * Move the rows at the provided coordinates.\r\n     *\r\n     * @param {number[]} physicalStartIndexes Physical indexes of the rows about to be moved.\r\n     * @param {number} physicalDropIndex Physical drop index.\r\n     * @param {object} targetParent Parent of the destination row.\r\n     */\n\n  }, {\n    key: \"moveRows\",\n    value: function moveRows(physicalStartIndexes, physicalDropIndex, targetParent) {\n      var _this2 = this;\n\n      var moveToLastChild = physicalDropIndex === this.dataManager.getRowIndex(targetParent) + this.dataManager.countChildren(targetParent) + 1;\n      this.hot.batchRender(function () {\n        physicalStartIndexes.forEach(function (physicalStartIndex) {\n          _this2.dataManager.moveRow(physicalStartIndex, physicalDropIndex, _this2.movedToCollapsed, moveToLastChild);\n        });\n      });\n    }\n    /**\r\n     * Move the cell meta for multiple rows.\r\n     *\r\n     * @param {number[]} baseIndexes Array of indexes for the rows being moved.\r\n     * @param {number} targetIndex Index of the destination of the move.\r\n     */\n\n  }, {\n    key: \"moveCellsMeta\",\n    value: function moveCellsMeta(baseIndexes, targetIndex) {\n      var _this3 = this,\n          _this$hot;\n\n      var rowsOfMeta = [];\n      var movingDown = Math.max.apply(Math, _toConsumableArray(baseIndexes)) < targetIndex;\n      baseIndexes.forEach(function (baseIndex) {\n        rowsOfMeta.push(_this3.hot.getCellMetaAtRow(baseIndex));\n      });\n      this.hot.spliceCellsMeta(baseIndexes[0], baseIndexes.length);\n\n      (_this$hot = this.hot).spliceCellsMeta.apply(_this$hot, [targetIndex - (movingDown ? rowsOfMeta.length : 0), 0].concat(rowsOfMeta));\n    }\n    /**\r\n     * Select cells after the move.\r\n     *\r\n     * @param {Array} rows Array of visual row indexes to be moved.\r\n     * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we\r\n     *   are going to drop the moved elements. To check visualization of drop index please take a look at\r\n     *   [documentation](/docs/demo-moving.html).\r\n     */\n\n  }, {\n    key: \"selectCells\",\n    value: function selectCells(rows, dropIndex) {\n      var rowsLen = rows.length;\n      var startRow = 0;\n      var endRow = 0;\n      var selection = null;\n      var lastColIndex = null;\n\n      if (this.movedToCollapsed) {\n        var physicalDropIndex = null;\n\n        if (rows[rowsLen - 1] < dropIndex) {\n          physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex - rowsLen);\n        } else {\n          physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex);\n        }\n\n        var parentObject = this.dataManager.getRowParent(physicalDropIndex === null ? this.hot.countSourceRows() - 1 : physicalDropIndex - 1);\n        var parentIndex = this.dataManager.getRowIndex(parentObject);\n        startRow = this.dataManager.untranslateTrimmedRow(parentIndex);\n        endRow = startRow;\n      } else if (rows[rowsLen - 1] < dropIndex) {\n        endRow = dropIndex - 1;\n        startRow = endRow - rowsLen + 1;\n      } else {\n        startRow = dropIndex;\n        endRow = startRow + rowsLen - 1;\n      }\n\n      selection = this.hot.selection;\n      lastColIndex = this.hot.countCols() - 1;\n      selection.setRangeStart(new CellCoords(startRow, 0));\n      selection.setRangeEnd(new CellCoords(endRow, lastColIndex), true);\n    } // TODO: Reimplementation of function which is inside the `ManualRowMove` plugin.\n\n    /**\r\n     * Indicates if order of rows was changed.\r\n     *\r\n     * @param {Array} movedRows Array of visual row indexes to be moved.\r\n     * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements\r\n     *   will be placed after the moving action. To check the visualization of the final index, please take a look at\r\n     *   [documentation](/docs/demo-moving.html).\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isRowOrderChanged\",\n    value: function isRowOrderChanged(movedRows, finalIndex) {\n      return movedRows.some(function (row, nrOfMovedElement) {\n        return row - nrOfMovedElement !== finalIndex;\n      });\n    }\n  }]);\n\n  return RowMoveController;\n}();\n\nexport { RowMoveController as default };","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/plugins/nestedRows/utils/rowMoveController.mjs"],"names":["_templateObject","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","_taggedTemplateLiteral","strings","raw","freeze","defineProperties","value","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","isUndefined","warn","toSingleLine","CellCoords","RowMoveController","plugin","hot","dataManager","collapsingUI","onBeforeRowMove","rows","finalIndex","dropIndex","movePossible","_this","improperUsage","displayAPICompatibilityWarning","movedToCollapsed","dropToLastRow","countRows","physicalDropIndex","countSourceRows","translateTrimmedRow","allowMove","physicalStartIndexes","map","rowIndex","physicalRowIndex","shouldAllowMoving","willDataChange","indexOf","baseParent","getBaseParent","targetParent","getTargetParent","sameParent","areChildrenCollapsed","collapsedRowsStash","stash","shiftCollapsibleParentsLocations","moveRows","updateWithData","getRawSourceData","moveCellsMeta","applyStash","runHooks","isRowOrderChanged","render","selectCells","beforeMoveRowHookArgs","shouldTerminate","isParent","isRowHighestLevel","getRowParent","Math","max","apply","shiftStash","_this2","moveToLastChild","getRowIndex","countChildren","batchRender","forEach","physicalStartIndex","moveRow","baseIndexes","targetIndex","_this3","_this$hot","rowsOfMeta","movingDown","baseIndex","push","getCellMetaAtRow","spliceCellsMeta","concat","rowsLen","startRow","endRow","selection","lastColIndex","parentObject","parentIndex","untranslateTrimmedRow","countCols","setRangeStart","setRangeEnd","movedRows","some","row","nrOfMovedElement","default"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.slice.js\";\r\nimport \"core-js/modules/es.object.freeze.js\";\r\nimport \"core-js/modules/es.symbol.js\";\r\nimport \"core-js/modules/es.symbol.description.js\";\r\nimport \"core-js/modules/es.object.to-string.js\";\r\nimport \"core-js/modules/es.symbol.iterator.js\";\r\nimport \"core-js/modules/es.array.iterator.js\";\r\nimport \"core-js/modules/es.string.iterator.js\";\r\nimport \"core-js/modules/web.dom-collections.iterator.js\";\r\nimport \"core-js/modules/es.array.from.js\";\r\nimport \"core-js/modules/es.function.name.js\";\r\n\r\nvar _templateObject;\r\n\r\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\r\n\r\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\r\n\r\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\r\n\r\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\r\n\r\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\r\n\r\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\r\n\r\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\r\n\r\nimport \"core-js/modules/es.array.map.js\";\r\nimport \"core-js/modules/es.array.index-of.js\";\r\nimport \"core-js/modules/web.dom-collections.for-each.js\";\r\nimport \"core-js/modules/es.array.concat.js\";\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport { isUndefined } from \"../../../helpers/mixed.mjs\";\r\nimport { warn } from \"../../../helpers/console.mjs\";\r\nimport { toSingleLine } from \"../../../helpers/templateLiteralTag.mjs\";\r\nimport { CellCoords } from \"../../../3rdparty/walkontable/src/index.mjs\";\r\n/**\r\n * Helper class for the row-move-related operations.\r\n *\r\n * @class RowMoveController\r\n * @plugin NestedRows\r\n * @private\r\n */\r\n\r\nvar RowMoveController = /*#__PURE__*/function () {\r\n  function RowMoveController(plugin) {\r\n    _classCallCheck(this, RowMoveController);\r\n\r\n    /**\r\n     * Reference to the Nested Rows plugin instance.\r\n     *\r\n     * @type {NestedRows}\r\n     */\r\n    this.plugin = plugin;\r\n    /**\r\n     * Reference to the Handsontable instance.\r\n     *\r\n     * @type {Handsontable.Core}\r\n     */\r\n\r\n    this.hot = plugin.hot;\r\n    /**\r\n     * Reference to the Data Manager class instance.\r\n     *\r\n     * @type {DataManager}\r\n     */\r\n\r\n    this.dataManager = plugin.dataManager;\r\n    /**\r\n     * Reference to the Collapsing UI class instance.\r\n     *\r\n     * @type {CollapsingUI}\r\n     */\r\n\r\n    this.collapsingUI = plugin.collapsingUI;\r\n  }\r\n  /**\r\n   * `beforeRowMove` hook callback.\r\n   *\r\n   * @param {Array} rows Array of visual row indexes to be moved.\r\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements\r\n   *   will be placed after the moving action. To check the visualization of the final index, please take a look at\r\n   *   [documentation](/docs/demo-moving.html).\r\n   * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we\r\n   *   are going to drop the moved elements. To check visualization of drop index please take a look at\r\n   *   [documentation](/docs/demo-moving.html).\r\n   * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.\r\n   * @fires Hooks#afterRowMove\r\n   * @returns {boolean}\r\n   */\r\n\r\n\r\n  _createClass(RowMoveController, [{\r\n    key: \"onBeforeRowMove\",\r\n    value: function onBeforeRowMove(rows, finalIndex, dropIndex, movePossible) {\r\n      var _this = this;\r\n\r\n      var improperUsage = this.displayAPICompatibilityWarning({\r\n        rows: rows,\r\n        finalIndex: finalIndex,\r\n        dropIndex: dropIndex,\r\n        movePossible: movePossible\r\n      });\r\n\r\n      if (improperUsage) {\r\n        return false;\r\n      }\r\n\r\n      this.movedToCollapsed = false;\r\n      var dropToLastRow = dropIndex === this.hot.countRows();\r\n      var physicalDropIndex = dropToLastRow ? this.hot.countSourceRows() : this.dataManager.translateTrimmedRow(dropIndex);\r\n      var allowMove = true;\r\n      var physicalStartIndexes = rows.map(function (rowIndex) {\r\n        // Don't do the logic for the rest of the rows, as it's bound to fail anyway.\r\n        if (!allowMove) {\r\n          return false;\r\n        }\r\n\r\n        var physicalRowIndex = _this.dataManager.translateTrimmedRow(rowIndex);\r\n\r\n        allowMove = _this.shouldAllowMoving(physicalRowIndex, physicalDropIndex);\r\n        return physicalRowIndex;\r\n      });\r\n      var willDataChange = physicalStartIndexes.indexOf(physicalDropIndex) === -1;\r\n\r\n      if (!allowMove || !willDataChange) {\r\n        return false;\r\n      }\r\n\r\n      var baseParent = this.getBaseParent(physicalStartIndexes);\r\n      var targetParent = this.getTargetParent(dropToLastRow, physicalDropIndex);\r\n      var sameParent = baseParent === targetParent;\r\n      this.movedToCollapsed = this.collapsingUI.areChildrenCollapsed(targetParent); // Stash the current state of collapsed rows\r\n\r\n      this.collapsingUI.collapsedRowsStash.stash();\r\n      this.shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent);\r\n      this.moveRows(physicalStartIndexes, physicalDropIndex, targetParent);\r\n      this.dataManager.updateWithData(this.dataManager.getRawSourceData());\r\n      this.moveCellsMeta(physicalStartIndexes, physicalDropIndex);\r\n      this.collapsingUI.collapsedRowsStash.applyStash(false); // TODO: Trying to mock real work of the `ManualRowMove` plugin. It was blocked by returning `false` below.\r\n\r\n      this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, movePossible && this.isRowOrderChanged(rows, finalIndex)); // Not necessary - added to keep compatibility with other plugins (namely: columnSummary).\r\n\r\n      this.hot.render();\r\n      this.selectCells(rows, dropIndex);\r\n      return false;\r\n    }\r\n    /**\r\n     * Display a `dragRows`/`moveRows` method compatibility warning if needed.\r\n     *\r\n     * @param {object} beforeMoveRowHookArgs A set of arguments from the `beforeMoveRow` hook.\r\n     * @returns {boolean} `true` if is a result of an improper usage of the moving API.\r\n     */\r\n\r\n  }, {\r\n    key: \"displayAPICompatibilityWarning\",\r\n    value: function displayAPICompatibilityWarning(beforeMoveRowHookArgs) {\r\n      var rows = beforeMoveRowHookArgs.rows,\r\n          finalIndex = beforeMoveRowHookArgs.finalIndex,\r\n          dropIndex = beforeMoveRowHookArgs.dropIndex,\r\n          movePossible = beforeMoveRowHookArgs.movePossible;\r\n      var shouldTerminate = false;\r\n\r\n      if (isUndefined(dropIndex)) {\r\n        warn(toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows \\n      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead.\"], [\"Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows\\\\x20\\n      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead.\"])))); // TODO: Trying to mock real work of the `ManualRowMove` plugin. It was blocked by returning `false` below.\r\n\r\n        this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, false);\r\n        shouldTerminate = true;\r\n      }\r\n\r\n      return shouldTerminate;\r\n    }\r\n    /**\r\n     * Check if the moving action should be allowed.\r\n     *\r\n     * @param {number} physicalRowIndex Physical start row index.\r\n     * @param {number} physicalDropIndex Physical drop index.\r\n     * @returns {boolean} `true` if it should continue with the moving action.\r\n     */\r\n\r\n  }, {\r\n    key: \"shouldAllowMoving\",\r\n    value: function shouldAllowMoving(physicalRowIndex, physicalDropIndex) {\r\n      /*\r\n         We can't move rows when any of them is:\r\n         - a parent\r\n         - a top-level element\r\n         - is being moved to the top level\r\n         - is being moved to the position of any of the moved rows (not changing position)\r\n      */\r\n      return !(this.dataManager.isParent(physicalRowIndex) || this.dataManager.isRowHighestLevel(physicalRowIndex) || physicalRowIndex === physicalDropIndex || physicalDropIndex === 0);\r\n    }\r\n    /**\r\n     * Get the base row parent.\r\n     *\r\n     * @param {number} physicalStartIndexes Physical start row index.\r\n     * @returns {object|null} The base row parent.\r\n     */\r\n\r\n  }, {\r\n    key: \"getBaseParent\",\r\n    value: function getBaseParent(physicalStartIndexes) {\r\n      return this.dataManager.getRowParent(physicalStartIndexes[0]);\r\n    }\r\n    /**\r\n     * Get the target row parent.\r\n     *\r\n     * @param {boolean} dropToLastRow `true` if the row is moved to the last row of the table.\r\n     * @param {number} physicalDropIndex Physical drop row index.\r\n     * @returns {object|null} The target row parent.\r\n     */\r\n\r\n  }, {\r\n    key: \"getTargetParent\",\r\n    value: function getTargetParent(dropToLastRow, physicalDropIndex) {\r\n      var targetParent = this.dataManager.getRowParent(dropToLastRow ? physicalDropIndex - 1 : physicalDropIndex); // If we try to move an element to the place of a top-level parent, snap the element to the previous top-level\r\n      // parent's children instead\r\n\r\n      if (targetParent === null || targetParent === void 0) {\r\n        targetParent = this.dataManager.getRowParent(physicalDropIndex - 1);\r\n      }\r\n\r\n      return targetParent;\r\n    }\r\n    /**\r\n     * Shift the cached collapsible rows position according to the move action.\r\n     *\r\n     * @param {number[]} physicalStartIndexes Physical start row indexes.\r\n     * @param {number} physicalDropIndex Physical drop index.\r\n     * @param {boolean} sameParent `true` if the row's being moved between siblings of the same parent.\r\n     */\r\n\r\n  }, {\r\n    key: \"shiftCollapsibleParentsLocations\",\r\n    value: function shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent) {\r\n      if (!sameParent) {\r\n        if (Math.max.apply(Math, _toConsumableArray(physicalStartIndexes)) <= physicalDropIndex) {\r\n          this.collapsingUI.collapsedRowsStash.shiftStash(physicalStartIndexes[0], physicalDropIndex, -1 * physicalStartIndexes.length);\r\n        } else {\r\n          this.collapsingUI.collapsedRowsStash.shiftStash(physicalDropIndex, physicalStartIndexes[0], physicalStartIndexes.length);\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Move the rows at the provided coordinates.\r\n     *\r\n     * @param {number[]} physicalStartIndexes Physical indexes of the rows about to be moved.\r\n     * @param {number} physicalDropIndex Physical drop index.\r\n     * @param {object} targetParent Parent of the destination row.\r\n     */\r\n\r\n  }, {\r\n    key: \"moveRows\",\r\n    value: function moveRows(physicalStartIndexes, physicalDropIndex, targetParent) {\r\n      var _this2 = this;\r\n\r\n      var moveToLastChild = physicalDropIndex === this.dataManager.getRowIndex(targetParent) + this.dataManager.countChildren(targetParent) + 1;\r\n      this.hot.batchRender(function () {\r\n        physicalStartIndexes.forEach(function (physicalStartIndex) {\r\n          _this2.dataManager.moveRow(physicalStartIndex, physicalDropIndex, _this2.movedToCollapsed, moveToLastChild);\r\n        });\r\n      });\r\n    }\r\n    /**\r\n     * Move the cell meta for multiple rows.\r\n     *\r\n     * @param {number[]} baseIndexes Array of indexes for the rows being moved.\r\n     * @param {number} targetIndex Index of the destination of the move.\r\n     */\r\n\r\n  }, {\r\n    key: \"moveCellsMeta\",\r\n    value: function moveCellsMeta(baseIndexes, targetIndex) {\r\n      var _this3 = this,\r\n          _this$hot;\r\n\r\n      var rowsOfMeta = [];\r\n      var movingDown = Math.max.apply(Math, _toConsumableArray(baseIndexes)) < targetIndex;\r\n      baseIndexes.forEach(function (baseIndex) {\r\n        rowsOfMeta.push(_this3.hot.getCellMetaAtRow(baseIndex));\r\n      });\r\n      this.hot.spliceCellsMeta(baseIndexes[0], baseIndexes.length);\r\n\r\n      (_this$hot = this.hot).spliceCellsMeta.apply(_this$hot, [targetIndex - (movingDown ? rowsOfMeta.length : 0), 0].concat(rowsOfMeta));\r\n    }\r\n    /**\r\n     * Select cells after the move.\r\n     *\r\n     * @param {Array} rows Array of visual row indexes to be moved.\r\n     * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we\r\n     *   are going to drop the moved elements. To check visualization of drop index please take a look at\r\n     *   [documentation](/docs/demo-moving.html).\r\n     */\r\n\r\n  }, {\r\n    key: \"selectCells\",\r\n    value: function selectCells(rows, dropIndex) {\r\n      var rowsLen = rows.length;\r\n      var startRow = 0;\r\n      var endRow = 0;\r\n      var selection = null;\r\n      var lastColIndex = null;\r\n\r\n      if (this.movedToCollapsed) {\r\n        var physicalDropIndex = null;\r\n\r\n        if (rows[rowsLen - 1] < dropIndex) {\r\n          physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex - rowsLen);\r\n        } else {\r\n          physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex);\r\n        }\r\n\r\n        var parentObject = this.dataManager.getRowParent(physicalDropIndex === null ? this.hot.countSourceRows() - 1 : physicalDropIndex - 1);\r\n        var parentIndex = this.dataManager.getRowIndex(parentObject);\r\n        startRow = this.dataManager.untranslateTrimmedRow(parentIndex);\r\n        endRow = startRow;\r\n      } else if (rows[rowsLen - 1] < dropIndex) {\r\n        endRow = dropIndex - 1;\r\n        startRow = endRow - rowsLen + 1;\r\n      } else {\r\n        startRow = dropIndex;\r\n        endRow = startRow + rowsLen - 1;\r\n      }\r\n\r\n      selection = this.hot.selection;\r\n      lastColIndex = this.hot.countCols() - 1;\r\n      selection.setRangeStart(new CellCoords(startRow, 0));\r\n      selection.setRangeEnd(new CellCoords(endRow, lastColIndex), true);\r\n    } // TODO: Reimplementation of function which is inside the `ManualRowMove` plugin.\r\n\r\n    /**\r\n     * Indicates if order of rows was changed.\r\n     *\r\n     * @param {Array} movedRows Array of visual row indexes to be moved.\r\n     * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements\r\n     *   will be placed after the moving action. To check the visualization of the final index, please take a look at\r\n     *   [documentation](/docs/demo-moving.html).\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isRowOrderChanged\",\r\n    value: function isRowOrderChanged(movedRows, finalIndex) {\r\n      return movedRows.some(function (row, nrOfMovedElement) {\r\n        return row - nrOfMovedElement !== finalIndex;\r\n      });\r\n    }\r\n  }]);\r\n\r\n  return RowMoveController;\r\n}();\r\n\r\nexport { RowMoveController as default };"]},"metadata":{},"sourceType":"module"}