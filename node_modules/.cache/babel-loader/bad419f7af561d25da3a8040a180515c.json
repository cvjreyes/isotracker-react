{"ast":null,"code":"import { arrayEach } from \"../../../../helpers/array.mjs\";\nimport { collapseNode } from \"./collapse.mjs\";\nimport { getFirstChildProperty, isNodeReflectsFirstChildColspan, traverseHiddenNodeColumnIndexes } from \"./utils/tree.mjs\";\n/**\n * Expanding a node is a process where the processing node is expanded to\n * its original colspan width. To restore an original state of all node\n * children on the right, the modified nodes are replaced with the cloned\n * nodes (they were cloned while collapsing).\n *\n * @param {TreeNode} nodeToProcess A tree node to process.\n * @returns {object} Returns an object with properties:\n *                    - rollbackModification: The function that rollbacks\n *                      the tree to the previous state.\n *                    - affectedColumns: The list of the visual column\n *                      indexes which are affected. That list is passed\n *                      to the hiddens column logic.\n *                    - colspanCompensation: The number of colspan by\n *                      which the processed node colspan was increased.\n */\n\nexport function expandNode(nodeToProcess) {\n  var nodeData = nodeToProcess.data,\n      nodeChilds = nodeToProcess.childs;\n\n  if (!nodeData.isCollapsed || nodeData.isHidden || nodeData.origColspan <= 1) {\n    return {\n      rollbackModification: function rollbackModification() {},\n      affectedColumns: [],\n      colspanCompensation: 0\n    };\n  }\n\n  var isNodeReflected = isNodeReflectsFirstChildColspan(nodeToProcess);\n\n  if (isNodeReflected) {\n    return expandNode(nodeChilds[0]);\n  }\n\n  nodeData.isCollapsed = false;\n  var allLeavesExceptMostLeft = nodeChilds.slice(1);\n  var affectedColumns = new Set();\n  var colspanCompensation = 0;\n\n  if (allLeavesExceptMostLeft.length > 0) {\n    arrayEach(allLeavesExceptMostLeft, function (node) {\n      // Restore original state of the collapsed headers.\n      node.replaceTreeWith(node.data.clonedTree);\n      node.data.clonedTree = null;\n      var leafData = node.data; // Calculate by how many colspan it needs to increase the headings to match them to\n      // the colspan width of all its children.\n\n      colspanCompensation += leafData.colspan;\n      traverseHiddenNodeColumnIndexes(node, function (gridColumnIndex) {\n        affectedColumns.add(gridColumnIndex);\n      });\n    });\n  } else {\n    var colspan = nodeData.colspan,\n        origColspan = nodeData.origColspan,\n        columnIndex = nodeData.columnIndex; // In a case when the node doesn't have any children restore the colspan width to\n    // its original state.\n\n    colspanCompensation = origColspan - colspan; // Add column to \"affected\" started from 1. The header without children can not be\n    // collapsed so the first column is already visible and we shouldn't touch it.\n\n    for (var i = 1; i < origColspan; i++) {\n      affectedColumns.add(columnIndex + i);\n    }\n  }\n\n  nodeToProcess.walkUp(function (node) {\n    var data = node.data;\n    data.colspan += colspanCompensation;\n\n    if (data.colspan >= data.origColspan) {\n      data.colspan = data.origColspan;\n      data.isCollapsed = false;\n    } else if (isNodeReflectsFirstChildColspan(node)) {\n      data.isCollapsed = getFirstChildProperty(node, 'isCollapsed');\n    }\n  });\n  return {\n    rollbackModification: function rollbackModification() {\n      return collapseNode(nodeToProcess);\n    },\n    affectedColumns: Array.from(affectedColumns),\n    colspanCompensation: colspanCompensation\n  };\n}","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/expand.mjs"],"names":["arrayEach","collapseNode","getFirstChildProperty","isNodeReflectsFirstChildColspan","traverseHiddenNodeColumnIndexes","expandNode","nodeToProcess","nodeData","data","nodeChilds","childs","isCollapsed","isHidden","origColspan","rollbackModification","affectedColumns","colspanCompensation","isNodeReflected","allLeavesExceptMostLeft","slice","Set","length","node","replaceTreeWith","clonedTree","leafData","colspan","gridColumnIndex","add","columnIndex","i","walkUp","Array","from"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport { arrayEach } from \"../../../../helpers/array.mjs\";\nimport { collapseNode } from \"./collapse.mjs\";\nimport { getFirstChildProperty, isNodeReflectsFirstChildColspan, traverseHiddenNodeColumnIndexes } from \"./utils/tree.mjs\";\n/**\n * Expanding a node is a process where the processing node is expanded to\n * its original colspan width. To restore an original state of all node\n * children on the right, the modified nodes are replaced with the cloned\n * nodes (they were cloned while collapsing).\n *\n * @param {TreeNode} nodeToProcess A tree node to process.\n * @returns {object} Returns an object with properties:\n *                    - rollbackModification: The function that rollbacks\n *                      the tree to the previous state.\n *                    - affectedColumns: The list of the visual column\n *                      indexes which are affected. That list is passed\n *                      to the hiddens column logic.\n *                    - colspanCompensation: The number of colspan by\n *                      which the processed node colspan was increased.\n */\n\nexport function expandNode(nodeToProcess) {\n  var nodeData = nodeToProcess.data,\n      nodeChilds = nodeToProcess.childs;\n\n  if (!nodeData.isCollapsed || nodeData.isHidden || nodeData.origColspan <= 1) {\n    return {\n      rollbackModification: function rollbackModification() {},\n      affectedColumns: [],\n      colspanCompensation: 0\n    };\n  }\n\n  var isNodeReflected = isNodeReflectsFirstChildColspan(nodeToProcess);\n\n  if (isNodeReflected) {\n    return expandNode(nodeChilds[0]);\n  }\n\n  nodeData.isCollapsed = false;\n  var allLeavesExceptMostLeft = nodeChilds.slice(1);\n  var affectedColumns = new Set();\n  var colspanCompensation = 0;\n\n  if (allLeavesExceptMostLeft.length > 0) {\n    arrayEach(allLeavesExceptMostLeft, function (node) {\n      // Restore original state of the collapsed headers.\n      node.replaceTreeWith(node.data.clonedTree);\n      node.data.clonedTree = null;\n      var leafData = node.data; // Calculate by how many colspan it needs to increase the headings to match them to\n      // the colspan width of all its children.\n\n      colspanCompensation += leafData.colspan;\n      traverseHiddenNodeColumnIndexes(node, function (gridColumnIndex) {\n        affectedColumns.add(gridColumnIndex);\n      });\n    });\n  } else {\n    var colspan = nodeData.colspan,\n        origColspan = nodeData.origColspan,\n        columnIndex = nodeData.columnIndex; // In a case when the node doesn't have any children restore the colspan width to\n    // its original state.\n\n    colspanCompensation = origColspan - colspan; // Add column to \"affected\" started from 1. The header without children can not be\n    // collapsed so the first column is already visible and we shouldn't touch it.\n\n    for (var i = 1; i < origColspan; i++) {\n      affectedColumns.add(columnIndex + i);\n    }\n  }\n\n  nodeToProcess.walkUp(function (node) {\n    var data = node.data;\n    data.colspan += colspanCompensation;\n\n    if (data.colspan >= data.origColspan) {\n      data.colspan = data.origColspan;\n      data.isCollapsed = false;\n    } else if (isNodeReflectsFirstChildColspan(node)) {\n      data.isCollapsed = getFirstChildProperty(node, 'isCollapsed');\n    }\n  });\n  return {\n    rollbackModification: function rollbackModification() {\n      return collapseNode(nodeToProcess);\n    },\n    affectedColumns: Array.from(affectedColumns),\n    colspanCompensation: colspanCompensation\n  };\n}"]},"metadata":{},"sourceType":"module"}