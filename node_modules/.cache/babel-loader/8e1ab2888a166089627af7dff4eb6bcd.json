{"ast":null,"code":"import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.array.slice\";\nimport \"core-js/modules/es.array.splice\";\nimport \"core-js/modules/es.function.name\";\nimport \"core-js/modules/es.object.freeze\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nvar _templateObject;\n\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport MergedCellCoords from \"./cellCoords.mjs\";\nimport { CellCoords, CellRange } from \"../../3rdparty/walkontable/src/index.mjs\";\nimport { rangeEach, rangeEachReverse } from \"../../helpers/number.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { applySpanProperties } from \"./utils.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\r\n * Defines a container object for the merged cells.\r\n *\r\n * @class MergedCellsCollection\r\n * @plugin MergeCells\r\n */\n\nvar MergedCellsCollection = /*#__PURE__*/function () {\n  function MergedCellsCollection(plugin) {\n    _classCallCheck(this, MergedCellsCollection);\n    /**\r\n     * Reference to the Merge Cells plugin.\r\n     *\r\n     * @type {MergeCells}\r\n     */\n\n\n    this.plugin = plugin;\n    /**\r\n     * Array of merged cells.\r\n     *\r\n     * @type {Array}\r\n     */\n\n    this.mergedCells = [];\n    /**\r\n     * The Handsontable instance.\r\n     *\r\n     * @type {Handsontable}\r\n     */\n\n    this.hot = plugin.hot;\n  }\n  /**\r\n   * Get a warning message for when the declared merged cell data overlaps already existing merged cells.\r\n   *\r\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\r\n   * @returns {string}\r\n   */\n\n\n  _createClass(MergedCellsCollection, [{\n    key: \"get\",\n    value:\n    /**\r\n     * Get a merged cell from the container, based on the provided arguments. You can provide either the \"starting coordinates\"\r\n     * of a merged cell, or any coordinates from the body of the merged cell.\r\n     *\r\n     * @param {number} row Row index.\r\n     * @param {number} column Column index.\r\n     * @returns {MergedCellCoords|boolean} Returns a wanted merged cell on success and `false` on failure.\r\n     */\n    function get(row, column) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row <= row && mergedCell.row + mergedCell.rowspan - 1 >= row && mergedCell.col <= column && mergedCell.col + mergedCell.colspan - 1 >= column) {\n          result = mergedCell;\n          return false;\n        }\n\n        return true;\n      });\n      return result;\n    }\n    /**\r\n     * Get a merged cell containing the provided range.\r\n     *\r\n     * @param {CellRange|object} range The range to search merged cells for.\r\n     * @returns {MergedCellCoords|boolean}\r\n     */\n\n  }, {\n    key: \"getByRange\",\n    value: function getByRange(range) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 >= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + mergedCell.colspan - 1 >= range.to.col) {\n          result = mergedCell;\n          return result;\n        }\n\n        return true;\n      });\n      return result;\n    }\n    /**\r\n     * Get a merged cell contained in the provided range.\r\n     *\r\n     * @param {CellRange|object} range The range to search merged cells in.\r\n     * @param {boolean} [countPartials=false] If set to `true`, all the merged cells overlapping the range will be taken into calculation.\r\n     * @returns {Array|boolean} Array of found merged cells of `false` if none were found.\r\n     */\n\n  }, {\n    key: \"getWithinRange\",\n    value: function getWithinRange(range) {\n      var countPartials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var mergedCells = this.mergedCells;\n      var foundMergedCells = [];\n      var testedRange = range;\n\n      if (!testedRange.includesRange) {\n        var from = new CellCoords(testedRange.from.row, testedRange.from.col);\n        var to = new CellCoords(testedRange.to.row, testedRange.to.col);\n        testedRange = new CellRange(from, from, to);\n      }\n\n      arrayEach(mergedCells, function (mergedCell) {\n        var mergedCellTopLeft = new CellCoords(mergedCell.row, mergedCell.col);\n        var mergedCellBottomRight = new CellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1);\n        var mergedCellRange = new CellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);\n\n        if (countPartials) {\n          if (testedRange.overlaps(mergedCellRange)) {\n            foundMergedCells.push(mergedCell);\n          }\n        } else if (testedRange.includesRange(mergedCellRange)) {\n          foundMergedCells.push(mergedCell);\n        }\n      });\n      return foundMergedCells.length ? foundMergedCells : false;\n    }\n    /**\r\n     * Add a merged cell to the container.\r\n     *\r\n     * @param {object} mergedCellInfo The merged cell information object. Has to contain `row`, `col`, `colspan` and `rowspan` properties.\r\n     * @returns {MergedCellCoords|boolean} Returns the new merged cell on success and `false` on failure.\r\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(mergedCellInfo) {\n      var mergedCells = this.mergedCells;\n      var row = mergedCellInfo.row;\n      var column = mergedCellInfo.col;\n      var rowspan = mergedCellInfo.rowspan;\n      var colspan = mergedCellInfo.colspan;\n      var newMergedCell = new MergedCellCoords(row, column, rowspan, colspan);\n      var alreadyExists = this.get(row, column);\n      var isOverlapping = this.isOverlapping(newMergedCell);\n\n      if (!alreadyExists && !isOverlapping) {\n        if (this.hot) {\n          newMergedCell.normalize(this.hot);\n        }\n\n        mergedCells.push(newMergedCell);\n        return newMergedCell;\n      }\n\n      warn(MergedCellsCollection.IS_OVERLAPPING_WARNING(newMergedCell));\n      return false;\n    }\n    /**\r\n     * Remove a merged cell from the container. You can provide either the \"starting coordinates\"\r\n     * of a merged cell, or any coordinates from the body of the merged cell.\r\n     *\r\n     * @param {number} row Row index.\r\n     * @param {number} column Column index.\r\n     * @returns {MergedCellCoords|boolean} Returns the removed merged cell on success and `false` on failure.\r\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(row, column) {\n      var mergedCells = this.mergedCells;\n      var wantedCollection = this.get(row, column);\n      var wantedCollectionIndex = wantedCollection ? this.mergedCells.indexOf(wantedCollection) : null;\n\n      if (wantedCollection && wantedCollectionIndex !== false) {\n        mergedCells.splice(wantedCollectionIndex, 1);\n        return wantedCollection;\n      }\n\n      return false;\n    }\n    /**\r\n     * Clear all the merged cells.\r\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this = this;\n\n      var mergedCells = this.mergedCells;\n      var mergedCellParentsToClear = [];\n      var hiddenCollectionElements = [];\n      arrayEach(mergedCells, function (mergedCell) {\n        var TD = _this.hot.getCell(mergedCell.row, mergedCell.col);\n\n        if (TD) {\n          mergedCellParentsToClear.push([TD, _this.get(mergedCell.row, mergedCell.col), mergedCell.row, mergedCell.col]);\n        }\n      });\n      this.mergedCells.length = 0;\n      arrayEach(mergedCellParentsToClear, function (mergedCell, i) {\n        rangeEach(0, mergedCell.rowspan - 1, function (j) {\n          rangeEach(0, mergedCell.colspan - 1, function (k) {\n            if (k !== 0 || j !== 0) {\n              var TD = _this.hot.getCell(mergedCell.row + j, mergedCell.col + k);\n\n              if (TD) {\n                hiddenCollectionElements.push([TD, null, null, null]);\n              }\n            }\n          });\n        });\n        mergedCellParentsToClear[i][1] = null;\n      });\n      arrayEach(mergedCellParentsToClear, function (mergedCellParents) {\n        applySpanProperties.apply(void 0, _toConsumableArray(mergedCellParents));\n      });\n      arrayEach(hiddenCollectionElements, function (hiddenCollectionElement) {\n        applySpanProperties.apply(void 0, _toConsumableArray(hiddenCollectionElement));\n      });\n    }\n    /**\r\n     * Check if the provided merged cell overlaps with the others in the container.\r\n     *\r\n     * @param {MergedCellCoords} mergedCell The merged cell to check against all others in the container.\r\n     * @returns {boolean} `true` if the provided merged cell overlaps with the others, `false` otherwise.\r\n     */\n\n  }, {\n    key: \"isOverlapping\",\n    value: function isOverlapping(mergedCell) {\n      var mergedCellRange = new CellRange(new CellCoords(0, 0), new CellCoords(mergedCell.row, mergedCell.col), new CellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1));\n      var result = false;\n      arrayEach(this.mergedCells, function (col) {\n        var currentRange = new CellRange(new CellCoords(0, 0), new CellCoords(col.row, col.col), new CellCoords(col.row + col.rowspan - 1, col.col + col.colspan - 1));\n\n        if (currentRange.overlaps(mergedCellRange)) {\n          result = true;\n          return false;\n        }\n\n        return true;\n      });\n      return result;\n    }\n    /**\r\n     * Check whether the provided row/col coordinates direct to a first not hidden cell within merge area.\r\n     *\r\n     * @param {number} row Visual row index.\r\n     * @param {number} column Visual column index.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isFirstRenderableMergedCell\",\n    value: function isFirstRenderableMergedCell(row, column) {\n      var mergeParent = this.get(row, column); // Return if row and column indexes are within merge area and if they are first rendered indexes within the area.\n\n      return mergeParent && this.hot.rowIndexMapper.getFirstNotHiddenIndex(mergeParent.row, 1) === row && this.hot.columnIndexMapper.getFirstNotHiddenIndex(mergeParent.col, 1) === column;\n    }\n    /**\r\n     * Get the first renderable coords of the merged cell at the provided coordinates.\r\n     *\r\n     * @param {number} row Visual row index.\r\n     * @param {number} column Visual column index.\r\n     * @returns {CellCoords} A `CellCoords` object with the coordinates to the first renderable cell within the\r\n     *                        merged cell.\r\n     */\n\n  }, {\n    key: \"getFirstRenderableCoords\",\n    value: function getFirstRenderableCoords(row, column) {\n      var mergeParent = this.get(row, column);\n\n      if (!mergeParent || this.isFirstRenderableMergedCell(row, column)) {\n        return new CellCoords(row, column);\n      }\n\n      var firstRenderableRow = this.hot.rowIndexMapper.getFirstNotHiddenIndex(mergeParent.row, 1);\n      var firstRenderableColumn = this.hot.columnIndexMapper.getFirstNotHiddenIndex(mergeParent.col, 1);\n      return new CellCoords(firstRenderableRow, firstRenderableColumn);\n    }\n    /**\r\n     * Shift the merged cell in the direction and by an offset defined in the arguments.\r\n     *\r\n     * @param {string} direction `right`, `left`, `up` or `down`.\r\n     * @param {number} index Index where the change, which caused the shifting took place.\r\n     * @param {number} count Number of rows/columns added/removed in the preceding action.\r\n     */\n\n  }, {\n    key: \"shiftCollections\",\n    value: function shiftCollections(direction, index, count) {\n      var _this2 = this;\n\n      var shiftVector = [0, 0];\n\n      switch (direction) {\n        case 'right':\n          shiftVector[0] += count;\n          break;\n\n        case 'left':\n          shiftVector[0] -= count;\n          break;\n\n        case 'down':\n          shiftVector[1] += count;\n          break;\n\n        case 'up':\n          shiftVector[1] -= count;\n          break;\n\n        default:\n      }\n\n      arrayEach(this.mergedCells, function (currentMerge) {\n        currentMerge.shift(shiftVector, index);\n      });\n      rangeEachReverse(this.mergedCells.length - 1, 0, function (i) {\n        var currentMerge = _this2.mergedCells[i];\n\n        if (currentMerge && currentMerge.removed) {\n          _this2.mergedCells.splice(_this2.mergedCells.indexOf(currentMerge), 1);\n        }\n      });\n    }\n  }], [{\n    key: \"IS_OVERLAPPING_WARNING\",\n    value: function IS_OVERLAPPING_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"], overlaps \\n      with the other declared merged cell. The overlapping merged cell was not added to the table, please \\n      fix your setup.\"], [\"The merged cell declared at [\", \", \", \"], overlaps\\\\x20\\n      with the other declared merged cell. The overlapping merged cell was not added to the table, please\\\\x20\\n      fix your setup.\"])), newMergedCell.row, newMergedCell.col);\n    }\n  }]);\n\n  return MergedCellsCollection;\n}();\n\nexport default MergedCellsCollection;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/plugins/mergeCells/cellsCollection.mjs"],"names":["_templateObject","_taggedTemplateLiteral","strings","raw","slice","Object","freeze","defineProperties","value","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","prototype","toString","call","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","MergedCellCoords","CellCoords","CellRange","rangeEach","rangeEachReverse","warn","arrayEach","applySpanProperties","toSingleLine","MergedCellsCollection","plugin","mergedCells","hot","get","row","column","result","mergedCell","rowspan","col","colspan","getByRange","range","to","getWithinRange","countPartials","arguments","undefined","foundMergedCells","testedRange","includesRange","mergedCellTopLeft","mergedCellBottomRight","mergedCellRange","overlaps","push","add","mergedCellInfo","newMergedCell","alreadyExists","isOverlapping","normalize","IS_OVERLAPPING_WARNING","remove","wantedCollection","wantedCollectionIndex","indexOf","splice","clear","_this","mergedCellParentsToClear","hiddenCollectionElements","TD","getCell","j","k","mergedCellParents","apply","hiddenCollectionElement","currentRange","isFirstRenderableMergedCell","mergeParent","rowIndexMapper","getFirstNotHiddenIndex","columnIndexMapper","getFirstRenderableCoords","firstRenderableRow","firstRenderableColumn","shiftCollections","direction","index","count","_this2","shiftVector","currentMerge","shift","removed"],"mappings":"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","sourcesContent":["var _templateObject;\r\n\r\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\r\n\r\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\r\n\r\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\r\n\r\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\r\n\r\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\r\n\r\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\r\n\r\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\r\n\r\nimport \"core-js/modules/es.array.index-of.js\";\r\nimport \"core-js/modules/es.array.splice.js\";\r\nimport \"core-js/modules/es.symbol.js\";\r\nimport \"core-js/modules/es.symbol.description.js\";\r\nimport \"core-js/modules/es.object.to-string.js\";\r\nimport \"core-js/modules/es.symbol.iterator.js\";\r\nimport \"core-js/modules/es.array.iterator.js\";\r\nimport \"core-js/modules/es.string.iterator.js\";\r\nimport \"core-js/modules/web.dom-collections.iterator.js\";\r\nimport \"core-js/modules/es.array.from.js\";\r\nimport \"core-js/modules/es.array.slice.js\";\r\nimport \"core-js/modules/es.function.name.js\";\r\nimport \"core-js/modules/es.object.freeze.js\";\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport MergedCellCoords from \"./cellCoords.mjs\";\r\nimport { CellCoords, CellRange } from \"../../3rdparty/walkontable/src/index.mjs\";\r\nimport { rangeEach, rangeEachReverse } from \"../../helpers/number.mjs\";\r\nimport { warn } from \"../../helpers/console.mjs\";\r\nimport { arrayEach } from \"../../helpers/array.mjs\";\r\nimport { applySpanProperties } from \"./utils.mjs\";\r\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\r\n/**\r\n * Defines a container object for the merged cells.\r\n *\r\n * @class MergedCellsCollection\r\n * @plugin MergeCells\r\n */\r\n\r\nvar MergedCellsCollection = /*#__PURE__*/function () {\r\n  function MergedCellsCollection(plugin) {\r\n    _classCallCheck(this, MergedCellsCollection);\r\n\r\n    /**\r\n     * Reference to the Merge Cells plugin.\r\n     *\r\n     * @type {MergeCells}\r\n     */\r\n    this.plugin = plugin;\r\n    /**\r\n     * Array of merged cells.\r\n     *\r\n     * @type {Array}\r\n     */\r\n\r\n    this.mergedCells = [];\r\n    /**\r\n     * The Handsontable instance.\r\n     *\r\n     * @type {Handsontable}\r\n     */\r\n\r\n    this.hot = plugin.hot;\r\n  }\r\n  /**\r\n   * Get a warning message for when the declared merged cell data overlaps already existing merged cells.\r\n   *\r\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\r\n   * @returns {string}\r\n   */\r\n\r\n\r\n  _createClass(MergedCellsCollection, [{\r\n    key: \"get\",\r\n    value:\r\n    /**\r\n     * Get a merged cell from the container, based on the provided arguments. You can provide either the \"starting coordinates\"\r\n     * of a merged cell, or any coordinates from the body of the merged cell.\r\n     *\r\n     * @param {number} row Row index.\r\n     * @param {number} column Column index.\r\n     * @returns {MergedCellCoords|boolean} Returns a wanted merged cell on success and `false` on failure.\r\n     */\r\n    function get(row, column) {\r\n      var mergedCells = this.mergedCells;\r\n      var result = false;\r\n      arrayEach(mergedCells, function (mergedCell) {\r\n        if (mergedCell.row <= row && mergedCell.row + mergedCell.rowspan - 1 >= row && mergedCell.col <= column && mergedCell.col + mergedCell.colspan - 1 >= column) {\r\n          result = mergedCell;\r\n          return false;\r\n        }\r\n\r\n        return true;\r\n      });\r\n      return result;\r\n    }\r\n    /**\r\n     * Get a merged cell containing the provided range.\r\n     *\r\n     * @param {CellRange|object} range The range to search merged cells for.\r\n     * @returns {MergedCellCoords|boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"getByRange\",\r\n    value: function getByRange(range) {\r\n      var mergedCells = this.mergedCells;\r\n      var result = false;\r\n      arrayEach(mergedCells, function (mergedCell) {\r\n        if (mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 >= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + mergedCell.colspan - 1 >= range.to.col) {\r\n          result = mergedCell;\r\n          return result;\r\n        }\r\n\r\n        return true;\r\n      });\r\n      return result;\r\n    }\r\n    /**\r\n     * Get a merged cell contained in the provided range.\r\n     *\r\n     * @param {CellRange|object} range The range to search merged cells in.\r\n     * @param {boolean} [countPartials=false] If set to `true`, all the merged cells overlapping the range will be taken into calculation.\r\n     * @returns {Array|boolean} Array of found merged cells of `false` if none were found.\r\n     */\r\n\r\n  }, {\r\n    key: \"getWithinRange\",\r\n    value: function getWithinRange(range) {\r\n      var countPartials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n      var mergedCells = this.mergedCells;\r\n      var foundMergedCells = [];\r\n      var testedRange = range;\r\n\r\n      if (!testedRange.includesRange) {\r\n        var from = new CellCoords(testedRange.from.row, testedRange.from.col);\r\n        var to = new CellCoords(testedRange.to.row, testedRange.to.col);\r\n        testedRange = new CellRange(from, from, to);\r\n      }\r\n\r\n      arrayEach(mergedCells, function (mergedCell) {\r\n        var mergedCellTopLeft = new CellCoords(mergedCell.row, mergedCell.col);\r\n        var mergedCellBottomRight = new CellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1);\r\n        var mergedCellRange = new CellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);\r\n\r\n        if (countPartials) {\r\n          if (testedRange.overlaps(mergedCellRange)) {\r\n            foundMergedCells.push(mergedCell);\r\n          }\r\n        } else if (testedRange.includesRange(mergedCellRange)) {\r\n          foundMergedCells.push(mergedCell);\r\n        }\r\n      });\r\n      return foundMergedCells.length ? foundMergedCells : false;\r\n    }\r\n    /**\r\n     * Add a merged cell to the container.\r\n     *\r\n     * @param {object} mergedCellInfo The merged cell information object. Has to contain `row`, `col`, `colspan` and `rowspan` properties.\r\n     * @returns {MergedCellCoords|boolean} Returns the new merged cell on success and `false` on failure.\r\n     */\r\n\r\n  }, {\r\n    key: \"add\",\r\n    value: function add(mergedCellInfo) {\r\n      var mergedCells = this.mergedCells;\r\n      var row = mergedCellInfo.row;\r\n      var column = mergedCellInfo.col;\r\n      var rowspan = mergedCellInfo.rowspan;\r\n      var colspan = mergedCellInfo.colspan;\r\n      var newMergedCell = new MergedCellCoords(row, column, rowspan, colspan);\r\n      var alreadyExists = this.get(row, column);\r\n      var isOverlapping = this.isOverlapping(newMergedCell);\r\n\r\n      if (!alreadyExists && !isOverlapping) {\r\n        if (this.hot) {\r\n          newMergedCell.normalize(this.hot);\r\n        }\r\n\r\n        mergedCells.push(newMergedCell);\r\n        return newMergedCell;\r\n      }\r\n\r\n      warn(MergedCellsCollection.IS_OVERLAPPING_WARNING(newMergedCell));\r\n      return false;\r\n    }\r\n    /**\r\n     * Remove a merged cell from the container. You can provide either the \"starting coordinates\"\r\n     * of a merged cell, or any coordinates from the body of the merged cell.\r\n     *\r\n     * @param {number} row Row index.\r\n     * @param {number} column Column index.\r\n     * @returns {MergedCellCoords|boolean} Returns the removed merged cell on success and `false` on failure.\r\n     */\r\n\r\n  }, {\r\n    key: \"remove\",\r\n    value: function remove(row, column) {\r\n      var mergedCells = this.mergedCells;\r\n      var wantedCollection = this.get(row, column);\r\n      var wantedCollectionIndex = wantedCollection ? this.mergedCells.indexOf(wantedCollection) : null;\r\n\r\n      if (wantedCollection && wantedCollectionIndex !== false) {\r\n        mergedCells.splice(wantedCollectionIndex, 1);\r\n        return wantedCollection;\r\n      }\r\n\r\n      return false;\r\n    }\r\n    /**\r\n     * Clear all the merged cells.\r\n     */\r\n\r\n  }, {\r\n    key: \"clear\",\r\n    value: function clear() {\r\n      var _this = this;\r\n\r\n      var mergedCells = this.mergedCells;\r\n      var mergedCellParentsToClear = [];\r\n      var hiddenCollectionElements = [];\r\n      arrayEach(mergedCells, function (mergedCell) {\r\n        var TD = _this.hot.getCell(mergedCell.row, mergedCell.col);\r\n\r\n        if (TD) {\r\n          mergedCellParentsToClear.push([TD, _this.get(mergedCell.row, mergedCell.col), mergedCell.row, mergedCell.col]);\r\n        }\r\n      });\r\n      this.mergedCells.length = 0;\r\n      arrayEach(mergedCellParentsToClear, function (mergedCell, i) {\r\n        rangeEach(0, mergedCell.rowspan - 1, function (j) {\r\n          rangeEach(0, mergedCell.colspan - 1, function (k) {\r\n            if (k !== 0 || j !== 0) {\r\n              var TD = _this.hot.getCell(mergedCell.row + j, mergedCell.col + k);\r\n\r\n              if (TD) {\r\n                hiddenCollectionElements.push([TD, null, null, null]);\r\n              }\r\n            }\r\n          });\r\n        });\r\n        mergedCellParentsToClear[i][1] = null;\r\n      });\r\n      arrayEach(mergedCellParentsToClear, function (mergedCellParents) {\r\n        applySpanProperties.apply(void 0, _toConsumableArray(mergedCellParents));\r\n      });\r\n      arrayEach(hiddenCollectionElements, function (hiddenCollectionElement) {\r\n        applySpanProperties.apply(void 0, _toConsumableArray(hiddenCollectionElement));\r\n      });\r\n    }\r\n    /**\r\n     * Check if the provided merged cell overlaps with the others in the container.\r\n     *\r\n     * @param {MergedCellCoords} mergedCell The merged cell to check against all others in the container.\r\n     * @returns {boolean} `true` if the provided merged cell overlaps with the others, `false` otherwise.\r\n     */\r\n\r\n  }, {\r\n    key: \"isOverlapping\",\r\n    value: function isOverlapping(mergedCell) {\r\n      var mergedCellRange = new CellRange(new CellCoords(0, 0), new CellCoords(mergedCell.row, mergedCell.col), new CellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1));\r\n      var result = false;\r\n      arrayEach(this.mergedCells, function (col) {\r\n        var currentRange = new CellRange(new CellCoords(0, 0), new CellCoords(col.row, col.col), new CellCoords(col.row + col.rowspan - 1, col.col + col.colspan - 1));\r\n\r\n        if (currentRange.overlaps(mergedCellRange)) {\r\n          result = true;\r\n          return false;\r\n        }\r\n\r\n        return true;\r\n      });\r\n      return result;\r\n    }\r\n    /**\r\n     * Check whether the provided row/col coordinates direct to a first not hidden cell within merge area.\r\n     *\r\n     * @param {number} row Visual row index.\r\n     * @param {number} column Visual column index.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isFirstRenderableMergedCell\",\r\n    value: function isFirstRenderableMergedCell(row, column) {\r\n      var mergeParent = this.get(row, column); // Return if row and column indexes are within merge area and if they are first rendered indexes within the area.\r\n\r\n      return mergeParent && this.hot.rowIndexMapper.getFirstNotHiddenIndex(mergeParent.row, 1) === row && this.hot.columnIndexMapper.getFirstNotHiddenIndex(mergeParent.col, 1) === column;\r\n    }\r\n    /**\r\n     * Get the first renderable coords of the merged cell at the provided coordinates.\r\n     *\r\n     * @param {number} row Visual row index.\r\n     * @param {number} column Visual column index.\r\n     * @returns {CellCoords} A `CellCoords` object with the coordinates to the first renderable cell within the\r\n     *                        merged cell.\r\n     */\r\n\r\n  }, {\r\n    key: \"getFirstRenderableCoords\",\r\n    value: function getFirstRenderableCoords(row, column) {\r\n      var mergeParent = this.get(row, column);\r\n\r\n      if (!mergeParent || this.isFirstRenderableMergedCell(row, column)) {\r\n        return new CellCoords(row, column);\r\n      }\r\n\r\n      var firstRenderableRow = this.hot.rowIndexMapper.getFirstNotHiddenIndex(mergeParent.row, 1);\r\n      var firstRenderableColumn = this.hot.columnIndexMapper.getFirstNotHiddenIndex(mergeParent.col, 1);\r\n      return new CellCoords(firstRenderableRow, firstRenderableColumn);\r\n    }\r\n    /**\r\n     * Shift the merged cell in the direction and by an offset defined in the arguments.\r\n     *\r\n     * @param {string} direction `right`, `left`, `up` or `down`.\r\n     * @param {number} index Index where the change, which caused the shifting took place.\r\n     * @param {number} count Number of rows/columns added/removed in the preceding action.\r\n     */\r\n\r\n  }, {\r\n    key: \"shiftCollections\",\r\n    value: function shiftCollections(direction, index, count) {\r\n      var _this2 = this;\r\n\r\n      var shiftVector = [0, 0];\r\n\r\n      switch (direction) {\r\n        case 'right':\r\n          shiftVector[0] += count;\r\n          break;\r\n\r\n        case 'left':\r\n          shiftVector[0] -= count;\r\n          break;\r\n\r\n        case 'down':\r\n          shiftVector[1] += count;\r\n          break;\r\n\r\n        case 'up':\r\n          shiftVector[1] -= count;\r\n          break;\r\n\r\n        default:\r\n      }\r\n\r\n      arrayEach(this.mergedCells, function (currentMerge) {\r\n        currentMerge.shift(shiftVector, index);\r\n      });\r\n      rangeEachReverse(this.mergedCells.length - 1, 0, function (i) {\r\n        var currentMerge = _this2.mergedCells[i];\r\n\r\n        if (currentMerge && currentMerge.removed) {\r\n          _this2.mergedCells.splice(_this2.mergedCells.indexOf(currentMerge), 1);\r\n        }\r\n      });\r\n    }\r\n  }], [{\r\n    key: \"IS_OVERLAPPING_WARNING\",\r\n    value: function IS_OVERLAPPING_WARNING(newMergedCell) {\r\n      return toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"], overlaps \\n      with the other declared merged cell. The overlapping merged cell was not added to the table, please \\n      fix your setup.\"], [\"The merged cell declared at [\", \", \", \"], overlaps\\\\x20\\n      with the other declared merged cell. The overlapping merged cell was not added to the table, please\\\\x20\\n      fix your setup.\"])), newMergedCell.row, newMergedCell.col);\r\n    }\r\n  }]);\r\n\r\n  return MergedCellsCollection;\r\n}();\r\n\r\nexport default MergedCellsCollection;"]},"metadata":{},"sourceType":"module"}