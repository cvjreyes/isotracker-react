{"ast":null,"code":"import { htmlRenderer } from \"../htmlRenderer/index.mjs\";\nimport { textRenderer } from \"../textRenderer/index.mjs\";\nimport { CellCoords } from \"../../3rdparty/walkontable/src/index.mjs\";\nimport EventManager from \"../../eventManager.mjs\";\nimport { addClass, hasClass } from \"../../helpers/dom/element.mjs\";\nexport var RENDERER_TYPE = 'autocomplete';\n/**\r\n * Autocomplete renderer.\r\n *\r\n * @private\r\n * @param {Core} instance The Handsontable instance.\r\n * @param {HTMLTableCellElement} TD The rendered cell element.\r\n * @param {number} row The visual row index.\r\n * @param {number} col The visual column index.\r\n * @param {number|string} prop The column property (passed when datasource is an array of objects).\r\n * @param {*} value The rendered value.\r\n * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).\r\n */\n\nexport function autocompleteRenderer(instance, TD, row, col, prop, value, cellProperties) {\n  var rootDocument = instance.rootDocument;\n  var rendererFunc = cellProperties.allowHtml ? htmlRenderer : textRenderer;\n  var ARROW = rootDocument.createElement('DIV');\n  ARROW.className = 'htAutocompleteArrow';\n  ARROW.appendChild(rootDocument.createTextNode(String.fromCharCode(9660)));\n  rendererFunc.apply(this, [instance, TD, row, col, prop, value, cellProperties]);\n\n  if (!TD.firstChild) {\n    // http://jsperf.com/empty-node-if-needed\n    // otherwise empty fields appear borderless in demo/renderers.html (IE)\n    TD.appendChild(rootDocument.createTextNode(String.fromCharCode(160))); // workaround for https://github.com/handsontable/handsontable/issues/1946\n    // this is faster than innerHTML. See: https://github.com/handsontable/handsontable/wiki/JavaScript-&-DOM-performance-tips\n  }\n\n  TD.insertBefore(ARROW, TD.firstChild);\n  addClass(TD, 'htAutocomplete');\n\n  if (!instance.acArrowListener) {\n    var eventManager = new EventManager(instance); // not very elegant but easy and fast\n\n    instance.acArrowListener = function (event) {\n      if (hasClass(event.target, 'htAutocompleteArrow')) {\n        instance.view.wt.getSetting('onCellDblClick', null, new CellCoords(row, col), TD);\n      }\n    };\n\n    eventManager.addEventListener(instance.rootElement, 'mousedown', instance.acArrowListener); // We need to unbind the listener after the table has been destroyed\n\n    instance.addHookOnce('afterDestroy', function () {\n      eventManager.destroy();\n    });\n  }\n}\nautocompleteRenderer.RENDERER_TYPE = RENDERER_TYPE;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/renderers/autocompleteRenderer/autocompleteRenderer.mjs"],"names":["htmlRenderer","textRenderer","CellCoords","EventManager","addClass","hasClass","RENDERER_TYPE","autocompleteRenderer","instance","TD","row","col","prop","value","cellProperties","rootDocument","rendererFunc","allowHtml","ARROW","createElement","className","appendChild","createTextNode","String","fromCharCode","apply","firstChild","insertBefore","acArrowListener","eventManager","event","target","view","wt","getSetting","addEventListener","rootElement","addHookOnce","destroy"],"mappings":"AAAA,SAASA,YAAT,QAA6B,2BAA7B;AACA,SAASC,YAAT,QAA6B,2BAA7B;AACA,SAASC,UAAT,QAA2B,0CAA3B;AACA,OAAOC,YAAP,MAAyB,wBAAzB;AACA,SAASC,QAAT,EAAmBC,QAAnB,QAAmC,+BAAnC;AACA,OAAO,IAAIC,aAAa,GAAG,cAApB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,oBAAT,CAA8BC,QAA9B,EAAwCC,EAAxC,EAA4CC,GAA5C,EAAiDC,GAAjD,EAAsDC,IAAtD,EAA4DC,KAA5D,EAAmEC,cAAnE,EAAmF;AACxF,MAAIC,YAAY,GAAGP,QAAQ,CAACO,YAA5B;AACA,MAAIC,YAAY,GAAGF,cAAc,CAACG,SAAf,GAA2BjB,YAA3B,GAA0CC,YAA7D;AACA,MAAIiB,KAAK,GAAGH,YAAY,CAACI,aAAb,CAA2B,KAA3B,CAAZ;AACAD,EAAAA,KAAK,CAACE,SAAN,GAAkB,qBAAlB;AACAF,EAAAA,KAAK,CAACG,WAAN,CAAkBN,YAAY,CAACO,cAAb,CAA4BC,MAAM,CAACC,YAAP,CAAoB,IAApB,CAA5B,CAAlB;AACAR,EAAAA,YAAY,CAACS,KAAb,CAAmB,IAAnB,EAAyB,CAACjB,QAAD,EAAWC,EAAX,EAAeC,GAAf,EAAoBC,GAApB,EAAyBC,IAAzB,EAA+BC,KAA/B,EAAsCC,cAAtC,CAAzB;;AAEA,MAAI,CAACL,EAAE,CAACiB,UAAR,EAAoB;AAClB;AACA;AACAjB,IAAAA,EAAE,CAACY,WAAH,CAAeN,YAAY,CAACO,cAAb,CAA4BC,MAAM,CAACC,YAAP,CAAoB,GAApB,CAA5B,CAAf,EAHkB,CAGqD;AACvE;AACD;;AAEDf,EAAAA,EAAE,CAACkB,YAAH,CAAgBT,KAAhB,EAAuBT,EAAE,CAACiB,UAA1B;AACAtB,EAAAA,QAAQ,CAACK,EAAD,EAAK,gBAAL,CAAR;;AAEA,MAAI,CAACD,QAAQ,CAACoB,eAAd,EAA+B;AAC7B,QAAIC,YAAY,GAAG,IAAI1B,YAAJ,CAAiBK,QAAjB,CAAnB,CAD6B,CACkB;;AAE/CA,IAAAA,QAAQ,CAACoB,eAAT,GAA2B,UAAUE,KAAV,EAAiB;AAC1C,UAAIzB,QAAQ,CAACyB,KAAK,CAACC,MAAP,EAAe,qBAAf,CAAZ,EAAmD;AACjDvB,QAAAA,QAAQ,CAACwB,IAAT,CAAcC,EAAd,CAAiBC,UAAjB,CAA4B,gBAA5B,EAA8C,IAA9C,EAAoD,IAAIhC,UAAJ,CAAeQ,GAAf,EAAoBC,GAApB,CAApD,EAA8EF,EAA9E;AACD;AACF,KAJD;;AAMAoB,IAAAA,YAAY,CAACM,gBAAb,CAA8B3B,QAAQ,CAAC4B,WAAvC,EAAoD,WAApD,EAAiE5B,QAAQ,CAACoB,eAA1E,EAT6B,CAS+D;;AAE5FpB,IAAAA,QAAQ,CAAC6B,WAAT,CAAqB,cAArB,EAAqC,YAAY;AAC/CR,MAAAA,YAAY,CAACS,OAAb;AACD,KAFD;AAGD;AACF;AACD/B,oBAAoB,CAACD,aAArB,GAAqCA,aAArC","sourcesContent":["import { htmlRenderer } from \"../htmlRenderer/index.mjs\";\r\nimport { textRenderer } from \"../textRenderer/index.mjs\";\r\nimport { CellCoords } from \"../../3rdparty/walkontable/src/index.mjs\";\r\nimport EventManager from \"../../eventManager.mjs\";\r\nimport { addClass, hasClass } from \"../../helpers/dom/element.mjs\";\r\nexport var RENDERER_TYPE = 'autocomplete';\r\n/**\r\n * Autocomplete renderer.\r\n *\r\n * @private\r\n * @param {Core} instance The Handsontable instance.\r\n * @param {HTMLTableCellElement} TD The rendered cell element.\r\n * @param {number} row The visual row index.\r\n * @param {number} col The visual column index.\r\n * @param {number|string} prop The column property (passed when datasource is an array of objects).\r\n * @param {*} value The rendered value.\r\n * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).\r\n */\r\n\r\nexport function autocompleteRenderer(instance, TD, row, col, prop, value, cellProperties) {\r\n  var rootDocument = instance.rootDocument;\r\n  var rendererFunc = cellProperties.allowHtml ? htmlRenderer : textRenderer;\r\n  var ARROW = rootDocument.createElement('DIV');\r\n  ARROW.className = 'htAutocompleteArrow';\r\n  ARROW.appendChild(rootDocument.createTextNode(String.fromCharCode(9660)));\r\n  rendererFunc.apply(this, [instance, TD, row, col, prop, value, cellProperties]);\r\n\r\n  if (!TD.firstChild) {\r\n    // http://jsperf.com/empty-node-if-needed\r\n    // otherwise empty fields appear borderless in demo/renderers.html (IE)\r\n    TD.appendChild(rootDocument.createTextNode(String.fromCharCode(160))); // workaround for https://github.com/handsontable/handsontable/issues/1946\r\n    // this is faster than innerHTML. See: https://github.com/handsontable/handsontable/wiki/JavaScript-&-DOM-performance-tips\r\n  }\r\n\r\n  TD.insertBefore(ARROW, TD.firstChild);\r\n  addClass(TD, 'htAutocomplete');\r\n\r\n  if (!instance.acArrowListener) {\r\n    var eventManager = new EventManager(instance); // not very elegant but easy and fast\r\n\r\n    instance.acArrowListener = function (event) {\r\n      if (hasClass(event.target, 'htAutocompleteArrow')) {\r\n        instance.view.wt.getSetting('onCellDblClick', null, new CellCoords(row, col), TD);\r\n      }\r\n    };\r\n\r\n    eventManager.addEventListener(instance.rootElement, 'mousedown', instance.acArrowListener); // We need to unbind the listener after the table has been destroyed\r\n\r\n    instance.addHookOnce('afterDestroy', function () {\r\n      eventManager.destroy();\r\n    });\r\n  }\r\n}\r\nautocompleteRenderer.RENDERER_TYPE = RENDERER_TYPE;"]},"metadata":{},"sourceType":"module"}