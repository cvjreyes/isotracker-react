{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { CellCoords } from \"./../3rdparty/walkontable/src/index.mjs\";\nimport { mixin } from \"../helpers/object.mjs\";\nimport localHooks from \"./../mixins/localHooks.mjs\";\n/**\r\n * The Transformation class implements algorithms for transforming coordinates based on current settings\r\n * passed to the Handsontable.\r\n *\r\n * Transformation is always applied relative to the current selection.\r\n *\r\n * @class Transformation\r\n * @util\r\n */\n\nvar Transformation = /*#__PURE__*/function () {\n  function Transformation(range, options) {\n    _classCallCheck(this, Transformation);\n    /**\r\n     * Instance of the SelectionRange, holder for visual coordinates applied to the table.\r\n     *\r\n     * @type {SelectionRange}\r\n     */\n\n\n    this.range = range;\n    /**\r\n     * Additional options which define the state of the settings which can infer transformation and\r\n     * give the possibility to translate indexes.\r\n     *\r\n     * @type {object}\r\n     */\n\n    this.options = options;\n  }\n  /**\r\n   * Selects cell relative to current cell (if possible).\r\n   *\r\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\r\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\r\n   * @param {boolean} force If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\r\n   *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\r\n   * @returns {CellCoords} Visual coordinates after transformation.\r\n   */\n\n\n  _createClass(Transformation, [{\n    key: \"transformStart\",\n    value: function transformStart(rowDelta, colDelta, force) {\n      var delta = new CellCoords(rowDelta, colDelta);\n      var highlightCoords = this.range.current().highlight;\n\n      var _this$options$visualT = this.options.visualToRenderableCoords(highlightCoords),\n          renderableRow = _this$options$visualT.row,\n          renderableColumn = _this$options$visualT.col;\n\n      var visualCoords = highlightCoords;\n      var rowTransformDir = 0;\n      var colTransformDir = 0;\n      this.runLocalHooks('beforeTransformStart', delta);\n\n      if (renderableRow !== null && renderableColumn !== null) {\n        var totalRows = this.options.countRows();\n        var totalCols = this.options.countCols();\n        var fixedRowsBottom = this.options.fixedRowsBottom();\n        var minSpareRows = this.options.minSpareRows();\n        var minSpareCols = this.options.minSpareCols();\n        var autoWrapRow = this.options.autoWrapRow();\n        var autoWrapCol = this.options.autoWrapCol();\n\n        if (renderableRow + rowDelta > totalRows - 1) {\n          if (force && minSpareRows > 0 && !(fixedRowsBottom && renderableRow >= totalRows - fixedRowsBottom - 1)) {\n            this.runLocalHooks('insertRowRequire', totalRows);\n            totalRows = this.options.countRows();\n          } else if (autoWrapCol) {\n            delta.row = 1 - totalRows;\n            delta.col = renderableColumn + delta.col === totalCols - 1 ? 1 - totalCols : 1;\n          }\n        } else if (autoWrapCol && renderableRow + delta.row < 0 && renderableColumn + delta.col >= 0) {\n          delta.row = totalRows - 1;\n          delta.col = renderableColumn + delta.col === 0 ? totalCols - 1 : -1;\n        }\n\n        if (renderableColumn + delta.col > totalCols - 1) {\n          if (force && minSpareCols > 0) {\n            this.runLocalHooks('insertColRequire', totalCols);\n            totalCols = this.options.countCols();\n          } else if (autoWrapRow) {\n            delta.row = renderableRow + delta.row === totalRows - 1 ? 1 - totalRows : 1;\n            delta.col = 1 - totalCols;\n          }\n        } else if (autoWrapRow && renderableColumn + delta.col < 0 && renderableRow + delta.row >= 0) {\n          delta.row = renderableRow + delta.row === 0 ? totalRows - 1 : -1;\n          delta.col = totalCols - 1;\n        }\n\n        var coords = new CellCoords(renderableRow + delta.row, renderableColumn + delta.col);\n        rowTransformDir = 0;\n        colTransformDir = 0;\n\n        if (coords.row < 0) {\n          rowTransformDir = -1;\n          coords.row = 0;\n        } else if (coords.row > 0 && coords.row >= totalRows) {\n          rowTransformDir = 1;\n          coords.row = totalRows - 1;\n        }\n\n        if (coords.col < 0) {\n          colTransformDir = -1;\n          coords.col = 0;\n        } else if (coords.col > 0 && coords.col >= totalCols) {\n          colTransformDir = 1;\n          coords.col = totalCols - 1;\n        }\n\n        visualCoords = this.options.renderableToVisualCoords(coords);\n      }\n\n      this.runLocalHooks('afterTransformStart', visualCoords, rowTransformDir, colTransformDir);\n      return visualCoords;\n    }\n    /**\r\n     * Sets selection end cell relative to current selection end cell (if possible).\r\n     *\r\n     * @param {number} rowDelta Rows number to move, value can be passed as negative number.\r\n     * @param {number} colDelta Columns number to move, value can be passed as negative number.\r\n     * @returns {CellCoords} Visual coordinates after transformation.\r\n     */\n\n  }, {\n    key: \"transformEnd\",\n    value: function transformEnd(rowDelta, colDelta) {\n      var delta = new CellCoords(rowDelta, colDelta);\n      var cellRange = this.range.current();\n      var visualCoords = cellRange.to;\n      var rowTransformDir = 0;\n      var colTransformDir = 0;\n      this.runLocalHooks('beforeTransformEnd', delta);\n\n      var _this$options$visualT2 = this.options.visualToRenderableCoords(cellRange.highlight),\n          rowHighlight = _this$options$visualT2.row,\n          colHighlight = _this$options$visualT2.col; // We have highlight (start point for the selection).\n\n\n      if (rowHighlight !== null && colHighlight !== null) {\n        var totalRows = this.options.countRows();\n        var totalCols = this.options.countCols();\n\n        var _this$options$visualT3 = this.options.visualToRenderableCoords(cellRange.to),\n            rowTo = _this$options$visualT3.row,\n            colTo = _this$options$visualT3.col;\n\n        var coords = new CellCoords(rowTo + delta.row, colTo + delta.col);\n        rowTransformDir = 0;\n        colTransformDir = 0;\n\n        if (coords.row < 0) {\n          rowTransformDir = -1;\n          coords.row = 0;\n        } else if (coords.row > 0 && coords.row >= totalRows) {\n          rowTransformDir = 1;\n          coords.row = totalRows - 1;\n        }\n\n        if (coords.col < 0) {\n          colTransformDir = -1;\n          coords.col = 0;\n        } else if (coords.col > 0 && coords.col >= totalCols) {\n          colTransformDir = 1;\n          coords.col = totalCols - 1;\n        }\n\n        visualCoords = this.options.renderableToVisualCoords(coords);\n      }\n\n      this.runLocalHooks('afterTransformEnd', visualCoords, rowTransformDir, colTransformDir);\n      return visualCoords;\n    }\n  }]);\n\n  return Transformation;\n}();\n\nmixin(Transformation, localHooks);\nexport default Transformation;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/selection/transformation.mjs"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","CellCoords","mixin","localHooks","Transformation","range","options","value","transformStart","rowDelta","colDelta","force","delta","highlightCoords","current","highlight","_this$options$visualT","visualToRenderableCoords","renderableRow","row","renderableColumn","col","visualCoords","rowTransformDir","colTransformDir","runLocalHooks","totalRows","countRows","totalCols","countCols","fixedRowsBottom","minSpareRows","minSpareCols","autoWrapRow","autoWrapCol","coords","renderableToVisualCoords","transformEnd","cellRange","to","_this$options$visualT2","rowHighlight","colHighlight","_this$options$visualT3","rowTo","colTo"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport { CellCoords } from \"./../3rdparty/walkontable/src/index.mjs\";\r\nimport { mixin } from \"../helpers/object.mjs\";\r\nimport localHooks from \"./../mixins/localHooks.mjs\";\r\n/**\r\n * The Transformation class implements algorithms for transforming coordinates based on current settings\r\n * passed to the Handsontable.\r\n *\r\n * Transformation is always applied relative to the current selection.\r\n *\r\n * @class Transformation\r\n * @util\r\n */\r\n\r\nvar Transformation = /*#__PURE__*/function () {\r\n  function Transformation(range, options) {\r\n    _classCallCheck(this, Transformation);\r\n\r\n    /**\r\n     * Instance of the SelectionRange, holder for visual coordinates applied to the table.\r\n     *\r\n     * @type {SelectionRange}\r\n     */\r\n    this.range = range;\r\n    /**\r\n     * Additional options which define the state of the settings which can infer transformation and\r\n     * give the possibility to translate indexes.\r\n     *\r\n     * @type {object}\r\n     */\r\n\r\n    this.options = options;\r\n  }\r\n  /**\r\n   * Selects cell relative to current cell (if possible).\r\n   *\r\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\r\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\r\n   * @param {boolean} force If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\r\n   *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\r\n   * @returns {CellCoords} Visual coordinates after transformation.\r\n   */\r\n\r\n\r\n  _createClass(Transformation, [{\r\n    key: \"transformStart\",\r\n    value: function transformStart(rowDelta, colDelta, force) {\r\n      var delta = new CellCoords(rowDelta, colDelta);\r\n      var highlightCoords = this.range.current().highlight;\r\n\r\n      var _this$options$visualT = this.options.visualToRenderableCoords(highlightCoords),\r\n          renderableRow = _this$options$visualT.row,\r\n          renderableColumn = _this$options$visualT.col;\r\n\r\n      var visualCoords = highlightCoords;\r\n      var rowTransformDir = 0;\r\n      var colTransformDir = 0;\r\n      this.runLocalHooks('beforeTransformStart', delta);\r\n\r\n      if (renderableRow !== null && renderableColumn !== null) {\r\n        var totalRows = this.options.countRows();\r\n        var totalCols = this.options.countCols();\r\n        var fixedRowsBottom = this.options.fixedRowsBottom();\r\n        var minSpareRows = this.options.minSpareRows();\r\n        var minSpareCols = this.options.minSpareCols();\r\n        var autoWrapRow = this.options.autoWrapRow();\r\n        var autoWrapCol = this.options.autoWrapCol();\r\n\r\n        if (renderableRow + rowDelta > totalRows - 1) {\r\n          if (force && minSpareRows > 0 && !(fixedRowsBottom && renderableRow >= totalRows - fixedRowsBottom - 1)) {\r\n            this.runLocalHooks('insertRowRequire', totalRows);\r\n            totalRows = this.options.countRows();\r\n          } else if (autoWrapCol) {\r\n            delta.row = 1 - totalRows;\r\n            delta.col = renderableColumn + delta.col === totalCols - 1 ? 1 - totalCols : 1;\r\n          }\r\n        } else if (autoWrapCol && renderableRow + delta.row < 0 && renderableColumn + delta.col >= 0) {\r\n          delta.row = totalRows - 1;\r\n          delta.col = renderableColumn + delta.col === 0 ? totalCols - 1 : -1;\r\n        }\r\n\r\n        if (renderableColumn + delta.col > totalCols - 1) {\r\n          if (force && minSpareCols > 0) {\r\n            this.runLocalHooks('insertColRequire', totalCols);\r\n            totalCols = this.options.countCols();\r\n          } else if (autoWrapRow) {\r\n            delta.row = renderableRow + delta.row === totalRows - 1 ? 1 - totalRows : 1;\r\n            delta.col = 1 - totalCols;\r\n          }\r\n        } else if (autoWrapRow && renderableColumn + delta.col < 0 && renderableRow + delta.row >= 0) {\r\n          delta.row = renderableRow + delta.row === 0 ? totalRows - 1 : -1;\r\n          delta.col = totalCols - 1;\r\n        }\r\n\r\n        var coords = new CellCoords(renderableRow + delta.row, renderableColumn + delta.col);\r\n        rowTransformDir = 0;\r\n        colTransformDir = 0;\r\n\r\n        if (coords.row < 0) {\r\n          rowTransformDir = -1;\r\n          coords.row = 0;\r\n        } else if (coords.row > 0 && coords.row >= totalRows) {\r\n          rowTransformDir = 1;\r\n          coords.row = totalRows - 1;\r\n        }\r\n\r\n        if (coords.col < 0) {\r\n          colTransformDir = -1;\r\n          coords.col = 0;\r\n        } else if (coords.col > 0 && coords.col >= totalCols) {\r\n          colTransformDir = 1;\r\n          coords.col = totalCols - 1;\r\n        }\r\n\r\n        visualCoords = this.options.renderableToVisualCoords(coords);\r\n      }\r\n\r\n      this.runLocalHooks('afterTransformStart', visualCoords, rowTransformDir, colTransformDir);\r\n      return visualCoords;\r\n    }\r\n    /**\r\n     * Sets selection end cell relative to current selection end cell (if possible).\r\n     *\r\n     * @param {number} rowDelta Rows number to move, value can be passed as negative number.\r\n     * @param {number} colDelta Columns number to move, value can be passed as negative number.\r\n     * @returns {CellCoords} Visual coordinates after transformation.\r\n     */\r\n\r\n  }, {\r\n    key: \"transformEnd\",\r\n    value: function transformEnd(rowDelta, colDelta) {\r\n      var delta = new CellCoords(rowDelta, colDelta);\r\n      var cellRange = this.range.current();\r\n      var visualCoords = cellRange.to;\r\n      var rowTransformDir = 0;\r\n      var colTransformDir = 0;\r\n      this.runLocalHooks('beforeTransformEnd', delta);\r\n\r\n      var _this$options$visualT2 = this.options.visualToRenderableCoords(cellRange.highlight),\r\n          rowHighlight = _this$options$visualT2.row,\r\n          colHighlight = _this$options$visualT2.col; // We have highlight (start point for the selection).\r\n\r\n\r\n      if (rowHighlight !== null && colHighlight !== null) {\r\n        var totalRows = this.options.countRows();\r\n        var totalCols = this.options.countCols();\r\n\r\n        var _this$options$visualT3 = this.options.visualToRenderableCoords(cellRange.to),\r\n            rowTo = _this$options$visualT3.row,\r\n            colTo = _this$options$visualT3.col;\r\n\r\n        var coords = new CellCoords(rowTo + delta.row, colTo + delta.col);\r\n        rowTransformDir = 0;\r\n        colTransformDir = 0;\r\n\r\n        if (coords.row < 0) {\r\n          rowTransformDir = -1;\r\n          coords.row = 0;\r\n        } else if (coords.row > 0 && coords.row >= totalRows) {\r\n          rowTransformDir = 1;\r\n          coords.row = totalRows - 1;\r\n        }\r\n\r\n        if (coords.col < 0) {\r\n          colTransformDir = -1;\r\n          coords.col = 0;\r\n        } else if (coords.col > 0 && coords.col >= totalCols) {\r\n          colTransformDir = 1;\r\n          coords.col = totalCols - 1;\r\n        }\r\n\r\n        visualCoords = this.options.renderableToVisualCoords(coords);\r\n      }\r\n\r\n      this.runLocalHooks('afterTransformEnd', visualCoords, rowTransformDir, colTransformDir);\r\n      return visualCoords;\r\n    }\r\n  }]);\r\n\r\n  return Transformation;\r\n}();\r\n\r\nmixin(Transformation, localHooks);\r\nexport default Transformation;"]},"metadata":{},"sourceType":"module"}