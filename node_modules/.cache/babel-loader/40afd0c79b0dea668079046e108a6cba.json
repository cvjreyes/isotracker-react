{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\n/**\r\n * Class used to make all endpoint-related operations.\r\n *\r\n * @class Endpoints\r\n * @plugin ColumnSummary\r\n */\n\nvar Endpoints = /*#__PURE__*/function () {\n  function Endpoints(plugin, settings) {\n    _classCallCheck(this, Endpoints);\n    /**\r\n     * The main plugin instance.\r\n     */\n\n\n    this.plugin = plugin;\n    /**\r\n     * Handsontable instance.\r\n     *\r\n     * @type {object}\r\n     */\n\n    this.hot = this.plugin.hot;\n    /**\r\n     * Array of declared plugin endpoints (calculation destination points).\r\n     *\r\n     * @type {Array}\r\n     * @default {Array} Empty array.\r\n     */\n\n    this.endpoints = [];\n    /**\r\n     * The plugin settings, taken from Handsontable configuration.\r\n     *\r\n     * @type {object|Function}\r\n     * @default null\r\n     */\n\n    this.settings = settings;\n    /**\r\n     * Settings type. Can be either 'array' or 'function.\r\n     *\r\n     * @type {string}\r\n     * @default {'array'}\r\n     */\n\n    this.settingsType = 'array';\n    /**\r\n     * The current endpoint (calculation destination point) in question.\r\n     *\r\n     * @type {object}\r\n     * @default null\r\n     */\n\n    this.currentEndpoint = null;\n    /**\r\n     * Array containing a list of changes to be applied.\r\n     *\r\n     * @private\r\n     * @type {Array}\r\n     * @default {[]}\r\n     */\n\n    this.cellsToSetCache = [];\n  }\n  /**\r\n   * Get a single endpoint object.\r\n   *\r\n   * @param {number} index Index of the endpoint.\r\n   * @returns {object}\r\n   */\n\n\n  _createClass(Endpoints, [{\n    key: \"getEndpoint\",\n    value: function getEndpoint(index) {\n      if (this.settingsType === 'function') {\n        return this.fillMissingEndpointData(this.settings)[index];\n      }\n\n      return this.endpoints[index];\n    }\n    /**\r\n     * Get an array with all the endpoints.\r\n     *\r\n     * @returns {Array}\r\n     */\n\n  }, {\n    key: \"getAllEndpoints\",\n    value: function getAllEndpoints() {\n      if (this.settingsType === 'function') {\n        return this.fillMissingEndpointData(this.settings);\n      }\n\n      return this.endpoints;\n    }\n    /**\r\n     * Used to fill the blanks in the endpoint data provided by a settings function.\r\n     *\r\n     * @private\r\n     * @param {Function} func Function provided in the HOT settings.\r\n     * @returns {Array} An array of endpoints.\r\n     */\n\n  }, {\n    key: \"fillMissingEndpointData\",\n    value: function fillMissingEndpointData(func) {\n      return this.parseSettings(func.call(this));\n    }\n    /**\r\n     * Parse plugin's settings.\r\n     *\r\n     * @param {Array} settings The settings array.\r\n     * @returns {object[]}\r\n     */\n\n  }, {\n    key: \"parseSettings\",\n    value: function parseSettings(settings) {\n      var _this = this;\n\n      var endpointsArray = [];\n      var settingsArray = settings;\n\n      if (!settingsArray && typeof this.settings === 'function') {\n        this.settingsType = 'function';\n        return;\n      }\n\n      if (!settingsArray) {\n        settingsArray = this.settings;\n      }\n\n      arrayEach(settingsArray, function (val) {\n        var newEndpoint = {};\n\n        _this.assignSetting(val, newEndpoint, 'ranges', [[0, _this.hot.countRows() - 1]]);\n\n        _this.assignSetting(val, newEndpoint, 'reversedRowCoords', false);\n\n        _this.assignSetting(val, newEndpoint, 'destinationRow', new Error(\"\\n        You must provide a destination row for the Column Summary plugin in order to work properly!\\n      \"));\n\n        _this.assignSetting(val, newEndpoint, 'destinationColumn', new Error(\"\\n        You must provide a destination column for the Column Summary plugin in order to work properly!\\n      \"));\n\n        _this.assignSetting(val, newEndpoint, 'sourceColumn', val.destinationColumn);\n\n        _this.assignSetting(val, newEndpoint, 'type', 'sum');\n\n        _this.assignSetting(val, newEndpoint, 'forceNumeric', false);\n\n        _this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\n\n        _this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\n\n        _this.assignSetting(val, newEndpoint, 'customFunction', null);\n\n        _this.assignSetting(val, newEndpoint, 'readOnly', true);\n\n        _this.assignSetting(val, newEndpoint, 'roundFloat', false);\n\n        endpointsArray.push(newEndpoint);\n      });\n      return endpointsArray;\n    }\n    /**\r\n     * Setter for the internal setting objects.\r\n     *\r\n     * @param {object} settings Object with the settings.\r\n     * @param {object} endpoint Contains information about the endpoint for the the calculation.\r\n     * @param {string} name Settings name.\r\n     * @param {object} defaultValue Default value for the settings.\r\n     */\n\n  }, {\n    key: \"assignSetting\",\n    value: function assignSetting(settings, endpoint, name, defaultValue) {\n      if (name === 'ranges' && settings[name] === void 0) {\n        endpoint[name] = defaultValue;\n        return;\n      } else if (name === 'ranges' && settings[name].length === 0) {\n        return;\n      }\n\n      if (settings[name] === void 0) {\n        if (defaultValue instanceof Error) {\n          throw defaultValue;\n        }\n\n        endpoint[name] = defaultValue;\n      } else {\n        /* eslint-disable no-lonely-if */\n        if (name === 'destinationRow' && endpoint.reversedRowCoords) {\n          endpoint[name] = this.hot.countRows() - settings[name] - 1;\n        } else {\n          endpoint[name] = settings[name];\n        }\n      }\n    }\n    /**\r\n     * Resets the endpoint setup before the structure alteration (like inserting or removing rows/columns). Used for settings provided as a function.\r\n     *\r\n     * @private\r\n     * @param {string} action Type of the action performed.\r\n     * @param {number} index Row/column index.\r\n     * @param {number} number Number of rows/columns added/removed.\r\n     */\n\n  }, {\n    key: \"resetSetupBeforeStructureAlteration\",\n    value: function resetSetupBeforeStructureAlteration(action, index, number) {\n      if (this.settingsType !== 'function') {\n        return;\n      }\n\n      var type = action.indexOf('row') > -1 ? 'row' : 'col';\n      var endpoints = this.getAllEndpoints();\n      arrayEach(endpoints, function (val) {\n        if (type === 'row' && val.destinationRow >= index) {\n          if (action === 'insert_row') {\n            val.alterRowOffset = number;\n          } else if (action === 'remove_row') {\n            val.alterRowOffset = -1 * number;\n          }\n        }\n\n        if (type === 'col' && val.destinationColumn >= index) {\n          if (action === 'insert_col') {\n            val.alterColumnOffset = number;\n          } else if (action === 'remove_col') {\n            val.alterColumnOffset = -1 * number;\n          }\n        }\n      });\n      this.resetAllEndpoints(endpoints, false);\n    }\n    /**\r\n     * AfterCreateRow/afterCreateRow/afterRemoveRow/afterRemoveCol hook callback. Reset and reenables the summary functionality\r\n     * after changing the table structure.\r\n     *\r\n     * @private\r\n     * @param {string} action Type of the action performed.\r\n     * @param {number} index Row/column index.\r\n     * @param {number} number Number of rows/columns added/removed.\r\n     * @param {Array} [logicRows] Array of the logical indexes.\r\n     * @param {string} [source] Source of change.\r\n     * @param {boolean} [forceRefresh] `true` of the endpoints should refresh after completing the function.\r\n     */\n\n  }, {\n    key: \"resetSetupAfterStructureAlteration\",\n    value: function resetSetupAfterStructureAlteration(action, index, number, logicRows, source) {\n      var _this2 = this;\n\n      var forceRefresh = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n      if (this.settingsType === 'function') {\n        // We need to run it on a next avaiable hook, because the TrimRows' `afterCreateRow` hook triggers after this one,\n        // and it needs to be run to properly calculate the endpoint value.\n        var beforeRenderCallback = function beforeRenderCallback() {\n          _this2.hot.removeHook('beforeRender', beforeRenderCallback);\n\n          return _this2.refreshAllEndpoints();\n        };\n\n        this.hot.addHookOnce('beforeRender', beforeRenderCallback);\n        return;\n      }\n\n      var type = action.indexOf('row') > -1 ? 'row' : 'col';\n      var multiplier = action.indexOf('remove') > -1 ? -1 : 1;\n      var endpoints = this.getAllEndpoints();\n      var rowMoving = action.indexOf('move_row') === 0;\n      var placeOfAlteration = index;\n      arrayEach(endpoints, function (val) {\n        if (type === 'row' && val.destinationRow >= placeOfAlteration) {\n          val.alterRowOffset = multiplier * number;\n        }\n\n        if (type === 'col' && val.destinationColumn >= placeOfAlteration) {\n          val.alterColumnOffset = multiplier * number;\n        }\n      });\n      this.resetAllEndpoints(endpoints, !rowMoving);\n\n      if (rowMoving) {\n        arrayEach(endpoints, function (endpoint) {\n          _this2.extendEndpointRanges(endpoint, placeOfAlteration, logicRows[0], logicRows.length);\n\n          _this2.recreatePhysicalRanges(endpoint);\n\n          _this2.clearOffsetInformation(endpoint);\n        });\n      } else {\n        arrayEach(endpoints, function (endpoint) {\n          _this2.shiftEndpointCoordinates(endpoint, placeOfAlteration);\n        });\n      }\n\n      if (forceRefresh) {\n        this.refreshAllEndpoints();\n      }\n    }\n    /**\r\n     * Clear the offset information from the endpoint object.\r\n     *\r\n     * @private\r\n     * @param {object} endpoint And endpoint object.\r\n     */\n\n  }, {\n    key: \"clearOffsetInformation\",\n    value: function clearOffsetInformation(endpoint) {\n      endpoint.alterRowOffset = void 0;\n      endpoint.alterColumnOffset = void 0;\n    }\n    /**\r\n     * Extend the row ranges for the provided endpoint.\r\n     *\r\n     * @private\r\n     * @param {object} endpoint The endpoint object.\r\n     * @param {number} placeOfAlteration Index of the row where the alteration takes place.\r\n     * @param {number} previousPosition Previous endpoint result position.\r\n     * @param {number} offset Offset generated by the alteration.\r\n     */\n\n  }, {\n    key: \"extendEndpointRanges\",\n    value: function extendEndpointRanges(endpoint, placeOfAlteration, previousPosition, offset) {\n      arrayEach(endpoint.ranges, function (range) {\n        // is a range, not a single row\n        if (range[1]) {\n          if (placeOfAlteration >= range[0] && placeOfAlteration <= range[1]) {\n            if (previousPosition > range[1]) {\n              range[1] += offset;\n            } else if (previousPosition < range[0]) {\n              range[0] -= offset;\n            }\n          } else if (previousPosition >= range[0] && previousPosition <= range[1]) {\n            range[1] -= offset;\n\n            if (placeOfAlteration <= range[0]) {\n              range[0] += 1;\n              range[1] += 1;\n            }\n          }\n        }\n      });\n    }\n    /**\r\n     * Recreate the physical ranges for the provided endpoint. Used (for example) when a row gets moved and extends an existing range.\r\n     *\r\n     * @private\r\n     * @param {object} endpoint An endpoint object.\r\n     */\n\n  }, {\n    key: \"recreatePhysicalRanges\",\n    value: function recreatePhysicalRanges(endpoint) {\n      var _this3 = this;\n\n      var ranges = endpoint.ranges;\n      var newRanges = [];\n      var allIndexes = [];\n      arrayEach(ranges, function (range) {\n        var newRange = [];\n\n        if (range[1]) {\n          for (var i = range[0]; i <= range[1]; i++) {\n            newRange.push(_this3.hot.toPhysicalRow(i));\n          }\n        } else {\n          newRange.push(_this3.hot.toPhysicalRow(range[0]));\n        }\n\n        allIndexes.push(newRange);\n      });\n      arrayEach(allIndexes, function (range) {\n        var newRange = [];\n        arrayEach(range, function (coord, index) {\n          if (index === 0) {\n            newRange.push(coord);\n          } else if (range[index] !== range[index - 1] + 1) {\n            newRange.push(range[index - 1]);\n            newRanges.push(newRange);\n            newRange = [];\n            newRange.push(coord);\n          }\n\n          if (index === range.length - 1) {\n            newRange.push(coord);\n            newRanges.push(newRange);\n          }\n        });\n      });\n      endpoint.ranges = newRanges;\n    }\n    /**\r\n     * Shifts the endpoint coordinates by the defined offset.\r\n     *\r\n     * @private\r\n     * @param {object} endpoint Endpoint object.\r\n     * @param {number} offsetStartIndex Index of the performed change (if the change is located after the endpoint, nothing about the endpoint has to be changed.\r\n     */\n\n  }, {\n    key: \"shiftEndpointCoordinates\",\n    value: function shiftEndpointCoordinates(endpoint, offsetStartIndex) {\n      if (endpoint.alterRowOffset && endpoint.alterRowOffset !== 0) {\n        endpoint.destinationRow += endpoint.alterRowOffset || 0;\n        arrayEach(endpoint.ranges, function (element) {\n          arrayEach(element, function (subElement, j) {\n            if (subElement >= offsetStartIndex) {\n              element[j] += endpoint.alterRowOffset || 0;\n            }\n          });\n        });\n      } else if (endpoint.alterColumnOffset && endpoint.alterColumnOffset !== 0) {\n        endpoint.destinationColumn += endpoint.alterColumnOffset || 0;\n        endpoint.sourceColumn += endpoint.alterColumnOffset || 0;\n      }\n    }\n    /**\r\n     * Resets (removes) the endpoints from the table.\r\n     *\r\n     * @param {Array} [endpoints] Array containing the endpoints.\r\n     * @param {boolean} [useOffset=true] Use the cell offset value.\r\n     */\n\n  }, {\n    key: \"resetAllEndpoints\",\n    value: function resetAllEndpoints() {\n      var _this4 = this;\n\n      var endpoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAllEndpoints();\n      var useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var anyEndpointOutOfRange = endpoints.some(function (endpoint) {\n        var alterRowOffset = endpoint.alterRowOffset || 0;\n        var alterColOffset = endpoint.alterColumnOffset || 0;\n\n        if (endpoint.destinationRow + alterRowOffset >= _this4.hot.countRows() || endpoint.destinationColumn + alterColOffset >= _this4.hot.countCols()) {\n          return true;\n        }\n\n        return false;\n      });\n\n      if (anyEndpointOutOfRange) {\n        return;\n      }\n\n      this.cellsToSetCache = [];\n      arrayEach(endpoints, function (endpoint) {\n        _this4.resetEndpointValue(endpoint, useOffset);\n      });\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\r\n     * Calculate and refresh all defined endpoints.\r\n     */\n\n  }, {\n    key: \"refreshAllEndpoints\",\n    value: function refreshAllEndpoints() {\n      var _this5 = this;\n\n      this.cellsToSetCache = [];\n      arrayEach(this.getAllEndpoints(), function (value) {\n        _this5.currentEndpoint = value;\n\n        _this5.plugin.calculate(value);\n\n        _this5.setEndpointValue(value, 'init');\n      });\n      this.currentEndpoint = null;\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\r\n     * Calculate and refresh endpoints only in the changed columns.\r\n     *\r\n     * @param {Array} changes Array of changes from the `afterChange` hook.\r\n     */\n\n  }, {\n    key: \"refreshChangedEndpoints\",\n    value: function refreshChangedEndpoints(changes) {\n      var _this6 = this;\n\n      var needToRefresh = [];\n      this.cellsToSetCache = [];\n      arrayEach(changes, function (value, key, changesObj) {\n        // if nothing changed, dont update anything\n        if (\"\".concat(value[2] || '') === \"\".concat(value[3])) {\n          return;\n        }\n\n        arrayEach(_this6.getAllEndpoints(), function (endpoint, j) {\n          if (_this6.hot.propToCol(changesObj[key][1]) === endpoint.sourceColumn && needToRefresh.indexOf(j) === -1) {\n            needToRefresh.push(j);\n          }\n        });\n      });\n      arrayEach(needToRefresh, function (value) {\n        _this6.refreshEndpoint(_this6.getEndpoint(value));\n      });\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\r\n     * Calculate and refresh a single endpoint.\r\n     *\r\n     * @param {object} endpoint Contains the endpoint information.\r\n     */\n\n  }, {\n    key: \"refreshEndpoint\",\n    value: function refreshEndpoint(endpoint) {\n      this.currentEndpoint = endpoint;\n      this.plugin.calculate(endpoint);\n      this.setEndpointValue(endpoint);\n      this.currentEndpoint = null;\n    }\n    /**\r\n     * Reset the endpoint value.\r\n     *\r\n     * @param {object} endpoint Contains the endpoint information.\r\n     * @param {boolean} [useOffset=true] Use the cell offset value.\r\n     */\n\n  }, {\n    key: \"resetEndpointValue\",\n    value: function resetEndpointValue(endpoint) {\n      var useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var alterRowOffset = endpoint.alterRowOffset || 0;\n      var alterColOffset = endpoint.alterColumnOffset || 0;\n      var _ref = [this.hot.toVisualRow(endpoint.destinationRow), this.hot.toVisualColumn(endpoint.destinationColumn)],\n          visualRowIndex = _ref[0],\n          visualColumnIndex = _ref[1];\n\n      if (visualColumnIndex !== null && visualRowIndex !== null) {\n        // Clear the meta on the \"old\" indexes\n        var cellMeta = this.hot.getCellMeta(visualRowIndex, visualColumnIndex);\n        cellMeta.readOnly = false;\n        cellMeta.className = '';\n      }\n\n      this.cellsToSetCache.push([this.hot.toVisualRow(endpoint.destinationRow + (useOffset ? alterRowOffset : 0)), this.hot.toVisualColumn(endpoint.destinationColumn + (useOffset ? alterColOffset : 0)), '']);\n    }\n    /**\r\n     * Set the endpoint value.\r\n     *\r\n     * @param {object} endpoint Contains the endpoint information.\r\n     * @param {string} [source] Source of the call information.\r\n     * @param {boolean} [render=false] `true` if it needs to render the table afterwards.\r\n     */\n\n  }, {\n    key: \"setEndpointValue\",\n    value: function setEndpointValue(endpoint, source) {\n      var render = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; // We'll need the reversed offset values, because cellMeta will be shifted AGAIN afterwards.\n\n      var reverseRowOffset = -1 * endpoint.alterRowOffset || 0;\n      var reverseColOffset = -1 * endpoint.alterColumnOffset || 0;\n      var visualEndpointRowIndex = this.hot.toVisualRow(endpoint.destinationRow);\n\n      if (endpoint.destinationRow >= this.hot.countRows() || endpoint.destinationColumn >= this.hot.countCols()) {\n        this.throwOutOfBoundsWarning();\n        return;\n      }\n\n      var destinationVisualRow = this.hot.toVisualRow(endpoint.destinationRow + reverseRowOffset);\n\n      if (destinationVisualRow !== null) {\n        var cellMeta = this.hot.getCellMeta(destinationVisualRow, endpoint.destinationColumn + reverseColOffset);\n\n        if (source === 'init' || cellMeta.readOnly !== endpoint.readOnly) {\n          cellMeta.readOnly = endpoint.readOnly;\n          cellMeta.className = 'columnSummaryResult';\n        }\n      }\n\n      if (endpoint.roundFloat && !isNaN(endpoint.result)) {\n        endpoint.result = endpoint.result.toFixed(endpoint.roundFloat);\n      }\n\n      if (render) {\n        this.hot.setDataAtCell(visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result, 'ColumnSummary.set');\n      } else {\n        this.cellsToSetCache.push([visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result]);\n      }\n\n      endpoint.alterRowOffset = void 0;\n      endpoint.alterColumnOffset = void 0;\n    }\n    /**\r\n     * Throw an error for the calculation range being out of boundaries.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: \"throwOutOfBoundsWarning\",\n    value: function throwOutOfBoundsWarning() {\n      warn('One of the Column Summary plugins\\' destination points you provided is beyond the table boundaries!');\n    }\n  }]);\n\n  return Endpoints;\n}();\n\nexport default Endpoints;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/plugins/columnSummary/endpoints.mjs"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","arrayEach","warn","Endpoints","plugin","settings","hot","endpoints","settingsType","currentEndpoint","cellsToSetCache","value","getEndpoint","index","fillMissingEndpointData","getAllEndpoints","func","parseSettings","call","_this","endpointsArray","settingsArray","val","newEndpoint","assignSetting","countRows","Error","destinationColumn","push","endpoint","name","defaultValue","reversedRowCoords","resetSetupBeforeStructureAlteration","action","number","type","indexOf","destinationRow","alterRowOffset","alterColumnOffset","resetAllEndpoints","resetSetupAfterStructureAlteration","logicRows","source","_this2","forceRefresh","arguments","undefined","beforeRenderCallback","removeHook","refreshAllEndpoints","addHookOnce","multiplier","rowMoving","placeOfAlteration","extendEndpointRanges","recreatePhysicalRanges","clearOffsetInformation","shiftEndpointCoordinates","previousPosition","offset","ranges","range","_this3","newRanges","allIndexes","newRange","toPhysicalRow","coord","offsetStartIndex","element","subElement","j","sourceColumn","_this4","useOffset","anyEndpointOutOfRange","some","alterColOffset","countCols","resetEndpointValue","setDataAtCell","_this5","calculate","setEndpointValue","refreshChangedEndpoints","changes","_this6","needToRefresh","changesObj","concat","propToCol","refreshEndpoint","_ref","toVisualRow","toVisualColumn","visualRowIndex","visualColumnIndex","cellMeta","getCellMeta","readOnly","className","render","reverseRowOffset","reverseColOffset","visualEndpointRowIndex","throwOutOfBoundsWarning","destinationVisualRow","roundFloat","isNaN","result","toFixed"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.index-of.js\";\r\nimport \"core-js/modules/es.number.to-fixed.js\";\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport { arrayEach } from \"../../helpers/array.mjs\";\r\nimport { warn } from \"../../helpers/console.mjs\";\r\n/**\r\n * Class used to make all endpoint-related operations.\r\n *\r\n * @class Endpoints\r\n * @plugin ColumnSummary\r\n */\r\n\r\nvar Endpoints = /*#__PURE__*/function () {\r\n  function Endpoints(plugin, settings) {\r\n    _classCallCheck(this, Endpoints);\r\n\r\n    /**\r\n     * The main plugin instance.\r\n     */\r\n    this.plugin = plugin;\r\n    /**\r\n     * Handsontable instance.\r\n     *\r\n     * @type {object}\r\n     */\r\n\r\n    this.hot = this.plugin.hot;\r\n    /**\r\n     * Array of declared plugin endpoints (calculation destination points).\r\n     *\r\n     * @type {Array}\r\n     * @default {Array} Empty array.\r\n     */\r\n\r\n    this.endpoints = [];\r\n    /**\r\n     * The plugin settings, taken from Handsontable configuration.\r\n     *\r\n     * @type {object|Function}\r\n     * @default null\r\n     */\r\n\r\n    this.settings = settings;\r\n    /**\r\n     * Settings type. Can be either 'array' or 'function.\r\n     *\r\n     * @type {string}\r\n     * @default {'array'}\r\n     */\r\n\r\n    this.settingsType = 'array';\r\n    /**\r\n     * The current endpoint (calculation destination point) in question.\r\n     *\r\n     * @type {object}\r\n     * @default null\r\n     */\r\n\r\n    this.currentEndpoint = null;\r\n    /**\r\n     * Array containing a list of changes to be applied.\r\n     *\r\n     * @private\r\n     * @type {Array}\r\n     * @default {[]}\r\n     */\r\n\r\n    this.cellsToSetCache = [];\r\n  }\r\n  /**\r\n   * Get a single endpoint object.\r\n   *\r\n   * @param {number} index Index of the endpoint.\r\n   * @returns {object}\r\n   */\r\n\r\n\r\n  _createClass(Endpoints, [{\r\n    key: \"getEndpoint\",\r\n    value: function getEndpoint(index) {\r\n      if (this.settingsType === 'function') {\r\n        return this.fillMissingEndpointData(this.settings)[index];\r\n      }\r\n\r\n      return this.endpoints[index];\r\n    }\r\n    /**\r\n     * Get an array with all the endpoints.\r\n     *\r\n     * @returns {Array}\r\n     */\r\n\r\n  }, {\r\n    key: \"getAllEndpoints\",\r\n    value: function getAllEndpoints() {\r\n      if (this.settingsType === 'function') {\r\n        return this.fillMissingEndpointData(this.settings);\r\n      }\r\n\r\n      return this.endpoints;\r\n    }\r\n    /**\r\n     * Used to fill the blanks in the endpoint data provided by a settings function.\r\n     *\r\n     * @private\r\n     * @param {Function} func Function provided in the HOT settings.\r\n     * @returns {Array} An array of endpoints.\r\n     */\r\n\r\n  }, {\r\n    key: \"fillMissingEndpointData\",\r\n    value: function fillMissingEndpointData(func) {\r\n      return this.parseSettings(func.call(this));\r\n    }\r\n    /**\r\n     * Parse plugin's settings.\r\n     *\r\n     * @param {Array} settings The settings array.\r\n     * @returns {object[]}\r\n     */\r\n\r\n  }, {\r\n    key: \"parseSettings\",\r\n    value: function parseSettings(settings) {\r\n      var _this = this;\r\n\r\n      var endpointsArray = [];\r\n      var settingsArray = settings;\r\n\r\n      if (!settingsArray && typeof this.settings === 'function') {\r\n        this.settingsType = 'function';\r\n        return;\r\n      }\r\n\r\n      if (!settingsArray) {\r\n        settingsArray = this.settings;\r\n      }\r\n\r\n      arrayEach(settingsArray, function (val) {\r\n        var newEndpoint = {};\r\n\r\n        _this.assignSetting(val, newEndpoint, 'ranges', [[0, _this.hot.countRows() - 1]]);\r\n\r\n        _this.assignSetting(val, newEndpoint, 'reversedRowCoords', false);\r\n\r\n        _this.assignSetting(val, newEndpoint, 'destinationRow', new Error(\"\\n        You must provide a destination row for the Column Summary plugin in order to work properly!\\n      \"));\r\n\r\n        _this.assignSetting(val, newEndpoint, 'destinationColumn', new Error(\"\\n        You must provide a destination column for the Column Summary plugin in order to work properly!\\n      \"));\r\n\r\n        _this.assignSetting(val, newEndpoint, 'sourceColumn', val.destinationColumn);\r\n\r\n        _this.assignSetting(val, newEndpoint, 'type', 'sum');\r\n\r\n        _this.assignSetting(val, newEndpoint, 'forceNumeric', false);\r\n\r\n        _this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\r\n\r\n        _this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\r\n\r\n        _this.assignSetting(val, newEndpoint, 'customFunction', null);\r\n\r\n        _this.assignSetting(val, newEndpoint, 'readOnly', true);\r\n\r\n        _this.assignSetting(val, newEndpoint, 'roundFloat', false);\r\n\r\n        endpointsArray.push(newEndpoint);\r\n      });\r\n      return endpointsArray;\r\n    }\r\n    /**\r\n     * Setter for the internal setting objects.\r\n     *\r\n     * @param {object} settings Object with the settings.\r\n     * @param {object} endpoint Contains information about the endpoint for the the calculation.\r\n     * @param {string} name Settings name.\r\n     * @param {object} defaultValue Default value for the settings.\r\n     */\r\n\r\n  }, {\r\n    key: \"assignSetting\",\r\n    value: function assignSetting(settings, endpoint, name, defaultValue) {\r\n      if (name === 'ranges' && settings[name] === void 0) {\r\n        endpoint[name] = defaultValue;\r\n        return;\r\n      } else if (name === 'ranges' && settings[name].length === 0) {\r\n        return;\r\n      }\r\n\r\n      if (settings[name] === void 0) {\r\n        if (defaultValue instanceof Error) {\r\n          throw defaultValue;\r\n        }\r\n\r\n        endpoint[name] = defaultValue;\r\n      } else {\r\n        /* eslint-disable no-lonely-if */\r\n        if (name === 'destinationRow' && endpoint.reversedRowCoords) {\r\n          endpoint[name] = this.hot.countRows() - settings[name] - 1;\r\n        } else {\r\n          endpoint[name] = settings[name];\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Resets the endpoint setup before the structure alteration (like inserting or removing rows/columns). Used for settings provided as a function.\r\n     *\r\n     * @private\r\n     * @param {string} action Type of the action performed.\r\n     * @param {number} index Row/column index.\r\n     * @param {number} number Number of rows/columns added/removed.\r\n     */\r\n\r\n  }, {\r\n    key: \"resetSetupBeforeStructureAlteration\",\r\n    value: function resetSetupBeforeStructureAlteration(action, index, number) {\r\n      if (this.settingsType !== 'function') {\r\n        return;\r\n      }\r\n\r\n      var type = action.indexOf('row') > -1 ? 'row' : 'col';\r\n      var endpoints = this.getAllEndpoints();\r\n      arrayEach(endpoints, function (val) {\r\n        if (type === 'row' && val.destinationRow >= index) {\r\n          if (action === 'insert_row') {\r\n            val.alterRowOffset = number;\r\n          } else if (action === 'remove_row') {\r\n            val.alterRowOffset = -1 * number;\r\n          }\r\n        }\r\n\r\n        if (type === 'col' && val.destinationColumn >= index) {\r\n          if (action === 'insert_col') {\r\n            val.alterColumnOffset = number;\r\n          } else if (action === 'remove_col') {\r\n            val.alterColumnOffset = -1 * number;\r\n          }\r\n        }\r\n      });\r\n      this.resetAllEndpoints(endpoints, false);\r\n    }\r\n    /**\r\n     * AfterCreateRow/afterCreateRow/afterRemoveRow/afterRemoveCol hook callback. Reset and reenables the summary functionality\r\n     * after changing the table structure.\r\n     *\r\n     * @private\r\n     * @param {string} action Type of the action performed.\r\n     * @param {number} index Row/column index.\r\n     * @param {number} number Number of rows/columns added/removed.\r\n     * @param {Array} [logicRows] Array of the logical indexes.\r\n     * @param {string} [source] Source of change.\r\n     * @param {boolean} [forceRefresh] `true` of the endpoints should refresh after completing the function.\r\n     */\r\n\r\n  }, {\r\n    key: \"resetSetupAfterStructureAlteration\",\r\n    value: function resetSetupAfterStructureAlteration(action, index, number, logicRows, source) {\r\n      var _this2 = this;\r\n\r\n      var forceRefresh = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\r\n\r\n      if (this.settingsType === 'function') {\r\n        // We need to run it on a next avaiable hook, because the TrimRows' `afterCreateRow` hook triggers after this one,\r\n        // and it needs to be run to properly calculate the endpoint value.\r\n        var beforeRenderCallback = function beforeRenderCallback() {\r\n          _this2.hot.removeHook('beforeRender', beforeRenderCallback);\r\n\r\n          return _this2.refreshAllEndpoints();\r\n        };\r\n\r\n        this.hot.addHookOnce('beforeRender', beforeRenderCallback);\r\n        return;\r\n      }\r\n\r\n      var type = action.indexOf('row') > -1 ? 'row' : 'col';\r\n      var multiplier = action.indexOf('remove') > -1 ? -1 : 1;\r\n      var endpoints = this.getAllEndpoints();\r\n      var rowMoving = action.indexOf('move_row') === 0;\r\n      var placeOfAlteration = index;\r\n      arrayEach(endpoints, function (val) {\r\n        if (type === 'row' && val.destinationRow >= placeOfAlteration) {\r\n          val.alterRowOffset = multiplier * number;\r\n        }\r\n\r\n        if (type === 'col' && val.destinationColumn >= placeOfAlteration) {\r\n          val.alterColumnOffset = multiplier * number;\r\n        }\r\n      });\r\n      this.resetAllEndpoints(endpoints, !rowMoving);\r\n\r\n      if (rowMoving) {\r\n        arrayEach(endpoints, function (endpoint) {\r\n          _this2.extendEndpointRanges(endpoint, placeOfAlteration, logicRows[0], logicRows.length);\r\n\r\n          _this2.recreatePhysicalRanges(endpoint);\r\n\r\n          _this2.clearOffsetInformation(endpoint);\r\n        });\r\n      } else {\r\n        arrayEach(endpoints, function (endpoint) {\r\n          _this2.shiftEndpointCoordinates(endpoint, placeOfAlteration);\r\n        });\r\n      }\r\n\r\n      if (forceRefresh) {\r\n        this.refreshAllEndpoints();\r\n      }\r\n    }\r\n    /**\r\n     * Clear the offset information from the endpoint object.\r\n     *\r\n     * @private\r\n     * @param {object} endpoint And endpoint object.\r\n     */\r\n\r\n  }, {\r\n    key: \"clearOffsetInformation\",\r\n    value: function clearOffsetInformation(endpoint) {\r\n      endpoint.alterRowOffset = void 0;\r\n      endpoint.alterColumnOffset = void 0;\r\n    }\r\n    /**\r\n     * Extend the row ranges for the provided endpoint.\r\n     *\r\n     * @private\r\n     * @param {object} endpoint The endpoint object.\r\n     * @param {number} placeOfAlteration Index of the row where the alteration takes place.\r\n     * @param {number} previousPosition Previous endpoint result position.\r\n     * @param {number} offset Offset generated by the alteration.\r\n     */\r\n\r\n  }, {\r\n    key: \"extendEndpointRanges\",\r\n    value: function extendEndpointRanges(endpoint, placeOfAlteration, previousPosition, offset) {\r\n      arrayEach(endpoint.ranges, function (range) {\r\n        // is a range, not a single row\r\n        if (range[1]) {\r\n          if (placeOfAlteration >= range[0] && placeOfAlteration <= range[1]) {\r\n            if (previousPosition > range[1]) {\r\n              range[1] += offset;\r\n            } else if (previousPosition < range[0]) {\r\n              range[0] -= offset;\r\n            }\r\n          } else if (previousPosition >= range[0] && previousPosition <= range[1]) {\r\n            range[1] -= offset;\r\n\r\n            if (placeOfAlteration <= range[0]) {\r\n              range[0] += 1;\r\n              range[1] += 1;\r\n            }\r\n          }\r\n        }\r\n      });\r\n    }\r\n    /**\r\n     * Recreate the physical ranges for the provided endpoint. Used (for example) when a row gets moved and extends an existing range.\r\n     *\r\n     * @private\r\n     * @param {object} endpoint An endpoint object.\r\n     */\r\n\r\n  }, {\r\n    key: \"recreatePhysicalRanges\",\r\n    value: function recreatePhysicalRanges(endpoint) {\r\n      var _this3 = this;\r\n\r\n      var ranges = endpoint.ranges;\r\n      var newRanges = [];\r\n      var allIndexes = [];\r\n      arrayEach(ranges, function (range) {\r\n        var newRange = [];\r\n\r\n        if (range[1]) {\r\n          for (var i = range[0]; i <= range[1]; i++) {\r\n            newRange.push(_this3.hot.toPhysicalRow(i));\r\n          }\r\n        } else {\r\n          newRange.push(_this3.hot.toPhysicalRow(range[0]));\r\n        }\r\n\r\n        allIndexes.push(newRange);\r\n      });\r\n      arrayEach(allIndexes, function (range) {\r\n        var newRange = [];\r\n        arrayEach(range, function (coord, index) {\r\n          if (index === 0) {\r\n            newRange.push(coord);\r\n          } else if (range[index] !== range[index - 1] + 1) {\r\n            newRange.push(range[index - 1]);\r\n            newRanges.push(newRange);\r\n            newRange = [];\r\n            newRange.push(coord);\r\n          }\r\n\r\n          if (index === range.length - 1) {\r\n            newRange.push(coord);\r\n            newRanges.push(newRange);\r\n          }\r\n        });\r\n      });\r\n      endpoint.ranges = newRanges;\r\n    }\r\n    /**\r\n     * Shifts the endpoint coordinates by the defined offset.\r\n     *\r\n     * @private\r\n     * @param {object} endpoint Endpoint object.\r\n     * @param {number} offsetStartIndex Index of the performed change (if the change is located after the endpoint, nothing about the endpoint has to be changed.\r\n     */\r\n\r\n  }, {\r\n    key: \"shiftEndpointCoordinates\",\r\n    value: function shiftEndpointCoordinates(endpoint, offsetStartIndex) {\r\n      if (endpoint.alterRowOffset && endpoint.alterRowOffset !== 0) {\r\n        endpoint.destinationRow += endpoint.alterRowOffset || 0;\r\n        arrayEach(endpoint.ranges, function (element) {\r\n          arrayEach(element, function (subElement, j) {\r\n            if (subElement >= offsetStartIndex) {\r\n              element[j] += endpoint.alterRowOffset || 0;\r\n            }\r\n          });\r\n        });\r\n      } else if (endpoint.alterColumnOffset && endpoint.alterColumnOffset !== 0) {\r\n        endpoint.destinationColumn += endpoint.alterColumnOffset || 0;\r\n        endpoint.sourceColumn += endpoint.alterColumnOffset || 0;\r\n      }\r\n    }\r\n    /**\r\n     * Resets (removes) the endpoints from the table.\r\n     *\r\n     * @param {Array} [endpoints] Array containing the endpoints.\r\n     * @param {boolean} [useOffset=true] Use the cell offset value.\r\n     */\r\n\r\n  }, {\r\n    key: \"resetAllEndpoints\",\r\n    value: function resetAllEndpoints() {\r\n      var _this4 = this;\r\n\r\n      var endpoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAllEndpoints();\r\n      var useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n      var anyEndpointOutOfRange = endpoints.some(function (endpoint) {\r\n        var alterRowOffset = endpoint.alterRowOffset || 0;\r\n        var alterColOffset = endpoint.alterColumnOffset || 0;\r\n\r\n        if (endpoint.destinationRow + alterRowOffset >= _this4.hot.countRows() || endpoint.destinationColumn + alterColOffset >= _this4.hot.countCols()) {\r\n          return true;\r\n        }\r\n\r\n        return false;\r\n      });\r\n\r\n      if (anyEndpointOutOfRange) {\r\n        return;\r\n      }\r\n\r\n      this.cellsToSetCache = [];\r\n      arrayEach(endpoints, function (endpoint) {\r\n        _this4.resetEndpointValue(endpoint, useOffset);\r\n      });\r\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\r\n      this.cellsToSetCache = [];\r\n    }\r\n    /**\r\n     * Calculate and refresh all defined endpoints.\r\n     */\r\n\r\n  }, {\r\n    key: \"refreshAllEndpoints\",\r\n    value: function refreshAllEndpoints() {\r\n      var _this5 = this;\r\n\r\n      this.cellsToSetCache = [];\r\n      arrayEach(this.getAllEndpoints(), function (value) {\r\n        _this5.currentEndpoint = value;\r\n\r\n        _this5.plugin.calculate(value);\r\n\r\n        _this5.setEndpointValue(value, 'init');\r\n      });\r\n      this.currentEndpoint = null;\r\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\r\n      this.cellsToSetCache = [];\r\n    }\r\n    /**\r\n     * Calculate and refresh endpoints only in the changed columns.\r\n     *\r\n     * @param {Array} changes Array of changes from the `afterChange` hook.\r\n     */\r\n\r\n  }, {\r\n    key: \"refreshChangedEndpoints\",\r\n    value: function refreshChangedEndpoints(changes) {\r\n      var _this6 = this;\r\n\r\n      var needToRefresh = [];\r\n      this.cellsToSetCache = [];\r\n      arrayEach(changes, function (value, key, changesObj) {\r\n        // if nothing changed, dont update anything\r\n        if (\"\".concat(value[2] || '') === \"\".concat(value[3])) {\r\n          return;\r\n        }\r\n\r\n        arrayEach(_this6.getAllEndpoints(), function (endpoint, j) {\r\n          if (_this6.hot.propToCol(changesObj[key][1]) === endpoint.sourceColumn && needToRefresh.indexOf(j) === -1) {\r\n            needToRefresh.push(j);\r\n          }\r\n        });\r\n      });\r\n      arrayEach(needToRefresh, function (value) {\r\n        _this6.refreshEndpoint(_this6.getEndpoint(value));\r\n      });\r\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\r\n      this.cellsToSetCache = [];\r\n    }\r\n    /**\r\n     * Calculate and refresh a single endpoint.\r\n     *\r\n     * @param {object} endpoint Contains the endpoint information.\r\n     */\r\n\r\n  }, {\r\n    key: \"refreshEndpoint\",\r\n    value: function refreshEndpoint(endpoint) {\r\n      this.currentEndpoint = endpoint;\r\n      this.plugin.calculate(endpoint);\r\n      this.setEndpointValue(endpoint);\r\n      this.currentEndpoint = null;\r\n    }\r\n    /**\r\n     * Reset the endpoint value.\r\n     *\r\n     * @param {object} endpoint Contains the endpoint information.\r\n     * @param {boolean} [useOffset=true] Use the cell offset value.\r\n     */\r\n\r\n  }, {\r\n    key: \"resetEndpointValue\",\r\n    value: function resetEndpointValue(endpoint) {\r\n      var useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n      var alterRowOffset = endpoint.alterRowOffset || 0;\r\n      var alterColOffset = endpoint.alterColumnOffset || 0;\r\n      var _ref = [this.hot.toVisualRow(endpoint.destinationRow), this.hot.toVisualColumn(endpoint.destinationColumn)],\r\n          visualRowIndex = _ref[0],\r\n          visualColumnIndex = _ref[1];\r\n\r\n      if (visualColumnIndex !== null && visualRowIndex !== null) {\r\n        // Clear the meta on the \"old\" indexes\r\n        var cellMeta = this.hot.getCellMeta(visualRowIndex, visualColumnIndex);\r\n        cellMeta.readOnly = false;\r\n        cellMeta.className = '';\r\n      }\r\n\r\n      this.cellsToSetCache.push([this.hot.toVisualRow(endpoint.destinationRow + (useOffset ? alterRowOffset : 0)), this.hot.toVisualColumn(endpoint.destinationColumn + (useOffset ? alterColOffset : 0)), '']);\r\n    }\r\n    /**\r\n     * Set the endpoint value.\r\n     *\r\n     * @param {object} endpoint Contains the endpoint information.\r\n     * @param {string} [source] Source of the call information.\r\n     * @param {boolean} [render=false] `true` if it needs to render the table afterwards.\r\n     */\r\n\r\n  }, {\r\n    key: \"setEndpointValue\",\r\n    value: function setEndpointValue(endpoint, source) {\r\n      var render = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n      // We'll need the reversed offset values, because cellMeta will be shifted AGAIN afterwards.\r\n      var reverseRowOffset = -1 * endpoint.alterRowOffset || 0;\r\n      var reverseColOffset = -1 * endpoint.alterColumnOffset || 0;\r\n      var visualEndpointRowIndex = this.hot.toVisualRow(endpoint.destinationRow);\r\n\r\n      if (endpoint.destinationRow >= this.hot.countRows() || endpoint.destinationColumn >= this.hot.countCols()) {\r\n        this.throwOutOfBoundsWarning();\r\n        return;\r\n      }\r\n\r\n      var destinationVisualRow = this.hot.toVisualRow(endpoint.destinationRow + reverseRowOffset);\r\n\r\n      if (destinationVisualRow !== null) {\r\n        var cellMeta = this.hot.getCellMeta(destinationVisualRow, endpoint.destinationColumn + reverseColOffset);\r\n\r\n        if (source === 'init' || cellMeta.readOnly !== endpoint.readOnly) {\r\n          cellMeta.readOnly = endpoint.readOnly;\r\n          cellMeta.className = 'columnSummaryResult';\r\n        }\r\n      }\r\n\r\n      if (endpoint.roundFloat && !isNaN(endpoint.result)) {\r\n        endpoint.result = endpoint.result.toFixed(endpoint.roundFloat);\r\n      }\r\n\r\n      if (render) {\r\n        this.hot.setDataAtCell(visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result, 'ColumnSummary.set');\r\n      } else {\r\n        this.cellsToSetCache.push([visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result]);\r\n      }\r\n\r\n      endpoint.alterRowOffset = void 0;\r\n      endpoint.alterColumnOffset = void 0;\r\n    }\r\n    /**\r\n     * Throw an error for the calculation range being out of boundaries.\r\n     *\r\n     * @private\r\n     */\r\n\r\n  }, {\r\n    key: \"throwOutOfBoundsWarning\",\r\n    value: function throwOutOfBoundsWarning() {\r\n      warn('One of the Column Summary plugins\\' destination points you provided is beyond the table boundaries!');\r\n    }\r\n  }]);\r\n\r\n  return Endpoints;\r\n}();\r\n\r\nexport default Endpoints;"]},"metadata":{},"sourceType":"module"}