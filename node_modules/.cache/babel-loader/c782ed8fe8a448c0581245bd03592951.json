{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nimport parseDate from './parseDate';\nimport Integer, { isInteger } from './types/Integer';\nimport URL, { isURL } from './types/URL';\nimport Email, { isEmail } from './types/Email';\nvar DEFAULT_OPTIONS = {\n  isColumnOriented: false\n  /**\r\n   * Convert 2D array to nested objects.\r\n   * If row oriented data, row 0 is dotted key names.\r\n   * Column oriented data is transposed.\r\n   * @param {string[][]} data - An array of rows, each row being an array of cells.\r\n   * @param {object} schema\r\n   * @return {object[]}\r\n   */\n\n};\nexport default function (data, schema, options) {\n  if (options) {\n    options = _extends({}, DEFAULT_OPTIONS, options);\n  } else {\n    options = DEFAULT_OPTIONS;\n  }\n\n  var _options = options,\n      isColumnOriented = _options.isColumnOriented,\n      rowMap = _options.rowMap;\n  validateSchema(schema);\n\n  if (isColumnOriented) {\n    data = transpose(data);\n  }\n\n  var columns = data[0];\n  var results = [];\n  var errors = [];\n\n  for (var i = 1; i < data.length; i++) {\n    var result = read(schema, data[i], i - 1, columns, errors, options);\n\n    if (result) {\n      results.push(result);\n    }\n  } // Correct error rows.\n\n\n  if (rowMap) {\n    for (var _iterator = errors, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var error = _ref; // Convert the `row` index in `data` to the\n      // actual `row` index in the spreadsheet.\n      // The `1` compensates for the header row.\n\n      error.row = rowMap[error.row] + 1;\n    }\n  }\n\n  return {\n    rows: results,\n    errors: errors\n  };\n}\n\nfunction read(schema, row, rowIndex, columns, errors, options) {\n  var object = {};\n\n  var _loop = function _loop() {\n    if (_isArray2) {\n      if (_i2 >= _iterator2.length) return 'break';\n      _ref2 = _iterator2[_i2++];\n    } else {\n      _i2 = _iterator2.next();\n      if (_i2.done) return 'break';\n      _ref2 = _i2.value;\n    }\n\n    var key = _ref2;\n    var schemaEntry = schema[key];\n    var isNestedSchema = _typeof(schemaEntry.type) === 'object' && !Array.isArray(schemaEntry.type);\n    var rawValue = row[columns.indexOf(key)];\n\n    if (rawValue === undefined) {\n      rawValue = null;\n    }\n\n    var value = void 0;\n    var error = void 0;\n\n    if (isNestedSchema) {\n      value = read(schemaEntry.type, row, rowIndex, columns, errors, options);\n    } else {\n      if (rawValue === null) {\n        value = null;\n      } else if (Array.isArray(schemaEntry.type)) {\n        var notEmpty = false;\n        var array = parseArray(rawValue).map(function (_value) {\n          var result = parseValue(_value, schemaEntry, options);\n\n          if (result.error) {\n            value = _value;\n            error = result.error;\n          }\n\n          if (result.value !== null) {\n            notEmpty = true;\n          }\n\n          return result.value;\n        });\n\n        if (!error) {\n          value = notEmpty ? array : null;\n        }\n      } else {\n        var result = parseValue(rawValue, schemaEntry, options);\n        error = result.error;\n        value = error ? rawValue : result.value;\n      }\n    }\n\n    if (!error && value === null && schemaEntry.required) {\n      error = 'required';\n    }\n\n    if (error) {\n      error = {\n        error: error,\n        row: rowIndex + 1,\n        column: key,\n        value: value\n      };\n\n      if (schemaEntry.type) {\n        error.type = schemaEntry.type;\n      }\n\n      errors.push(error);\n    } else if (value !== null) {\n      object[schemaEntry.prop] = value;\n    }\n  };\n\n  for (var _iterator2 = Object.keys(schema), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n    var _ref2;\n\n    var _ret = _loop();\n\n    if (_ret === 'break') break;\n  }\n\n  if (Object.keys(object).length > 0) {\n    return object;\n  }\n\n  return null;\n}\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {string} value\r\n * @param  {object} schemaEntry\r\n * @return {{ value: any, error: string }}\r\n */\n\n\nexport function parseValue(value, schemaEntry, options) {\n  if (value === null) {\n    return {\n      value: null\n    };\n  }\n\n  var result = void 0;\n\n  if (schemaEntry.parse) {\n    result = parseCustomValue(value, schemaEntry.parse);\n  } else if (schemaEntry.type) {\n    result = parseValueOfType(value, Array.isArray(schemaEntry.type) ? schemaEntry.type[0] : schemaEntry.type, options);\n  } else {\n    result = {\n      value: value // throw new Error('Invalid schema entry: no .type and no .parse():\\n\\n' + JSON.stringify(schemaEntry, null, 2))\n\n    };\n  } // If errored then return the error.\n\n\n  if (result.error) {\n    return result;\n  }\n\n  if (result.value !== null) {\n    if (schemaEntry.oneOf && schemaEntry.oneOf.indexOf(result.value) < 0) {\n      return {\n        error: 'invalid'\n      };\n    }\n\n    if (schemaEntry.validate) {\n      try {\n        schemaEntry.validate(result.value);\n      } catch (error) {\n        return {\n          error: error.message\n        };\n      }\n    }\n  }\n\n  return result;\n}\n/**\r\n * Converts textual value to a custom value using supplied `.parse()`.\r\n * @param  {string} value\r\n * @param  {function} parse\r\n * @return {{ value: any, error: string }}\r\n */\n\nfunction parseCustomValue(value, parse) {\n  try {\n    value = parse(value);\n\n    if (value === undefined) {\n      return {\n        value: null\n      };\n    }\n\n    return {\n      value: value\n    };\n  } catch (error) {\n    return {\n      error: error.message\n    };\n  }\n}\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {string} value\r\n * @param  {} type\r\n * @return {{ value: (string|number|Date|boolean), error: string }}\r\n */\n\n\nfunction parseValueOfType(value, type, options) {\n  switch (type) {\n    case String:\n      return {\n        value: value\n      };\n\n    case Number:\n    case Integer:\n      // The global isFinite() function determines\n      // whether the passed value is a finite number.\n      // If  needed, the parameter is first converted to a number.\n      if (!isFinite(value)) {\n        return {\n          error: 'invalid'\n        };\n      }\n\n      if (type === Integer && !isInteger(value)) {\n        return {\n          error: 'invalid'\n        };\n      } // Convert strings to numbers.\n      // Just an additional feature.\n      // Won't happen when called from `readXlsx()`.\n\n\n      if (typeof value === 'string') {\n        value = parseFloat(value);\n      }\n\n      return {\n        value: value\n      };\n\n    case URL:\n      if (!isURL(value)) {\n        return {\n          error: 'invalid'\n        };\n      }\n\n      return {\n        value: value\n      };\n\n    case Email:\n      if (!isEmail(value)) {\n        return {\n          error: 'invalid'\n        };\n      }\n\n      return {\n        value: value\n      };\n\n    case Date:\n      // XLSX has no specific format for dates.\n      // Sometimes a date can be heuristically detected.\n      // https://github.com/catamphetamine/read-excel-file/issues/3#issuecomment-395770777\n      if (value instanceof Date) {\n        return {\n          value: value\n        };\n      }\n\n      if (typeof value === 'number') {\n        if (!isFinite(value)) {\n          return {\n            error: 'invalid'\n          };\n        }\n\n        value = parseInt(value);\n        var date = parseDate(value, options.properties);\n\n        if (!date) {\n          return {\n            error: 'invalid'\n          };\n        }\n\n        return {\n          value: date\n        };\n      }\n\n      return {\n        error: 'invalid'\n      };\n\n    case Boolean:\n      if (typeof value === 'boolean') {\n        return {\n          value: value\n        };\n      }\n\n      return {\n        error: 'invalid'\n      };\n\n    default:\n      if (typeof type === 'function') {\n        return parseCustomValue(value, type);\n      }\n\n      throw new Error('Unknown schema type: ' + (type && type.name || type));\n  }\n}\n\nexport function getBlock(string, endCharacter, startIndex) {\n  var i = 0;\n  var substring = '';\n  var character = void 0;\n\n  while (startIndex + i < string.length) {\n    var _character = string[startIndex + i];\n\n    if (_character === endCharacter) {\n      return [substring, i];\n    } else if (_character === '\"') {\n      var block = getBlock(string, '\"', startIndex + i + 1);\n      substring += block[0];\n      i += '\"'.length + block[1] + '\"'.length;\n    } else {\n      substring += _character;\n      i++;\n    }\n  }\n\n  return [substring, i];\n}\nexport function parseArray(string) {\n  var blocks = [];\n  var index = 0;\n\n  while (index < string.length) {\n    var _getBlock = getBlock(string, ',', index),\n        _getBlock2 = _slicedToArray(_getBlock, 2),\n        substring = _getBlock2[0],\n        length = _getBlock2[1];\n\n    index += length + ','.length;\n    blocks.push(substring.trim());\n  }\n\n  return blocks;\n} // Transpose a 2D array.\n// https://stackoverflow.com/questions/17428587/transposing-a-2d-array-in-javascript\n\nvar transpose = function transpose(array) {\n  return array[0].map(function (_, i) {\n    return array.map(function (row) {\n      return row[i];\n    });\n  });\n};\n\nfunction validateSchema(schema) {\n  for (var _iterator3 = Object.keys(schema), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n    var _ref3;\n\n    if (_isArray3) {\n      if (_i3 >= _iterator3.length) break;\n      _ref3 = _iterator3[_i3++];\n    } else {\n      _i3 = _iterator3.next();\n      if (_i3.done) break;\n      _ref3 = _i3.value;\n    }\n\n    var _key = _ref3;\n    var entry = schema[_key];\n\n    if (!entry.prop) {\n      throw new Error('\"prop\" not defined for schema entry \"' + _key + '\".');\n    }\n  }\n}","map":{"version":3,"sources":["../source/convertToJson.js"],"names":["DEFAULT_OPTIONS","isColumnOriented","options","rowMap","validateSchema","data","transpose","columns","results","errors","i","result","read","error","rows","object","key","Object","schemaEntry","schema","isNestedSchema","Array","rawValue","row","value","notEmpty","array","parseValue","rowIndex","column","parseCustomValue","parseValueOfType","parse","isFinite","type","isInteger","parseFloat","isURL","isEmail","parseInt","date","parseDate","substring","character","startIndex","string","block","getBlock","blocks","index","length","entry"],"mappings":"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","sourcesContent":["import parseDate from './parseDate'\r\nimport Integer, { isInteger } from './types/Integer'\r\nimport URL, { isURL } from './types/URL'\r\nimport Email, { isEmail } from './types/Email'\r\n\r\nconst DEFAULT_OPTIONS = {\r\n  isColumnOriented: false\r\n}\r\n\r\n/**\r\n * Convert 2D array to nested objects.\r\n * If row oriented data, row 0 is dotted key names.\r\n * Column oriented data is transposed.\r\n * @param {string[][]} data - An array of rows, each row being an array of cells.\r\n * @param {object} schema\r\n * @return {object[]}\r\n */\r\nexport default function(data, schema, options) {\r\n  if (options) {\r\n    options = {\r\n      ...DEFAULT_OPTIONS,\r\n      ...options\r\n    }\r\n  } else {\r\n    options = DEFAULT_OPTIONS\r\n  }\r\n\r\n  const {\r\n    isColumnOriented,\r\n    rowMap\r\n  } = options\r\n\r\n  validateSchema(schema)\r\n\r\n  if (isColumnOriented) {\r\n    data = transpose(data)\r\n  }\r\n\r\n  const columns = data[0]\r\n\r\n  const results = []\r\n  const errors = []\r\n\r\n  for (let i = 1; i < data.length; i++) {\r\n    const result = read(schema, data[i], i - 1, columns, errors, options)\r\n    if (result) {\r\n      results.push(result)\r\n    }\r\n  }\r\n\r\n  // Correct error rows.\r\n  if (rowMap) {\r\n    for (const error of errors) {\r\n      // Convert the `row` index in `data` to the\r\n      // actual `row` index in the spreadsheet.\r\n      // The `1` compensates for the header row.\r\n      error.row = rowMap[error.row] + 1\r\n    }\r\n  }\r\n\r\n  return {\r\n    rows: results,\r\n    errors\r\n  }\r\n}\r\n\r\nfunction read(schema, row, rowIndex, columns, errors, options) {\r\n  const object = {}\r\n  for (const key of Object.keys(schema)) {\r\n    const schemaEntry = schema[key]\r\n    const isNestedSchema = typeof schemaEntry.type === 'object' && !Array.isArray(schemaEntry.type)\r\n    let rawValue = row[columns.indexOf(key)]\r\n    if (rawValue === undefined) {\r\n      rawValue = null\r\n    }\r\n    let value\r\n    let error\r\n    if (isNestedSchema) {\r\n      value = read(schemaEntry.type, row, rowIndex, columns, errors, options)\r\n    } else {\r\n      if (rawValue === null) {\r\n        value = null\r\n      }\r\n      else if (Array.isArray(schemaEntry.type)) {\r\n        let notEmpty = false\r\n        const array = parseArray(rawValue).map((_value) => {\r\n          const result = parseValue(_value, schemaEntry, options)\r\n          if (result.error) {\r\n            value = _value\r\n            error = result.error\r\n          }\r\n          if (result.value !== null) {\r\n            notEmpty = true\r\n          }\r\n          return result.value\r\n        })\r\n        if (!error) {\r\n          value = notEmpty ? array : null\r\n        }\r\n      } else {\r\n        const result = parseValue(rawValue, schemaEntry, options)\r\n        error = result.error\r\n        value = error ? rawValue : result.value\r\n      }\r\n    }\r\n    if (!error && value === null && schemaEntry.required) {\r\n      error = 'required'\r\n    }\r\n    if (error) {\r\n      error = {\r\n        error,\r\n        row: rowIndex + 1,\r\n        column: key,\r\n        value\r\n      }\r\n      if (schemaEntry.type) {\r\n        error.type = schemaEntry.type\r\n      }\r\n      errors.push(error)\r\n    } else if (value !== null) {\r\n      object[schemaEntry.prop] = value\r\n    }\r\n  }\r\n  if (Object.keys(object).length > 0) {\r\n    return object\r\n  }\r\n  return null\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {string} value\r\n * @param  {object} schemaEntry\r\n * @return {{ value: any, error: string }}\r\n */\r\nexport function parseValue(value, schemaEntry, options) {\r\n  if (value === null) {\r\n    return { value: null }\r\n  }\r\n  let result\r\n  if (schemaEntry.parse) {\r\n    result = parseCustomValue(value, schemaEntry.parse)\r\n  } else if (schemaEntry.type) {\r\n    result = parseValueOfType(value, Array.isArray(schemaEntry.type) ? schemaEntry.type[0] : schemaEntry.type, options)\r\n  } else {\r\n    result = { value: value }\r\n    // throw new Error('Invalid schema entry: no .type and no .parse():\\n\\n' + JSON.stringify(schemaEntry, null, 2))\r\n  }\r\n  // If errored then return the error.\r\n  if (result.error) {\r\n    return result\r\n  }\r\n  if (result.value !== null) {\r\n    if (schemaEntry.oneOf && schemaEntry.oneOf.indexOf(result.value) < 0) {\r\n      return { error: 'invalid' }\r\n    }\r\n    if (schemaEntry.validate) {\r\n      try {\r\n        schemaEntry.validate(result.value)\r\n      } catch (error) {\r\n        return { error: error.message }\r\n      }\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * Converts textual value to a custom value using supplied `.parse()`.\r\n * @param  {string} value\r\n * @param  {function} parse\r\n * @return {{ value: any, error: string }}\r\n */\r\nfunction parseCustomValue(value, parse) {\r\n  try {\r\n    value = parse(value)\r\n    if (value === undefined) {\r\n      return { value: null }\r\n    }\r\n    return { value }\r\n  } catch (error) {\r\n    return { error: error.message }\r\n  }\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {string} value\r\n * @param  {} type\r\n * @return {{ value: (string|number|Date|boolean), error: string }}\r\n */\r\nfunction parseValueOfType(value, type, options) {\r\n  switch (type) {\r\n    case String:\r\n      return { value }\r\n\r\n    case Number:\r\n    case Integer:\r\n      // The global isFinite() function determines\r\n      // whether the passed value is a finite number.\r\n      // If  needed, the parameter is first converted to a number.\r\n      if (!isFinite(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      if (type === Integer && !isInteger(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      // Convert strings to numbers.\r\n      // Just an additional feature.\r\n      // Won't happen when called from `readXlsx()`.\r\n      if (typeof value === 'string') {\r\n        value = parseFloat(value)\r\n      }\r\n      return { value }\r\n\r\n    case URL:\r\n      if (!isURL(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      return { value }\r\n\r\n    case Email:\r\n      if (!isEmail(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      return { value }\r\n\r\n    case Date:\r\n      // XLSX has no specific format for dates.\r\n      // Sometimes a date can be heuristically detected.\r\n      // https://github.com/catamphetamine/read-excel-file/issues/3#issuecomment-395770777\r\n      if (value instanceof Date) {\r\n        return { value }\r\n      }\r\n      if (typeof value === 'number') {\r\n        if (!isFinite(value)) {\r\n          return { error: 'invalid' }\r\n        }\r\n        value = parseInt(value)\r\n        const date = parseDate(value, options.properties)\r\n        if (!date) {\r\n          return { error: 'invalid' }\r\n        }\r\n        return { value: date }\r\n      }\r\n      return { error: 'invalid' }\r\n\r\n    case Boolean:\r\n      if (typeof value === 'boolean') {\r\n        return { value }\r\n      }\r\n      return { error: 'invalid' }\r\n\r\n    default:\r\n      if (typeof type === 'function') {\r\n        return parseCustomValue(value, type)\r\n      }\r\n      throw new Error(`Unknown schema type: ${type && type.name || type}`)\r\n  }\r\n}\r\n\r\nexport function getBlock(string, endCharacter, startIndex) {\r\n  let i = 0\r\n  let substring = ''\r\n  let character\r\n  while (startIndex + i < string.length) {\r\n    const character = string[startIndex + i]\r\n    if (character === endCharacter) {\r\n      return [substring, i]\r\n    }\r\n    else if (character === '\"') {\r\n      const block = getBlock(string, '\"', startIndex + i + 1)\r\n      substring += block[0]\r\n      i += '\"'.length + block[1] + '\"'.length\r\n    }\r\n    else {\r\n      substring += character\r\n      i++\r\n    }\r\n  }\r\n  return [substring, i]\r\n}\r\n\r\nexport function parseArray(string) {\r\n  const blocks = []\r\n  let index = 0\r\n  while (index < string.length) {\r\n    const [substring, length] = getBlock(string, ',', index)\r\n    index += length + ','.length\r\n    blocks.push(substring.trim())\r\n  }\r\n  return blocks\r\n}\r\n\r\n// Transpose a 2D array.\r\n// https://stackoverflow.com/questions/17428587/transposing-a-2d-array-in-javascript\r\nconst transpose = array => array[0].map((_, i) => array.map(row => row[i]))\r\n\r\nfunction validateSchema(schema) {\r\n  for (const key of Object.keys(schema)) {\r\n    const entry = schema[key]\r\n    if (!entry.prop) {\r\n      throw new Error(`\"prop\" not defined for schema entry \"${key}\".`)\r\n    }\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}