{"ast":null,"code":"function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\r\n * Refactored implementation of LinkedList (part of javascript-algorithms project) by Github users:\r\n * mgechev, AndriiHeonia, Microfed and Jakeh (part of javascript-algorithms project - all project contributors\r\n * at repository website).\r\n *\r\n * Link to repository: https://github.com/mgechev/javascript-algorithms.\r\n */\n\n/**\r\n * Linked list node.\r\n *\r\n * @class NodeStructure\r\n * @util\r\n */\n\n\nvar NodeStructure = function NodeStructure(data) {\n  _classCallCheck(this, NodeStructure);\n  /**\r\n   * Data of the node.\r\n   *\r\n   * @member {object}\r\n   */\n\n\n  this.data = data;\n  /**\r\n   * Next node.\r\n   *\r\n   * @member {NodeStructure}\r\n   */\n\n  this.next = null;\n  /**\r\n   * Previous node.\r\n   *\r\n   * @member {NodeStructure}\r\n   */\n\n  this.prev = null;\n};\n/**\r\n * Linked list.\r\n *\r\n * @class LinkedList\r\n * @util\r\n */\n\n\nvar LinkedList = /*#__PURE__*/function () {\n  function LinkedList() {\n    _classCallCheck(this, LinkedList);\n\n    this.first = null;\n    this.last = null;\n  }\n  /**\r\n   * Add data to the end of linked list.\r\n   *\r\n   * @param {object} data Data which should be added.\r\n   */\n\n\n  _createClass(LinkedList, [{\n    key: \"push\",\n    value: function push(data) {\n      var node = new NodeStructure(data);\n\n      if (this.first === null) {\n        this.first = node;\n        this.last = node;\n      } else {\n        var temp = this.last;\n        this.last = node;\n        node.prev = temp;\n        temp.next = node;\n      }\n    }\n    /**\r\n     * Add data to the beginning of linked list.\r\n     *\r\n     * @param {object} data Data which should be added.\r\n     */\n\n  }, {\n    key: \"unshift\",\n    value: function unshift(data) {\n      var node = new NodeStructure(data);\n\n      if (this.first === null) {\n        this.first = node;\n        this.last = node;\n      } else {\n        var temp = this.first;\n        this.first = node;\n        node.next = temp;\n        temp.prev = node;\n      }\n    }\n    /**\r\n     * In order traversal of the linked list.\r\n     *\r\n     * @param {Function} callback Callback which should be executed on each node.\r\n     */\n\n  }, {\n    key: \"inorder\",\n    value: function inorder(callback) {\n      var temp = this.first;\n\n      while (temp) {\n        callback(temp);\n        temp = temp.next;\n      }\n    }\n    /**\r\n     * Remove data from the linked list.\r\n     *\r\n     * @param {object} data Data which should be removed.\r\n     * @returns {boolean} Returns true if data has been removed.\r\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(data) {\n      if (this.first === null) {\n        return false;\n      }\n\n      var temp = this.first;\n      var next;\n      var prev;\n\n      while (temp) {\n        if (temp.data === data) {\n          next = temp.next;\n          prev = temp.prev;\n\n          if (next) {\n            next.prev = prev;\n          }\n\n          if (prev) {\n            prev.next = next;\n          }\n\n          if (temp === this.first) {\n            this.first = next;\n          }\n\n          if (temp === this.last) {\n            this.last = prev;\n          }\n\n          return true;\n        }\n\n        temp = temp.next;\n      }\n\n      return false;\n    }\n    /**\r\n     * Check if linked list contains cycle.\r\n     *\r\n     * @returns {boolean} Returns true if linked list contains cycle.\r\n     */\n\n  }, {\n    key: \"hasCycle\",\n    value: function hasCycle() {\n      var fast = this.first;\n      var slow = this.first;\n\n      while (true) {\n        if (fast === null) {\n          return false;\n        }\n\n        fast = fast.next;\n\n        if (fast === null) {\n          return false;\n        }\n\n        fast = fast.next;\n        slow = slow.next;\n\n        if (fast === slow) {\n          return true;\n        }\n      }\n    }\n    /**\r\n     * Return last node from the linked list.\r\n     *\r\n     * @returns {NodeStructure} Last node.\r\n     */\n\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      if (this.last === null) {\n        return null;\n      }\n\n      var temp = this.last;\n      this.last = this.last.prev;\n      return temp;\n    }\n    /**\r\n     * Return first node from the linked list.\r\n     *\r\n     * @returns {NodeStructure} First node.\r\n     */\n\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.first === null) {\n        return null;\n      }\n\n      var temp = this.first;\n      this.first = this.first.next;\n      return temp;\n    }\n    /**\r\n     * Reverses the linked list recursively.\r\n     */\n\n  }, {\n    key: \"recursiveReverse\",\n    value: function recursiveReverse() {\n      /**\r\n       * @param {*} current The current value.\r\n       * @param {*} next The next value.\r\n       */\n      function inverse(current, next) {\n        if (!next) {\n          return;\n        }\n\n        inverse(next, next.next);\n        next.next = current;\n      }\n\n      if (!this.first) {\n        return;\n      }\n\n      inverse(this.first, this.first.next);\n      this.first.next = null;\n      var temp = this.first;\n      this.first = this.last;\n      this.last = temp;\n    }\n    /**\r\n     * Reverses the linked list iteratively.\r\n     */\n\n  }, {\n    key: \"reverse\",\n    value: function reverse() {\n      if (!this.first || !this.first.next) {\n        return;\n      }\n\n      var current = this.first.next;\n      var prev = this.first;\n      var temp;\n\n      while (current) {\n        temp = current.next;\n        current.next = prev;\n        prev.prev = current;\n        prev = current;\n        current = temp;\n      }\n\n      this.first.next = null;\n      this.last.prev = null;\n      temp = this.first;\n      this.first = prev;\n      this.last = temp;\n    }\n  }]);\n\n  return LinkedList;\n}();\n\nexport { NodeStructure };\nexport default LinkedList;","map":{"version":3,"sources":["C:/Users/ssaez1/technip-repositories/isotracker/isotracker-react/node_modules/handsontable/utils/dataStructures/linkedList.mjs"],"names":["_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","NodeStructure","data","next","prev","LinkedList","first","last","value","push","node","temp","unshift","inorder","callback","remove","hasCycle","fast","slow","pop","shift","recursiveReverse","inverse","current","reverse"],"mappings":"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","sourcesContent":["function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\n/**\r\n * Refactored implementation of LinkedList (part of javascript-algorithms project) by Github users:\r\n * mgechev, AndriiHeonia, Microfed and Jakeh (part of javascript-algorithms project - all project contributors\r\n * at repository website).\r\n *\r\n * Link to repository: https://github.com/mgechev/javascript-algorithms.\r\n */\r\n\r\n/**\r\n * Linked list node.\r\n *\r\n * @class NodeStructure\r\n * @util\r\n */\r\nvar NodeStructure = function NodeStructure(data) {\r\n  _classCallCheck(this, NodeStructure);\r\n\r\n  /**\r\n   * Data of the node.\r\n   *\r\n   * @member {object}\r\n   */\r\n  this.data = data;\r\n  /**\r\n   * Next node.\r\n   *\r\n   * @member {NodeStructure}\r\n   */\r\n\r\n  this.next = null;\r\n  /**\r\n   * Previous node.\r\n   *\r\n   * @member {NodeStructure}\r\n   */\r\n\r\n  this.prev = null;\r\n};\r\n/**\r\n * Linked list.\r\n *\r\n * @class LinkedList\r\n * @util\r\n */\r\n\r\n\r\nvar LinkedList = /*#__PURE__*/function () {\r\n  function LinkedList() {\r\n    _classCallCheck(this, LinkedList);\r\n\r\n    this.first = null;\r\n    this.last = null;\r\n  }\r\n  /**\r\n   * Add data to the end of linked list.\r\n   *\r\n   * @param {object} data Data which should be added.\r\n   */\r\n\r\n\r\n  _createClass(LinkedList, [{\r\n    key: \"push\",\r\n    value: function push(data) {\r\n      var node = new NodeStructure(data);\r\n\r\n      if (this.first === null) {\r\n        this.first = node;\r\n        this.last = node;\r\n      } else {\r\n        var temp = this.last;\r\n        this.last = node;\r\n        node.prev = temp;\r\n        temp.next = node;\r\n      }\r\n    }\r\n    /**\r\n     * Add data to the beginning of linked list.\r\n     *\r\n     * @param {object} data Data which should be added.\r\n     */\r\n\r\n  }, {\r\n    key: \"unshift\",\r\n    value: function unshift(data) {\r\n      var node = new NodeStructure(data);\r\n\r\n      if (this.first === null) {\r\n        this.first = node;\r\n        this.last = node;\r\n      } else {\r\n        var temp = this.first;\r\n        this.first = node;\r\n        node.next = temp;\r\n        temp.prev = node;\r\n      }\r\n    }\r\n    /**\r\n     * In order traversal of the linked list.\r\n     *\r\n     * @param {Function} callback Callback which should be executed on each node.\r\n     */\r\n\r\n  }, {\r\n    key: \"inorder\",\r\n    value: function inorder(callback) {\r\n      var temp = this.first;\r\n\r\n      while (temp) {\r\n        callback(temp);\r\n        temp = temp.next;\r\n      }\r\n    }\r\n    /**\r\n     * Remove data from the linked list.\r\n     *\r\n     * @param {object} data Data which should be removed.\r\n     * @returns {boolean} Returns true if data has been removed.\r\n     */\r\n\r\n  }, {\r\n    key: \"remove\",\r\n    value: function remove(data) {\r\n      if (this.first === null) {\r\n        return false;\r\n      }\r\n\r\n      var temp = this.first;\r\n      var next;\r\n      var prev;\r\n\r\n      while (temp) {\r\n        if (temp.data === data) {\r\n          next = temp.next;\r\n          prev = temp.prev;\r\n\r\n          if (next) {\r\n            next.prev = prev;\r\n          }\r\n\r\n          if (prev) {\r\n            prev.next = next;\r\n          }\r\n\r\n          if (temp === this.first) {\r\n            this.first = next;\r\n          }\r\n\r\n          if (temp === this.last) {\r\n            this.last = prev;\r\n          }\r\n\r\n          return true;\r\n        }\r\n\r\n        temp = temp.next;\r\n      }\r\n\r\n      return false;\r\n    }\r\n    /**\r\n     * Check if linked list contains cycle.\r\n     *\r\n     * @returns {boolean} Returns true if linked list contains cycle.\r\n     */\r\n\r\n  }, {\r\n    key: \"hasCycle\",\r\n    value: function hasCycle() {\r\n      var fast = this.first;\r\n      var slow = this.first;\r\n\r\n      while (true) {\r\n        if (fast === null) {\r\n          return false;\r\n        }\r\n\r\n        fast = fast.next;\r\n\r\n        if (fast === null) {\r\n          return false;\r\n        }\r\n\r\n        fast = fast.next;\r\n        slow = slow.next;\r\n\r\n        if (fast === slow) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Return last node from the linked list.\r\n     *\r\n     * @returns {NodeStructure} Last node.\r\n     */\r\n\r\n  }, {\r\n    key: \"pop\",\r\n    value: function pop() {\r\n      if (this.last === null) {\r\n        return null;\r\n      }\r\n\r\n      var temp = this.last;\r\n      this.last = this.last.prev;\r\n      return temp;\r\n    }\r\n    /**\r\n     * Return first node from the linked list.\r\n     *\r\n     * @returns {NodeStructure} First node.\r\n     */\r\n\r\n  }, {\r\n    key: \"shift\",\r\n    value: function shift() {\r\n      if (this.first === null) {\r\n        return null;\r\n      }\r\n\r\n      var temp = this.first;\r\n      this.first = this.first.next;\r\n      return temp;\r\n    }\r\n    /**\r\n     * Reverses the linked list recursively.\r\n     */\r\n\r\n  }, {\r\n    key: \"recursiveReverse\",\r\n    value: function recursiveReverse() {\r\n      /**\r\n       * @param {*} current The current value.\r\n       * @param {*} next The next value.\r\n       */\r\n      function inverse(current, next) {\r\n        if (!next) {\r\n          return;\r\n        }\r\n\r\n        inverse(next, next.next);\r\n        next.next = current;\r\n      }\r\n\r\n      if (!this.first) {\r\n        return;\r\n      }\r\n\r\n      inverse(this.first, this.first.next);\r\n      this.first.next = null;\r\n      var temp = this.first;\r\n      this.first = this.last;\r\n      this.last = temp;\r\n    }\r\n    /**\r\n     * Reverses the linked list iteratively.\r\n     */\r\n\r\n  }, {\r\n    key: \"reverse\",\r\n    value: function reverse() {\r\n      if (!this.first || !this.first.next) {\r\n        return;\r\n      }\r\n\r\n      var current = this.first.next;\r\n      var prev = this.first;\r\n      var temp;\r\n\r\n      while (current) {\r\n        temp = current.next;\r\n        current.next = prev;\r\n        prev.prev = current;\r\n        prev = current;\r\n        current = temp;\r\n      }\r\n\r\n      this.first.next = null;\r\n      this.last.prev = null;\r\n      temp = this.first;\r\n      this.first = prev;\r\n      this.last = temp;\r\n    }\r\n  }]);\r\n\r\n  return LinkedList;\r\n}();\r\n\r\nexport { NodeStructure };\r\nexport default LinkedList;"]},"metadata":{},"sourceType":"module"}