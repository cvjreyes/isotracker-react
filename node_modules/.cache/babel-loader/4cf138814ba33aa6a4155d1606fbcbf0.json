{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { arrayFilter } from \"../../helpers/array.mjs\";\nimport { assert, isUnsignedNumber, isNullish } from \"./utils.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\r\n * @class LazyFactoryMap\r\n *\r\n * The LazyFactoryMap object holds key-value pairs in the structure similar to the\r\n * regular Map. Once created, items can be moved around a grid depending on the operations\r\n * performed on that grid - adding or removing rows. The collection requires \"key\"\r\n * to be a zero-based index.\r\n *\r\n * It's essential to notice that the \"key\" index under which the item was created\r\n * is volatile. After altering the grid, the \"key\" index can change.\r\n *\r\n * Having created N items with corresponding example data where the data has 10\r\n * holes (`undefined` values) within (that's why internal storage index counts from 10).\r\n * +------+------+------+------+------+.\r\n * | 0/10 | 1/11 | 2/12 | 3/13 | 4/14 |  Keys (volatile zero-based index / internal storage index)\r\n * +------+------+------+------+------+.\r\n *    │      │      │      │      │\r\n * +------+------+------+------+------+.\r\n * | AAA  | BBB  | CCC  | DDD  | EEE  |  Data\r\n * +------+------+------+------+------+.\r\n *\r\n * Map.obtain(0) // returns \"AAA\"\r\n * map.obtain(2) // returns \"CCC\".\r\n *\r\n * After inserting 2 new rows, keys that hold the data positioned after the place\r\n * where the new rows are added are upshifted by 2.\r\n *               │\r\n *               │ Insert 2 rows\r\n *              \\│/\r\n * +------+------+------+------+------+.\r\n * | 0/10 | 1/11 | 2/12 | 3/13 | 4/14 |  Keys before\r\n * +------+------+------+------+------+.\r\n *\r\n *                / 2 new rows \\\r\n * +------+------+------+------+------+------+------+.\r\n * | 0/10 | 1/11 | 2/15 | 3/16 | 4/12 | 5/13 | 6/14 |  Keys after\r\n * +------+------+------+------+------+------+------+.\r\n *    │       │      │      │      │      │     │\r\n *    │       │      └──────┼──────┼──────┼┐    │\r\n *    │       │             └──────┼──────┼┼────┼┐\r\n *    │       │      ┌─────────────┘      ││    ││\r\n *    │       │      │      ┌─────────────┘│    ││\r\n *    │       │      │      │      ┌───────┼────┘│\r\n *    │       │      │      │      │       │     │\r\n * +------+------+------+------+------+------+------+.\r\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\r\n * +------+------+------+------+------+------+------+\r\n *\r\n * Now at index 2 and 3 we have access to new items.\r\n *\r\n * map.obtain(2) // returns new value \"FFF\" for newly created row.\r\n * map.obtain(4) // index shifted by 2 has access to the old \"CCC\" value, as before inserting.\r\n *\r\n * after removing 4 rows, keys that hold the data positioned after the place where the\r\n * rows are removed are downshifted by 4.\r\n *        │\r\n *        │ Remove 4 rows\r\n *        ├───────────────────────────┐\r\n *       \\│/                          │\r\n * +------+------+------+------+------+------+------+\r\n * | 0/10 | 1/11 | 2/15 | 3/16 | 4/12 | 5/13 | 6/14 |  Keys after\r\n * +------+------+------+------+------+------+------+\r\n *    │       │      │      │      │      │     │\r\n *    │       │      └──────┼──────┼──────┼┐    │\r\n *    │       │             └──────┼──────┼┼────┼┐\r\n *    │       │      ┌─────────────┘      ││    ││\r\n *    │       │      │      ┌─────────────┘│    ││\r\n *    │       │      │      │      ┌───────┼────┘│\r\n *    │       │      │      │      │       │     │\r\n * +------+------+------+------+------+------+------+\r\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\r\n * +------+------+------+------+------+------+------+\r\n *\r\n * +------+------+------+\r\n * | 0/10 | 1/13 | 2/14 |  Keys after\r\n * +------+------+------+\r\n *    │       │      │\r\n *    │       │      └─────────────┐\r\n *    │       └────────────┐       │\r\n *    │                    │       │\r\n *    │                    │       │\r\n *    │                    │       │\r\n *    │                    │       │\r\n * +------+------+------+------+------+------+------+\r\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\r\n * +------+------+------+------+------+------+------+\r\n *           /│\\   /│\\                   /│\\   /│\\\r\n *            └──┬──┘                     └──┬──┘\r\n *           This data is marked as \"hole\" which\r\n *           means that can be replaced by new item\r\n *           when that will be created.\r\n *\r\n * map.obtain(2) // returns the value (\"EEE\") as it should. Access to the value is\r\n *               // changed (the key was downshifted). However, the internal index has not changed,\r\n *               // which means that the data does not need to be changed (spliced) too.\r\n *\r\n * After previous remove operation which creates some \"holes\" obtaining new\r\n * items replaces that \"holes\" as follows:\r\n *\r\n * // Obtains new item\r\n * map.obtain(90) // Returns \"NEW\" value\r\n *\r\n * +------+------+------+...+------+\r\n * | 0/10 | 1/13 | 2/14 |   | 90/0 |  Keys after\r\n * +------+------+------+...+------+\r\n *    │       │      │          │\r\n *    │       │      └──────────┼────────────┐\r\n *    │       └─────────────────┼─────┐      │\r\n *    └──────────┐              │     │      │\r\n *               │              │     │      │\r\n *    ┌──────────┼──────────────┘     │      │\r\n *    │          │                    │      │\r\n * +------+...+------+------+------+------+------+-----+\r\n * | NEW  |   | AAA  | BBB  | CCC  | DDD  | EEE  | FFF |  Data\r\n * +------+...+------+------+------+------+------+-----+\r\n *   /│\\\r\n *    │\r\n * The first \"hole\" (at index 0) item is permanently removed and replaced by a new item.\r\n * The hole index is taken from the hole collection which act as FIFO (First In First Out).\r\n */\n\n/* eslint-enable jsdoc/require-description-complete-sentence */\n\nvar LazyFactoryMap = /*#__PURE__*/function () {\n  function LazyFactoryMap(valueFactory) {\n    _classCallCheck(this, LazyFactoryMap);\n\n    this.valueFactory = valueFactory;\n    /**\r\n     * An array which contains data.\r\n     *\r\n     * @type {Array}\r\n     */\n\n    this.data = [];\n    /**\r\n     * An array of indexes where the key of the array is mapped to the value which points to the\r\n     * specific position of the data array.\r\n     *\r\n     * @type {number[]}\r\n     */\n\n    this.index = [];\n    /**\r\n     * The collection of indexes that points to the data items which can be replaced by obtaining new\r\n     * ones. The \"holes\" are an intended effect of deleting entries.\r\n     *\r\n     * The idea of \"holes\" generally allows us to not modify the \"data\" structure while removing\r\n     * items from the collection.\r\n     *\r\n     * @type {Set<number>}\r\n     */\n\n    this.holes = new Set();\n  }\n  /**\r\n   * Gets or if data not exist creates and returns new data.\r\n   *\r\n   * @param {number} key The item key as zero-based index.\r\n   * @returns {*}\r\n   */\n\n\n  _createClass(LazyFactoryMap, [{\n    key: \"obtain\",\n    value: function obtain(key) {\n      assert(function () {\n        return isUnsignedNumber(key);\n      }, 'Expecting an unsigned number.');\n\n      var dataIndex = this._getStorageIndexByKey(key);\n\n      var result;\n\n      if (dataIndex >= 0) {\n        result = this.data[dataIndex];\n\n        if (result === void 0) {\n          result = this.valueFactory(key);\n          this.data[dataIndex] = result;\n        }\n      } else {\n        result = this.valueFactory(key);\n\n        if (this.holes.size > 0) {\n          var reuseIndex = this.holes.values().next().value; // Gets first item from the collection\n\n          this.holes.delete(reuseIndex);\n          this.data[reuseIndex] = result;\n          this.index[key] = reuseIndex;\n        } else {\n          this.data.push(result);\n          this.index[key] = this.data.length - 1;\n        }\n      }\n\n      return result;\n    }\n    /**\r\n     * Inserts an empty data to the map. This method creates an empty space for obtaining\r\n     * new data.\r\n     *\r\n     * @param {number} key The key as volatile zero-based index at which to begin inserting space for new data.\r\n     * @param {number} [amount=1] Ammount of data to insert.\r\n     */\n\n  }, {\n    key: \"insert\",\n    value: function insert(key) {\n      var _this$index;\n\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      assert(function () {\n        return isUnsignedNumber(key) || isNullish(key);\n      }, 'Expecting an unsigned number or null/undefined argument.');\n      var newIndexes = [];\n      var dataLength = this.data.length;\n\n      for (var i = 0; i < amount; i++) {\n        newIndexes.push(dataLength + i);\n        this.data.push(void 0);\n      }\n\n      (_this$index = this.index).splice.apply(_this$index, [isNullish(key) ? this.index.length : key, 0].concat(newIndexes));\n    }\n    /**\r\n     * Removes (soft remove) data from \"index\" and according to the amount of data.\r\n     *\r\n     * @param {number} key The key as volatile zero-based index at which to begin removing the data.\r\n     * @param {number} [amount=1] Ammount data to remove.\r\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(key) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      assert(function () {\n        return isUnsignedNumber(key) || isNullish(key);\n      }, 'Expecting an unsigned number or null/undefined argument.');\n      var removed = this.index.splice(isNullish(key) ? this.index.length - amount : key, amount);\n\n      for (var i = 0; i < removed.length; i++) {\n        var removedIndex = removed[i];\n\n        if (typeof removedIndex === 'number') {\n          this.holes.add(removedIndex);\n        }\n      }\n    }\n    /**\r\n     * Returns the size of the data which this map holds.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this.data.length - this.holes.size;\n    }\n    /**\r\n     * Returns a new Iterator object that contains the values for each item in the LazyMap object.\r\n     *\r\n     * @returns {Iterator}\r\n     */\n\n  }, {\n    key: \"values\",\n    value: function values() {\n      var _this = this;\n\n      return arrayFilter(this.data, function (_, index) {\n        return !_this.holes.has(index);\n      })[Symbol.iterator]();\n    }\n    /**\r\n     * Returns a new Iterator object that contains an array of `[index, value]` for each item in the LazyMap object.\r\n     *\r\n     * @returns {Iterator}\r\n     */\n\n  }, {\n    key: \"entries\",\n    value: function entries() {\n      var validEntries = [];\n\n      for (var i = 0; i < this.data.length; i++) {\n        var keyIndex = this._getKeyByStorageIndex(i);\n\n        if (keyIndex !== -1) {\n          validEntries.push([keyIndex, this.data[i]]);\n        }\n      }\n\n      var dataIndex = 0;\n      return {\n        next: function next() {\n          if (dataIndex < validEntries.length) {\n            var value = validEntries[dataIndex];\n            dataIndex += 1;\n            return {\n              value: value,\n              done: false\n            };\n          }\n\n          return {\n            done: true\n          };\n        }\n      };\n    }\n    /**\r\n     * Clears the map.\r\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.data = [];\n      this.index = [];\n      this.holes.clear();\n    }\n    /**\r\n     * Gets storage index calculated from the key associated with the specified value.\r\n     *\r\n     * @param {number} key Volatile zero-based index.\r\n     * @returns {number} Returns index 0-N or -1 if no storage index found.\r\n     */\n\n  }, {\n    key: \"_getStorageIndexByKey\",\n    value: function _getStorageIndexByKey(key) {\n      return this.index.length > key ? this.index[key] : -1;\n    }\n    /**\r\n     * Gets the key associated with the specified value calculated from storage index.\r\n     *\r\n     * @param {number} dataIndex Zero-based storage index.\r\n     * @returns {number} Returns index 0-N or -1 if no key found.\r\n     */\n\n  }, {\n    key: \"_getKeyByStorageIndex\",\n    value: function _getKeyByStorageIndex(dataIndex) {\n      return this.index.indexOf(dataIndex);\n    }\n    /**\r\n     * Makes this object iterable.\r\n     *\r\n     * @returns {Iterator}\r\n     */\n\n  }, {\n    key: Symbol.iterator,\n    value: function value() {\n      return this.entries();\n    }\n  }]);\n\n  return LazyFactoryMap;\n}();\n\nexport { LazyFactoryMap as default };","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/dataMap/metaManager/lazyFactoryMap.mjs"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","arrayFilter","assert","isUnsignedNumber","isNullish","LazyFactoryMap","valueFactory","data","index","holes","Set","value","obtain","dataIndex","_getStorageIndexByKey","result","size","reuseIndex","values","next","delete","push","insert","_this$index","amount","arguments","undefined","newIndexes","dataLength","splice","apply","concat","remove","removed","removedIndex","add","_this","_","has","Symbol","iterator","entries","validEntries","keyIndex","_getKeyByStorageIndex","done","clear","indexOf","default"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.iterator.js\";\r\nimport \"core-js/modules/es.object.to-string.js\";\r\nimport \"core-js/modules/es.set.js\";\r\nimport \"core-js/modules/es.string.iterator.js\";\r\nimport \"core-js/modules/web.dom-collections.iterator.js\";\r\nimport \"core-js/modules/es.array.splice.js\";\r\nimport \"core-js/modules/es.array.concat.js\";\r\nimport \"core-js/modules/es.symbol.iterator.js\";\r\nimport \"core-js/modules/es.symbol.js\";\r\nimport \"core-js/modules/es.symbol.description.js\";\r\nimport \"core-js/modules/es.array.index-of.js\";\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport { arrayFilter } from \"../../helpers/array.mjs\";\r\nimport { assert, isUnsignedNumber, isNullish } from \"./utils.mjs\";\r\n/* eslint-disable jsdoc/require-description-complete-sentence */\r\n\r\n/**\r\n * @class LazyFactoryMap\r\n *\r\n * The LazyFactoryMap object holds key-value pairs in the structure similar to the\r\n * regular Map. Once created, items can be moved around a grid depending on the operations\r\n * performed on that grid - adding or removing rows. The collection requires \"key\"\r\n * to be a zero-based index.\r\n *\r\n * It's essential to notice that the \"key\" index under which the item was created\r\n * is volatile. After altering the grid, the \"key\" index can change.\r\n *\r\n * Having created N items with corresponding example data where the data has 10\r\n * holes (`undefined` values) within (that's why internal storage index counts from 10).\r\n * +------+------+------+------+------+.\r\n * | 0/10 | 1/11 | 2/12 | 3/13 | 4/14 |  Keys (volatile zero-based index / internal storage index)\r\n * +------+------+------+------+------+.\r\n *    │      │      │      │      │\r\n * +------+------+------+------+------+.\r\n * | AAA  | BBB  | CCC  | DDD  | EEE  |  Data\r\n * +------+------+------+------+------+.\r\n *\r\n * Map.obtain(0) // returns \"AAA\"\r\n * map.obtain(2) // returns \"CCC\".\r\n *\r\n * After inserting 2 new rows, keys that hold the data positioned after the place\r\n * where the new rows are added are upshifted by 2.\r\n *               │\r\n *               │ Insert 2 rows\r\n *              \\│/\r\n * +------+------+------+------+------+.\r\n * | 0/10 | 1/11 | 2/12 | 3/13 | 4/14 |  Keys before\r\n * +------+------+------+------+------+.\r\n *\r\n *                / 2 new rows \\\r\n * +------+------+------+------+------+------+------+.\r\n * | 0/10 | 1/11 | 2/15 | 3/16 | 4/12 | 5/13 | 6/14 |  Keys after\r\n * +------+------+------+------+------+------+------+.\r\n *    │       │      │      │      │      │     │\r\n *    │       │      └──────┼──────┼──────┼┐    │\r\n *    │       │             └──────┼──────┼┼────┼┐\r\n *    │       │      ┌─────────────┘      ││    ││\r\n *    │       │      │      ┌─────────────┘│    ││\r\n *    │       │      │      │      ┌───────┼────┘│\r\n *    │       │      │      │      │       │     │\r\n * +------+------+------+------+------+------+------+.\r\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\r\n * +------+------+------+------+------+------+------+\r\n *\r\n * Now at index 2 and 3 we have access to new items.\r\n *\r\n * map.obtain(2) // returns new value \"FFF\" for newly created row.\r\n * map.obtain(4) // index shifted by 2 has access to the old \"CCC\" value, as before inserting.\r\n *\r\n * after removing 4 rows, keys that hold the data positioned after the place where the\r\n * rows are removed are downshifted by 4.\r\n *        │\r\n *        │ Remove 4 rows\r\n *        ├───────────────────────────┐\r\n *       \\│/                          │\r\n * +------+------+------+------+------+------+------+\r\n * | 0/10 | 1/11 | 2/15 | 3/16 | 4/12 | 5/13 | 6/14 |  Keys after\r\n * +------+------+------+------+------+------+------+\r\n *    │       │      │      │      │      │     │\r\n *    │       │      └──────┼──────┼──────┼┐    │\r\n *    │       │             └──────┼──────┼┼────┼┐\r\n *    │       │      ┌─────────────┘      ││    ││\r\n *    │       │      │      ┌─────────────┘│    ││\r\n *    │       │      │      │      ┌───────┼────┘│\r\n *    │       │      │      │      │       │     │\r\n * +------+------+------+------+------+------+------+\r\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\r\n * +------+------+------+------+------+------+------+\r\n *\r\n * +------+------+------+\r\n * | 0/10 | 1/13 | 2/14 |  Keys after\r\n * +------+------+------+\r\n *    │       │      │\r\n *    │       │      └─────────────┐\r\n *    │       └────────────┐       │\r\n *    │                    │       │\r\n *    │                    │       │\r\n *    │                    │       │\r\n *    │                    │       │\r\n * +------+------+------+------+------+------+------+\r\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\r\n * +------+------+------+------+------+------+------+\r\n *           /│\\   /│\\                   /│\\   /│\\\r\n *            └──┬──┘                     └──┬──┘\r\n *           This data is marked as \"hole\" which\r\n *           means that can be replaced by new item\r\n *           when that will be created.\r\n *\r\n * map.obtain(2) // returns the value (\"EEE\") as it should. Access to the value is\r\n *               // changed (the key was downshifted). However, the internal index has not changed,\r\n *               // which means that the data does not need to be changed (spliced) too.\r\n *\r\n * After previous remove operation which creates some \"holes\" obtaining new\r\n * items replaces that \"holes\" as follows:\r\n *\r\n * // Obtains new item\r\n * map.obtain(90) // Returns \"NEW\" value\r\n *\r\n * +------+------+------+...+------+\r\n * | 0/10 | 1/13 | 2/14 |   | 90/0 |  Keys after\r\n * +------+------+------+...+------+\r\n *    │       │      │          │\r\n *    │       │      └──────────┼────────────┐\r\n *    │       └─────────────────┼─────┐      │\r\n *    └──────────┐              │     │      │\r\n *               │              │     │      │\r\n *    ┌──────────┼──────────────┘     │      │\r\n *    │          │                    │      │\r\n * +------+...+------+------+------+------+------+-----+\r\n * | NEW  |   | AAA  | BBB  | CCC  | DDD  | EEE  | FFF |  Data\r\n * +------+...+------+------+------+------+------+-----+\r\n *   /│\\\r\n *    │\r\n * The first \"hole\" (at index 0) item is permanently removed and replaced by a new item.\r\n * The hole index is taken from the hole collection which act as FIFO (First In First Out).\r\n */\r\n\r\n/* eslint-enable jsdoc/require-description-complete-sentence */\r\n\r\nvar LazyFactoryMap = /*#__PURE__*/function () {\r\n  function LazyFactoryMap(valueFactory) {\r\n    _classCallCheck(this, LazyFactoryMap);\r\n\r\n    this.valueFactory = valueFactory;\r\n    /**\r\n     * An array which contains data.\r\n     *\r\n     * @type {Array}\r\n     */\r\n\r\n    this.data = [];\r\n    /**\r\n     * An array of indexes where the key of the array is mapped to the value which points to the\r\n     * specific position of the data array.\r\n     *\r\n     * @type {number[]}\r\n     */\r\n\r\n    this.index = [];\r\n    /**\r\n     * The collection of indexes that points to the data items which can be replaced by obtaining new\r\n     * ones. The \"holes\" are an intended effect of deleting entries.\r\n     *\r\n     * The idea of \"holes\" generally allows us to not modify the \"data\" structure while removing\r\n     * items from the collection.\r\n     *\r\n     * @type {Set<number>}\r\n     */\r\n\r\n    this.holes = new Set();\r\n  }\r\n  /**\r\n   * Gets or if data not exist creates and returns new data.\r\n   *\r\n   * @param {number} key The item key as zero-based index.\r\n   * @returns {*}\r\n   */\r\n\r\n\r\n  _createClass(LazyFactoryMap, [{\r\n    key: \"obtain\",\r\n    value: function obtain(key) {\r\n      assert(function () {\r\n        return isUnsignedNumber(key);\r\n      }, 'Expecting an unsigned number.');\r\n\r\n      var dataIndex = this._getStorageIndexByKey(key);\r\n\r\n      var result;\r\n\r\n      if (dataIndex >= 0) {\r\n        result = this.data[dataIndex];\r\n\r\n        if (result === void 0) {\r\n          result = this.valueFactory(key);\r\n          this.data[dataIndex] = result;\r\n        }\r\n      } else {\r\n        result = this.valueFactory(key);\r\n\r\n        if (this.holes.size > 0) {\r\n          var reuseIndex = this.holes.values().next().value; // Gets first item from the collection\r\n\r\n          this.holes.delete(reuseIndex);\r\n          this.data[reuseIndex] = result;\r\n          this.index[key] = reuseIndex;\r\n        } else {\r\n          this.data.push(result);\r\n          this.index[key] = this.data.length - 1;\r\n        }\r\n      }\r\n\r\n      return result;\r\n    }\r\n    /**\r\n     * Inserts an empty data to the map. This method creates an empty space for obtaining\r\n     * new data.\r\n     *\r\n     * @param {number} key The key as volatile zero-based index at which to begin inserting space for new data.\r\n     * @param {number} [amount=1] Ammount of data to insert.\r\n     */\r\n\r\n  }, {\r\n    key: \"insert\",\r\n    value: function insert(key) {\r\n      var _this$index;\r\n\r\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\r\n      assert(function () {\r\n        return isUnsignedNumber(key) || isNullish(key);\r\n      }, 'Expecting an unsigned number or null/undefined argument.');\r\n      var newIndexes = [];\r\n      var dataLength = this.data.length;\r\n\r\n      for (var i = 0; i < amount; i++) {\r\n        newIndexes.push(dataLength + i);\r\n        this.data.push(void 0);\r\n      }\r\n\r\n      (_this$index = this.index).splice.apply(_this$index, [isNullish(key) ? this.index.length : key, 0].concat(newIndexes));\r\n    }\r\n    /**\r\n     * Removes (soft remove) data from \"index\" and according to the amount of data.\r\n     *\r\n     * @param {number} key The key as volatile zero-based index at which to begin removing the data.\r\n     * @param {number} [amount=1] Ammount data to remove.\r\n     */\r\n\r\n  }, {\r\n    key: \"remove\",\r\n    value: function remove(key) {\r\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\r\n      assert(function () {\r\n        return isUnsignedNumber(key) || isNullish(key);\r\n      }, 'Expecting an unsigned number or null/undefined argument.');\r\n      var removed = this.index.splice(isNullish(key) ? this.index.length - amount : key, amount);\r\n\r\n      for (var i = 0; i < removed.length; i++) {\r\n        var removedIndex = removed[i];\r\n\r\n        if (typeof removedIndex === 'number') {\r\n          this.holes.add(removedIndex);\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Returns the size of the data which this map holds.\r\n     *\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"size\",\r\n    value: function size() {\r\n      return this.data.length - this.holes.size;\r\n    }\r\n    /**\r\n     * Returns a new Iterator object that contains the values for each item in the LazyMap object.\r\n     *\r\n     * @returns {Iterator}\r\n     */\r\n\r\n  }, {\r\n    key: \"values\",\r\n    value: function values() {\r\n      var _this = this;\r\n\r\n      return arrayFilter(this.data, function (_, index) {\r\n        return !_this.holes.has(index);\r\n      })[Symbol.iterator]();\r\n    }\r\n    /**\r\n     * Returns a new Iterator object that contains an array of `[index, value]` for each item in the LazyMap object.\r\n     *\r\n     * @returns {Iterator}\r\n     */\r\n\r\n  }, {\r\n    key: \"entries\",\r\n    value: function entries() {\r\n      var validEntries = [];\r\n\r\n      for (var i = 0; i < this.data.length; i++) {\r\n        var keyIndex = this._getKeyByStorageIndex(i);\r\n\r\n        if (keyIndex !== -1) {\r\n          validEntries.push([keyIndex, this.data[i]]);\r\n        }\r\n      }\r\n\r\n      var dataIndex = 0;\r\n      return {\r\n        next: function next() {\r\n          if (dataIndex < validEntries.length) {\r\n            var value = validEntries[dataIndex];\r\n            dataIndex += 1;\r\n            return {\r\n              value: value,\r\n              done: false\r\n            };\r\n          }\r\n\r\n          return {\r\n            done: true\r\n          };\r\n        }\r\n      };\r\n    }\r\n    /**\r\n     * Clears the map.\r\n     */\r\n\r\n  }, {\r\n    key: \"clear\",\r\n    value: function clear() {\r\n      this.data = [];\r\n      this.index = [];\r\n      this.holes.clear();\r\n    }\r\n    /**\r\n     * Gets storage index calculated from the key associated with the specified value.\r\n     *\r\n     * @param {number} key Volatile zero-based index.\r\n     * @returns {number} Returns index 0-N or -1 if no storage index found.\r\n     */\r\n\r\n  }, {\r\n    key: \"_getStorageIndexByKey\",\r\n    value: function _getStorageIndexByKey(key) {\r\n      return this.index.length > key ? this.index[key] : -1;\r\n    }\r\n    /**\r\n     * Gets the key associated with the specified value calculated from storage index.\r\n     *\r\n     * @param {number} dataIndex Zero-based storage index.\r\n     * @returns {number} Returns index 0-N or -1 if no key found.\r\n     */\r\n\r\n  }, {\r\n    key: \"_getKeyByStorageIndex\",\r\n    value: function _getKeyByStorageIndex(dataIndex) {\r\n      return this.index.indexOf(dataIndex);\r\n    }\r\n    /**\r\n     * Makes this object iterable.\r\n     *\r\n     * @returns {Iterator}\r\n     */\r\n\r\n  }, {\r\n    key: Symbol.iterator,\r\n    value: function value() {\r\n      return this.entries();\r\n    }\r\n  }]);\r\n\r\n  return LazyFactoryMap;\r\n}();\r\n\r\nexport { LazyFactoryMap as default };"]},"metadata":{},"sourceType":"module"}