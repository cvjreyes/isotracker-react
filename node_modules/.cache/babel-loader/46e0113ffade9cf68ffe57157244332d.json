{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { addClass, fastInnerText, removeClass } from \"./../../../helpers/dom/element.mjs\";\nimport { objectEach } from \"./../../../helpers/object.mjs\";\nimport { randomString } from \"./../../../helpers/string.mjs\";\nimport Event from \"./event.mjs\";\nimport Overlays from \"./overlays.mjs\";\nimport Scroll from \"./scroll.mjs\";\nimport Settings from \"./settings.mjs\";\nimport MasterTable from \"./table/master.mjs\";\nimport Viewport from \"./viewport.mjs\";\n/**\r\n * @class Walkontable\r\n */\n\nvar Walkontable = /*#__PURE__*/function () {\n  /**\r\n   * @param {object} settings The Walkontable settings.\r\n   */\n  function Walkontable(settings) {\n    _classCallCheck(this, Walkontable);\n\n    var originalHeaders = []; // this is the namespace for global events\n\n    this.guid = \"wt_\".concat(randomString());\n    this.rootDocument = settings.table.ownerDocument;\n    this.rootWindow = this.rootDocument.defaultView; // bootstrap from settings\n\n    if (settings.cloneSource) {\n      this.cloneSource = settings.cloneSource;\n      this.cloneOverlay = settings.cloneOverlay;\n      this.wtSettings = settings.cloneSource.wtSettings;\n      this.wtTable = this.cloneOverlay.createTable(this, settings.table);\n      this.wtScroll = new Scroll(this);\n      this.wtViewport = settings.cloneSource.wtViewport;\n      this.wtEvent = new Event(this);\n      this.selections = this.cloneSource.selections;\n    } else {\n      this.wtSettings = new Settings(this, settings);\n      this.wtTable = new MasterTable(this, settings.table);\n      this.wtScroll = new Scroll(this);\n      this.wtViewport = new Viewport(this);\n      this.wtEvent = new Event(this);\n      this.selections = this.getSetting('selections');\n      this.wtOverlays = new Overlays(this);\n      this.exportSettingsAsClassNames();\n    } // find original headers\n\n\n    if (this.wtTable.THEAD.childNodes.length && this.wtTable.THEAD.childNodes[0].childNodes.length) {\n      for (var c = 0, clen = this.wtTable.THEAD.childNodes[0].childNodes.length; c < clen; c++) {\n        originalHeaders.push(this.wtTable.THEAD.childNodes[0].childNodes[c].innerHTML);\n      }\n\n      if (!this.getSetting('columnHeaders').length) {\n        this.update('columnHeaders', [function (column, TH) {\n          fastInnerText(TH, originalHeaders[column]);\n        }]);\n      }\n    }\n\n    this.drawn = false;\n    this.drawInterrupted = false;\n  }\n  /**\r\n   * Force rerender of Walkontable.\r\n   *\r\n   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\r\n   *                                   the data. It will only work if Table.draw() does not force\r\n   *                                   rendering anyway.\r\n   * @returns {Walkontable}\r\n   */\n\n\n  _createClass(Walkontable, [{\n    key: \"draw\",\n    value: function draw() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.drawInterrupted = false;\n\n      if (!fastDraw && !this.wtTable.isVisible()) {\n        // draw interrupted because TABLE is not visible\n        this.drawInterrupted = true;\n      } else {\n        this.wtTable.draw(fastDraw);\n      }\n\n      return this;\n    }\n    /**\r\n     * Returns the TD at coords. If topmost is set to true, returns TD from the topmost overlay layer,\r\n     * if not set or set to false, returns TD from the master table.\r\n     *\r\n     * @param {CellCoords} coords The cell coordinates.\r\n     * @param {boolean} [topmost=false] If set to `true`, it returns the TD element from the topmost overlay. For example,\r\n     *                                  if the wanted cell is in the range of fixed rows, it will return a TD element\r\n     *                                  from the top overlay.\r\n     * @returns {HTMLElement}\r\n     */\n\n  }, {\n    key: \"getCell\",\n    value: function getCell(coords) {\n      var topmost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (!topmost) {\n        return this.wtTable.getCell(coords);\n      }\n\n      var totalRows = this.wtSettings.getSetting('totalRows');\n      var fixedRowsTop = this.wtSettings.getSetting('fixedRowsTop');\n      var fixedRowsBottom = this.wtSettings.getSetting('fixedRowsBottom');\n      var fixedColumns = this.wtSettings.getSetting('fixedColumnsLeft');\n\n      if (coords.row < fixedRowsTop && coords.col < fixedColumns) {\n        return this.wtOverlays.topLeftCornerOverlay.clone.wtTable.getCell(coords);\n      } else if (coords.row < fixedRowsTop) {\n        return this.wtOverlays.topOverlay.clone.wtTable.getCell(coords);\n      } else if (coords.col < fixedColumns && coords.row >= totalRows - fixedRowsBottom) {\n        if (this.wtOverlays.bottomLeftCornerOverlay && this.wtOverlays.bottomLeftCornerOverlay.clone) {\n          return this.wtOverlays.bottomLeftCornerOverlay.clone.wtTable.getCell(coords);\n        }\n      } else if (coords.col < fixedColumns) {\n        return this.wtOverlays.leftOverlay.clone.wtTable.getCell(coords);\n      } else if (coords.row < totalRows && coords.row >= totalRows - fixedRowsBottom) {\n        if (this.wtOverlays.bottomOverlay && this.wtOverlays.bottomOverlay.clone) {\n          return this.wtOverlays.bottomOverlay.clone.wtTable.getCell(coords);\n        }\n      }\n\n      return this.wtTable.getCell(coords);\n    }\n    /**\r\n     * @param {object} settings The singular settings to update or if passed as object to merge with.\r\n     * @param {*} value The value to set if the first argument is passed as string.\r\n     * @returns {Walkontable}\r\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(settings, value) {\n      return this.wtSettings.update(settings, value);\n    }\n    /**\r\n     * Scrolls the viewport to a cell (rerenders if needed).\r\n     *\r\n     * @param {CellCoords} coords The cell coordinates to scroll to.\r\n     * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\r\n     * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\r\n     * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\r\n     * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"scrollViewport\",\n    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n      if (coords.col < 0 || coords.row < 0) {\n        return false;\n      }\n\n      return this.wtScroll.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);\n    }\n    /**\r\n     * Scrolls the viewport to a column (rerenders if needed).\r\n     *\r\n     * @param {number} column Visual column index.\r\n     * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\r\n     * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"scrollViewportHorizontally\",\n    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n      if (column < 0) {\n        return false;\n      }\n\n      return this.wtScroll.scrollViewportHorizontally(column, snapToRight, snapToLeft);\n    }\n    /**\r\n     * Scrolls the viewport to a row (rerenders if needed).\r\n     *\r\n     * @param {number} row Visual row index.\r\n     * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\r\n     * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"scrollViewportVertically\",\n    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {\n      if (row < 0) {\n        return false;\n      }\n\n      return this.wtScroll.scrollViewportVertically(row, snapToTop, snapToBottom);\n    }\n    /**\r\n     * @returns {Array}\r\n     */\n\n  }, {\n    key: \"getViewport\",\n    value: function getViewport() {\n      return [this.wtTable.getFirstVisibleRow(), this.wtTable.getFirstVisibleColumn(), this.wtTable.getLastVisibleRow(), this.wtTable.getLastVisibleColumn()];\n    }\n    /**\r\n     * Get overlay name.\r\n     *\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: \"getOverlayName\",\n    value: function getOverlayName() {\n      return this.cloneOverlay ? this.cloneOverlay.type : 'master';\n    }\n    /**\r\n     * Export settings as class names added to the parent element of the table.\r\n     */\n\n  }, {\n    key: \"exportSettingsAsClassNames\",\n    value: function exportSettingsAsClassNames() {\n      var _this = this;\n\n      var toExport = {\n        rowHeaders: 'htRowHeaders',\n        columnHeaders: 'htColumnHeaders'\n      };\n      var allClassNames = [];\n      var newClassNames = [];\n      objectEach(toExport, function (className, key) {\n        if (_this.getSetting(key).length) {\n          newClassNames.push(className);\n        }\n\n        allClassNames.push(className);\n      });\n      removeClass(this.wtTable.wtRootElement.parentNode, allClassNames);\n      addClass(this.wtTable.wtRootElement.parentNode, newClassNames);\n    }\n    /**\r\n     * Get/Set Walkontable instance setting.\r\n     *\r\n     * @param {string} key The settings key to retrieve.\r\n     * @param {*} [param1] Additional parameter passed to the options defined as function.\r\n     * @param {*} [param2] Additional parameter passed to the options defined as function.\r\n     * @param {*} [param3] Additional parameter passed to the options defined as function.\r\n     * @param {*} [param4] Additional parameter passed to the options defined as function.\r\n     * @returns {*}\r\n     */\n\n  }, {\n    key: \"getSetting\",\n    value: function getSetting(key, param1, param2, param3, param4) {\n      // this is faster than .apply - https://github.com/handsontable/handsontable/wiki/JavaScript-&-DOM-performance-tips\n      return this.wtSettings.getSetting(key, param1, param2, param3, param4);\n    }\n    /**\r\n     * Checks if setting exists.\r\n     *\r\n     * @param {string} key The settings key to check.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"hasSetting\",\n    value: function hasSetting(key) {\n      return this.wtSettings.has(key);\n    }\n    /**\r\n     * Destroy instance.\r\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.wtOverlays.destroy();\n      this.wtEvent.destroy();\n    }\n  }]);\n\n  return Walkontable;\n}();\n\nexport default Walkontable;","map":{"version":3,"sources":["C:/Users/ssaez1/technip-repositories/isotracker/isotracker-react/node_modules/handsontable/3rdparty/walkontable/src/core.mjs"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","addClass","fastInnerText","removeClass","objectEach","randomString","Event","Overlays","Scroll","Settings","MasterTable","Viewport","Walkontable","settings","originalHeaders","guid","concat","rootDocument","table","ownerDocument","rootWindow","defaultView","cloneSource","cloneOverlay","wtSettings","wtTable","createTable","wtScroll","wtViewport","wtEvent","selections","getSetting","wtOverlays","exportSettingsAsClassNames","THEAD","childNodes","c","clen","push","innerHTML","update","column","TH","drawn","drawInterrupted","value","draw","fastDraw","arguments","undefined","isVisible","getCell","coords","topmost","totalRows","fixedRowsTop","fixedRowsBottom","fixedColumns","row","col","topLeftCornerOverlay","clone","topOverlay","bottomLeftCornerOverlay","leftOverlay","bottomOverlay","scrollViewport","snapToTop","snapToRight","snapToBottom","snapToLeft","scrollViewportHorizontally","scrollViewportVertically","getViewport","getFirstVisibleRow","getFirstVisibleColumn","getLastVisibleRow","getLastVisibleColumn","getOverlayName","type","_this","toExport","rowHeaders","columnHeaders","allClassNames","newClassNames","className","wtRootElement","parentNode","param1","param2","param3","param4","hasSetting","has","destroy"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport { addClass, fastInnerText, removeClass } from \"./../../../helpers/dom/element.mjs\";\r\nimport { objectEach } from \"./../../../helpers/object.mjs\";\r\nimport { randomString } from \"./../../../helpers/string.mjs\";\r\nimport Event from \"./event.mjs\";\r\nimport Overlays from \"./overlays.mjs\";\r\nimport Scroll from \"./scroll.mjs\";\r\nimport Settings from \"./settings.mjs\";\r\nimport MasterTable from \"./table/master.mjs\";\r\nimport Viewport from \"./viewport.mjs\";\r\n/**\r\n * @class Walkontable\r\n */\r\n\r\nvar Walkontable = /*#__PURE__*/function () {\r\n  /**\r\n   * @param {object} settings The Walkontable settings.\r\n   */\r\n  function Walkontable(settings) {\r\n    _classCallCheck(this, Walkontable);\r\n\r\n    var originalHeaders = []; // this is the namespace for global events\r\n\r\n    this.guid = \"wt_\".concat(randomString());\r\n    this.rootDocument = settings.table.ownerDocument;\r\n    this.rootWindow = this.rootDocument.defaultView; // bootstrap from settings\r\n\r\n    if (settings.cloneSource) {\r\n      this.cloneSource = settings.cloneSource;\r\n      this.cloneOverlay = settings.cloneOverlay;\r\n      this.wtSettings = settings.cloneSource.wtSettings;\r\n      this.wtTable = this.cloneOverlay.createTable(this, settings.table);\r\n      this.wtScroll = new Scroll(this);\r\n      this.wtViewport = settings.cloneSource.wtViewport;\r\n      this.wtEvent = new Event(this);\r\n      this.selections = this.cloneSource.selections;\r\n    } else {\r\n      this.wtSettings = new Settings(this, settings);\r\n      this.wtTable = new MasterTable(this, settings.table);\r\n      this.wtScroll = new Scroll(this);\r\n      this.wtViewport = new Viewport(this);\r\n      this.wtEvent = new Event(this);\r\n      this.selections = this.getSetting('selections');\r\n      this.wtOverlays = new Overlays(this);\r\n      this.exportSettingsAsClassNames();\r\n    } // find original headers\r\n\r\n\r\n    if (this.wtTable.THEAD.childNodes.length && this.wtTable.THEAD.childNodes[0].childNodes.length) {\r\n      for (var c = 0, clen = this.wtTable.THEAD.childNodes[0].childNodes.length; c < clen; c++) {\r\n        originalHeaders.push(this.wtTable.THEAD.childNodes[0].childNodes[c].innerHTML);\r\n      }\r\n\r\n      if (!this.getSetting('columnHeaders').length) {\r\n        this.update('columnHeaders', [function (column, TH) {\r\n          fastInnerText(TH, originalHeaders[column]);\r\n        }]);\r\n      }\r\n    }\r\n\r\n    this.drawn = false;\r\n    this.drawInterrupted = false;\r\n  }\r\n  /**\r\n   * Force rerender of Walkontable.\r\n   *\r\n   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\r\n   *                                   the data. It will only work if Table.draw() does not force\r\n   *                                   rendering anyway.\r\n   * @returns {Walkontable}\r\n   */\r\n\r\n\r\n  _createClass(Walkontable, [{\r\n    key: \"draw\",\r\n    value: function draw() {\r\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\r\n      this.drawInterrupted = false;\r\n\r\n      if (!fastDraw && !this.wtTable.isVisible()) {\r\n        // draw interrupted because TABLE is not visible\r\n        this.drawInterrupted = true;\r\n      } else {\r\n        this.wtTable.draw(fastDraw);\r\n      }\r\n\r\n      return this;\r\n    }\r\n    /**\r\n     * Returns the TD at coords. If topmost is set to true, returns TD from the topmost overlay layer,\r\n     * if not set or set to false, returns TD from the master table.\r\n     *\r\n     * @param {CellCoords} coords The cell coordinates.\r\n     * @param {boolean} [topmost=false] If set to `true`, it returns the TD element from the topmost overlay. For example,\r\n     *                                  if the wanted cell is in the range of fixed rows, it will return a TD element\r\n     *                                  from the top overlay.\r\n     * @returns {HTMLElement}\r\n     */\r\n\r\n  }, {\r\n    key: \"getCell\",\r\n    value: function getCell(coords) {\r\n      var topmost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n\r\n      if (!topmost) {\r\n        return this.wtTable.getCell(coords);\r\n      }\r\n\r\n      var totalRows = this.wtSettings.getSetting('totalRows');\r\n      var fixedRowsTop = this.wtSettings.getSetting('fixedRowsTop');\r\n      var fixedRowsBottom = this.wtSettings.getSetting('fixedRowsBottom');\r\n      var fixedColumns = this.wtSettings.getSetting('fixedColumnsLeft');\r\n\r\n      if (coords.row < fixedRowsTop && coords.col < fixedColumns) {\r\n        return this.wtOverlays.topLeftCornerOverlay.clone.wtTable.getCell(coords);\r\n      } else if (coords.row < fixedRowsTop) {\r\n        return this.wtOverlays.topOverlay.clone.wtTable.getCell(coords);\r\n      } else if (coords.col < fixedColumns && coords.row >= totalRows - fixedRowsBottom) {\r\n        if (this.wtOverlays.bottomLeftCornerOverlay && this.wtOverlays.bottomLeftCornerOverlay.clone) {\r\n          return this.wtOverlays.bottomLeftCornerOverlay.clone.wtTable.getCell(coords);\r\n        }\r\n      } else if (coords.col < fixedColumns) {\r\n        return this.wtOverlays.leftOverlay.clone.wtTable.getCell(coords);\r\n      } else if (coords.row < totalRows && coords.row >= totalRows - fixedRowsBottom) {\r\n        if (this.wtOverlays.bottomOverlay && this.wtOverlays.bottomOverlay.clone) {\r\n          return this.wtOverlays.bottomOverlay.clone.wtTable.getCell(coords);\r\n        }\r\n      }\r\n\r\n      return this.wtTable.getCell(coords);\r\n    }\r\n    /**\r\n     * @param {object} settings The singular settings to update or if passed as object to merge with.\r\n     * @param {*} value The value to set if the first argument is passed as string.\r\n     * @returns {Walkontable}\r\n     */\r\n\r\n  }, {\r\n    key: \"update\",\r\n    value: function update(settings, value) {\r\n      return this.wtSettings.update(settings, value);\r\n    }\r\n    /**\r\n     * Scrolls the viewport to a cell (rerenders if needed).\r\n     *\r\n     * @param {CellCoords} coords The cell coordinates to scroll to.\r\n     * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\r\n     * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\r\n     * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\r\n     * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"scrollViewport\",\r\n    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\r\n      if (coords.col < 0 || coords.row < 0) {\r\n        return false;\r\n      }\r\n\r\n      return this.wtScroll.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);\r\n    }\r\n    /**\r\n     * Scrolls the viewport to a column (rerenders if needed).\r\n     *\r\n     * @param {number} column Visual column index.\r\n     * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\r\n     * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"scrollViewportHorizontally\",\r\n    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {\r\n      if (column < 0) {\r\n        return false;\r\n      }\r\n\r\n      return this.wtScroll.scrollViewportHorizontally(column, snapToRight, snapToLeft);\r\n    }\r\n    /**\r\n     * Scrolls the viewport to a row (rerenders if needed).\r\n     *\r\n     * @param {number} row Visual row index.\r\n     * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\r\n     * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"scrollViewportVertically\",\r\n    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {\r\n      if (row < 0) {\r\n        return false;\r\n      }\r\n\r\n      return this.wtScroll.scrollViewportVertically(row, snapToTop, snapToBottom);\r\n    }\r\n    /**\r\n     * @returns {Array}\r\n     */\r\n\r\n  }, {\r\n    key: \"getViewport\",\r\n    value: function getViewport() {\r\n      return [this.wtTable.getFirstVisibleRow(), this.wtTable.getFirstVisibleColumn(), this.wtTable.getLastVisibleRow(), this.wtTable.getLastVisibleColumn()];\r\n    }\r\n    /**\r\n     * Get overlay name.\r\n     *\r\n     * @returns {string}\r\n     */\r\n\r\n  }, {\r\n    key: \"getOverlayName\",\r\n    value: function getOverlayName() {\r\n      return this.cloneOverlay ? this.cloneOverlay.type : 'master';\r\n    }\r\n    /**\r\n     * Export settings as class names added to the parent element of the table.\r\n     */\r\n\r\n  }, {\r\n    key: \"exportSettingsAsClassNames\",\r\n    value: function exportSettingsAsClassNames() {\r\n      var _this = this;\r\n\r\n      var toExport = {\r\n        rowHeaders: 'htRowHeaders',\r\n        columnHeaders: 'htColumnHeaders'\r\n      };\r\n      var allClassNames = [];\r\n      var newClassNames = [];\r\n      objectEach(toExport, function (className, key) {\r\n        if (_this.getSetting(key).length) {\r\n          newClassNames.push(className);\r\n        }\r\n\r\n        allClassNames.push(className);\r\n      });\r\n      removeClass(this.wtTable.wtRootElement.parentNode, allClassNames);\r\n      addClass(this.wtTable.wtRootElement.parentNode, newClassNames);\r\n    }\r\n    /**\r\n     * Get/Set Walkontable instance setting.\r\n     *\r\n     * @param {string} key The settings key to retrieve.\r\n     * @param {*} [param1] Additional parameter passed to the options defined as function.\r\n     * @param {*} [param2] Additional parameter passed to the options defined as function.\r\n     * @param {*} [param3] Additional parameter passed to the options defined as function.\r\n     * @param {*} [param4] Additional parameter passed to the options defined as function.\r\n     * @returns {*}\r\n     */\r\n\r\n  }, {\r\n    key: \"getSetting\",\r\n    value: function getSetting(key, param1, param2, param3, param4) {\r\n      // this is faster than .apply - https://github.com/handsontable/handsontable/wiki/JavaScript-&-DOM-performance-tips\r\n      return this.wtSettings.getSetting(key, param1, param2, param3, param4);\r\n    }\r\n    /**\r\n     * Checks if setting exists.\r\n     *\r\n     * @param {string} key The settings key to check.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"hasSetting\",\r\n    value: function hasSetting(key) {\r\n      return this.wtSettings.has(key);\r\n    }\r\n    /**\r\n     * Destroy instance.\r\n     */\r\n\r\n  }, {\r\n    key: \"destroy\",\r\n    value: function destroy() {\r\n      this.wtOverlays.destroy();\r\n      this.wtEvent.destroy();\r\n    }\r\n  }]);\r\n\r\n  return Walkontable;\r\n}();\r\n\r\nexport default Walkontable;"]},"metadata":{},"sourceType":"module"}