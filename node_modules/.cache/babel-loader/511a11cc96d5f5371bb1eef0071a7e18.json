{"ast":null,"code":"import { arrayEach } from \"../../../../helpers/array.mjs\";\nimport { expandNode } from \"./expand.mjs\";\nimport { getFirstChildProperty, isNodeReflectsFirstChildColspan, traverseHiddenNodeColumnIndexes } from \"./utils/tree.mjs\";\n/**\r\n * Collapsing a node is a process where the processing node is collapsed\r\n * to the colspan width of the first child. All node children, except the\r\n * first one, are hidden. To prevent losing a current state of node children\r\n * on the right, all nodes are cloned (and restored while expanding), and\r\n * only then original nodes are modified (hidden in this case).\r\n *\r\n * @param {TreeNode} nodeToProcess A tree node to process.\r\n * @returns {object} Returns an object with properties:\r\n *                    - rollbackModification: The function that rollbacks\r\n *                      the tree to the previous state.\r\n *                    - affectedColumns: The list of the visual column\r\n *                      indexes which are affected. That list is passed\r\n *                      to the hiddens column logic.\r\n *                    - colspanCompensation: The number of colspan by\r\n *                      which the processed node colspan was reduced.\r\n */\n\nexport function collapseNode(nodeToProcess) {\n  var _getFirstChildPropert;\n\n  var nodeData = nodeToProcess.data,\n      nodeChilds = nodeToProcess.childs;\n\n  if (nodeData.isCollapsed || nodeData.isHidden || nodeData.origColspan <= 1) {\n    return {\n      rollbackModification: function rollbackModification() {},\n      affectedColumns: [],\n      colspanCompensation: 0\n    };\n  }\n\n  var isNodeReflected = isNodeReflectsFirstChildColspan(nodeToProcess);\n\n  if (isNodeReflected) {\n    return collapseNode(nodeChilds[0]);\n  }\n\n  nodeData.isCollapsed = true;\n  var allLeavesExceptMostLeft = nodeChilds.slice(1);\n  var affectedColumns = new Set();\n\n  if (allLeavesExceptMostLeft.length > 0) {\n    arrayEach(allLeavesExceptMostLeft, function (node) {\n      traverseHiddenNodeColumnIndexes(node, function (gridColumnIndex) {\n        affectedColumns.add(gridColumnIndex);\n      }); // Clone the tree to preserve original tree state after header expanding.\n\n      node.data.clonedTree = node.cloneTree(); // Hide all leaves except the first leaf on the left (on headers context hide all\n      // headers on the right).\n\n      node.walkDown(function (_ref) {\n        var data = _ref.data;\n        data.isHidden = true;\n      });\n    });\n  } else {\n    var origColspan = nodeData.origColspan,\n        columnIndex = nodeData.columnIndex; // Add column to \"affected\" started from 1. The header without children can not be\n    // collapsed so the first have to be visible (untouched).\n\n    for (var i = 1; i < origColspan; i++) {\n      var gridColumnIndex = columnIndex + i;\n      affectedColumns.add(gridColumnIndex);\n    }\n  } // Calculate by how many colspan it needs to reduce the headings to match them to\n  // the first child colspan width.\n\n\n  var colspanCompensation = nodeData.colspan - ((_getFirstChildPropert = getFirstChildProperty(nodeToProcess, 'colspan')) !== null && _getFirstChildPropert !== void 0 ? _getFirstChildPropert : 1);\n  nodeToProcess.walkUp(function (node) {\n    var data = node.data;\n    data.colspan -= colspanCompensation;\n\n    if (data.colspan <= 1) {\n      data.colspan = 1;\n      data.isCollapsed = true;\n    } else if (isNodeReflectsFirstChildColspan(node)) {\n      data.isCollapsed = getFirstChildProperty(node, 'isCollapsed');\n    }\n  });\n  return {\n    rollbackModification: function rollbackModification() {\n      return expandNode(nodeToProcess);\n    },\n    affectedColumns: Array.from(affectedColumns),\n    colspanCompensation: colspanCompensation\n  };\n}","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/collapse.mjs"],"names":["arrayEach","expandNode","getFirstChildProperty","isNodeReflectsFirstChildColspan","traverseHiddenNodeColumnIndexes","collapseNode","nodeToProcess","_getFirstChildPropert","nodeData","data","nodeChilds","childs","isCollapsed","isHidden","origColspan","rollbackModification","affectedColumns","colspanCompensation","isNodeReflected","allLeavesExceptMostLeft","slice","Set","length","node","gridColumnIndex","add","clonedTree","cloneTree","walkDown","_ref","columnIndex","i","colspan","walkUp","Array","from"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.slice.js\";\r\nimport \"core-js/modules/es.array.iterator.js\";\r\nimport \"core-js/modules/es.object.to-string.js\";\r\nimport \"core-js/modules/es.set.js\";\r\nimport \"core-js/modules/es.string.iterator.js\";\r\nimport \"core-js/modules/web.dom-collections.iterator.js\";\r\nimport \"core-js/modules/es.array.from.js\";\r\nimport { arrayEach } from \"../../../../helpers/array.mjs\";\r\nimport { expandNode } from \"./expand.mjs\";\r\nimport { getFirstChildProperty, isNodeReflectsFirstChildColspan, traverseHiddenNodeColumnIndexes } from \"./utils/tree.mjs\";\r\n/**\r\n * Collapsing a node is a process where the processing node is collapsed\r\n * to the colspan width of the first child. All node children, except the\r\n * first one, are hidden. To prevent losing a current state of node children\r\n * on the right, all nodes are cloned (and restored while expanding), and\r\n * only then original nodes are modified (hidden in this case).\r\n *\r\n * @param {TreeNode} nodeToProcess A tree node to process.\r\n * @returns {object} Returns an object with properties:\r\n *                    - rollbackModification: The function that rollbacks\r\n *                      the tree to the previous state.\r\n *                    - affectedColumns: The list of the visual column\r\n *                      indexes which are affected. That list is passed\r\n *                      to the hiddens column logic.\r\n *                    - colspanCompensation: The number of colspan by\r\n *                      which the processed node colspan was reduced.\r\n */\r\n\r\nexport function collapseNode(nodeToProcess) {\r\n  var _getFirstChildPropert;\r\n\r\n  var nodeData = nodeToProcess.data,\r\n      nodeChilds = nodeToProcess.childs;\r\n\r\n  if (nodeData.isCollapsed || nodeData.isHidden || nodeData.origColspan <= 1) {\r\n    return {\r\n      rollbackModification: function rollbackModification() {},\r\n      affectedColumns: [],\r\n      colspanCompensation: 0\r\n    };\r\n  }\r\n\r\n  var isNodeReflected = isNodeReflectsFirstChildColspan(nodeToProcess);\r\n\r\n  if (isNodeReflected) {\r\n    return collapseNode(nodeChilds[0]);\r\n  }\r\n\r\n  nodeData.isCollapsed = true;\r\n  var allLeavesExceptMostLeft = nodeChilds.slice(1);\r\n  var affectedColumns = new Set();\r\n\r\n  if (allLeavesExceptMostLeft.length > 0) {\r\n    arrayEach(allLeavesExceptMostLeft, function (node) {\r\n      traverseHiddenNodeColumnIndexes(node, function (gridColumnIndex) {\r\n        affectedColumns.add(gridColumnIndex);\r\n      }); // Clone the tree to preserve original tree state after header expanding.\r\n\r\n      node.data.clonedTree = node.cloneTree(); // Hide all leaves except the first leaf on the left (on headers context hide all\r\n      // headers on the right).\r\n\r\n      node.walkDown(function (_ref) {\r\n        var data = _ref.data;\r\n        data.isHidden = true;\r\n      });\r\n    });\r\n  } else {\r\n    var origColspan = nodeData.origColspan,\r\n        columnIndex = nodeData.columnIndex; // Add column to \"affected\" started from 1. The header without children can not be\r\n    // collapsed so the first have to be visible (untouched).\r\n\r\n    for (var i = 1; i < origColspan; i++) {\r\n      var gridColumnIndex = columnIndex + i;\r\n      affectedColumns.add(gridColumnIndex);\r\n    }\r\n  } // Calculate by how many colspan it needs to reduce the headings to match them to\r\n  // the first child colspan width.\r\n\r\n\r\n  var colspanCompensation = nodeData.colspan - ((_getFirstChildPropert = getFirstChildProperty(nodeToProcess, 'colspan')) !== null && _getFirstChildPropert !== void 0 ? _getFirstChildPropert : 1);\r\n  nodeToProcess.walkUp(function (node) {\r\n    var data = node.data;\r\n    data.colspan -= colspanCompensation;\r\n\r\n    if (data.colspan <= 1) {\r\n      data.colspan = 1;\r\n      data.isCollapsed = true;\r\n    } else if (isNodeReflectsFirstChildColspan(node)) {\r\n      data.isCollapsed = getFirstChildProperty(node, 'isCollapsed');\r\n    }\r\n  });\r\n  return {\r\n    rollbackModification: function rollbackModification() {\r\n      return expandNode(nodeToProcess);\r\n    },\r\n    affectedColumns: Array.from(affectedColumns),\r\n    colspanCompensation: colspanCompensation\r\n  };\r\n}"]},"metadata":{},"sourceType":"module"}