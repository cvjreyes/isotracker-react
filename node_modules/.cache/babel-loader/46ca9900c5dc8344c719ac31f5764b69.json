{"ast":null,"code":"import moment from 'moment';\nimport { getEditorInstance } from \"../../editors/registry.mjs\";\nimport { EDITOR_TYPE as DATE_EDITOR_TYPE } from \"../../editors/dateEditor/index.mjs\";\nimport { getNormalizedDate } from \"../../helpers/date.mjs\";\nexport var VALIDATOR_TYPE = 'date';\n/**\r\n * The Date cell validator.\r\n *\r\n * @private\r\n * @param {*} value Value of edited cell.\r\n * @param {Function} callback Callback called with validation result.\r\n */\n\nexport function dateValidator(value, callback) {\n  var dateEditor = getEditorInstance(DATE_EDITOR_TYPE, this.instance);\n  var valueToValidate = value;\n  var valid = true;\n\n  if (valueToValidate === null || valueToValidate === void 0) {\n    valueToValidate = '';\n  }\n\n  var isValidFormat = moment(valueToValidate, this.dateFormat || dateEditor.defaultDateFormat, true).isValid();\n  var isValidDate = moment(new Date(valueToValidate)).isValid() || isValidFormat;\n\n  if (this.allowEmpty && valueToValidate === '') {\n    isValidDate = true;\n    isValidFormat = true;\n  }\n\n  if (!isValidDate) {\n    valid = false;\n  }\n\n  if (!isValidDate && isValidFormat) {\n    valid = true;\n  }\n\n  if (isValidDate && !isValidFormat) {\n    if (this.correctFormat === true) {\n      // if format correction is enabled\n      var correctedValue = correctFormat(valueToValidate, this.dateFormat);\n      var row = this.instance.toVisualRow(this.row);\n      var column = this.instance.toVisualColumn(this.col);\n      this.instance.setDataAtCell(row, column, correctedValue, 'dateValidator');\n      valid = true;\n    } else {\n      valid = false;\n    }\n  }\n\n  callback(valid);\n}\ndateValidator.VALIDATOR_TYPE = VALIDATOR_TYPE;\n/**\r\n * Format the given string using moment.js' format feature.\r\n *\r\n * @param {string} value The value to format.\r\n * @param {string} dateFormat The date pattern to format to.\r\n * @returns {string}\r\n */\n\nexport function correctFormat(value, dateFormat) {\n  var dateFromDate = moment(getNormalizedDate(value));\n  var dateFromMoment = moment(value, dateFormat);\n  var isAlphanumeric = value.search(/[A-z]/g) > -1;\n  var date;\n\n  if (dateFromDate.isValid() && dateFromDate.format('x') === dateFromMoment.format('x') || !dateFromMoment.isValid() || isAlphanumeric) {\n    date = dateFromDate;\n  } else {\n    date = dateFromMoment;\n  }\n\n  return date.format(dateFormat);\n}","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/validators/dateValidator/dateValidator.mjs"],"names":["moment","getEditorInstance","EDITOR_TYPE","DATE_EDITOR_TYPE","getNormalizedDate","VALIDATOR_TYPE","dateValidator","value","callback","dateEditor","instance","valueToValidate","valid","isValidFormat","dateFormat","defaultDateFormat","isValid","isValidDate","Date","allowEmpty","correctFormat","correctedValue","row","toVisualRow","column","toVisualColumn","col","setDataAtCell","dateFromDate","dateFromMoment","isAlphanumeric","search","date","format"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.regexp.exec.js\";\r\nimport \"core-js/modules/es.string.search.js\";\r\nimport moment from 'moment';\r\nimport { getEditorInstance } from \"../../editors/registry.mjs\";\r\nimport { EDITOR_TYPE as DATE_EDITOR_TYPE } from \"../../editors/dateEditor/index.mjs\";\r\nimport { getNormalizedDate } from \"../../helpers/date.mjs\";\r\nexport var VALIDATOR_TYPE = 'date';\r\n/**\r\n * The Date cell validator.\r\n *\r\n * @private\r\n * @param {*} value Value of edited cell.\r\n * @param {Function} callback Callback called with validation result.\r\n */\r\n\r\nexport function dateValidator(value, callback) {\r\n  var dateEditor = getEditorInstance(DATE_EDITOR_TYPE, this.instance);\r\n  var valueToValidate = value;\r\n  var valid = true;\r\n\r\n  if (valueToValidate === null || valueToValidate === void 0) {\r\n    valueToValidate = '';\r\n  }\r\n\r\n  var isValidFormat = moment(valueToValidate, this.dateFormat || dateEditor.defaultDateFormat, true).isValid();\r\n  var isValidDate = moment(new Date(valueToValidate)).isValid() || isValidFormat;\r\n\r\n  if (this.allowEmpty && valueToValidate === '') {\r\n    isValidDate = true;\r\n    isValidFormat = true;\r\n  }\r\n\r\n  if (!isValidDate) {\r\n    valid = false;\r\n  }\r\n\r\n  if (!isValidDate && isValidFormat) {\r\n    valid = true;\r\n  }\r\n\r\n  if (isValidDate && !isValidFormat) {\r\n    if (this.correctFormat === true) {\r\n      // if format correction is enabled\r\n      var correctedValue = correctFormat(valueToValidate, this.dateFormat);\r\n      var row = this.instance.toVisualRow(this.row);\r\n      var column = this.instance.toVisualColumn(this.col);\r\n      this.instance.setDataAtCell(row, column, correctedValue, 'dateValidator');\r\n      valid = true;\r\n    } else {\r\n      valid = false;\r\n    }\r\n  }\r\n\r\n  callback(valid);\r\n}\r\ndateValidator.VALIDATOR_TYPE = VALIDATOR_TYPE;\r\n/**\r\n * Format the given string using moment.js' format feature.\r\n *\r\n * @param {string} value The value to format.\r\n * @param {string} dateFormat The date pattern to format to.\r\n * @returns {string}\r\n */\r\n\r\nexport function correctFormat(value, dateFormat) {\r\n  var dateFromDate = moment(getNormalizedDate(value));\r\n  var dateFromMoment = moment(value, dateFormat);\r\n  var isAlphanumeric = value.search(/[A-z]/g) > -1;\r\n  var date;\r\n\r\n  if (dateFromDate.isValid() && dateFromDate.format('x') === dateFromMoment.format('x') || !dateFromMoment.isValid() || isAlphanumeric) {\r\n    date = dateFromDate;\r\n  } else {\r\n    date = dateFromMoment;\r\n  }\r\n\r\n  return date.format(dateFormat);\r\n}"]},"metadata":{},"sourceType":"module"}