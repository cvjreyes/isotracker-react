{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { addClass, hasClass } from \"./../../../helpers/dom/element.mjs\";\nimport Border from \"./border.mjs\";\nimport CellCoords from \"./cell/coords.mjs\";\nimport CellRange from \"./cell/range.mjs\";\n/**\n * @class Selection\n */\n\nvar Selection = /*#__PURE__*/function () {\n  /**\n   * @param {object} settings The selection settings object.\n   * @param {CellRange} cellRange The cell range instance.\n   */\n  function Selection(settings, cellRange) {\n    _classCallCheck(this, Selection);\n\n    this.settings = settings;\n    this.cellRange = cellRange || null;\n    this.instanceBorders = {};\n    this.classNames = [this.settings.className];\n    this.classNameGenerator = this.linearClassNameGenerator(this.settings.className, this.settings.layerLevel);\n  }\n  /**\n   * Each Walkontable clone requires it's own border for every selection. This method creates and returns selection\n   * borders per instance.\n   *\n   * @param {Walkontable} wotInstance The Walkontable instance.\n   * @returns {Border}\n   */\n\n\n  _createClass(Selection, [{\n    key: \"getBorder\",\n    value: function getBorder(wotInstance) {\n      if (!this.instanceBorders[wotInstance.guid]) {\n        this.instanceBorders[wotInstance.guid] = new Border(wotInstance, this.settings);\n      }\n\n      return this.instanceBorders[wotInstance.guid];\n    }\n    /**\n     * Checks if selection is empty.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.cellRange === null;\n    }\n    /**\n     * Adds a cell coords to the selection.\n     *\n     * @param {CellCoords} coords The cell coordinates to add.\n     * @returns {Selection}\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(coords) {\n      if (this.isEmpty()) {\n        this.cellRange = new CellRange(coords);\n      } else {\n        this.cellRange.expand(coords);\n      }\n\n      return this;\n    }\n    /**\n     * If selection range from or to property equals oldCoords, replace it with newCoords. Return boolean\n     * information about success.\n     *\n     * @param {CellCoords} oldCoords An old cell coordinates to replace.\n     * @param {CellCoords} newCoords The new cell coordinates.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"replace\",\n    value: function replace(oldCoords, newCoords) {\n      if (!this.isEmpty()) {\n        if (this.cellRange.from.isEqual(oldCoords)) {\n          this.cellRange.from = newCoords;\n          return true;\n        }\n\n        if (this.cellRange.to.isEqual(oldCoords)) {\n          this.cellRange.to = newCoords;\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Clears selection.\n     *\n     * @returns {Selection}\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.cellRange = null;\n      return this;\n    }\n    /**\n     * Returns the top left (TL) and bottom right (BR) selection coordinates.\n     *\n     * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.\n     */\n\n  }, {\n    key: \"getCorners\",\n    value: function getCorners() {\n      var topLeft = this.cellRange.getOuterTopLeftCorner();\n      var bottomRight = this.cellRange.getOuterBottomRightCorner();\n      return [topLeft.row, topLeft.col, bottomRight.row, bottomRight.col];\n    }\n    /**\n     * Adds class name to cell element at given coords.\n     *\n     * @param {Walkontable} wotInstance Walkontable instance.\n     * @param {number} sourceRow Cell row coord.\n     * @param {number} sourceColumn Cell column coord.\n     * @param {string} className Class name.\n     * @param {boolean} [markIntersections=false] If `true`, linear className generator will be used to add CSS classes\n     *                                            in a continuous way.\n     * @returns {Selection}\n     */\n\n  }, {\n    key: \"addClassAtCoords\",\n    value: function addClassAtCoords(wotInstance, sourceRow, sourceColumn, className) {\n      var markIntersections = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var TD = wotInstance.wtTable.getCell(new CellCoords(sourceRow, sourceColumn));\n\n      if (_typeof(TD) === 'object') {\n        var cellClassName = className;\n\n        if (markIntersections) {\n          cellClassName = this.classNameGenerator(TD);\n\n          if (!this.classNames.includes(cellClassName)) {\n            this.classNames.push(cellClassName);\n          }\n        }\n\n        addClass(TD, cellClassName);\n      }\n\n      return this;\n    }\n    /**\n     * Generate helper for calculating classNames based on previously added base className.\n     * The generated className is always generated as a continuation of the previous className. For example, when\n     * the currently checked element has 'area-2' className the generated new className will be 'area-3'. When\n     * the element doesn't have any classNames than the base className will be returned ('area');.\n     *\n     * @param {string} baseClassName Base className to be used.\n     * @param {number} layerLevelOwner Layer level which the instance of the Selection belongs to.\n     * @returns {Function}\n     */\n\n  }, {\n    key: \"linearClassNameGenerator\",\n    value: function linearClassNameGenerator(baseClassName, layerLevelOwner) {\n      // TODO: Make this recursive function Proper Tail Calls (TCO/PTC) friendly.\n      return function calcClassName(element) {\n        var previousIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n        if (layerLevelOwner === 0 || previousIndex === 0) {\n          return baseClassName;\n        }\n\n        var index = previousIndex >= 0 ? previousIndex : layerLevelOwner;\n        var className = baseClassName;\n        index -= 1;\n        var previousClassName = index === 0 ? baseClassName : \"\".concat(baseClassName, \"-\").concat(index);\n\n        if (hasClass(element, previousClassName)) {\n          var currentLayer = index + 1;\n          className = \"\".concat(baseClassName, \"-\").concat(currentLayer);\n        } else {\n          className = calcClassName(element, index);\n        }\n\n        return className;\n      };\n    }\n    /**\n     * @param {Walkontable} wotInstance The Walkontable instance.\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw(wotInstance) {\n      if (this.isEmpty()) {\n        if (this.settings.border) {\n          this.getBorder(wotInstance).disappear();\n        }\n\n        return;\n      }\n\n      var renderedRows = wotInstance.wtTable.getRenderedRowsCount();\n      var renderedColumns = wotInstance.wtTable.getRenderedColumnsCount();\n      var corners = this.getCorners();\n\n      var _corners = _slicedToArray(corners, 4),\n          topRow = _corners[0],\n          topColumn = _corners[1],\n          bottomRow = _corners[2],\n          bottomColumn = _corners[3];\n\n      var _this$settings = this.settings,\n          highlightHeaderClassName = _this$settings.highlightHeaderClassName,\n          highlightColumnClassName = _this$settings.highlightColumnClassName,\n          highlightRowClassName = _this$settings.highlightRowClassName,\n          highlightOnlyClosestHeader = _this$settings.highlightOnlyClosestHeader,\n          selectionType = _this$settings.selectionType;\n      var isHeaderSelectionType = selectionType === void 0 || ['active-header', 'header'].includes(selectionType);\n\n      if (isHeaderSelectionType && topColumn !== null && bottomColumn !== null) {\n        var selectionColumnCursor = 0;\n\n        for (var column = 0; column < renderedColumns; column += 1) {\n          var sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(column);\n\n          if (sourceCol >= topColumn && sourceCol <= bottomColumn) {\n            var THs = wotInstance.wtTable.getColumnHeaders(sourceCol);\n            var closestHeaderLevel = THs.length - 1;\n\n            if (highlightOnlyClosestHeader && THs.length > 1) {\n              THs = [THs[closestHeaderLevel]];\n            }\n\n            for (var headerLevel = 0; headerLevel < THs.length; headerLevel += 1) {\n              var newClasses = [];\n              var TH = THs[headerLevel];\n\n              if (highlightHeaderClassName) {\n                newClasses.push(highlightHeaderClassName);\n              }\n\n              if (highlightColumnClassName) {\n                newClasses.push(highlightColumnClassName);\n              }\n\n              headerLevel = highlightOnlyClosestHeader ? closestHeaderLevel : headerLevel;\n              var newSourceCol = wotInstance.getSetting('onBeforeHighlightingColumnHeader', sourceCol, headerLevel, {\n                selectionType: selectionType,\n                columnCursor: selectionColumnCursor,\n                selectionWidth: bottomColumn - topColumn + 1,\n                classNames: newClasses\n              });\n\n              if (newSourceCol !== sourceCol) {\n                TH = wotInstance.wtTable.getColumnHeader(newSourceCol, headerLevel);\n              }\n\n              addClass(TH, newClasses);\n            }\n\n            selectionColumnCursor += 1;\n          }\n        }\n      }\n\n      if (topRow !== null && bottomRow !== null) {\n        var selectionRowCursor = 0;\n\n        for (var row = 0; row < renderedRows; row += 1) {\n          var sourceRow = wotInstance.wtTable.rowFilter.renderedToSource(row);\n\n          if (isHeaderSelectionType && sourceRow >= topRow && sourceRow <= bottomRow) {\n            var _THs = wotInstance.wtTable.getRowHeaders(sourceRow);\n\n            var _closestHeaderLevel = _THs.length - 1;\n\n            if (highlightOnlyClosestHeader && _THs.length > 1) {\n              _THs = [_THs[_closestHeaderLevel]];\n            }\n\n            for (var _headerLevel = 0; _headerLevel < _THs.length; _headerLevel += 1) {\n              var _newClasses = [];\n              var _TH = _THs[_headerLevel];\n\n              if (highlightHeaderClassName) {\n                _newClasses.push(highlightHeaderClassName);\n              }\n\n              if (highlightRowClassName) {\n                _newClasses.push(highlightRowClassName);\n              }\n\n              _headerLevel = highlightOnlyClosestHeader ? _closestHeaderLevel : _headerLevel;\n              var newSourceRow = wotInstance.getSetting('onBeforeHighlightingRowHeader', sourceRow, _headerLevel, {\n                selectionType: selectionType,\n                rowCursor: selectionRowCursor,\n                selectionHeight: bottomRow - topRow + 1,\n                classNames: _newClasses\n              });\n\n              if (newSourceRow !== sourceRow) {\n                _TH = wotInstance.wtTable.getRowHeader(newSourceRow, _headerLevel);\n              }\n\n              addClass(_TH, _newClasses);\n            }\n\n            selectionRowCursor += 1;\n          }\n\n          if (topColumn !== null && bottomColumn !== null) {\n            for (var _column = 0; _column < renderedColumns; _column += 1) {\n              var _sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(_column);\n\n              if (sourceRow >= topRow && sourceRow <= bottomRow && _sourceCol >= topColumn && _sourceCol <= bottomColumn) {\n                // selected cell\n                if (this.settings.className) {\n                  this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, this.settings.className, this.settings.markIntersections);\n                }\n              } else if (sourceRow >= topRow && sourceRow <= bottomRow) {\n                // selection is in this row\n                if (highlightRowClassName) {\n                  this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, highlightRowClassName);\n                }\n              } else if (_sourceCol >= topColumn && _sourceCol <= bottomColumn) {\n                // selection is in this column\n                if (highlightColumnClassName) {\n                  this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, highlightColumnClassName);\n                }\n              }\n\n              var additionalSelectionClass = wotInstance.getSetting('onAfterDrawSelection', sourceRow, _sourceCol, this.settings.layerLevel);\n\n              if (typeof additionalSelectionClass === 'string') {\n                this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, additionalSelectionClass);\n              }\n            }\n          }\n        }\n      }\n\n      wotInstance.getSetting('onBeforeDrawBorders', corners, this.settings.className);\n\n      if (this.settings.border) {\n        // warning! border.appear modifies corners!\n        this.getBorder(wotInstance).appear(corners);\n      }\n    }\n    /**\n     * Cleans up all the DOM state related to a Selection instance. Call this prior to deleting a Selection instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      Object.values(this.instanceBorders).forEach(function (border) {\n        return border.destroy();\n      });\n    }\n  }]);\n\n  return Selection;\n}();\n\nexport default Selection;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/3rdparty/walkontable/src/selection.mjs"],"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","len","length","arr2","_i","Symbol","iterator","_arr","_n","_d","_s","_e","next","done","push","value","err","isArray","_typeof","obj","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","addClass","hasClass","Border","CellCoords","CellRange","Selection","settings","cellRange","instanceBorders","classNames","className","classNameGenerator","linearClassNameGenerator","layerLevel","getBorder","wotInstance","guid","isEmpty","add","coords","expand","replace","oldCoords","newCoords","isEqual","to","clear","getCorners","topLeft","getOuterTopLeftCorner","bottomRight","getOuterBottomRightCorner","row","col","addClassAtCoords","sourceRow","sourceColumn","markIntersections","arguments","undefined","TD","wtTable","getCell","cellClassName","includes","baseClassName","layerLevelOwner","calcClassName","element","previousIndex","index","previousClassName","concat","currentLayer","draw","border","disappear","renderedRows","getRenderedRowsCount","renderedColumns","getRenderedColumnsCount","corners","_corners","topRow","topColumn","bottomRow","bottomColumn","_this$settings","highlightHeaderClassName","highlightColumnClassName","highlightRowClassName","highlightOnlyClosestHeader","selectionType","isHeaderSelectionType","selectionColumnCursor","column","sourceCol","columnFilter","renderedToSource","THs","getColumnHeaders","closestHeaderLevel","headerLevel","newClasses","TH","newSourceCol","getSetting","columnCursor","selectionWidth","getColumnHeader","selectionRowCursor","rowFilter","_THs","getRowHeaders","_closestHeaderLevel","_headerLevel","_newClasses","_TH","newSourceRow","rowCursor","selectionHeight","getRowHeader","_column","_sourceCol","additionalSelectionClass","appear","destroy","values","forEach"],"mappings":"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","sourcesContent":["function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.values.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.from.js\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { addClass, hasClass } from \"./../../../helpers/dom/element.mjs\";\nimport Border from \"./border.mjs\";\nimport CellCoords from \"./cell/coords.mjs\";\nimport CellRange from \"./cell/range.mjs\";\n/**\n * @class Selection\n */\n\nvar Selection = /*#__PURE__*/function () {\n  /**\n   * @param {object} settings The selection settings object.\n   * @param {CellRange} cellRange The cell range instance.\n   */\n  function Selection(settings, cellRange) {\n    _classCallCheck(this, Selection);\n\n    this.settings = settings;\n    this.cellRange = cellRange || null;\n    this.instanceBorders = {};\n    this.classNames = [this.settings.className];\n    this.classNameGenerator = this.linearClassNameGenerator(this.settings.className, this.settings.layerLevel);\n  }\n  /**\n   * Each Walkontable clone requires it's own border for every selection. This method creates and returns selection\n   * borders per instance.\n   *\n   * @param {Walkontable} wotInstance The Walkontable instance.\n   * @returns {Border}\n   */\n\n\n  _createClass(Selection, [{\n    key: \"getBorder\",\n    value: function getBorder(wotInstance) {\n      if (!this.instanceBorders[wotInstance.guid]) {\n        this.instanceBorders[wotInstance.guid] = new Border(wotInstance, this.settings);\n      }\n\n      return this.instanceBorders[wotInstance.guid];\n    }\n    /**\n     * Checks if selection is empty.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.cellRange === null;\n    }\n    /**\n     * Adds a cell coords to the selection.\n     *\n     * @param {CellCoords} coords The cell coordinates to add.\n     * @returns {Selection}\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(coords) {\n      if (this.isEmpty()) {\n        this.cellRange = new CellRange(coords);\n      } else {\n        this.cellRange.expand(coords);\n      }\n\n      return this;\n    }\n    /**\n     * If selection range from or to property equals oldCoords, replace it with newCoords. Return boolean\n     * information about success.\n     *\n     * @param {CellCoords} oldCoords An old cell coordinates to replace.\n     * @param {CellCoords} newCoords The new cell coordinates.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"replace\",\n    value: function replace(oldCoords, newCoords) {\n      if (!this.isEmpty()) {\n        if (this.cellRange.from.isEqual(oldCoords)) {\n          this.cellRange.from = newCoords;\n          return true;\n        }\n\n        if (this.cellRange.to.isEqual(oldCoords)) {\n          this.cellRange.to = newCoords;\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Clears selection.\n     *\n     * @returns {Selection}\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.cellRange = null;\n      return this;\n    }\n    /**\n     * Returns the top left (TL) and bottom right (BR) selection coordinates.\n     *\n     * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.\n     */\n\n  }, {\n    key: \"getCorners\",\n    value: function getCorners() {\n      var topLeft = this.cellRange.getOuterTopLeftCorner();\n      var bottomRight = this.cellRange.getOuterBottomRightCorner();\n      return [topLeft.row, topLeft.col, bottomRight.row, bottomRight.col];\n    }\n    /**\n     * Adds class name to cell element at given coords.\n     *\n     * @param {Walkontable} wotInstance Walkontable instance.\n     * @param {number} sourceRow Cell row coord.\n     * @param {number} sourceColumn Cell column coord.\n     * @param {string} className Class name.\n     * @param {boolean} [markIntersections=false] If `true`, linear className generator will be used to add CSS classes\n     *                                            in a continuous way.\n     * @returns {Selection}\n     */\n\n  }, {\n    key: \"addClassAtCoords\",\n    value: function addClassAtCoords(wotInstance, sourceRow, sourceColumn, className) {\n      var markIntersections = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var TD = wotInstance.wtTable.getCell(new CellCoords(sourceRow, sourceColumn));\n\n      if (_typeof(TD) === 'object') {\n        var cellClassName = className;\n\n        if (markIntersections) {\n          cellClassName = this.classNameGenerator(TD);\n\n          if (!this.classNames.includes(cellClassName)) {\n            this.classNames.push(cellClassName);\n          }\n        }\n\n        addClass(TD, cellClassName);\n      }\n\n      return this;\n    }\n    /**\n     * Generate helper for calculating classNames based on previously added base className.\n     * The generated className is always generated as a continuation of the previous className. For example, when\n     * the currently checked element has 'area-2' className the generated new className will be 'area-3'. When\n     * the element doesn't have any classNames than the base className will be returned ('area');.\n     *\n     * @param {string} baseClassName Base className to be used.\n     * @param {number} layerLevelOwner Layer level which the instance of the Selection belongs to.\n     * @returns {Function}\n     */\n\n  }, {\n    key: \"linearClassNameGenerator\",\n    value: function linearClassNameGenerator(baseClassName, layerLevelOwner) {\n      // TODO: Make this recursive function Proper Tail Calls (TCO/PTC) friendly.\n      return function calcClassName(element) {\n        var previousIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n        if (layerLevelOwner === 0 || previousIndex === 0) {\n          return baseClassName;\n        }\n\n        var index = previousIndex >= 0 ? previousIndex : layerLevelOwner;\n        var className = baseClassName;\n        index -= 1;\n        var previousClassName = index === 0 ? baseClassName : \"\".concat(baseClassName, \"-\").concat(index);\n\n        if (hasClass(element, previousClassName)) {\n          var currentLayer = index + 1;\n          className = \"\".concat(baseClassName, \"-\").concat(currentLayer);\n        } else {\n          className = calcClassName(element, index);\n        }\n\n        return className;\n      };\n    }\n    /**\n     * @param {Walkontable} wotInstance The Walkontable instance.\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw(wotInstance) {\n      if (this.isEmpty()) {\n        if (this.settings.border) {\n          this.getBorder(wotInstance).disappear();\n        }\n\n        return;\n      }\n\n      var renderedRows = wotInstance.wtTable.getRenderedRowsCount();\n      var renderedColumns = wotInstance.wtTable.getRenderedColumnsCount();\n      var corners = this.getCorners();\n\n      var _corners = _slicedToArray(corners, 4),\n          topRow = _corners[0],\n          topColumn = _corners[1],\n          bottomRow = _corners[2],\n          bottomColumn = _corners[3];\n\n      var _this$settings = this.settings,\n          highlightHeaderClassName = _this$settings.highlightHeaderClassName,\n          highlightColumnClassName = _this$settings.highlightColumnClassName,\n          highlightRowClassName = _this$settings.highlightRowClassName,\n          highlightOnlyClosestHeader = _this$settings.highlightOnlyClosestHeader,\n          selectionType = _this$settings.selectionType;\n      var isHeaderSelectionType = selectionType === void 0 || ['active-header', 'header'].includes(selectionType);\n\n      if (isHeaderSelectionType && topColumn !== null && bottomColumn !== null) {\n        var selectionColumnCursor = 0;\n\n        for (var column = 0; column < renderedColumns; column += 1) {\n          var sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(column);\n\n          if (sourceCol >= topColumn && sourceCol <= bottomColumn) {\n            var THs = wotInstance.wtTable.getColumnHeaders(sourceCol);\n            var closestHeaderLevel = THs.length - 1;\n\n            if (highlightOnlyClosestHeader && THs.length > 1) {\n              THs = [THs[closestHeaderLevel]];\n            }\n\n            for (var headerLevel = 0; headerLevel < THs.length; headerLevel += 1) {\n              var newClasses = [];\n              var TH = THs[headerLevel];\n\n              if (highlightHeaderClassName) {\n                newClasses.push(highlightHeaderClassName);\n              }\n\n              if (highlightColumnClassName) {\n                newClasses.push(highlightColumnClassName);\n              }\n\n              headerLevel = highlightOnlyClosestHeader ? closestHeaderLevel : headerLevel;\n              var newSourceCol = wotInstance.getSetting('onBeforeHighlightingColumnHeader', sourceCol, headerLevel, {\n                selectionType: selectionType,\n                columnCursor: selectionColumnCursor,\n                selectionWidth: bottomColumn - topColumn + 1,\n                classNames: newClasses\n              });\n\n              if (newSourceCol !== sourceCol) {\n                TH = wotInstance.wtTable.getColumnHeader(newSourceCol, headerLevel);\n              }\n\n              addClass(TH, newClasses);\n            }\n\n            selectionColumnCursor += 1;\n          }\n        }\n      }\n\n      if (topRow !== null && bottomRow !== null) {\n        var selectionRowCursor = 0;\n\n        for (var row = 0; row < renderedRows; row += 1) {\n          var sourceRow = wotInstance.wtTable.rowFilter.renderedToSource(row);\n\n          if (isHeaderSelectionType && sourceRow >= topRow && sourceRow <= bottomRow) {\n            var _THs = wotInstance.wtTable.getRowHeaders(sourceRow);\n\n            var _closestHeaderLevel = _THs.length - 1;\n\n            if (highlightOnlyClosestHeader && _THs.length > 1) {\n              _THs = [_THs[_closestHeaderLevel]];\n            }\n\n            for (var _headerLevel = 0; _headerLevel < _THs.length; _headerLevel += 1) {\n              var _newClasses = [];\n              var _TH = _THs[_headerLevel];\n\n              if (highlightHeaderClassName) {\n                _newClasses.push(highlightHeaderClassName);\n              }\n\n              if (highlightRowClassName) {\n                _newClasses.push(highlightRowClassName);\n              }\n\n              _headerLevel = highlightOnlyClosestHeader ? _closestHeaderLevel : _headerLevel;\n              var newSourceRow = wotInstance.getSetting('onBeforeHighlightingRowHeader', sourceRow, _headerLevel, {\n                selectionType: selectionType,\n                rowCursor: selectionRowCursor,\n                selectionHeight: bottomRow - topRow + 1,\n                classNames: _newClasses\n              });\n\n              if (newSourceRow !== sourceRow) {\n                _TH = wotInstance.wtTable.getRowHeader(newSourceRow, _headerLevel);\n              }\n\n              addClass(_TH, _newClasses);\n            }\n\n            selectionRowCursor += 1;\n          }\n\n          if (topColumn !== null && bottomColumn !== null) {\n            for (var _column = 0; _column < renderedColumns; _column += 1) {\n              var _sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(_column);\n\n              if (sourceRow >= topRow && sourceRow <= bottomRow && _sourceCol >= topColumn && _sourceCol <= bottomColumn) {\n                // selected cell\n                if (this.settings.className) {\n                  this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, this.settings.className, this.settings.markIntersections);\n                }\n              } else if (sourceRow >= topRow && sourceRow <= bottomRow) {\n                // selection is in this row\n                if (highlightRowClassName) {\n                  this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, highlightRowClassName);\n                }\n              } else if (_sourceCol >= topColumn && _sourceCol <= bottomColumn) {\n                // selection is in this column\n                if (highlightColumnClassName) {\n                  this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, highlightColumnClassName);\n                }\n              }\n\n              var additionalSelectionClass = wotInstance.getSetting('onAfterDrawSelection', sourceRow, _sourceCol, this.settings.layerLevel);\n\n              if (typeof additionalSelectionClass === 'string') {\n                this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, additionalSelectionClass);\n              }\n            }\n          }\n        }\n      }\n\n      wotInstance.getSetting('onBeforeDrawBorders', corners, this.settings.className);\n\n      if (this.settings.border) {\n        // warning! border.appear modifies corners!\n        this.getBorder(wotInstance).appear(corners);\n      }\n    }\n    /**\n     * Cleans up all the DOM state related to a Selection instance. Call this prior to deleting a Selection instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      Object.values(this.instanceBorders).forEach(function (border) {\n        return border.destroy();\n      });\n    }\n  }]);\n\n  return Selection;\n}();\n\nexport default Selection;"]},"metadata":{},"sourceType":"module"}