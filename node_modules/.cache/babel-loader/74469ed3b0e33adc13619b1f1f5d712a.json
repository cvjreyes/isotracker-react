{"ast":null,"code":"// Parses an Excel Date (\"serial\") into a\n// corresponding javascript Date in UTC+0 timezone.\n// (with time equal to 12:00)\n//\n// Doesn't account for leap seconds.\n// Therefore is not 100% correct.\n// But will do, I guess, since we're\n// not doing rocket science here.\n//\n// https://www.pcworld.com/article/3063622/software/mastering-excel-date-time-serial-numbers-networkdays-datevalue-and-more.html\n// \"If you need to calculate dates in your spreadsheets,\n//  Excel uses its own unique system, which it calls Serial Numbers\".\n//\nexport default function parseExcelDate(excelSerialDate, options) {\n  // https://support.microsoft.com/en-gb/help/214330/differences-between-the-1900-and-the-1904-date-system-in-excel\n  if (options && options.epoch1904) {\n    excelSerialDate += 1462;\n  } // \"Excel serial date\" is just\n  // the count of days since `01/01/1900`\n  // (seems that it may be even fractional).\n  //\n  // The count of days elapsed\n  // since `01/01/1900` (Excel epoch)\n  // till `01/01/1970` (Unix epoch).\n  // Accounts for leap years\n  // (19 of them, yielding 19 extra days).\n\n\n  var daysBeforeUnixEpoch = 70 * 365 + 19; // An hour, approximately, because a minute\n  // may be longer than 60 seconds, see \"leap seconds\".\n\n  var hour = 60 * 60 * 1000; // \"In the 1900 system, the serial number 1 represents January 1, 1900, 12:00:00 a.m.\n  //  while the number 0 represents the fictitious date January 0, 1900\".\n  // These extra 12 hours are a hack to make things\n  // a little bit less weird when rendering parsed dates.\n  // E.g. if a date `Jan 1st, 2017` gets parsed as\n  // `Jan 1st, 2017, 00:00 UTC` then when displayed in the US\n  // it would show up as `Dec 31st, 2016, 19:00 UTC-05` (Austin, Texas).\n  // That would be weird for a website user.\n  // Therefore this extra 12-hour padding is added\n  // to compensate for the most weird cases like this\n  // (doesn't solve all of them, but most of them).\n  // And if you ask what about -12/+12 border then\n  // the answer is people there are already accustomed\n  // to the weird time behaviour when their neighbours\n  // may have completely different date than they do.\n  //\n  // `Math.round()` rounds all time fractions\n  // smaller than a millisecond (e.g. nanoseconds)\n  // but it's unlikely that an Excel serial date\n  // is gonna contain even seconds.\n  //\n\n  return new Date(Math.round((excelSerialDate - daysBeforeUnixEpoch) * 24 * hour) + 12 * hour);\n}","map":{"version":3,"sources":["../source/parseDate.js"],"names":["options","excelSerialDate","daysBeforeUnixEpoch","hour","Math"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAA,cAAA,CAAA,eAAA,EAAA,OAAA,EAAkD;AAC/D;AACA,MAAIA,OAAAA,IAAWA,OAAAA,CAAf,SAAA,EAAkC;AAChCC,IAAAA,eAAAA,IAAAA,IAAAA;AACD,GAJ8D,CAM/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,mBAAAA,GAAsB,KAAA,GAAA,GAA5B,EAAA,CAf+D,CAiB/D;AACA;;AACA,MAAMC,IAAAA,GAAO,KAAA,EAAA,GAAb,IAAA,CAnB+D,CAqB/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAO,IAAA,IAAA,CAASC,IAAAA,CAAAA,KAAAA,CAAW,CAACH,eAAAA,GAAD,mBAAA,IAAA,EAAA,GAAXG,IAAAA,IAAkE,KAAlF,IAAO,CAAP;AACD","sourcesContent":["// Parses an Excel Date (\"serial\") into a\r\n// corresponding javascript Date in UTC+0 timezone.\r\n// (with time equal to 12:00)\r\n//\r\n// Doesn't account for leap seconds.\r\n// Therefore is not 100% correct.\r\n// But will do, I guess, since we're\r\n// not doing rocket science here.\r\n//\r\n// https://www.pcworld.com/article/3063622/software/mastering-excel-date-time-serial-numbers-networkdays-datevalue-and-more.html\r\n// \"If you need to calculate dates in your spreadsheets,\r\n//  Excel uses its own unique system, which it calls Serial Numbers\".\r\n//\r\nexport default function parseExcelDate(excelSerialDate, options) {\r\n  // https://support.microsoft.com/en-gb/help/214330/differences-between-the-1900-and-the-1904-date-system-in-excel\r\n  if (options && options.epoch1904) {\r\n    excelSerialDate += 1462\r\n  }\r\n\r\n  // \"Excel serial date\" is just\r\n  // the count of days since `01/01/1900`\r\n  // (seems that it may be even fractional).\r\n  //\r\n  // The count of days elapsed\r\n  // since `01/01/1900` (Excel epoch)\r\n  // till `01/01/1970` (Unix epoch).\r\n  // Accounts for leap years\r\n  // (19 of them, yielding 19 extra days).\r\n  const daysBeforeUnixEpoch = 70 * 365 + 19\r\n\r\n  // An hour, approximately, because a minute\r\n  // may be longer than 60 seconds, see \"leap seconds\".\r\n  const hour = 60 * 60 * 1000\r\n\r\n  // \"In the 1900 system, the serial number 1 represents January 1, 1900, 12:00:00 a.m.\r\n  //  while the number 0 represents the fictitious date January 0, 1900\".\r\n  // These extra 12 hours are a hack to make things\r\n  // a little bit less weird when rendering parsed dates.\r\n  // E.g. if a date `Jan 1st, 2017` gets parsed as\r\n  // `Jan 1st, 2017, 00:00 UTC` then when displayed in the US\r\n  // it would show up as `Dec 31st, 2016, 19:00 UTC-05` (Austin, Texas).\r\n  // That would be weird for a website user.\r\n  // Therefore this extra 12-hour padding is added\r\n  // to compensate for the most weird cases like this\r\n  // (doesn't solve all of them, but most of them).\r\n  // And if you ask what about -12/+12 border then\r\n  // the answer is people there are already accustomed\r\n  // to the weird time behaviour when their neighbours\r\n  // may have completely different date than they do.\r\n  //\r\n  // `Math.round()` rounds all time fractions\r\n  // smaller than a millisecond (e.g. nanoseconds)\r\n  // but it's unlikely that an Excel serial date\r\n  // is gonna contain even seconds.\r\n  //\r\n  return new Date(Math.round((excelSerialDate - daysBeforeUnixEpoch) * 24 * hour) + 12 * hour)\r\n}"]},"metadata":{},"sourceType":"module"}