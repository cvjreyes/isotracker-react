{"ast":null,"code":"var _templateObject, _templateObject2, _templateObject3, _templateObject4;\n\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { CellCoords, CellRange } from \"../../3rdparty/walkontable/src/index.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\r\n * The `MergedCellCoords` class represents a single merged cell.\r\n *\r\n * @class MergedCellCoords\r\n * @plugin MergeCells\r\n */\n\nvar MergedCellCoords = /*#__PURE__*/function () {\n  function MergedCellCoords(row, column, rowspan, colspan) {\n    _classCallCheck(this, MergedCellCoords);\n    /**\r\n     * The index of the topmost merged cell row.\r\n     *\r\n     * @type {number}\r\n     */\n\n\n    this.row = row;\n    /**\r\n     * The index of the leftmost column.\r\n     *\r\n     * @type {number}\r\n     */\n\n    this.col = column;\n    /**\r\n     * The `rowspan` value of the merged cell.\r\n     *\r\n     * @type {number}\r\n     */\n\n    this.rowspan = rowspan;\n    /**\r\n     * The `colspan` value of the merged cell.\r\n     *\r\n     * @type {number}\r\n     */\n\n    this.colspan = colspan;\n    /**\r\n     * `true` only if the merged cell is bound to be removed.\r\n     *\r\n     * @type {boolean}\r\n     */\n\n    this.removed = false;\n  }\n  /**\r\n   * Get a warning message for when the declared merged cell data contains negative values.\r\n   *\r\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\r\n   * @returns {string}\r\n   */\n\n\n  _createClass(MergedCellCoords, [{\n    key: \"normalize\",\n    value:\n    /**\r\n     * Sanitize (prevent from going outside the boundaries) the merged cell.\r\n     *\r\n     * @param {Core} hotInstance The Handsontable instance.\r\n     */\n    function normalize(hotInstance) {\n      var totalRows = hotInstance.countRows();\n      var totalColumns = hotInstance.countCols();\n\n      if (this.row < 0) {\n        this.row = 0;\n      } else if (this.row > totalRows - 1) {\n        this.row = totalRows - 1;\n      }\n\n      if (this.col < 0) {\n        this.col = 0;\n      } else if (this.col > totalColumns - 1) {\n        this.col = totalColumns - 1;\n      }\n\n      if (this.row + this.rowspan > totalRows - 1) {\n        this.rowspan = totalRows - this.row;\n      }\n\n      if (this.col + this.colspan > totalColumns - 1) {\n        this.colspan = totalColumns - this.col;\n      }\n    }\n    /**\r\n     * Returns `true` if the provided coordinates are inside the merged cell.\r\n     *\r\n     * @param {number} row The row index.\r\n     * @param {number} column The column index.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"includes\",\n    value: function includes(row, column) {\n      return this.row <= row && this.col <= column && this.row + this.rowspan - 1 >= row && this.col + this.colspan - 1 >= column;\n    }\n    /**\r\n     * Returns `true` if the provided `column` property is within the column span of the merged cell.\r\n     *\r\n     * @param {number} column The column index.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"includesHorizontally\",\n    value: function includesHorizontally(column) {\n      return this.col <= column && this.col + this.colspan - 1 >= column;\n    }\n    /**\r\n     * Returns `true` if the provided `row` property is within the row span of the merged cell.\r\n     *\r\n     * @param {number} row Row index.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"includesVertically\",\n    value: function includesVertically(row) {\n      return this.row <= row && this.row + this.rowspan - 1 >= row;\n    }\n    /**\r\n     * Shift (and possibly resize, if needed) the merged cell.\r\n     *\r\n     * @param {Array} shiftVector 2-element array containing the information on the shifting in the `x` and `y` axis.\r\n     * @param {number} indexOfChange Index of the preceding change.\r\n     * @returns {boolean} Returns `false` if the whole merged cell was removed.\r\n     */\n\n  }, {\n    key: \"shift\",\n    value: function shift(shiftVector, indexOfChange) {\n      var shiftValue = shiftVector[0] || shiftVector[1];\n      var shiftedIndex = indexOfChange + Math.abs(shiftVector[0] || shiftVector[1]) - 1;\n      var span = shiftVector[0] ? 'colspan' : 'rowspan';\n      var index = shiftVector[0] ? 'col' : 'row';\n      var changeStart = Math.min(indexOfChange, shiftedIndex);\n      var changeEnd = Math.max(indexOfChange, shiftedIndex);\n      var mergeStart = this[index];\n      var mergeEnd = this[index] + this[span] - 1;\n\n      if (mergeStart >= indexOfChange) {\n        this[index] += shiftValue;\n      } // adding rows/columns\n\n\n      if (shiftValue > 0) {\n        if (indexOfChange <= mergeEnd && indexOfChange > mergeStart) {\n          this[span] += shiftValue;\n        } // removing rows/columns\n\n      } else if (shiftValue < 0) {\n        // removing the whole merge\n        if (changeStart <= mergeStart && changeEnd >= mergeEnd) {\n          this.removed = true;\n          return false; // removing the merge partially, including the beginning\n        } else if (mergeStart >= changeStart && mergeStart <= changeEnd) {\n          var removedOffset = changeEnd - mergeStart + 1;\n          var preRemovedOffset = Math.abs(shiftValue) - removedOffset;\n          this[index] -= preRemovedOffset + shiftValue;\n          this[span] -= removedOffset; // removing the middle part of the merge\n        } else if (mergeStart <= changeStart && mergeEnd >= changeEnd) {\n          this[span] += shiftValue; // removing the end part of the merge\n        } else if (mergeStart <= changeStart && mergeEnd >= changeStart && mergeEnd < changeEnd) {\n          var removedPart = mergeEnd - changeStart + 1;\n          this[span] -= removedPart;\n        }\n      }\n\n      return true;\n    }\n    /**\r\n     * Check if the second provided merged cell is \"farther\" in the provided direction.\r\n     *\r\n     * @param {MergedCellCoords} mergedCell The merged cell to check.\r\n     * @param {string} direction Drag direction.\r\n     * @returns {boolean|null} `true` if the second provided merged cell is \"farther\".\r\n     */\n\n  }, {\n    key: \"isFarther\",\n    value: function isFarther(mergedCell, direction) {\n      if (!mergedCell) {\n        return true;\n      }\n\n      if (direction === 'down') {\n        return mergedCell.row + mergedCell.rowspan - 1 < this.row + this.rowspan - 1;\n      } else if (direction === 'up') {\n        return mergedCell.row > this.row;\n      } else if (direction === 'right') {\n        return mergedCell.col + mergedCell.colspan - 1 < this.col + this.colspan - 1;\n      } else if (direction === 'left') {\n        return mergedCell.col > this.col;\n      }\n\n      return null;\n    }\n    /**\r\n     * Get the bottom row index of the merged cell.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getLastRow\",\n    value: function getLastRow() {\n      return this.row + this.rowspan - 1;\n    }\n    /**\r\n     * Get the rightmost column index of the merged cell.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getLastColumn\",\n    value: function getLastColumn() {\n      return this.col + this.colspan - 1;\n    }\n    /**\r\n     * Get the range coordinates of the merged cell.\r\n     *\r\n     * @returns {CellRange}\r\n     */\n\n  }, {\n    key: \"getRange\",\n    value: function getRange() {\n      return new CellRange(new CellCoords(this.row, this.col), new CellCoords(this.row, this.col), new CellCoords(this.getLastRow(), this.getLastColumn()));\n    }\n  }], [{\n    key: \"NEGATIVE_VALUES_WARNING\",\n    value: function NEGATIVE_VALUES_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"The merged cell declared with {row: \", \", col: \", \", \\n      rowspan: \", \", colspan: \", \"} contains negative values, which is \\n      not supported. It will not be added to the collection.\"], [\"The merged cell declared with {row: \", \", col: \", \",\\\\x20\\n      rowspan: \", \", colspan: \", \"} contains negative values, which is\\\\x20\\n      not supported. It will not be added to the collection.\"])), newMergedCell.row, newMergedCell.col, newMergedCell.rowspan, newMergedCell.colspan);\n    }\n    /**\r\n     * Get a warning message for when the declared merged cell data contains values exceeding the table limits.\r\n     *\r\n     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: \"IS_OUT_OF_BOUNDS_WARNING\",\n    value: function IS_OUT_OF_BOUNDS_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"] is positioned \\n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup.\"], [\"The merged cell declared at [\", \", \", \"] is positioned\\\\x20\\n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup.\"])), newMergedCell.row, newMergedCell.col);\n    }\n    /**\r\n     * Get a warning message for when the declared merged cell data represents a single cell.\r\n     *\r\n     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: \"IS_SINGLE_CELL\",\n    value: function IS_SINGLE_CELL(newMergedCell) {\n      return toSingleLine(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"] has both \\\"rowspan\\\" \\n      and \\\"colspan\\\" declared as \\\"1\\\", which makes it a single cell. It cannot be added to the collection.\"], [\"The merged cell declared at [\", \", \", \"] has both \\\"rowspan\\\"\\\\x20\\n      and \\\"colspan\\\" declared as \\\"1\\\", which makes it a single cell. It cannot be added to the collection.\"])), newMergedCell.row, newMergedCell.col);\n    }\n    /**\r\n     * Get a warning message for when the declared merged cell data contains \"colspan\" or \"rowspan\", that equals 0.\r\n     *\r\n     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: \"ZERO_SPAN_WARNING\",\n    value: function ZERO_SPAN_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"] has \\\"rowspan\\\" \\n      or \\\"colspan\\\" declared as \\\"0\\\", which is not supported. It cannot be added to the collection.\"], [\"The merged cell declared at [\", \", \", \"] has \\\"rowspan\\\"\\\\x20\\n      or \\\"colspan\\\" declared as \\\"0\\\", which is not supported. It cannot be added to the collection.\"])), newMergedCell.row, newMergedCell.col);\n    }\n    /**\r\n     * Check whether the values provided for a merged cell contain any negative values.\r\n     *\r\n     * @param {object} mergedCellInfo Object containing the `row`, `col`, `rowspan` and `colspan` properties.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"containsNegativeValues\",\n    value: function containsNegativeValues(mergedCellInfo) {\n      return mergedCellInfo.row < 0 || mergedCellInfo.col < 0 || mergedCellInfo.rowspan < 0 || mergedCellInfo.colspan < 0;\n    }\n    /**\r\n     * Check whether the provided merged cell information object represents a single cell.\r\n     *\r\n     * @private\r\n     * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isSingleCell\",\n    value: function isSingleCell(mergedCellInfo) {\n      return mergedCellInfo.colspan === 1 && mergedCellInfo.rowspan === 1;\n    }\n    /**\r\n     * Check whether the provided merged cell information object contains a rowspan or colspan of 0.\r\n     *\r\n     * @private\r\n     * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"containsZeroSpan\",\n    value: function containsZeroSpan(mergedCellInfo) {\n      return mergedCellInfo.colspan === 0 || mergedCellInfo.rowspan === 0;\n    }\n    /**\r\n     * Check whether the provided merged cell object is to be declared out of bounds of the table.\r\n     *\r\n     * @param {object} mergeCell Object containing the `row`, `col`, `rowspan` and `colspan` properties.\r\n     * @param {number} rowCount Number of rows in the table.\r\n     * @param {number} columnCount Number of rows in the table.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isOutOfBounds\",\n    value: function isOutOfBounds(mergeCell, rowCount, columnCount) {\n      return mergeCell.row < 0 || mergeCell.col < 0 || mergeCell.row >= rowCount || mergeCell.row + mergeCell.rowspan - 1 >= rowCount || mergeCell.col >= columnCount || mergeCell.col + mergeCell.colspan - 1 >= columnCount;\n    }\n  }]);\n\n  return MergedCellCoords;\n}();\n\nexport default MergedCellCoords;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/plugins/mergeCells/cellCoords.mjs"],"names":["_templateObject","_templateObject2","_templateObject3","_templateObject4","_taggedTemplateLiteral","strings","raw","slice","Object","freeze","defineProperties","value","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","prototype","CellCoords","CellRange","toSingleLine","MergedCellCoords","row","column","rowspan","colspan","col","removed","normalize","hotInstance","totalRows","countRows","totalColumns","countCols","includes","includesHorizontally","includesVertically","shift","shiftVector","indexOfChange","shiftValue","shiftedIndex","Math","abs","span","index","changeStart","min","changeEnd","max","mergeStart","mergeEnd","removedOffset","preRemovedOffset","removedPart","isFarther","mergedCell","direction","getLastRow","getLastColumn","getRange","NEGATIVE_VALUES_WARNING","newMergedCell","IS_OUT_OF_BOUNDS_WARNING","IS_SINGLE_CELL","ZERO_SPAN_WARNING","containsNegativeValues","mergedCellInfo","isSingleCell","containsZeroSpan","isOutOfBounds","mergeCell","rowCount","columnCount"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.slice.js\";\r\nimport \"core-js/modules/es.object.freeze.js\";\r\n\r\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4;\r\n\r\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport { CellCoords, CellRange } from \"../../3rdparty/walkontable/src/index.mjs\";\r\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\r\n/**\r\n * The `MergedCellCoords` class represents a single merged cell.\r\n *\r\n * @class MergedCellCoords\r\n * @plugin MergeCells\r\n */\r\n\r\nvar MergedCellCoords = /*#__PURE__*/function () {\r\n  function MergedCellCoords(row, column, rowspan, colspan) {\r\n    _classCallCheck(this, MergedCellCoords);\r\n\r\n    /**\r\n     * The index of the topmost merged cell row.\r\n     *\r\n     * @type {number}\r\n     */\r\n    this.row = row;\r\n    /**\r\n     * The index of the leftmost column.\r\n     *\r\n     * @type {number}\r\n     */\r\n\r\n    this.col = column;\r\n    /**\r\n     * The `rowspan` value of the merged cell.\r\n     *\r\n     * @type {number}\r\n     */\r\n\r\n    this.rowspan = rowspan;\r\n    /**\r\n     * The `colspan` value of the merged cell.\r\n     *\r\n     * @type {number}\r\n     */\r\n\r\n    this.colspan = colspan;\r\n    /**\r\n     * `true` only if the merged cell is bound to be removed.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n\r\n    this.removed = false;\r\n  }\r\n  /**\r\n   * Get a warning message for when the declared merged cell data contains negative values.\r\n   *\r\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\r\n   * @returns {string}\r\n   */\r\n\r\n\r\n  _createClass(MergedCellCoords, [{\r\n    key: \"normalize\",\r\n    value:\r\n    /**\r\n     * Sanitize (prevent from going outside the boundaries) the merged cell.\r\n     *\r\n     * @param {Core} hotInstance The Handsontable instance.\r\n     */\r\n    function normalize(hotInstance) {\r\n      var totalRows = hotInstance.countRows();\r\n      var totalColumns = hotInstance.countCols();\r\n\r\n      if (this.row < 0) {\r\n        this.row = 0;\r\n      } else if (this.row > totalRows - 1) {\r\n        this.row = totalRows - 1;\r\n      }\r\n\r\n      if (this.col < 0) {\r\n        this.col = 0;\r\n      } else if (this.col > totalColumns - 1) {\r\n        this.col = totalColumns - 1;\r\n      }\r\n\r\n      if (this.row + this.rowspan > totalRows - 1) {\r\n        this.rowspan = totalRows - this.row;\r\n      }\r\n\r\n      if (this.col + this.colspan > totalColumns - 1) {\r\n        this.colspan = totalColumns - this.col;\r\n      }\r\n    }\r\n    /**\r\n     * Returns `true` if the provided coordinates are inside the merged cell.\r\n     *\r\n     * @param {number} row The row index.\r\n     * @param {number} column The column index.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"includes\",\r\n    value: function includes(row, column) {\r\n      return this.row <= row && this.col <= column && this.row + this.rowspan - 1 >= row && this.col + this.colspan - 1 >= column;\r\n    }\r\n    /**\r\n     * Returns `true` if the provided `column` property is within the column span of the merged cell.\r\n     *\r\n     * @param {number} column The column index.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"includesHorizontally\",\r\n    value: function includesHorizontally(column) {\r\n      return this.col <= column && this.col + this.colspan - 1 >= column;\r\n    }\r\n    /**\r\n     * Returns `true` if the provided `row` property is within the row span of the merged cell.\r\n     *\r\n     * @param {number} row Row index.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"includesVertically\",\r\n    value: function includesVertically(row) {\r\n      return this.row <= row && this.row + this.rowspan - 1 >= row;\r\n    }\r\n    /**\r\n     * Shift (and possibly resize, if needed) the merged cell.\r\n     *\r\n     * @param {Array} shiftVector 2-element array containing the information on the shifting in the `x` and `y` axis.\r\n     * @param {number} indexOfChange Index of the preceding change.\r\n     * @returns {boolean} Returns `false` if the whole merged cell was removed.\r\n     */\r\n\r\n  }, {\r\n    key: \"shift\",\r\n    value: function shift(shiftVector, indexOfChange) {\r\n      var shiftValue = shiftVector[0] || shiftVector[1];\r\n      var shiftedIndex = indexOfChange + Math.abs(shiftVector[0] || shiftVector[1]) - 1;\r\n      var span = shiftVector[0] ? 'colspan' : 'rowspan';\r\n      var index = shiftVector[0] ? 'col' : 'row';\r\n      var changeStart = Math.min(indexOfChange, shiftedIndex);\r\n      var changeEnd = Math.max(indexOfChange, shiftedIndex);\r\n      var mergeStart = this[index];\r\n      var mergeEnd = this[index] + this[span] - 1;\r\n\r\n      if (mergeStart >= indexOfChange) {\r\n        this[index] += shiftValue;\r\n      } // adding rows/columns\r\n\r\n\r\n      if (shiftValue > 0) {\r\n        if (indexOfChange <= mergeEnd && indexOfChange > mergeStart) {\r\n          this[span] += shiftValue;\r\n        } // removing rows/columns\r\n\r\n      } else if (shiftValue < 0) {\r\n        // removing the whole merge\r\n        if (changeStart <= mergeStart && changeEnd >= mergeEnd) {\r\n          this.removed = true;\r\n          return false; // removing the merge partially, including the beginning\r\n        } else if (mergeStart >= changeStart && mergeStart <= changeEnd) {\r\n          var removedOffset = changeEnd - mergeStart + 1;\r\n          var preRemovedOffset = Math.abs(shiftValue) - removedOffset;\r\n          this[index] -= preRemovedOffset + shiftValue;\r\n          this[span] -= removedOffset; // removing the middle part of the merge\r\n        } else if (mergeStart <= changeStart && mergeEnd >= changeEnd) {\r\n          this[span] += shiftValue; // removing the end part of the merge\r\n        } else if (mergeStart <= changeStart && mergeEnd >= changeStart && mergeEnd < changeEnd) {\r\n          var removedPart = mergeEnd - changeStart + 1;\r\n          this[span] -= removedPart;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    }\r\n    /**\r\n     * Check if the second provided merged cell is \"farther\" in the provided direction.\r\n     *\r\n     * @param {MergedCellCoords} mergedCell The merged cell to check.\r\n     * @param {string} direction Drag direction.\r\n     * @returns {boolean|null} `true` if the second provided merged cell is \"farther\".\r\n     */\r\n\r\n  }, {\r\n    key: \"isFarther\",\r\n    value: function isFarther(mergedCell, direction) {\r\n      if (!mergedCell) {\r\n        return true;\r\n      }\r\n\r\n      if (direction === 'down') {\r\n        return mergedCell.row + mergedCell.rowspan - 1 < this.row + this.rowspan - 1;\r\n      } else if (direction === 'up') {\r\n        return mergedCell.row > this.row;\r\n      } else if (direction === 'right') {\r\n        return mergedCell.col + mergedCell.colspan - 1 < this.col + this.colspan - 1;\r\n      } else if (direction === 'left') {\r\n        return mergedCell.col > this.col;\r\n      }\r\n\r\n      return null;\r\n    }\r\n    /**\r\n     * Get the bottom row index of the merged cell.\r\n     *\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getLastRow\",\r\n    value: function getLastRow() {\r\n      return this.row + this.rowspan - 1;\r\n    }\r\n    /**\r\n     * Get the rightmost column index of the merged cell.\r\n     *\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getLastColumn\",\r\n    value: function getLastColumn() {\r\n      return this.col + this.colspan - 1;\r\n    }\r\n    /**\r\n     * Get the range coordinates of the merged cell.\r\n     *\r\n     * @returns {CellRange}\r\n     */\r\n\r\n  }, {\r\n    key: \"getRange\",\r\n    value: function getRange() {\r\n      return new CellRange(new CellCoords(this.row, this.col), new CellCoords(this.row, this.col), new CellCoords(this.getLastRow(), this.getLastColumn()));\r\n    }\r\n  }], [{\r\n    key: \"NEGATIVE_VALUES_WARNING\",\r\n    value: function NEGATIVE_VALUES_WARNING(newMergedCell) {\r\n      return toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"The merged cell declared with {row: \", \", col: \", \", \\n      rowspan: \", \", colspan: \", \"} contains negative values, which is \\n      not supported. It will not be added to the collection.\"], [\"The merged cell declared with {row: \", \", col: \", \",\\\\x20\\n      rowspan: \", \", colspan: \", \"} contains negative values, which is\\\\x20\\n      not supported. It will not be added to the collection.\"])), newMergedCell.row, newMergedCell.col, newMergedCell.rowspan, newMergedCell.colspan);\r\n    }\r\n    /**\r\n     * Get a warning message for when the declared merged cell data contains values exceeding the table limits.\r\n     *\r\n     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\r\n     * @returns {string}\r\n     */\r\n\r\n  }, {\r\n    key: \"IS_OUT_OF_BOUNDS_WARNING\",\r\n    value: function IS_OUT_OF_BOUNDS_WARNING(newMergedCell) {\r\n      return toSingleLine(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"] is positioned \\n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup.\"], [\"The merged cell declared at [\", \", \", \"] is positioned\\\\x20\\n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup.\"])), newMergedCell.row, newMergedCell.col);\r\n    }\r\n    /**\r\n     * Get a warning message for when the declared merged cell data represents a single cell.\r\n     *\r\n     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\r\n     * @returns {string}\r\n     */\r\n\r\n  }, {\r\n    key: \"IS_SINGLE_CELL\",\r\n    value: function IS_SINGLE_CELL(newMergedCell) {\r\n      return toSingleLine(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"] has both \\\"rowspan\\\" \\n      and \\\"colspan\\\" declared as \\\"1\\\", which makes it a single cell. It cannot be added to the collection.\"], [\"The merged cell declared at [\", \", \", \"] has both \\\"rowspan\\\"\\\\x20\\n      and \\\"colspan\\\" declared as \\\"1\\\", which makes it a single cell. It cannot be added to the collection.\"])), newMergedCell.row, newMergedCell.col);\r\n    }\r\n    /**\r\n     * Get a warning message for when the declared merged cell data contains \"colspan\" or \"rowspan\", that equals 0.\r\n     *\r\n     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\r\n     * @returns {string}\r\n     */\r\n\r\n  }, {\r\n    key: \"ZERO_SPAN_WARNING\",\r\n    value: function ZERO_SPAN_WARNING(newMergedCell) {\r\n      return toSingleLine(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"] has \\\"rowspan\\\" \\n      or \\\"colspan\\\" declared as \\\"0\\\", which is not supported. It cannot be added to the collection.\"], [\"The merged cell declared at [\", \", \", \"] has \\\"rowspan\\\"\\\\x20\\n      or \\\"colspan\\\" declared as \\\"0\\\", which is not supported. It cannot be added to the collection.\"])), newMergedCell.row, newMergedCell.col);\r\n    }\r\n    /**\r\n     * Check whether the values provided for a merged cell contain any negative values.\r\n     *\r\n     * @param {object} mergedCellInfo Object containing the `row`, `col`, `rowspan` and `colspan` properties.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"containsNegativeValues\",\r\n    value: function containsNegativeValues(mergedCellInfo) {\r\n      return mergedCellInfo.row < 0 || mergedCellInfo.col < 0 || mergedCellInfo.rowspan < 0 || mergedCellInfo.colspan < 0;\r\n    }\r\n    /**\r\n     * Check whether the provided merged cell information object represents a single cell.\r\n     *\r\n     * @private\r\n     * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isSingleCell\",\r\n    value: function isSingleCell(mergedCellInfo) {\r\n      return mergedCellInfo.colspan === 1 && mergedCellInfo.rowspan === 1;\r\n    }\r\n    /**\r\n     * Check whether the provided merged cell information object contains a rowspan or colspan of 0.\r\n     *\r\n     * @private\r\n     * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"containsZeroSpan\",\r\n    value: function containsZeroSpan(mergedCellInfo) {\r\n      return mergedCellInfo.colspan === 0 || mergedCellInfo.rowspan === 0;\r\n    }\r\n    /**\r\n     * Check whether the provided merged cell object is to be declared out of bounds of the table.\r\n     *\r\n     * @param {object} mergeCell Object containing the `row`, `col`, `rowspan` and `colspan` properties.\r\n     * @param {number} rowCount Number of rows in the table.\r\n     * @param {number} columnCount Number of rows in the table.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isOutOfBounds\",\r\n    value: function isOutOfBounds(mergeCell, rowCount, columnCount) {\r\n      return mergeCell.row < 0 || mergeCell.col < 0 || mergeCell.row >= rowCount || mergeCell.row + mergeCell.rowspan - 1 >= rowCount || mergeCell.col >= columnCount || mergeCell.col + mergeCell.colspan - 1 >= columnCount;\r\n    }\r\n  }]);\r\n\r\n  return MergedCellCoords;\r\n}();\r\n\r\nexport default MergedCellCoords;"]},"metadata":{},"sourceType":"module"}