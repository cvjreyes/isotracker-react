{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nimport { stopImmediatePropagation } from \"../../../helpers/dom/event.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\nimport { rangeEach } from \"../../../helpers/number.mjs\";\nimport { hasClass } from \"../../../helpers/dom/element.mjs\";\nimport BaseUI from \"./_base.mjs\";\nimport HeadersUI from \"./headers.mjs\";\n/**\r\n * Class responsible for the UI for collapsing and expanding groups.\r\n *\r\n * @class\r\n * @util\r\n * @private\r\n * @augments BaseUI\r\n */\n\nvar CollapsingUI = /*#__PURE__*/function (_BaseUI) {\n  _inherits(CollapsingUI, _BaseUI);\n\n  var _super = _createSuper(CollapsingUI);\n\n  function CollapsingUI(nestedRowsPlugin, hotInstance) {\n    var _this;\n\n    _classCallCheck(this, CollapsingUI);\n\n    _this = _super.call(this, nestedRowsPlugin, hotInstance);\n    /**\r\n     * Reference to the TrimRows plugin.\r\n     */\n\n    _this.dataManager = _this.plugin.dataManager;\n    _this.collapsedRows = [];\n    _this.collapsedRowsStash = {\n      stash: function stash() {\n        var forceRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        _this.lastCollapsedRows = _this.collapsedRows.slice(0); // Workaround for wrong indexes being set in the trimRows plugin\n\n        _this.expandMultipleChildren(_this.lastCollapsedRows, forceRender);\n      },\n      shiftStash: function shiftStash(baseIndex, targetIndex) {\n        var delta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n        if (targetIndex === null || targetIndex === void 0) {\n          targetIndex = Infinity;\n        }\n\n        arrayEach(_this.lastCollapsedRows, function (elem, i) {\n          if (elem >= baseIndex && elem < targetIndex) {\n            _this.lastCollapsedRows[i] = elem + delta;\n          }\n        });\n      },\n      applyStash: function applyStash() {\n        var forceRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n        _this.collapseMultipleChildren(_this.lastCollapsedRows, forceRender);\n\n        _this.lastCollapsedRows = void 0;\n      },\n      trimStash: function trimStash(realElementIndex, amount) {\n        rangeEach(realElementIndex, realElementIndex + amount - 1, function (i) {\n          var indexOfElement = _this.lastCollapsedRows.indexOf(i);\n\n          if (indexOfElement > -1) {\n            _this.lastCollapsedRows.splice(indexOfElement, 1);\n          }\n        });\n      }\n    };\n    return _this;\n  }\n  /**\r\n   * Collapse the children of the row passed as an argument.\r\n   *\r\n   * @param {number|object} row The parent row.\r\n   * @param {boolean} [forceRender=true] Whether to render the table after the function ends.\r\n   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.\r\n   * @returns {Array}\r\n   */\n\n\n  _createClass(CollapsingUI, [{\n    key: \"collapseChildren\",\n    value: function collapseChildren(row) {\n      var _this2 = this;\n\n      var forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var rowsToCollapse = [];\n      var rowObject = null;\n      var rowIndex = null;\n      var rowsToTrim = null;\n\n      if (isNaN(row)) {\n        rowObject = row;\n        rowIndex = this.dataManager.getRowIndex(rowObject);\n      } else {\n        rowObject = this.dataManager.getDataObject(row);\n        rowIndex = row;\n      }\n\n      if (this.dataManager.hasChildren(rowObject)) {\n        arrayEach(rowObject.__children, function (elem) {\n          rowsToCollapse.push(_this2.dataManager.getRowIndex(elem));\n        });\n      }\n\n      rowsToTrim = this.collapseRows(rowsToCollapse, true, false);\n\n      if (doTrimming) {\n        this.trimRows(rowsToTrim);\n      }\n\n      if (forceRender) {\n        this.renderAndAdjust();\n      }\n\n      if (this.collapsedRows.indexOf(rowIndex) === -1) {\n        this.collapsedRows.push(rowIndex);\n      }\n\n      return rowsToTrim;\n    }\n    /**\r\n     * Collapse multiple children.\r\n     *\r\n     * @param {Array} rows Rows to collapse (including their children).\r\n     * @param {boolean} [forceRender=true] `true` if the table should be rendered after finishing the function.\r\n     * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.\r\n     */\n\n  }, {\n    key: \"collapseMultipleChildren\",\n    value: function collapseMultipleChildren(rows) {\n      var _this3 = this;\n\n      var forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var rowsToTrim = [];\n      arrayEach(rows, function (elem) {\n        rowsToTrim.push.apply(rowsToTrim, _toConsumableArray(_this3.collapseChildren(elem, false, false)));\n      });\n\n      if (doTrimming) {\n        this.trimRows(rowsToTrim);\n      }\n\n      if (forceRender) {\n        this.renderAndAdjust();\n      }\n    }\n    /**\r\n     * Collapse a single row.\r\n     *\r\n     * @param {number} rowIndex Index of the row to collapse.\r\n     * @param {boolean} [recursive=true] `true` if it should collapse the row's children.\r\n     */\n\n  }, {\n    key: \"collapseRow\",\n    value: function collapseRow(rowIndex) {\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      this.collapseRows([rowIndex], recursive);\n    }\n    /**\r\n     * Collapse multiple rows.\r\n     *\r\n     * @param {Array} rowIndexes Array of row indexes to collapse.\r\n     * @param {boolean} [recursive=true] `true` if it should collapse the rows' children.\r\n     * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.\r\n     * @returns {Array} Rows prepared for trimming (or trimmed, if doTrimming == true).\r\n     */\n\n  }, {\n    key: \"collapseRows\",\n    value: function collapseRows(rowIndexes) {\n      var _this4 = this;\n\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var rowsToTrim = [];\n      arrayEach(rowIndexes, function (elem) {\n        rowsToTrim.push(elem);\n\n        if (recursive) {\n          _this4.collapseChildRows(elem, rowsToTrim);\n        }\n      });\n\n      if (doTrimming) {\n        this.trimRows(rowsToTrim);\n      }\n\n      return rowsToTrim;\n    }\n    /**\r\n     * Collapse child rows of the row at the provided index.\r\n     *\r\n     * @param {number} parentIndex Index of the parent node.\r\n     * @param {Array} [rowsToTrim=[]] Array of rows to trim. Defaults to an empty array.\r\n     * @param {boolean} [recursive] `true` if the collapsing process should be recursive.\r\n     * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.\r\n     */\n\n  }, {\n    key: \"collapseChildRows\",\n    value: function collapseChildRows(parentIndex) {\n      var _this5 = this;\n\n      var rowsToTrim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var recursive = arguments.length > 2 ? arguments[2] : undefined;\n      var doTrimming = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      if (this.dataManager.hasChildren(parentIndex)) {\n        var parentObject = this.dataManager.getDataObject(parentIndex);\n        arrayEach(parentObject.__children, function (elem) {\n          var elemIndex = _this5.dataManager.getRowIndex(elem);\n\n          rowsToTrim.push(elemIndex);\n\n          _this5.collapseChildRows(elemIndex, rowsToTrim);\n        });\n      }\n\n      if (doTrimming) {\n        this.trimRows(rowsToTrim);\n      }\n    }\n    /**\r\n     * Expand a single row.\r\n     *\r\n     * @param {number} rowIndex Index of the row to expand.\r\n     * @param {boolean} [recursive=true] `true` if it should expand the row's children recursively.\r\n     */\n\n  }, {\n    key: \"expandRow\",\n    value: function expandRow(rowIndex) {\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      this.expandRows([rowIndex], recursive);\n    }\n    /**\r\n     * Expand multiple rows.\r\n     *\r\n     * @param {Array} rowIndexes Array of indexes of the rows to expand.\r\n     * @param {boolean} [recursive=true] `true` if it should expand the rows' children recursively.\r\n     * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.\r\n     * @returns {Array} Array of row indexes to be untrimmed.\r\n     */\n\n  }, {\n    key: \"expandRows\",\n    value: function expandRows(rowIndexes) {\n      var _this6 = this;\n\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var rowsToUntrim = [];\n      arrayEach(rowIndexes, function (elem) {\n        rowsToUntrim.push(elem);\n\n        if (recursive) {\n          _this6.expandChildRows(elem, rowsToUntrim);\n        }\n      });\n\n      if (doTrimming) {\n        this.untrimRows(rowsToUntrim);\n      }\n\n      return rowsToUntrim;\n    }\n    /**\r\n     * Expand child rows of the provided index.\r\n     *\r\n     * @param {number} parentIndex Index of the parent row.\r\n     * @param {Array} [rowsToUntrim=[]] Array of the rows to be untrimmed.\r\n     * @param {boolean} [recursive] `true` if it should expand the rows' children recursively.\r\n     * @param {boolean} [doTrimming=false] I determine whether collapsing should envolve trimming rows.\r\n     */\n\n  }, {\n    key: \"expandChildRows\",\n    value: function expandChildRows(parentIndex) {\n      var _this7 = this;\n\n      var rowsToUntrim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var recursive = arguments.length > 2 ? arguments[2] : undefined;\n      var doTrimming = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      if (this.dataManager.hasChildren(parentIndex)) {\n        var parentObject = this.dataManager.getDataObject(parentIndex);\n        arrayEach(parentObject.__children, function (elem) {\n          if (!_this7.isAnyParentCollapsed(elem)) {\n            var elemIndex = _this7.dataManager.getRowIndex(elem);\n\n            rowsToUntrim.push(elemIndex);\n\n            _this7.expandChildRows(elemIndex, rowsToUntrim);\n          }\n        });\n      }\n\n      if (doTrimming) {\n        this.untrimRows(rowsToUntrim);\n      }\n    }\n    /**\r\n     * Expand the children of the row passed as an argument.\r\n     *\r\n     * @param {number|object} row Parent row.\r\n     * @param {boolean} [forceRender=true] Whether to render the table after the function ends.\r\n     * @param {boolean} [doTrimming=true] If set to `true`, the trimming will be applied when the function finishes.\r\n     * @returns {number[]}\r\n     */\n\n  }, {\n    key: \"expandChildren\",\n    value: function expandChildren(row) {\n      var _this8 = this;\n\n      var forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var rowsToExpand = [];\n      var rowObject = null;\n      var rowIndex = null;\n      var rowsToUntrim = null;\n\n      if (isNaN(row)) {\n        rowObject = row;\n        rowIndex = this.dataManager.getRowIndex(row);\n      } else {\n        rowObject = this.dataManager.getDataObject(row);\n        rowIndex = row;\n      }\n\n      this.collapsedRows.splice(this.collapsedRows.indexOf(rowIndex), 1);\n\n      if (this.dataManager.hasChildren(rowObject)) {\n        arrayEach(rowObject.__children, function (elem) {\n          var childIndex = _this8.dataManager.getRowIndex(elem);\n\n          rowsToExpand.push(childIndex);\n        });\n      }\n\n      rowsToUntrim = this.expandRows(rowsToExpand, true, false);\n\n      if (doTrimming) {\n        this.untrimRows(rowsToUntrim);\n      }\n\n      if (forceRender) {\n        this.renderAndAdjust();\n      }\n\n      return rowsToUntrim;\n    }\n    /**\r\n     * Expand multiple rows' children.\r\n     *\r\n     * @param {Array} rows Array of rows which children are about to be expanded.\r\n     * @param {boolean} [forceRender=true] `true` if the table should render after finishing the function.\r\n     * @param {boolean} [doTrimming=true] `true` if the rows should be untrimmed after finishing the function.\r\n     */\n\n  }, {\n    key: \"expandMultipleChildren\",\n    value: function expandMultipleChildren(rows) {\n      var _this9 = this;\n\n      var forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var rowsToUntrim = [];\n      arrayEach(rows, function (elem) {\n        rowsToUntrim.push.apply(rowsToUntrim, _toConsumableArray(_this9.expandChildren(elem, false, false)));\n      });\n\n      if (doTrimming) {\n        this.untrimRows(rowsToUntrim);\n      }\n\n      if (forceRender) {\n        this.renderAndAdjust();\n      }\n    }\n    /**\r\n     * Collapse all collapsable rows.\r\n     */\n\n  }, {\n    key: \"collapseAll\",\n    value: function collapseAll() {\n      var _this10 = this;\n\n      var data = this.dataManager.getData();\n      var parentsToCollapse = [];\n      arrayEach(data, function (elem) {\n        if (_this10.dataManager.hasChildren(elem)) {\n          parentsToCollapse.push(elem);\n        }\n      });\n      this.collapseMultipleChildren(parentsToCollapse);\n      this.renderAndAdjust();\n    }\n    /**\r\n     * Expand all collapsable rows.\r\n     */\n\n  }, {\n    key: \"expandAll\",\n    value: function expandAll() {\n      var _this11 = this;\n\n      var data = this.dataManager.getData();\n      var parentsToExpand = [];\n      arrayEach(data, function (elem) {\n        if (_this11.dataManager.hasChildren(elem)) {\n          parentsToExpand.push(elem);\n        }\n      });\n      this.expandMultipleChildren(parentsToExpand);\n      this.renderAndAdjust();\n    }\n    /**\r\n     * Trim rows.\r\n     *\r\n     * @param {Array} rows Physical row indexes.\r\n     */\n\n  }, {\n    key: \"trimRows\",\n    value: function trimRows(rows) {\n      var _this12 = this;\n\n      this.hot.batchExecution(function () {\n        arrayEach(rows, function (physicalRow) {\n          _this12.plugin.collapsedRowsMap.setValueAtIndex(physicalRow, true);\n        });\n      }, true);\n    }\n    /**\r\n     * Untrim rows.\r\n     *\r\n     * @param {Array} rows Physical row indexes.\r\n     */\n\n  }, {\n    key: \"untrimRows\",\n    value: function untrimRows(rows) {\n      var _this13 = this;\n\n      this.hot.batchExecution(function () {\n        arrayEach(rows, function (physicalRow) {\n          _this13.plugin.collapsedRowsMap.setValueAtIndex(physicalRow, false);\n        });\n      }, true);\n    }\n    /**\r\n     * Check if all child rows are collapsed.\r\n     *\r\n     * @private\r\n     * @param {number|object|null} row The parent row. `null` for the top level.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"areChildrenCollapsed\",\n    value: function areChildrenCollapsed(row) {\n      var _this14 = this;\n\n      var rowObj = isNaN(row) ? row : this.dataManager.getDataObject(row);\n      var allCollapsed = true; // Checking the children of the top-level \"parent\"\n\n      if (rowObj === null) {\n        rowObj = {\n          __children: this.dataManager.data\n        };\n      }\n\n      if (this.dataManager.hasChildren(rowObj)) {\n        arrayEach(rowObj.__children, function (elem) {\n          var rowIndex = _this14.dataManager.getRowIndex(elem);\n\n          if (!_this14.plugin.collapsedRowsMap.getValueAtIndex(rowIndex)) {\n            allCollapsed = false;\n            return false;\n          }\n        });\n      }\n\n      return allCollapsed;\n    }\n    /**\r\n     * Check if any of the row object parents are collapsed.\r\n     *\r\n     * @private\r\n     * @param {object} rowObj Row object.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isAnyParentCollapsed\",\n    value: function isAnyParentCollapsed(rowObj) {\n      var parent = rowObj;\n\n      while (parent !== null) {\n        parent = this.dataManager.getRowParent(parent);\n        var parentIndex = this.dataManager.getRowIndex(parent);\n\n        if (this.collapsedRows.indexOf(parentIndex) > -1) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\r\n     * Toggle collapsed state. Callback for the `beforeOnCellMousedown` hook.\r\n     *\r\n     * @private\r\n     * @param {MouseEvent} event `mousedown` event.\r\n     * @param {object} coords Coordinates of the clicked cell/header.\r\n     */\n\n  }, {\n    key: \"toggleState\",\n    value: function toggleState(event, coords) {\n      if (coords.col >= 0) {\n        return;\n      }\n\n      var row = this.translateTrimmedRow(coords.row);\n\n      if (hasClass(event.target, HeadersUI.CSS_CLASSES.button)) {\n        if (this.areChildrenCollapsed(row)) {\n          this.expandChildren(row);\n        } else {\n          this.collapseChildren(row);\n        }\n\n        stopImmediatePropagation(event);\n      }\n    }\n    /**\r\n     * Translate visual row after trimming to physical base row index.\r\n     *\r\n     * @private\r\n     * @param {number} row Row index.\r\n     * @returns {number} Base row index.\r\n     */\n\n  }, {\n    key: \"translateTrimmedRow\",\n    value: function translateTrimmedRow(row) {\n      return this.hot.toPhysicalRow(row);\n    }\n    /**\r\n     * Translate physical row after trimming to visual base row index.\r\n     *\r\n     * @private\r\n     * @param {number} row Row index.\r\n     * @returns {number} Base row index.\r\n     */\n\n  }, {\n    key: \"untranslateTrimmedRow\",\n    value: function untranslateTrimmedRow(row) {\n      return this.hot.toVisualRow(row);\n    }\n    /**\r\n     * Helper function to render the table and call the `adjustElementsSize` method.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: \"renderAndAdjust\",\n    value: function renderAndAdjust() {\n      this.hot.render(); // Dirty workaround to prevent scroll height not adjusting to the table height. Needs refactoring in the future.\n\n      this.hot.view.adjustElementsSize();\n    }\n  }]);\n\n  return CollapsingUI;\n}(BaseUI);\n\nexport default CollapsingUI;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/plugins/nestedRows/ui/collapsing.mjs"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","toString","call","slice","name","Array","from","test","iter","isArray","len","length","i","arr2","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","_inherits","subClass","superClass","create","value","_setPrototypeOf","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","_getPrototypeOf","result","NewTarget","Reflect","construct","arguments","apply","_possibleConstructorReturn","self","_assertThisInitialized","ReferenceError","sham","Proxy","Boolean","valueOf","e","getPrototypeOf","stopImmediatePropagation","arrayEach","rangeEach","hasClass","BaseUI","HeadersUI","CollapsingUI","_BaseUI","_super","nestedRowsPlugin","hotInstance","_this","dataManager","plugin","collapsedRows","collapsedRowsStash","stash","forceRender","undefined","lastCollapsedRows","expandMultipleChildren","shiftStash","baseIndex","targetIndex","delta","Infinity","elem","applyStash","collapseMultipleChildren","trimStash","realElementIndex","amount","indexOfElement","indexOf","splice","collapseChildren","row","_this2","doTrimming","rowsToCollapse","rowObject","rowIndex","rowsToTrim","isNaN","getRowIndex","getDataObject","hasChildren","__children","push","collapseRows","trimRows","renderAndAdjust","rows","_this3","collapseRow","recursive","rowIndexes","_this4","collapseChildRows","parentIndex","_this5","parentObject","elemIndex","expandRow","expandRows","_this6","rowsToUntrim","expandChildRows","untrimRows","_this7","isAnyParentCollapsed","expandChildren","_this8","rowsToExpand","childIndex","_this9","collapseAll","_this10","data","getData","parentsToCollapse","expandAll","_this11","parentsToExpand","_this12","hot","batchExecution","physicalRow","collapsedRowsMap","setValueAtIndex","_this13","areChildrenCollapsed","_this14","rowObj","allCollapsed","getValueAtIndex","parent","getRowParent","toggleState","event","coords","col","translateTrimmedRow","CSS_CLASSES","button","toPhysicalRow","untranslateTrimmedRow","toVisualRow","render","view","adjustElementsSize"],"mappings":"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","sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\r\n\r\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\r\n\r\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\r\n\r\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\r\n\r\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\r\n\r\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\r\n\r\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\r\n\r\nimport \"core-js/modules/es.array.slice.js\";\r\nimport \"core-js/modules/es.array.index-of.js\";\r\nimport \"core-js/modules/es.array.splice.js\";\r\nimport \"core-js/modules/es.object.set-prototype-of.js\";\r\nimport \"core-js/modules/es.object.get-prototype-of.js\";\r\nimport \"core-js/modules/es.reflect.construct.js\";\r\nimport \"core-js/modules/es.symbol.js\";\r\nimport \"core-js/modules/es.symbol.description.js\";\r\nimport \"core-js/modules/es.object.to-string.js\";\r\nimport \"core-js/modules/es.symbol.iterator.js\";\r\nimport \"core-js/modules/es.array.iterator.js\";\r\nimport \"core-js/modules/es.string.iterator.js\";\r\nimport \"core-js/modules/web.dom-collections.iterator.js\";\r\nimport \"core-js/modules/es.array.from.js\";\r\nimport \"core-js/modules/es.function.name.js\";\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\r\n\r\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\r\n\r\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\r\n\r\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\r\n\r\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\r\n\r\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\r\n\r\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\r\n\r\nimport { stopImmediatePropagation } from \"../../../helpers/dom/event.mjs\";\r\nimport { arrayEach } from \"../../../helpers/array.mjs\";\r\nimport { rangeEach } from \"../../../helpers/number.mjs\";\r\nimport { hasClass } from \"../../../helpers/dom/element.mjs\";\r\nimport BaseUI from \"./_base.mjs\";\r\nimport HeadersUI from \"./headers.mjs\";\r\n/**\r\n * Class responsible for the UI for collapsing and expanding groups.\r\n *\r\n * @class\r\n * @util\r\n * @private\r\n * @augments BaseUI\r\n */\r\n\r\nvar CollapsingUI = /*#__PURE__*/function (_BaseUI) {\r\n  _inherits(CollapsingUI, _BaseUI);\r\n\r\n  var _super = _createSuper(CollapsingUI);\r\n\r\n  function CollapsingUI(nestedRowsPlugin, hotInstance) {\r\n    var _this;\r\n\r\n    _classCallCheck(this, CollapsingUI);\r\n\r\n    _this = _super.call(this, nestedRowsPlugin, hotInstance);\r\n    /**\r\n     * Reference to the TrimRows plugin.\r\n     */\r\n\r\n    _this.dataManager = _this.plugin.dataManager;\r\n    _this.collapsedRows = [];\r\n    _this.collapsedRowsStash = {\r\n      stash: function stash() {\r\n        var forceRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\r\n        _this.lastCollapsedRows = _this.collapsedRows.slice(0); // Workaround for wrong indexes being set in the trimRows plugin\r\n\r\n        _this.expandMultipleChildren(_this.lastCollapsedRows, forceRender);\r\n      },\r\n      shiftStash: function shiftStash(baseIndex, targetIndex) {\r\n        var delta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\r\n\r\n        if (targetIndex === null || targetIndex === void 0) {\r\n          targetIndex = Infinity;\r\n        }\r\n\r\n        arrayEach(_this.lastCollapsedRows, function (elem, i) {\r\n          if (elem >= baseIndex && elem < targetIndex) {\r\n            _this.lastCollapsedRows[i] = elem + delta;\r\n          }\r\n        });\r\n      },\r\n      applyStash: function applyStash() {\r\n        var forceRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\r\n\r\n        _this.collapseMultipleChildren(_this.lastCollapsedRows, forceRender);\r\n\r\n        _this.lastCollapsedRows = void 0;\r\n      },\r\n      trimStash: function trimStash(realElementIndex, amount) {\r\n        rangeEach(realElementIndex, realElementIndex + amount - 1, function (i) {\r\n          var indexOfElement = _this.lastCollapsedRows.indexOf(i);\r\n\r\n          if (indexOfElement > -1) {\r\n            _this.lastCollapsedRows.splice(indexOfElement, 1);\r\n          }\r\n        });\r\n      }\r\n    };\r\n    return _this;\r\n  }\r\n  /**\r\n   * Collapse the children of the row passed as an argument.\r\n   *\r\n   * @param {number|object} row The parent row.\r\n   * @param {boolean} [forceRender=true] Whether to render the table after the function ends.\r\n   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.\r\n   * @returns {Array}\r\n   */\r\n\r\n\r\n  _createClass(CollapsingUI, [{\r\n    key: \"collapseChildren\",\r\n    value: function collapseChildren(row) {\r\n      var _this2 = this;\r\n\r\n      var forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n      var doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\r\n      var rowsToCollapse = [];\r\n      var rowObject = null;\r\n      var rowIndex = null;\r\n      var rowsToTrim = null;\r\n\r\n      if (isNaN(row)) {\r\n        rowObject = row;\r\n        rowIndex = this.dataManager.getRowIndex(rowObject);\r\n      } else {\r\n        rowObject = this.dataManager.getDataObject(row);\r\n        rowIndex = row;\r\n      }\r\n\r\n      if (this.dataManager.hasChildren(rowObject)) {\r\n        arrayEach(rowObject.__children, function (elem) {\r\n          rowsToCollapse.push(_this2.dataManager.getRowIndex(elem));\r\n        });\r\n      }\r\n\r\n      rowsToTrim = this.collapseRows(rowsToCollapse, true, false);\r\n\r\n      if (doTrimming) {\r\n        this.trimRows(rowsToTrim);\r\n      }\r\n\r\n      if (forceRender) {\r\n        this.renderAndAdjust();\r\n      }\r\n\r\n      if (this.collapsedRows.indexOf(rowIndex) === -1) {\r\n        this.collapsedRows.push(rowIndex);\r\n      }\r\n\r\n      return rowsToTrim;\r\n    }\r\n    /**\r\n     * Collapse multiple children.\r\n     *\r\n     * @param {Array} rows Rows to collapse (including their children).\r\n     * @param {boolean} [forceRender=true] `true` if the table should be rendered after finishing the function.\r\n     * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.\r\n     */\r\n\r\n  }, {\r\n    key: \"collapseMultipleChildren\",\r\n    value: function collapseMultipleChildren(rows) {\r\n      var _this3 = this;\r\n\r\n      var forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n      var doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\r\n      var rowsToTrim = [];\r\n      arrayEach(rows, function (elem) {\r\n        rowsToTrim.push.apply(rowsToTrim, _toConsumableArray(_this3.collapseChildren(elem, false, false)));\r\n      });\r\n\r\n      if (doTrimming) {\r\n        this.trimRows(rowsToTrim);\r\n      }\r\n\r\n      if (forceRender) {\r\n        this.renderAndAdjust();\r\n      }\r\n    }\r\n    /**\r\n     * Collapse a single row.\r\n     *\r\n     * @param {number} rowIndex Index of the row to collapse.\r\n     * @param {boolean} [recursive=true] `true` if it should collapse the row's children.\r\n     */\r\n\r\n  }, {\r\n    key: \"collapseRow\",\r\n    value: function collapseRow(rowIndex) {\r\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n      this.collapseRows([rowIndex], recursive);\r\n    }\r\n    /**\r\n     * Collapse multiple rows.\r\n     *\r\n     * @param {Array} rowIndexes Array of row indexes to collapse.\r\n     * @param {boolean} [recursive=true] `true` if it should collapse the rows' children.\r\n     * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.\r\n     * @returns {Array} Rows prepared for trimming (or trimmed, if doTrimming == true).\r\n     */\r\n\r\n  }, {\r\n    key: \"collapseRows\",\r\n    value: function collapseRows(rowIndexes) {\r\n      var _this4 = this;\r\n\r\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n      var doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n      var rowsToTrim = [];\r\n      arrayEach(rowIndexes, function (elem) {\r\n        rowsToTrim.push(elem);\r\n\r\n        if (recursive) {\r\n          _this4.collapseChildRows(elem, rowsToTrim);\r\n        }\r\n      });\r\n\r\n      if (doTrimming) {\r\n        this.trimRows(rowsToTrim);\r\n      }\r\n\r\n      return rowsToTrim;\r\n    }\r\n    /**\r\n     * Collapse child rows of the row at the provided index.\r\n     *\r\n     * @param {number} parentIndex Index of the parent node.\r\n     * @param {Array} [rowsToTrim=[]] Array of rows to trim. Defaults to an empty array.\r\n     * @param {boolean} [recursive] `true` if the collapsing process should be recursive.\r\n     * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.\r\n     */\r\n\r\n  }, {\r\n    key: \"collapseChildRows\",\r\n    value: function collapseChildRows(parentIndex) {\r\n      var _this5 = this;\r\n\r\n      var rowsToTrim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\r\n      var recursive = arguments.length > 2 ? arguments[2] : undefined;\r\n      var doTrimming = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\r\n\r\n      if (this.dataManager.hasChildren(parentIndex)) {\r\n        var parentObject = this.dataManager.getDataObject(parentIndex);\r\n        arrayEach(parentObject.__children, function (elem) {\r\n          var elemIndex = _this5.dataManager.getRowIndex(elem);\r\n\r\n          rowsToTrim.push(elemIndex);\r\n\r\n          _this5.collapseChildRows(elemIndex, rowsToTrim);\r\n        });\r\n      }\r\n\r\n      if (doTrimming) {\r\n        this.trimRows(rowsToTrim);\r\n      }\r\n    }\r\n    /**\r\n     * Expand a single row.\r\n     *\r\n     * @param {number} rowIndex Index of the row to expand.\r\n     * @param {boolean} [recursive=true] `true` if it should expand the row's children recursively.\r\n     */\r\n\r\n  }, {\r\n    key: \"expandRow\",\r\n    value: function expandRow(rowIndex) {\r\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n      this.expandRows([rowIndex], recursive);\r\n    }\r\n    /**\r\n     * Expand multiple rows.\r\n     *\r\n     * @param {Array} rowIndexes Array of indexes of the rows to expand.\r\n     * @param {boolean} [recursive=true] `true` if it should expand the rows' children recursively.\r\n     * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.\r\n     * @returns {Array} Array of row indexes to be untrimmed.\r\n     */\r\n\r\n  }, {\r\n    key: \"expandRows\",\r\n    value: function expandRows(rowIndexes) {\r\n      var _this6 = this;\r\n\r\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n      var doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n      var rowsToUntrim = [];\r\n      arrayEach(rowIndexes, function (elem) {\r\n        rowsToUntrim.push(elem);\r\n\r\n        if (recursive) {\r\n          _this6.expandChildRows(elem, rowsToUntrim);\r\n        }\r\n      });\r\n\r\n      if (doTrimming) {\r\n        this.untrimRows(rowsToUntrim);\r\n      }\r\n\r\n      return rowsToUntrim;\r\n    }\r\n    /**\r\n     * Expand child rows of the provided index.\r\n     *\r\n     * @param {number} parentIndex Index of the parent row.\r\n     * @param {Array} [rowsToUntrim=[]] Array of the rows to be untrimmed.\r\n     * @param {boolean} [recursive] `true` if it should expand the rows' children recursively.\r\n     * @param {boolean} [doTrimming=false] I determine whether collapsing should envolve trimming rows.\r\n     */\r\n\r\n  }, {\r\n    key: \"expandChildRows\",\r\n    value: function expandChildRows(parentIndex) {\r\n      var _this7 = this;\r\n\r\n      var rowsToUntrim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\r\n      var recursive = arguments.length > 2 ? arguments[2] : undefined;\r\n      var doTrimming = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\r\n\r\n      if (this.dataManager.hasChildren(parentIndex)) {\r\n        var parentObject = this.dataManager.getDataObject(parentIndex);\r\n        arrayEach(parentObject.__children, function (elem) {\r\n          if (!_this7.isAnyParentCollapsed(elem)) {\r\n            var elemIndex = _this7.dataManager.getRowIndex(elem);\r\n\r\n            rowsToUntrim.push(elemIndex);\r\n\r\n            _this7.expandChildRows(elemIndex, rowsToUntrim);\r\n          }\r\n        });\r\n      }\r\n\r\n      if (doTrimming) {\r\n        this.untrimRows(rowsToUntrim);\r\n      }\r\n    }\r\n    /**\r\n     * Expand the children of the row passed as an argument.\r\n     *\r\n     * @param {number|object} row Parent row.\r\n     * @param {boolean} [forceRender=true] Whether to render the table after the function ends.\r\n     * @param {boolean} [doTrimming=true] If set to `true`, the trimming will be applied when the function finishes.\r\n     * @returns {number[]}\r\n     */\r\n\r\n  }, {\r\n    key: \"expandChildren\",\r\n    value: function expandChildren(row) {\r\n      var _this8 = this;\r\n\r\n      var forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n      var doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\r\n      var rowsToExpand = [];\r\n      var rowObject = null;\r\n      var rowIndex = null;\r\n      var rowsToUntrim = null;\r\n\r\n      if (isNaN(row)) {\r\n        rowObject = row;\r\n        rowIndex = this.dataManager.getRowIndex(row);\r\n      } else {\r\n        rowObject = this.dataManager.getDataObject(row);\r\n        rowIndex = row;\r\n      }\r\n\r\n      this.collapsedRows.splice(this.collapsedRows.indexOf(rowIndex), 1);\r\n\r\n      if (this.dataManager.hasChildren(rowObject)) {\r\n        arrayEach(rowObject.__children, function (elem) {\r\n          var childIndex = _this8.dataManager.getRowIndex(elem);\r\n\r\n          rowsToExpand.push(childIndex);\r\n        });\r\n      }\r\n\r\n      rowsToUntrim = this.expandRows(rowsToExpand, true, false);\r\n\r\n      if (doTrimming) {\r\n        this.untrimRows(rowsToUntrim);\r\n      }\r\n\r\n      if (forceRender) {\r\n        this.renderAndAdjust();\r\n      }\r\n\r\n      return rowsToUntrim;\r\n    }\r\n    /**\r\n     * Expand multiple rows' children.\r\n     *\r\n     * @param {Array} rows Array of rows which children are about to be expanded.\r\n     * @param {boolean} [forceRender=true] `true` if the table should render after finishing the function.\r\n     * @param {boolean} [doTrimming=true] `true` if the rows should be untrimmed after finishing the function.\r\n     */\r\n\r\n  }, {\r\n    key: \"expandMultipleChildren\",\r\n    value: function expandMultipleChildren(rows) {\r\n      var _this9 = this;\r\n\r\n      var forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n      var doTrimming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\r\n      var rowsToUntrim = [];\r\n      arrayEach(rows, function (elem) {\r\n        rowsToUntrim.push.apply(rowsToUntrim, _toConsumableArray(_this9.expandChildren(elem, false, false)));\r\n      });\r\n\r\n      if (doTrimming) {\r\n        this.untrimRows(rowsToUntrim);\r\n      }\r\n\r\n      if (forceRender) {\r\n        this.renderAndAdjust();\r\n      }\r\n    }\r\n    /**\r\n     * Collapse all collapsable rows.\r\n     */\r\n\r\n  }, {\r\n    key: \"collapseAll\",\r\n    value: function collapseAll() {\r\n      var _this10 = this;\r\n\r\n      var data = this.dataManager.getData();\r\n      var parentsToCollapse = [];\r\n      arrayEach(data, function (elem) {\r\n        if (_this10.dataManager.hasChildren(elem)) {\r\n          parentsToCollapse.push(elem);\r\n        }\r\n      });\r\n      this.collapseMultipleChildren(parentsToCollapse);\r\n      this.renderAndAdjust();\r\n    }\r\n    /**\r\n     * Expand all collapsable rows.\r\n     */\r\n\r\n  }, {\r\n    key: \"expandAll\",\r\n    value: function expandAll() {\r\n      var _this11 = this;\r\n\r\n      var data = this.dataManager.getData();\r\n      var parentsToExpand = [];\r\n      arrayEach(data, function (elem) {\r\n        if (_this11.dataManager.hasChildren(elem)) {\r\n          parentsToExpand.push(elem);\r\n        }\r\n      });\r\n      this.expandMultipleChildren(parentsToExpand);\r\n      this.renderAndAdjust();\r\n    }\r\n    /**\r\n     * Trim rows.\r\n     *\r\n     * @param {Array} rows Physical row indexes.\r\n     */\r\n\r\n  }, {\r\n    key: \"trimRows\",\r\n    value: function trimRows(rows) {\r\n      var _this12 = this;\r\n\r\n      this.hot.batchExecution(function () {\r\n        arrayEach(rows, function (physicalRow) {\r\n          _this12.plugin.collapsedRowsMap.setValueAtIndex(physicalRow, true);\r\n        });\r\n      }, true);\r\n    }\r\n    /**\r\n     * Untrim rows.\r\n     *\r\n     * @param {Array} rows Physical row indexes.\r\n     */\r\n\r\n  }, {\r\n    key: \"untrimRows\",\r\n    value: function untrimRows(rows) {\r\n      var _this13 = this;\r\n\r\n      this.hot.batchExecution(function () {\r\n        arrayEach(rows, function (physicalRow) {\r\n          _this13.plugin.collapsedRowsMap.setValueAtIndex(physicalRow, false);\r\n        });\r\n      }, true);\r\n    }\r\n    /**\r\n     * Check if all child rows are collapsed.\r\n     *\r\n     * @private\r\n     * @param {number|object|null} row The parent row. `null` for the top level.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"areChildrenCollapsed\",\r\n    value: function areChildrenCollapsed(row) {\r\n      var _this14 = this;\r\n\r\n      var rowObj = isNaN(row) ? row : this.dataManager.getDataObject(row);\r\n      var allCollapsed = true; // Checking the children of the top-level \"parent\"\r\n\r\n      if (rowObj === null) {\r\n        rowObj = {\r\n          __children: this.dataManager.data\r\n        };\r\n      }\r\n\r\n      if (this.dataManager.hasChildren(rowObj)) {\r\n        arrayEach(rowObj.__children, function (elem) {\r\n          var rowIndex = _this14.dataManager.getRowIndex(elem);\r\n\r\n          if (!_this14.plugin.collapsedRowsMap.getValueAtIndex(rowIndex)) {\r\n            allCollapsed = false;\r\n            return false;\r\n          }\r\n        });\r\n      }\r\n\r\n      return allCollapsed;\r\n    }\r\n    /**\r\n     * Check if any of the row object parents are collapsed.\r\n     *\r\n     * @private\r\n     * @param {object} rowObj Row object.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isAnyParentCollapsed\",\r\n    value: function isAnyParentCollapsed(rowObj) {\r\n      var parent = rowObj;\r\n\r\n      while (parent !== null) {\r\n        parent = this.dataManager.getRowParent(parent);\r\n        var parentIndex = this.dataManager.getRowIndex(parent);\r\n\r\n        if (this.collapsedRows.indexOf(parentIndex) > -1) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    }\r\n    /**\r\n     * Toggle collapsed state. Callback for the `beforeOnCellMousedown` hook.\r\n     *\r\n     * @private\r\n     * @param {MouseEvent} event `mousedown` event.\r\n     * @param {object} coords Coordinates of the clicked cell/header.\r\n     */\r\n\r\n  }, {\r\n    key: \"toggleState\",\r\n    value: function toggleState(event, coords) {\r\n      if (coords.col >= 0) {\r\n        return;\r\n      }\r\n\r\n      var row = this.translateTrimmedRow(coords.row);\r\n\r\n      if (hasClass(event.target, HeadersUI.CSS_CLASSES.button)) {\r\n        if (this.areChildrenCollapsed(row)) {\r\n          this.expandChildren(row);\r\n        } else {\r\n          this.collapseChildren(row);\r\n        }\r\n\r\n        stopImmediatePropagation(event);\r\n      }\r\n    }\r\n    /**\r\n     * Translate visual row after trimming to physical base row index.\r\n     *\r\n     * @private\r\n     * @param {number} row Row index.\r\n     * @returns {number} Base row index.\r\n     */\r\n\r\n  }, {\r\n    key: \"translateTrimmedRow\",\r\n    value: function translateTrimmedRow(row) {\r\n      return this.hot.toPhysicalRow(row);\r\n    }\r\n    /**\r\n     * Translate physical row after trimming to visual base row index.\r\n     *\r\n     * @private\r\n     * @param {number} row Row index.\r\n     * @returns {number} Base row index.\r\n     */\r\n\r\n  }, {\r\n    key: \"untranslateTrimmedRow\",\r\n    value: function untranslateTrimmedRow(row) {\r\n      return this.hot.toVisualRow(row);\r\n    }\r\n    /**\r\n     * Helper function to render the table and call the `adjustElementsSize` method.\r\n     *\r\n     * @private\r\n     */\r\n\r\n  }, {\r\n    key: \"renderAndAdjust\",\r\n    value: function renderAndAdjust() {\r\n      this.hot.render(); // Dirty workaround to prevent scroll height not adjusting to the table height. Needs refactoring in the future.\r\n\r\n      this.hot.view.adjustElementsSize();\r\n    }\r\n  }]);\r\n\r\n  return CollapsingUI;\r\n}(BaseUI);\r\n\r\nexport default CollapsingUI;"]},"metadata":{},"sourceType":"module"}