{"ast":null,"code":"import \"core-js/modules/es.array.includes\";\nimport \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.string.includes\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport CellCoords from \"./../cell/coords.mjs\";\n/**\r\n * CellRange holds cell coordinates as {@link CellCoords} instances. This object represent unit of the selection layer which\r\n * can contains multiple contiquous cells or single cell.\r\n *\r\n * @util\r\n */\n\nvar CellRange = /*#__PURE__*/function () {\n  function CellRange(highlight) {\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : highlight;\n    var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : highlight;\n\n    _classCallCheck(this, CellRange);\n    /**\r\n     * Used to draw bold border around a cell where selection was started and to edit the cell\r\n     * when you press Enter. The highlight cannot point to headers (negative values) so its\r\n     * coordinates object is normalized while assigning.\r\n     *\r\n     * @type {CellCoords}\r\n     */\n\n\n    this.highlight = highlight.clone().normalize();\n    /**\r\n     * Usually the same as highlight, but in Excel there is distinction - one can change\r\n     * highlight within a selection.\r\n     *\r\n     * @type {CellCoords}\r\n     */\n\n    this.from = from.clone();\n    /**\r\n     * End selection.\r\n     *\r\n     * @type {CellCoords}\r\n     */\n\n    this.to = to.clone();\n  }\n  /**\r\n   * Set the new coordinates for highlighting selection.\r\n   *\r\n   * @param {CellCoords} coords Coordinates to use.\r\n   * @returns {CellRange}\r\n   */\n\n\n  _createClass(CellRange, [{\n    key: \"setHighlight\",\n    value: function setHighlight(coords) {\n      this.highlight = coords.clone().normalize();\n      return this;\n    }\n    /**\r\n     * Set the new coordinates where selection starts from.\r\n     *\r\n     * @param {CellCoords} coords Coordinates to use.\r\n     * @returns {CellRange}\r\n     */\n\n  }, {\n    key: \"setFrom\",\n    value: function setFrom(coords) {\n      this.from = coords.clone();\n      return this;\n    }\n    /**\r\n     * Set new coordinates where selection ends from.\r\n     *\r\n     * @param {CellCoords} coords Coordinates to use.\r\n     * @returns {CellRange}\r\n     */\n\n  }, {\n    key: \"setTo\",\n    value: function setTo(coords) {\n      this.to = coords.clone();\n      return this;\n    }\n    /**\r\n     * Checks if given coordinates are valid in context of a given Walkontable instance.\r\n     *\r\n     * @param {Walkontable} wot The Walkontable instance.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid(wot) {\n      return this.from.isValid(wot) && this.to.isValid(wot);\n    }\n    /**\r\n     * Checks if this cell range is restricted to one cell.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isSingle\",\n    value: function isSingle() {\n      return this.from.row >= 0 && this.from.row === this.to.row && this.from.col >= 0 && this.from.col === this.to.col;\n    }\n    /**\r\n     * Returns selected range height (in number of rows including rows' headers).\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getOuterHeight\",\n    value: function getOuterHeight() {\n      return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;\n    }\n    /**\r\n     * Returns selected range width (in number of columns including columns' headers).\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getOuterWidth\",\n    value: function getOuterWidth() {\n      return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;\n    }\n    /**\r\n     * Returns selected range height (in number of rows excluding rows' headers).\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      var fromRow = Math.max(this.from.row, 0);\n      var toRow = Math.max(this.to.row, 0);\n      return Math.max(fromRow, toRow) - Math.min(fromRow, toRow) + 1;\n    }\n    /**\r\n     * Returns selected range width (in number of columns excluding columns' headers).\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      var fromCol = Math.max(this.from.col, 0);\n      var toCol = Math.max(this.to.col, 0);\n      return Math.max(fromCol, toCol) - Math.min(fromCol, toCol) + 1;\n    }\n    /**\r\n     * Checks if given cell coordinates are within `from` and `to` cell coordinates of this range.\r\n     *\r\n     * @param {CellCoords} cellCoords The cell coordinates to check.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"includes\",\n    value: function includes(cellCoords) {\n      var row = cellCoords.row,\n          col = cellCoords.col;\n      var topLeft = this.getOuterTopLeftCorner();\n      var bottomRight = this.getOuterBottomRightCorner();\n      return topLeft.row <= row && bottomRight.row >= row && topLeft.col <= col && bottomRight.col >= col;\n    }\n    /**\r\n     * Checks if given range is within of this range.\r\n     *\r\n     * @param {CellRange} cellRange The cells range to check.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"includesRange\",\n    value: function includesRange(cellRange) {\n      return this.includes(cellRange.getOuterTopLeftCorner()) && this.includes(cellRange.getOuterBottomRightCorner());\n    }\n    /**\r\n     * Checks if given range is equal to this range.\r\n     *\r\n     * @param {CellRange} cellRange The cells range to check.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(cellRange) {\n      return Math.min(this.from.row, this.to.row) === Math.min(cellRange.from.row, cellRange.to.row) && Math.max(this.from.row, this.to.row) === Math.max(cellRange.from.row, cellRange.to.row) && Math.min(this.from.col, this.to.col) === Math.min(cellRange.from.col, cellRange.to.col) && Math.max(this.from.col, this.to.col) === Math.max(cellRange.from.col, cellRange.to.col);\n    }\n    /**\r\n     * Checks if tested range overlaps with the range. Range A is considered to to be overlapping with range B\r\n     * if intersection of A and B or B and A is not empty.\r\n     *\r\n     * @param {CellRange} cellRange The cells range to check.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(cellRange) {\n      return cellRange.isSouthEastOf(this.getOuterTopLeftCorner()) && cellRange.isNorthWestOf(this.getOuterBottomRightCorner());\n    }\n    /**\r\n     * Checks if tested coordinates are positioned in south-east from this cell range.\r\n     *\r\n     * @param {CellRange} cellRange The cells range to check.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isSouthEastOf\",\n    value: function isSouthEastOf(cellRange) {\n      return this.getOuterTopLeftCorner().isSouthEastOf(cellRange) || this.getOuterBottomRightCorner().isSouthEastOf(cellRange);\n    }\n    /**\r\n     * Checks if tested coordinates are positioned in north-west from this cell range.\r\n     *\r\n     * @param {CellRange} cellRange The cells range to check.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isNorthWestOf\",\n    value: function isNorthWestOf(cellRange) {\n      return this.getOuterTopLeftCorner().isNorthWestOf(cellRange) || this.getOuterBottomRightCorner().isNorthWestOf(cellRange);\n    }\n    /**\r\n     * Returns `true` if the provided range is overlapping the current range horizontally (e.g. The current range's last\r\n     * column is 5 and the provided range's first column is 3).\r\n     *\r\n     * @param {CellRange} cellRange The cells range to check.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isOverlappingHorizontally\",\n    value: function isOverlappingHorizontally(cellRange) {\n      return this.getOuterTopRightCorner().col >= cellRange.getOuterTopLeftCorner().col && this.getOuterTopRightCorner().col <= cellRange.getOuterTopRightCorner().col || this.getOuterTopLeftCorner().col <= cellRange.getOuterTopRightCorner().col && this.getOuterTopLeftCorner().col >= cellRange.getOuterTopLeftCorner().col;\n    }\n    /**\r\n     * Returns `true` if the provided range is overlapping the current range vertically (e.g. The current range's last\r\n     *  row is 5 and the provided range's first row is 3).\r\n     *\r\n     * @param {CellRange} cellRange The cells range to check.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isOverlappingVertically\",\n    value: function isOverlappingVertically(cellRange) {\n      return this.getOuterBottomRightCorner().row >= cellRange.getOuterTopRightCorner().row && this.getOuterBottomRightCorner().row <= cellRange.getOuterBottomRightCorner().row || this.getOuterTopRightCorner().row <= cellRange.getOuterBottomRightCorner().row && this.getOuterTopRightCorner().row >= cellRange.getOuterTopRightCorner().row;\n    }\n    /**\r\n     * Adds a cell to a range (only if exceeds corners of the range). Returns information if range was expanded.\r\n     *\r\n     * @param {CellCoords} cellCoords The cell coordinates.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"expand\",\n    value: function expand(cellCoords) {\n      var topLeft = this.getOuterTopLeftCorner();\n      var bottomRight = this.getOuterBottomRightCorner();\n\n      if (cellCoords.row < topLeft.row || cellCoords.col < topLeft.col || cellCoords.row > bottomRight.row || cellCoords.col > bottomRight.col) {\n        this.from = new CellCoords(Math.min(topLeft.row, cellCoords.row), Math.min(topLeft.col, cellCoords.col));\n        this.to = new CellCoords(Math.max(bottomRight.row, cellCoords.row), Math.max(bottomRight.col, cellCoords.col));\n        return true;\n      }\n\n      return false;\n    }\n    /**\r\n     * Expand the current object by the range passed in the first argument.\r\n     *\r\n     * @param {CellRange} expandingRange Object extending the range.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"expandByRange\",\n    value: function expandByRange(expandingRange) {\n      if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {\n        return false;\n      }\n\n      var topLeft = this.getOuterTopLeftCorner();\n      var bottomRight = this.getOuterBottomRightCorner();\n      var initialDirection = this.getDirection();\n      var expandingTopLeft = expandingRange.getOuterTopLeftCorner();\n      var expandingBottomRight = expandingRange.getOuterBottomRightCorner();\n      var resultTopRow = Math.min(topLeft.row, expandingTopLeft.row);\n      var resultTopCol = Math.min(topLeft.col, expandingTopLeft.col);\n      var resultBottomRow = Math.max(bottomRight.row, expandingBottomRight.row);\n      var resultBottomCol = Math.max(bottomRight.col, expandingBottomRight.col);\n      var finalFrom = new CellCoords(resultTopRow, resultTopCol);\n      var finalTo = new CellCoords(resultBottomRow, resultBottomCol);\n      this.from = finalFrom;\n      this.to = finalTo;\n      this.setDirection(initialDirection);\n\n      if (this.highlight.row === this.getOuterBottomRightCorner().row && this.getVerticalDirection() === 'N-S') {\n        this.flipDirectionVertically();\n      }\n\n      if (this.highlight.col === this.getOuterTopRightCorner().col && this.getHorizontalDirection() === 'W-E') {\n        this.flipDirectionHorizontally();\n      }\n\n      return true;\n    }\n    /**\r\n     * Gets the direction of the selection.\r\n     *\r\n     * @returns {string} Returns one of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\r\n     */\n\n  }, {\n    key: \"getDirection\",\n    value: function getDirection() {\n      if (this.from.isNorthWestOf(this.to)) {\n        // NorthWest - SouthEast\n        return 'NW-SE';\n      } else if (this.from.isNorthEastOf(this.to)) {\n        // NorthEast - SouthWest\n        return 'NE-SW';\n      } else if (this.from.isSouthEastOf(this.to)) {\n        // SouthEast - NorthWest\n        return 'SE-NW';\n      } else if (this.from.isSouthWestOf(this.to)) {\n        // SouthWest - NorthEast\n        return 'SW-NE';\n      }\n    }\n    /**\r\n     * Sets the direction of the selection.\r\n     *\r\n     * @param {string} direction One of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\r\n     */\n\n  }, {\n    key: \"setDirection\",\n    value: function setDirection(direction) {\n      switch (direction) {\n        case 'NW-SE':\n          var _ref = [this.getOuterTopLeftCorner(), this.getOuterBottomRightCorner()];\n          this.from = _ref[0];\n          this.to = _ref[1];\n          break;\n\n        case 'NE-SW':\n          var _ref2 = [this.getOuterTopRightCorner(), this.getOuterBottomLeftCorner()];\n          this.from = _ref2[0];\n          this.to = _ref2[1];\n          break;\n\n        case 'SE-NW':\n          var _ref3 = [this.getOuterBottomRightCorner(), this.getOuterTopLeftCorner()];\n          this.from = _ref3[0];\n          this.to = _ref3[1];\n          break;\n\n        case 'SW-NE':\n          var _ref4 = [this.getOuterBottomLeftCorner(), this.getOuterTopRightCorner()];\n          this.from = _ref4[0];\n          this.to = _ref4[1];\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\r\n     * Gets the vertical direction of the range.\r\n     *\r\n     * @returns {string} Returns one of the values: `N-S` (north->south), `S-N` (south->north).\r\n     */\n\n  }, {\n    key: \"getVerticalDirection\",\n    value: function getVerticalDirection() {\n      return ['NE-SW', 'NW-SE'].indexOf(this.getDirection()) > -1 ? 'N-S' : 'S-N';\n    }\n    /**\r\n     * Gets the horizontal direction of the range.\r\n     *\r\n     * @returns {string} Returns one of the values: `W-E` (west->east), `E-W` (east->west).\r\n     */\n\n  }, {\n    key: \"getHorizontalDirection\",\n    value: function getHorizontalDirection() {\n      return ['NW-SE', 'SW-NE'].indexOf(this.getDirection()) > -1 ? 'W-E' : 'E-W';\n    }\n    /**\r\n     * Flip the direction vertically. (e.g. `NW-SE` changes to `SW-NE`).\r\n     */\n\n  }, {\n    key: \"flipDirectionVertically\",\n    value: function flipDirectionVertically() {\n      var direction = this.getDirection();\n\n      switch (direction) {\n        case 'NW-SE':\n          this.setDirection('SW-NE');\n          break;\n\n        case 'NE-SW':\n          this.setDirection('SE-NW');\n          break;\n\n        case 'SE-NW':\n          this.setDirection('NE-SW');\n          break;\n\n        case 'SW-NE':\n          this.setDirection('NW-SE');\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\r\n     * Flip the direction horizontally. (e.g. `NW-SE` changes to `NE-SW`).\r\n     */\n\n  }, {\n    key: \"flipDirectionHorizontally\",\n    value: function flipDirectionHorizontally() {\n      var direction = this.getDirection();\n\n      switch (direction) {\n        case 'NW-SE':\n          this.setDirection('NE-SW');\n          break;\n\n        case 'NE-SW':\n          this.setDirection('NW-SE');\n          break;\n\n        case 'SE-NW':\n          this.setDirection('SW-NE');\n          break;\n\n        case 'SW-NE':\n          this.setDirection('SE-NW');\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\r\n     * Gets the top left corner of this range. If the corner contains header coordinates\r\n     * (negative values), the corner coordinates will be normalized to 0.\r\n     *\r\n     * @returns {CellCoords}\r\n     */\n\n  }, {\n    key: \"getTopLeftCorner\",\n    value: function getTopLeftCorner() {\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();\n    }\n    /**\r\n     * Gets the bottom right corner of this range. If the corner contains header coordinates\r\n     * (negative values), the corner coordinates will be normalized to 0.\r\n     *\r\n     * @returns {CellCoords}\r\n     */\n\n  }, {\n    key: \"getBottomRightCorner\",\n    value: function getBottomRightCorner() {\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();\n    }\n    /**\r\n     * Gets the top right corner of this range. If the corner contains header coordinates\r\n     * (negative values), the corner coordinates will be normalized to 0.\r\n     *\r\n     * @returns {CellCoords}\r\n     */\n\n  }, {\n    key: \"getTopRightCorner\",\n    value: function getTopRightCorner() {\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();\n    }\n    /**\r\n     * Gets the bottom left corner of this range. If the corner contains header coordinates\r\n     * (negative values), the corner coordinates will be normalized to 0.\r\n     *\r\n     * @returns {CellCoords}\r\n     */\n\n  }, {\n    key: \"getBottomLeftCorner\",\n    value: function getBottomLeftCorner() {\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();\n    }\n    /**\r\n     * Gets the top left corner of this range. If the corner contains header coordinates\r\n     * (negative values), then the top and left coordinates will be pointed to that header.\r\n     *\r\n     * @returns {CellCoords}\r\n     */\n\n  }, {\n    key: \"getOuterTopLeftCorner\",\n    value: function getOuterTopLeftCorner() {\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n    }\n    /**\r\n     * Gets the bottom right corner of this range.\r\n     *\r\n     * @returns {CellCoords}\r\n     */\n\n  }, {\n    key: \"getOuterBottomRightCorner\",\n    value: function getOuterBottomRightCorner() {\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n    }\n    /**\r\n     * Gets the top right corner of this range. If the corner contains header coordinates\r\n     * (negative values), then the top coordinate will be pointed to that header.\r\n     *\r\n     * @returns {CellCoords}\r\n     */\n\n  }, {\n    key: \"getOuterTopRightCorner\",\n    value: function getOuterTopRightCorner() {\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n    }\n    /**\r\n     * Gets the bottom left corner of this range. If the corner contains header coordinates\r\n     * (negative values), then the left coordinate will be pointed to that header.\r\n     *\r\n     * @returns {CellCoords}\r\n     */\n\n  }, {\n    key: \"getOuterBottomLeftCorner\",\n    value: function getOuterBottomLeftCorner() {\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n    }\n    /**\r\n     * Checks if coordinates match to one of the 4th corners of this range.\r\n     *\r\n     * @param {CellCoords} coords Cell coordinates to check.\r\n     * @param {CellRange} [expandedRange] The cells range to compare with.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isCorner\",\n    value: function isCorner(coords, expandedRange) {\n      if (expandedRange && expandedRange.includes(coords) && (this.getOuterTopLeftCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.from.col)) || this.getOuterTopRightCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.to.col)) || this.getOuterBottomLeftCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.from.col)) || this.getOuterBottomRightCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.to.col)))) {\n        return true;\n      }\n\n      return coords.isEqual(this.getOuterTopLeftCorner()) || coords.isEqual(this.getOuterTopRightCorner()) || coords.isEqual(this.getOuterBottomLeftCorner()) || coords.isEqual(this.getOuterBottomRightCorner());\n    }\n    /**\r\n     * Gets coordinates of the corner which is opposite to the matched. When the passed coordinates matched to the\r\n     * bottom-right corner of this range then the coordinates for top-left will be returned.\r\n     *\r\n     * @param {CellCoords} coords Cell coordinates to check.\r\n     * @param {CellRange} [expandedRange] The cells range to compare with.\r\n     * @returns {CellCoords}\r\n     */\n\n  }, {\n    key: \"getOppositeCorner\",\n    value: function getOppositeCorner(coords, expandedRange) {\n      if (!(coords instanceof CellCoords)) {\n        return false;\n      }\n\n      if (expandedRange) {\n        if (expandedRange.includes(coords)) {\n          if (this.getOuterTopLeftCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.from.col))) {\n            return this.getOuterBottomRightCorner();\n          }\n\n          if (this.getOuterTopRightCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.to.col))) {\n            return this.getOuterBottomLeftCorner();\n          }\n\n          if (this.getOuterBottomLeftCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.from.col))) {\n            return this.getOuterTopRightCorner();\n          }\n\n          if (this.getOuterBottomRightCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.to.col))) {\n            return this.getOuterTopLeftCorner();\n          }\n        }\n      }\n\n      if (coords.isEqual(this.getOuterBottomRightCorner())) {\n        return this.getOuterTopLeftCorner();\n      } else if (coords.isEqual(this.getOuterTopLeftCorner())) {\n        return this.getOuterBottomRightCorner();\n      } else if (coords.isEqual(this.getOuterTopRightCorner())) {\n        return this.getOuterBottomLeftCorner();\n      } else if (coords.isEqual(this.getOuterBottomLeftCorner())) {\n        return this.getOuterTopRightCorner();\n      }\n    }\n    /**\r\n     * @param {CellRange} range The cells range to compare with.\r\n     * @returns {Array}\r\n     */\n\n  }, {\n    key: \"getBordersSharedWith\",\n    value: function getBordersSharedWith(range) {\n      if (!this.includesRange(range)) {\n        return [];\n      }\n\n      var thisBorders = {\n        top: Math.min(this.from.row, this.to.row),\n        bottom: Math.max(this.from.row, this.to.row),\n        left: Math.min(this.from.col, this.to.col),\n        right: Math.max(this.from.col, this.to.col)\n      };\n      var rangeBorders = {\n        top: Math.min(range.from.row, range.to.row),\n        bottom: Math.max(range.from.row, range.to.row),\n        left: Math.min(range.from.col, range.to.col),\n        right: Math.max(range.from.col, range.to.col)\n      };\n      var result = [];\n\n      if (thisBorders.top === rangeBorders.top) {\n        result.push('top');\n      }\n\n      if (thisBorders.right === rangeBorders.right) {\n        result.push('right');\n      }\n\n      if (thisBorders.bottom === rangeBorders.bottom) {\n        result.push('bottom');\n      }\n\n      if (thisBorders.left === rangeBorders.left) {\n        result.push('left');\n      }\n\n      return result;\n    }\n    /**\r\n     * Get inner selected cell coords defined by this range.\r\n     *\r\n     * @returns {Array}\r\n     */\n\n  }, {\n    key: \"getInner\",\n    value: function getInner() {\n      var topLeft = this.getOuterTopLeftCorner();\n      var bottomRight = this.getOuterBottomRightCorner();\n      var out = [];\n\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {\n            out.push(new CellCoords(r, c));\n          }\n        }\n      }\n\n      return out;\n    }\n    /**\r\n     * Get all selected cell coords defined by this range.\r\n     *\r\n     * @returns {Array}\r\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var topLeft = this.getOuterTopLeftCorner();\n      var bottomRight = this.getOuterBottomRightCorner();\n      var out = [];\n\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          if (topLeft.row === r && topLeft.col === c) {\n            out.push(topLeft);\n          } else if (bottomRight.row === r && bottomRight.col === c) {\n            out.push(bottomRight);\n          } else {\n            out.push(new CellCoords(r, c));\n          }\n        }\n      }\n\n      return out;\n    }\n    /**\r\n     * Runs a callback function against all cells in the range. You can break the iteration by returning\r\n     * `false` in the callback function.\r\n     *\r\n     * @param {Function} callback The callback function.\r\n     */\n\n  }, {\n    key: \"forAll\",\n    value: function forAll(callback) {\n      var topLeft = this.getOuterTopLeftCorner();\n      var bottomRight = this.getOuterBottomRightCorner();\n\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          var breakIteration = callback(r, c);\n\n          if (breakIteration === false) {\n            return;\n          }\n        }\n      }\n    }\n    /**\r\n     * Clones the range coordinates.\r\n     *\r\n     * @returns {CellRange}\r\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new CellRange(this.highlight, this.from, this.to);\n    }\n    /**\r\n     * Convert CellRange to literal object.\r\n     *\r\n     * @returns {object} Returns a literal object with `from` and `to` properties which each of that object\r\n     *                  contains `row` and `col` keys.\r\n     */\n\n  }, {\n    key: \"toObject\",\n    value: function toObject() {\n      return {\n        from: this.from.toObject(),\n        to: this.to.toObject()\n      };\n    }\n  }]);\n\n  return CellRange;\n}();\n\nexport default CellRange;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/3rdparty/walkontable/src/cell/range.mjs"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","CellCoords","CellRange","highlight","from","arguments","undefined","to","clone","normalize","value","setHighlight","coords","setFrom","setTo","isValid","wot","isSingle","row","col","getOuterHeight","Math","max","min","getOuterWidth","getHeight","fromRow","toRow","getWidth","fromCol","toCol","includes","cellCoords","topLeft","getOuterTopLeftCorner","bottomRight","getOuterBottomRightCorner","includesRange","cellRange","isEqual","overlaps","isSouthEastOf","isNorthWestOf","isOverlappingHorizontally","getOuterTopRightCorner","isOverlappingVertically","expand","expandByRange","expandingRange","initialDirection","getDirection","expandingTopLeft","expandingBottomRight","resultTopRow","resultTopCol","resultBottomRow","resultBottomCol","finalFrom","finalTo","setDirection","getVerticalDirection","flipDirectionVertically","getHorizontalDirection","flipDirectionHorizontally","isNorthEastOf","isSouthWestOf","direction","_ref","_ref2","getOuterBottomLeftCorner","_ref3","_ref4","indexOf","getTopLeftCorner","getBottomRightCorner","getTopRightCorner","getBottomLeftCorner","isCorner","expandedRange","getOppositeCorner","getBordersSharedWith","range","thisBorders","top","bottom","left","right","rangeBorders","result","push","getInner","out","r","c","getAll","forAll","callback","breakIteration","toObject"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.includes.js\";\r\nimport \"core-js/modules/es.string.includes.js\";\r\nimport \"core-js/modules/es.array.index-of.js\";\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport CellCoords from \"./../cell/coords.mjs\";\r\n/**\r\n * CellRange holds cell coordinates as {@link CellCoords} instances. This object represent unit of the selection layer which\r\n * can contains multiple contiquous cells or single cell.\r\n *\r\n * @util\r\n */\r\n\r\nvar CellRange = /*#__PURE__*/function () {\r\n  function CellRange(highlight) {\r\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : highlight;\r\n    var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : highlight;\r\n\r\n    _classCallCheck(this, CellRange);\r\n\r\n    /**\r\n     * Used to draw bold border around a cell where selection was started and to edit the cell\r\n     * when you press Enter. The highlight cannot point to headers (negative values) so its\r\n     * coordinates object is normalized while assigning.\r\n     *\r\n     * @type {CellCoords}\r\n     */\r\n    this.highlight = highlight.clone().normalize();\r\n    /**\r\n     * Usually the same as highlight, but in Excel there is distinction - one can change\r\n     * highlight within a selection.\r\n     *\r\n     * @type {CellCoords}\r\n     */\r\n\r\n    this.from = from.clone();\r\n    /**\r\n     * End selection.\r\n     *\r\n     * @type {CellCoords}\r\n     */\r\n\r\n    this.to = to.clone();\r\n  }\r\n  /**\r\n   * Set the new coordinates for highlighting selection.\r\n   *\r\n   * @param {CellCoords} coords Coordinates to use.\r\n   * @returns {CellRange}\r\n   */\r\n\r\n\r\n  _createClass(CellRange, [{\r\n    key: \"setHighlight\",\r\n    value: function setHighlight(coords) {\r\n      this.highlight = coords.clone().normalize();\r\n      return this;\r\n    }\r\n    /**\r\n     * Set the new coordinates where selection starts from.\r\n     *\r\n     * @param {CellCoords} coords Coordinates to use.\r\n     * @returns {CellRange}\r\n     */\r\n\r\n  }, {\r\n    key: \"setFrom\",\r\n    value: function setFrom(coords) {\r\n      this.from = coords.clone();\r\n      return this;\r\n    }\r\n    /**\r\n     * Set new coordinates where selection ends from.\r\n     *\r\n     * @param {CellCoords} coords Coordinates to use.\r\n     * @returns {CellRange}\r\n     */\r\n\r\n  }, {\r\n    key: \"setTo\",\r\n    value: function setTo(coords) {\r\n      this.to = coords.clone();\r\n      return this;\r\n    }\r\n    /**\r\n     * Checks if given coordinates are valid in context of a given Walkontable instance.\r\n     *\r\n     * @param {Walkontable} wot The Walkontable instance.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isValid\",\r\n    value: function isValid(wot) {\r\n      return this.from.isValid(wot) && this.to.isValid(wot);\r\n    }\r\n    /**\r\n     * Checks if this cell range is restricted to one cell.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isSingle\",\r\n    value: function isSingle() {\r\n      return this.from.row >= 0 && this.from.row === this.to.row && this.from.col >= 0 && this.from.col === this.to.col;\r\n    }\r\n    /**\r\n     * Returns selected range height (in number of rows including rows' headers).\r\n     *\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getOuterHeight\",\r\n    value: function getOuterHeight() {\r\n      return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;\r\n    }\r\n    /**\r\n     * Returns selected range width (in number of columns including columns' headers).\r\n     *\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getOuterWidth\",\r\n    value: function getOuterWidth() {\r\n      return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;\r\n    }\r\n    /**\r\n     * Returns selected range height (in number of rows excluding rows' headers).\r\n     *\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getHeight\",\r\n    value: function getHeight() {\r\n      var fromRow = Math.max(this.from.row, 0);\r\n      var toRow = Math.max(this.to.row, 0);\r\n      return Math.max(fromRow, toRow) - Math.min(fromRow, toRow) + 1;\r\n    }\r\n    /**\r\n     * Returns selected range width (in number of columns excluding columns' headers).\r\n     *\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: \"getWidth\",\r\n    value: function getWidth() {\r\n      var fromCol = Math.max(this.from.col, 0);\r\n      var toCol = Math.max(this.to.col, 0);\r\n      return Math.max(fromCol, toCol) - Math.min(fromCol, toCol) + 1;\r\n    }\r\n    /**\r\n     * Checks if given cell coordinates are within `from` and `to` cell coordinates of this range.\r\n     *\r\n     * @param {CellCoords} cellCoords The cell coordinates to check.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"includes\",\r\n    value: function includes(cellCoords) {\r\n      var row = cellCoords.row,\r\n          col = cellCoords.col;\r\n      var topLeft = this.getOuterTopLeftCorner();\r\n      var bottomRight = this.getOuterBottomRightCorner();\r\n      return topLeft.row <= row && bottomRight.row >= row && topLeft.col <= col && bottomRight.col >= col;\r\n    }\r\n    /**\r\n     * Checks if given range is within of this range.\r\n     *\r\n     * @param {CellRange} cellRange The cells range to check.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"includesRange\",\r\n    value: function includesRange(cellRange) {\r\n      return this.includes(cellRange.getOuterTopLeftCorner()) && this.includes(cellRange.getOuterBottomRightCorner());\r\n    }\r\n    /**\r\n     * Checks if given range is equal to this range.\r\n     *\r\n     * @param {CellRange} cellRange The cells range to check.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isEqual\",\r\n    value: function isEqual(cellRange) {\r\n      return Math.min(this.from.row, this.to.row) === Math.min(cellRange.from.row, cellRange.to.row) && Math.max(this.from.row, this.to.row) === Math.max(cellRange.from.row, cellRange.to.row) && Math.min(this.from.col, this.to.col) === Math.min(cellRange.from.col, cellRange.to.col) && Math.max(this.from.col, this.to.col) === Math.max(cellRange.from.col, cellRange.to.col);\r\n    }\r\n    /**\r\n     * Checks if tested range overlaps with the range. Range A is considered to to be overlapping with range B\r\n     * if intersection of A and B or B and A is not empty.\r\n     *\r\n     * @param {CellRange} cellRange The cells range to check.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"overlaps\",\r\n    value: function overlaps(cellRange) {\r\n      return cellRange.isSouthEastOf(this.getOuterTopLeftCorner()) && cellRange.isNorthWestOf(this.getOuterBottomRightCorner());\r\n    }\r\n    /**\r\n     * Checks if tested coordinates are positioned in south-east from this cell range.\r\n     *\r\n     * @param {CellRange} cellRange The cells range to check.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isSouthEastOf\",\r\n    value: function isSouthEastOf(cellRange) {\r\n      return this.getOuterTopLeftCorner().isSouthEastOf(cellRange) || this.getOuterBottomRightCorner().isSouthEastOf(cellRange);\r\n    }\r\n    /**\r\n     * Checks if tested coordinates are positioned in north-west from this cell range.\r\n     *\r\n     * @param {CellRange} cellRange The cells range to check.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isNorthWestOf\",\r\n    value: function isNorthWestOf(cellRange) {\r\n      return this.getOuterTopLeftCorner().isNorthWestOf(cellRange) || this.getOuterBottomRightCorner().isNorthWestOf(cellRange);\r\n    }\r\n    /**\r\n     * Returns `true` if the provided range is overlapping the current range horizontally (e.g. The current range's last\r\n     * column is 5 and the provided range's first column is 3).\r\n     *\r\n     * @param {CellRange} cellRange The cells range to check.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isOverlappingHorizontally\",\r\n    value: function isOverlappingHorizontally(cellRange) {\r\n      return this.getOuterTopRightCorner().col >= cellRange.getOuterTopLeftCorner().col && this.getOuterTopRightCorner().col <= cellRange.getOuterTopRightCorner().col || this.getOuterTopLeftCorner().col <= cellRange.getOuterTopRightCorner().col && this.getOuterTopLeftCorner().col >= cellRange.getOuterTopLeftCorner().col;\r\n    }\r\n    /**\r\n     * Returns `true` if the provided range is overlapping the current range vertically (e.g. The current range's last\r\n     *  row is 5 and the provided range's first row is 3).\r\n     *\r\n     * @param {CellRange} cellRange The cells range to check.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isOverlappingVertically\",\r\n    value: function isOverlappingVertically(cellRange) {\r\n      return this.getOuterBottomRightCorner().row >= cellRange.getOuterTopRightCorner().row && this.getOuterBottomRightCorner().row <= cellRange.getOuterBottomRightCorner().row || this.getOuterTopRightCorner().row <= cellRange.getOuterBottomRightCorner().row && this.getOuterTopRightCorner().row >= cellRange.getOuterTopRightCorner().row;\r\n    }\r\n    /**\r\n     * Adds a cell to a range (only if exceeds corners of the range). Returns information if range was expanded.\r\n     *\r\n     * @param {CellCoords} cellCoords The cell coordinates.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"expand\",\r\n    value: function expand(cellCoords) {\r\n      var topLeft = this.getOuterTopLeftCorner();\r\n      var bottomRight = this.getOuterBottomRightCorner();\r\n\r\n      if (cellCoords.row < topLeft.row || cellCoords.col < topLeft.col || cellCoords.row > bottomRight.row || cellCoords.col > bottomRight.col) {\r\n        this.from = new CellCoords(Math.min(topLeft.row, cellCoords.row), Math.min(topLeft.col, cellCoords.col));\r\n        this.to = new CellCoords(Math.max(bottomRight.row, cellCoords.row), Math.max(bottomRight.col, cellCoords.col));\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    }\r\n    /**\r\n     * Expand the current object by the range passed in the first argument.\r\n     *\r\n     * @param {CellRange} expandingRange Object extending the range.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"expandByRange\",\r\n    value: function expandByRange(expandingRange) {\r\n      if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {\r\n        return false;\r\n      }\r\n\r\n      var topLeft = this.getOuterTopLeftCorner();\r\n      var bottomRight = this.getOuterBottomRightCorner();\r\n      var initialDirection = this.getDirection();\r\n      var expandingTopLeft = expandingRange.getOuterTopLeftCorner();\r\n      var expandingBottomRight = expandingRange.getOuterBottomRightCorner();\r\n      var resultTopRow = Math.min(topLeft.row, expandingTopLeft.row);\r\n      var resultTopCol = Math.min(topLeft.col, expandingTopLeft.col);\r\n      var resultBottomRow = Math.max(bottomRight.row, expandingBottomRight.row);\r\n      var resultBottomCol = Math.max(bottomRight.col, expandingBottomRight.col);\r\n      var finalFrom = new CellCoords(resultTopRow, resultTopCol);\r\n      var finalTo = new CellCoords(resultBottomRow, resultBottomCol);\r\n      this.from = finalFrom;\r\n      this.to = finalTo;\r\n      this.setDirection(initialDirection);\r\n\r\n      if (this.highlight.row === this.getOuterBottomRightCorner().row && this.getVerticalDirection() === 'N-S') {\r\n        this.flipDirectionVertically();\r\n      }\r\n\r\n      if (this.highlight.col === this.getOuterTopRightCorner().col && this.getHorizontalDirection() === 'W-E') {\r\n        this.flipDirectionHorizontally();\r\n      }\r\n\r\n      return true;\r\n    }\r\n    /**\r\n     * Gets the direction of the selection.\r\n     *\r\n     * @returns {string} Returns one of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\r\n     */\r\n\r\n  }, {\r\n    key: \"getDirection\",\r\n    value: function getDirection() {\r\n      if (this.from.isNorthWestOf(this.to)) {\r\n        // NorthWest - SouthEast\r\n        return 'NW-SE';\r\n      } else if (this.from.isNorthEastOf(this.to)) {\r\n        // NorthEast - SouthWest\r\n        return 'NE-SW';\r\n      } else if (this.from.isSouthEastOf(this.to)) {\r\n        // SouthEast - NorthWest\r\n        return 'SE-NW';\r\n      } else if (this.from.isSouthWestOf(this.to)) {\r\n        // SouthWest - NorthEast\r\n        return 'SW-NE';\r\n      }\r\n    }\r\n    /**\r\n     * Sets the direction of the selection.\r\n     *\r\n     * @param {string} direction One of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\r\n     */\r\n\r\n  }, {\r\n    key: \"setDirection\",\r\n    value: function setDirection(direction) {\r\n      switch (direction) {\r\n        case 'NW-SE':\r\n          var _ref = [this.getOuterTopLeftCorner(), this.getOuterBottomRightCorner()];\r\n          this.from = _ref[0];\r\n          this.to = _ref[1];\r\n          break;\r\n\r\n        case 'NE-SW':\r\n          var _ref2 = [this.getOuterTopRightCorner(), this.getOuterBottomLeftCorner()];\r\n          this.from = _ref2[0];\r\n          this.to = _ref2[1];\r\n          break;\r\n\r\n        case 'SE-NW':\r\n          var _ref3 = [this.getOuterBottomRightCorner(), this.getOuterTopLeftCorner()];\r\n          this.from = _ref3[0];\r\n          this.to = _ref3[1];\r\n          break;\r\n\r\n        case 'SW-NE':\r\n          var _ref4 = [this.getOuterBottomLeftCorner(), this.getOuterTopRightCorner()];\r\n          this.from = _ref4[0];\r\n          this.to = _ref4[1];\r\n          break;\r\n\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n    /**\r\n     * Gets the vertical direction of the range.\r\n     *\r\n     * @returns {string} Returns one of the values: `N-S` (north->south), `S-N` (south->north).\r\n     */\r\n\r\n  }, {\r\n    key: \"getVerticalDirection\",\r\n    value: function getVerticalDirection() {\r\n      return ['NE-SW', 'NW-SE'].indexOf(this.getDirection()) > -1 ? 'N-S' : 'S-N';\r\n    }\r\n    /**\r\n     * Gets the horizontal direction of the range.\r\n     *\r\n     * @returns {string} Returns one of the values: `W-E` (west->east), `E-W` (east->west).\r\n     */\r\n\r\n  }, {\r\n    key: \"getHorizontalDirection\",\r\n    value: function getHorizontalDirection() {\r\n      return ['NW-SE', 'SW-NE'].indexOf(this.getDirection()) > -1 ? 'W-E' : 'E-W';\r\n    }\r\n    /**\r\n     * Flip the direction vertically. (e.g. `NW-SE` changes to `SW-NE`).\r\n     */\r\n\r\n  }, {\r\n    key: \"flipDirectionVertically\",\r\n    value: function flipDirectionVertically() {\r\n      var direction = this.getDirection();\r\n\r\n      switch (direction) {\r\n        case 'NW-SE':\r\n          this.setDirection('SW-NE');\r\n          break;\r\n\r\n        case 'NE-SW':\r\n          this.setDirection('SE-NW');\r\n          break;\r\n\r\n        case 'SE-NW':\r\n          this.setDirection('NE-SW');\r\n          break;\r\n\r\n        case 'SW-NE':\r\n          this.setDirection('NW-SE');\r\n          break;\r\n\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n    /**\r\n     * Flip the direction horizontally. (e.g. `NW-SE` changes to `NE-SW`).\r\n     */\r\n\r\n  }, {\r\n    key: \"flipDirectionHorizontally\",\r\n    value: function flipDirectionHorizontally() {\r\n      var direction = this.getDirection();\r\n\r\n      switch (direction) {\r\n        case 'NW-SE':\r\n          this.setDirection('NE-SW');\r\n          break;\r\n\r\n        case 'NE-SW':\r\n          this.setDirection('NW-SE');\r\n          break;\r\n\r\n        case 'SE-NW':\r\n          this.setDirection('SW-NE');\r\n          break;\r\n\r\n        case 'SW-NE':\r\n          this.setDirection('SE-NW');\r\n          break;\r\n\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n    /**\r\n     * Gets the top left corner of this range. If the corner contains header coordinates\r\n     * (negative values), the corner coordinates will be normalized to 0.\r\n     *\r\n     * @returns {CellCoords}\r\n     */\r\n\r\n  }, {\r\n    key: \"getTopLeftCorner\",\r\n    value: function getTopLeftCorner() {\r\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();\r\n    }\r\n    /**\r\n     * Gets the bottom right corner of this range. If the corner contains header coordinates\r\n     * (negative values), the corner coordinates will be normalized to 0.\r\n     *\r\n     * @returns {CellCoords}\r\n     */\r\n\r\n  }, {\r\n    key: \"getBottomRightCorner\",\r\n    value: function getBottomRightCorner() {\r\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();\r\n    }\r\n    /**\r\n     * Gets the top right corner of this range. If the corner contains header coordinates\r\n     * (negative values), the corner coordinates will be normalized to 0.\r\n     *\r\n     * @returns {CellCoords}\r\n     */\r\n\r\n  }, {\r\n    key: \"getTopRightCorner\",\r\n    value: function getTopRightCorner() {\r\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();\r\n    }\r\n    /**\r\n     * Gets the bottom left corner of this range. If the corner contains header coordinates\r\n     * (negative values), the corner coordinates will be normalized to 0.\r\n     *\r\n     * @returns {CellCoords}\r\n     */\r\n\r\n  }, {\r\n    key: \"getBottomLeftCorner\",\r\n    value: function getBottomLeftCorner() {\r\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();\r\n    }\r\n    /**\r\n     * Gets the top left corner of this range. If the corner contains header coordinates\r\n     * (negative values), then the top and left coordinates will be pointed to that header.\r\n     *\r\n     * @returns {CellCoords}\r\n     */\r\n\r\n  }, {\r\n    key: \"getOuterTopLeftCorner\",\r\n    value: function getOuterTopLeftCorner() {\r\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\r\n    }\r\n    /**\r\n     * Gets the bottom right corner of this range.\r\n     *\r\n     * @returns {CellCoords}\r\n     */\r\n\r\n  }, {\r\n    key: \"getOuterBottomRightCorner\",\r\n    value: function getOuterBottomRightCorner() {\r\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\r\n    }\r\n    /**\r\n     * Gets the top right corner of this range. If the corner contains header coordinates\r\n     * (negative values), then the top coordinate will be pointed to that header.\r\n     *\r\n     * @returns {CellCoords}\r\n     */\r\n\r\n  }, {\r\n    key: \"getOuterTopRightCorner\",\r\n    value: function getOuterTopRightCorner() {\r\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\r\n    }\r\n    /**\r\n     * Gets the bottom left corner of this range. If the corner contains header coordinates\r\n     * (negative values), then the left coordinate will be pointed to that header.\r\n     *\r\n     * @returns {CellCoords}\r\n     */\r\n\r\n  }, {\r\n    key: \"getOuterBottomLeftCorner\",\r\n    value: function getOuterBottomLeftCorner() {\r\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\r\n    }\r\n    /**\r\n     * Checks if coordinates match to one of the 4th corners of this range.\r\n     *\r\n     * @param {CellCoords} coords Cell coordinates to check.\r\n     * @param {CellRange} [expandedRange] The cells range to compare with.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isCorner\",\r\n    value: function isCorner(coords, expandedRange) {\r\n      if (expandedRange && expandedRange.includes(coords) && (this.getOuterTopLeftCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.from.col)) || this.getOuterTopRightCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.to.col)) || this.getOuterBottomLeftCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.from.col)) || this.getOuterBottomRightCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.to.col)))) {\r\n        return true;\r\n      }\r\n\r\n      return coords.isEqual(this.getOuterTopLeftCorner()) || coords.isEqual(this.getOuterTopRightCorner()) || coords.isEqual(this.getOuterBottomLeftCorner()) || coords.isEqual(this.getOuterBottomRightCorner());\r\n    }\r\n    /**\r\n     * Gets coordinates of the corner which is opposite to the matched. When the passed coordinates matched to the\r\n     * bottom-right corner of this range then the coordinates for top-left will be returned.\r\n     *\r\n     * @param {CellCoords} coords Cell coordinates to check.\r\n     * @param {CellRange} [expandedRange] The cells range to compare with.\r\n     * @returns {CellCoords}\r\n     */\r\n\r\n  }, {\r\n    key: \"getOppositeCorner\",\r\n    value: function getOppositeCorner(coords, expandedRange) {\r\n      if (!(coords instanceof CellCoords)) {\r\n        return false;\r\n      }\r\n\r\n      if (expandedRange) {\r\n        if (expandedRange.includes(coords)) {\r\n          if (this.getOuterTopLeftCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.from.col))) {\r\n            return this.getOuterBottomRightCorner();\r\n          }\r\n\r\n          if (this.getOuterTopRightCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.to.col))) {\r\n            return this.getOuterBottomLeftCorner();\r\n          }\r\n\r\n          if (this.getOuterBottomLeftCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.from.col))) {\r\n            return this.getOuterTopRightCorner();\r\n          }\r\n\r\n          if (this.getOuterBottomRightCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.to.col))) {\r\n            return this.getOuterTopLeftCorner();\r\n          }\r\n        }\r\n      }\r\n\r\n      if (coords.isEqual(this.getOuterBottomRightCorner())) {\r\n        return this.getOuterTopLeftCorner();\r\n      } else if (coords.isEqual(this.getOuterTopLeftCorner())) {\r\n        return this.getOuterBottomRightCorner();\r\n      } else if (coords.isEqual(this.getOuterTopRightCorner())) {\r\n        return this.getOuterBottomLeftCorner();\r\n      } else if (coords.isEqual(this.getOuterBottomLeftCorner())) {\r\n        return this.getOuterTopRightCorner();\r\n      }\r\n    }\r\n    /**\r\n     * @param {CellRange} range The cells range to compare with.\r\n     * @returns {Array}\r\n     */\r\n\r\n  }, {\r\n    key: \"getBordersSharedWith\",\r\n    value: function getBordersSharedWith(range) {\r\n      if (!this.includesRange(range)) {\r\n        return [];\r\n      }\r\n\r\n      var thisBorders = {\r\n        top: Math.min(this.from.row, this.to.row),\r\n        bottom: Math.max(this.from.row, this.to.row),\r\n        left: Math.min(this.from.col, this.to.col),\r\n        right: Math.max(this.from.col, this.to.col)\r\n      };\r\n      var rangeBorders = {\r\n        top: Math.min(range.from.row, range.to.row),\r\n        bottom: Math.max(range.from.row, range.to.row),\r\n        left: Math.min(range.from.col, range.to.col),\r\n        right: Math.max(range.from.col, range.to.col)\r\n      };\r\n      var result = [];\r\n\r\n      if (thisBorders.top === rangeBorders.top) {\r\n        result.push('top');\r\n      }\r\n\r\n      if (thisBorders.right === rangeBorders.right) {\r\n        result.push('right');\r\n      }\r\n\r\n      if (thisBorders.bottom === rangeBorders.bottom) {\r\n        result.push('bottom');\r\n      }\r\n\r\n      if (thisBorders.left === rangeBorders.left) {\r\n        result.push('left');\r\n      }\r\n\r\n      return result;\r\n    }\r\n    /**\r\n     * Get inner selected cell coords defined by this range.\r\n     *\r\n     * @returns {Array}\r\n     */\r\n\r\n  }, {\r\n    key: \"getInner\",\r\n    value: function getInner() {\r\n      var topLeft = this.getOuterTopLeftCorner();\r\n      var bottomRight = this.getOuterBottomRightCorner();\r\n      var out = [];\r\n\r\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\r\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\r\n          if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {\r\n            out.push(new CellCoords(r, c));\r\n          }\r\n        }\r\n      }\r\n\r\n      return out;\r\n    }\r\n    /**\r\n     * Get all selected cell coords defined by this range.\r\n     *\r\n     * @returns {Array}\r\n     */\r\n\r\n  }, {\r\n    key: \"getAll\",\r\n    value: function getAll() {\r\n      var topLeft = this.getOuterTopLeftCorner();\r\n      var bottomRight = this.getOuterBottomRightCorner();\r\n      var out = [];\r\n\r\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\r\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\r\n          if (topLeft.row === r && topLeft.col === c) {\r\n            out.push(topLeft);\r\n          } else if (bottomRight.row === r && bottomRight.col === c) {\r\n            out.push(bottomRight);\r\n          } else {\r\n            out.push(new CellCoords(r, c));\r\n          }\r\n        }\r\n      }\r\n\r\n      return out;\r\n    }\r\n    /**\r\n     * Runs a callback function against all cells in the range. You can break the iteration by returning\r\n     * `false` in the callback function.\r\n     *\r\n     * @param {Function} callback The callback function.\r\n     */\r\n\r\n  }, {\r\n    key: \"forAll\",\r\n    value: function forAll(callback) {\r\n      var topLeft = this.getOuterTopLeftCorner();\r\n      var bottomRight = this.getOuterBottomRightCorner();\r\n\r\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\r\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\r\n          var breakIteration = callback(r, c);\r\n\r\n          if (breakIteration === false) {\r\n            return;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Clones the range coordinates.\r\n     *\r\n     * @returns {CellRange}\r\n     */\r\n\r\n  }, {\r\n    key: \"clone\",\r\n    value: function clone() {\r\n      return new CellRange(this.highlight, this.from, this.to);\r\n    }\r\n    /**\r\n     * Convert CellRange to literal object.\r\n     *\r\n     * @returns {object} Returns a literal object with `from` and `to` properties which each of that object\r\n     *                  contains `row` and `col` keys.\r\n     */\r\n\r\n  }, {\r\n    key: \"toObject\",\r\n    value: function toObject() {\r\n      return {\r\n        from: this.from.toObject(),\r\n        to: this.to.toObject()\r\n      };\r\n    }\r\n  }]);\r\n\r\n  return CellRange;\r\n}();\r\n\r\nexport default CellRange;"]},"metadata":{},"sourceType":"module"}