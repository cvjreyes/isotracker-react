{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { RENDER_TYPE, FULLY_VISIBLE_TYPE } from \"./constants.mjs\";\nvar privatePool = new WeakMap();\n/**\r\n * Calculates indexes of rows to render OR rows that are visible.\r\n * To redo the calculation, you need to create a new calculator.\r\n *\r\n * @class ViewportRowsCalculator\r\n */\n\nvar ViewportRowsCalculator = /*#__PURE__*/function () {\n  /**\r\n   * @param {object} options Object with all options specified for row viewport calculation.\r\n   * @param {number} options.viewportSize Height of the viewport.\r\n   * @param {number} options.scrollOffset Current vertical scroll position of the viewport.\r\n   * @param {number} options.totalItems Total number of rows.\r\n   * @param {Function} options.itemSizeFn Function that returns the height of the row at a given index (in px).\r\n   * @param {Function} options.overrideFn Function that changes calculated this.startRow, this.endRow (used by MergeCells plugin).\r\n   * @param {string} options.calculationType String which describes types of calculation which will be performed.\r\n   * @param {number} options.scrollbarHeight The scrollbar height.\r\n   */\n  function ViewportRowsCalculator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        viewportSize = _ref.viewportSize,\n        scrollOffset = _ref.scrollOffset,\n        totalItems = _ref.totalItems,\n        itemSizeFn = _ref.itemSizeFn,\n        overrideFn = _ref.overrideFn,\n        calculationType = _ref.calculationType,\n        scrollbarHeight = _ref.scrollbarHeight;\n\n    _classCallCheck(this, ViewportRowsCalculator);\n\n    privatePool.set(this, {\n      viewportHeight: viewportSize,\n      scrollOffset: scrollOffset,\n      totalRows: totalItems,\n      rowHeightFn: itemSizeFn,\n      overrideFn: overrideFn,\n      calculationType: calculationType,\n      horizontalScrollbarHeight: scrollbarHeight\n    });\n    /**\r\n     * Number of rendered/visible rows.\r\n     *\r\n     * @type {number}\r\n     */\n\n    this.count = 0;\n    /**\r\n     * Index of the first rendered/visible row (can be overwritten using overrideFn).\r\n     *\r\n     * @type {number|null}\r\n     */\n\n    this.startRow = null;\n    /**\r\n     * Index of the last rendered/visible row (can be overwritten using overrideFn).\r\n     *\r\n     * @type {null}\r\n     */\n\n    this.endRow = null;\n    /**\r\n     * Position of the first rendered/visible row (in px).\r\n     *\r\n     * @type {number|null}\r\n     */\n\n    this.startPosition = null;\n    this.calculate();\n  }\n  /**\r\n   * Calculates viewport.\r\n   */\n\n\n  _createClass(ViewportRowsCalculator, [{\n    key: \"calculate\",\n    value: function calculate() {\n      var sum = 0;\n      var needReverse = true;\n      var startPositions = [];\n      var priv = privatePool.get(this);\n      var calculationType = priv.calculationType;\n      var overrideFn = priv.overrideFn;\n      var rowHeightFn = priv.rowHeightFn;\n      var scrollOffset = priv.scrollOffset;\n      var totalRows = priv.totalRows;\n      var viewportHeight = priv.viewportHeight;\n      var horizontalScrollbarHeight = priv.horizontalScrollbarHeight || 0;\n      var rowHeight; // Calculate the number (start and end index) of rows needed\n\n      for (var i = 0; i < totalRows; i++) {\n        rowHeight = rowHeightFn(i);\n\n        if (isNaN(rowHeight)) {\n          rowHeight = ViewportRowsCalculator.DEFAULT_HEIGHT;\n        }\n\n        if (sum <= scrollOffset && calculationType !== FULLY_VISIBLE_TYPE) {\n          this.startRow = i;\n        }\n\n        if (sum >= scrollOffset && sum + (calculationType === FULLY_VISIBLE_TYPE ? rowHeight : 0) <= scrollOffset + viewportHeight - horizontalScrollbarHeight) {\n          // eslint-disable-line max-len\n          if (this.startRow === null) {\n            this.startRow = i;\n          }\n\n          this.endRow = i;\n        }\n\n        startPositions.push(sum);\n        sum += rowHeight;\n\n        if (calculationType !== FULLY_VISIBLE_TYPE) {\n          this.endRow = i;\n        }\n\n        if (sum >= scrollOffset + viewportHeight - horizontalScrollbarHeight) {\n          needReverse = false;\n          break;\n        }\n      } // If the estimation has reached the last row and there is still some space available in the viewport,\n      // we need to render in reverse in order to fill the whole viewport with rows\n\n\n      if (this.endRow === totalRows - 1 && needReverse) {\n        this.startRow = this.endRow;\n\n        while (this.startRow > 0) {\n          // rowHeight is the height of the last row\n          var viewportSum = startPositions[this.endRow] + rowHeight - startPositions[this.startRow - 1];\n\n          if (viewportSum <= viewportHeight - horizontalScrollbarHeight || calculationType !== FULLY_VISIBLE_TYPE) {\n            this.startRow -= 1;\n          }\n\n          if (viewportSum >= viewportHeight - horizontalScrollbarHeight) {\n            break;\n          }\n        }\n      }\n\n      if (calculationType === RENDER_TYPE && this.startRow !== null && overrideFn) {\n        overrideFn(this);\n      }\n\n      this.startPosition = startPositions[this.startRow];\n\n      if (this.startPosition === void 0) {\n        this.startPosition = null;\n      } // If totalRows exceeded its total rows size set endRow to the latest item\n\n\n      if (totalRows < this.endRow) {\n        this.endRow = totalRows - 1;\n      }\n\n      if (this.startRow !== null) {\n        this.count = this.endRow - this.startRow + 1;\n      }\n    }\n  }], [{\n    key: \"DEFAULT_HEIGHT\",\n    get:\n    /**\r\n     * Default row height.\r\n     *\r\n     * @type {number}\r\n     */\n    function get() {\n      return 23;\n    }\n  }]);\n\n  return ViewportRowsCalculator;\n}();\n\nexport default ViewportRowsCalculator;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/3rdparty/walkontable/src/calculator/viewportRows.mjs"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","RENDER_TYPE","FULLY_VISIBLE_TYPE","privatePool","WeakMap","ViewportRowsCalculator","_ref","arguments","undefined","viewportSize","scrollOffset","totalItems","itemSizeFn","overrideFn","calculationType","scrollbarHeight","set","viewportHeight","totalRows","rowHeightFn","horizontalScrollbarHeight","count","startRow","endRow","startPosition","calculate","value","sum","needReverse","startPositions","priv","get","rowHeight","isNaN","DEFAULT_HEIGHT","push","viewportSum"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport \"core-js/modules/es.array.iterator.js\";\r\nimport \"core-js/modules/es.object.to-string.js\";\r\nimport \"core-js/modules/es.string.iterator.js\";\r\nimport \"core-js/modules/es.weak-map.js\";\r\nimport \"core-js/modules/web.dom-collections.iterator.js\";\r\nimport { RENDER_TYPE, FULLY_VISIBLE_TYPE } from \"./constants.mjs\";\r\nvar privatePool = new WeakMap();\r\n/**\r\n * Calculates indexes of rows to render OR rows that are visible.\r\n * To redo the calculation, you need to create a new calculator.\r\n *\r\n * @class ViewportRowsCalculator\r\n */\r\n\r\nvar ViewportRowsCalculator = /*#__PURE__*/function () {\r\n  /**\r\n   * @param {object} options Object with all options specified for row viewport calculation.\r\n   * @param {number} options.viewportSize Height of the viewport.\r\n   * @param {number} options.scrollOffset Current vertical scroll position of the viewport.\r\n   * @param {number} options.totalItems Total number of rows.\r\n   * @param {Function} options.itemSizeFn Function that returns the height of the row at a given index (in px).\r\n   * @param {Function} options.overrideFn Function that changes calculated this.startRow, this.endRow (used by MergeCells plugin).\r\n   * @param {string} options.calculationType String which describes types of calculation which will be performed.\r\n   * @param {number} options.scrollbarHeight The scrollbar height.\r\n   */\r\n  function ViewportRowsCalculator() {\r\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\r\n        viewportSize = _ref.viewportSize,\r\n        scrollOffset = _ref.scrollOffset,\r\n        totalItems = _ref.totalItems,\r\n        itemSizeFn = _ref.itemSizeFn,\r\n        overrideFn = _ref.overrideFn,\r\n        calculationType = _ref.calculationType,\r\n        scrollbarHeight = _ref.scrollbarHeight;\r\n\r\n    _classCallCheck(this, ViewportRowsCalculator);\r\n\r\n    privatePool.set(this, {\r\n      viewportHeight: viewportSize,\r\n      scrollOffset: scrollOffset,\r\n      totalRows: totalItems,\r\n      rowHeightFn: itemSizeFn,\r\n      overrideFn: overrideFn,\r\n      calculationType: calculationType,\r\n      horizontalScrollbarHeight: scrollbarHeight\r\n    });\r\n    /**\r\n     * Number of rendered/visible rows.\r\n     *\r\n     * @type {number}\r\n     */\r\n\r\n    this.count = 0;\r\n    /**\r\n     * Index of the first rendered/visible row (can be overwritten using overrideFn).\r\n     *\r\n     * @type {number|null}\r\n     */\r\n\r\n    this.startRow = null;\r\n    /**\r\n     * Index of the last rendered/visible row (can be overwritten using overrideFn).\r\n     *\r\n     * @type {null}\r\n     */\r\n\r\n    this.endRow = null;\r\n    /**\r\n     * Position of the first rendered/visible row (in px).\r\n     *\r\n     * @type {number|null}\r\n     */\r\n\r\n    this.startPosition = null;\r\n    this.calculate();\r\n  }\r\n  /**\r\n   * Calculates viewport.\r\n   */\r\n\r\n\r\n  _createClass(ViewportRowsCalculator, [{\r\n    key: \"calculate\",\r\n    value: function calculate() {\r\n      var sum = 0;\r\n      var needReverse = true;\r\n      var startPositions = [];\r\n      var priv = privatePool.get(this);\r\n      var calculationType = priv.calculationType;\r\n      var overrideFn = priv.overrideFn;\r\n      var rowHeightFn = priv.rowHeightFn;\r\n      var scrollOffset = priv.scrollOffset;\r\n      var totalRows = priv.totalRows;\r\n      var viewportHeight = priv.viewportHeight;\r\n      var horizontalScrollbarHeight = priv.horizontalScrollbarHeight || 0;\r\n      var rowHeight; // Calculate the number (start and end index) of rows needed\r\n\r\n      for (var i = 0; i < totalRows; i++) {\r\n        rowHeight = rowHeightFn(i);\r\n\r\n        if (isNaN(rowHeight)) {\r\n          rowHeight = ViewportRowsCalculator.DEFAULT_HEIGHT;\r\n        }\r\n\r\n        if (sum <= scrollOffset && calculationType !== FULLY_VISIBLE_TYPE) {\r\n          this.startRow = i;\r\n        }\r\n\r\n        if (sum >= scrollOffset && sum + (calculationType === FULLY_VISIBLE_TYPE ? rowHeight : 0) <= scrollOffset + viewportHeight - horizontalScrollbarHeight) {\r\n          // eslint-disable-line max-len\r\n          if (this.startRow === null) {\r\n            this.startRow = i;\r\n          }\r\n\r\n          this.endRow = i;\r\n        }\r\n\r\n        startPositions.push(sum);\r\n        sum += rowHeight;\r\n\r\n        if (calculationType !== FULLY_VISIBLE_TYPE) {\r\n          this.endRow = i;\r\n        }\r\n\r\n        if (sum >= scrollOffset + viewportHeight - horizontalScrollbarHeight) {\r\n          needReverse = false;\r\n          break;\r\n        }\r\n      } // If the estimation has reached the last row and there is still some space available in the viewport,\r\n      // we need to render in reverse in order to fill the whole viewport with rows\r\n\r\n\r\n      if (this.endRow === totalRows - 1 && needReverse) {\r\n        this.startRow = this.endRow;\r\n\r\n        while (this.startRow > 0) {\r\n          // rowHeight is the height of the last row\r\n          var viewportSum = startPositions[this.endRow] + rowHeight - startPositions[this.startRow - 1];\r\n\r\n          if (viewportSum <= viewportHeight - horizontalScrollbarHeight || calculationType !== FULLY_VISIBLE_TYPE) {\r\n            this.startRow -= 1;\r\n          }\r\n\r\n          if (viewportSum >= viewportHeight - horizontalScrollbarHeight) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (calculationType === RENDER_TYPE && this.startRow !== null && overrideFn) {\r\n        overrideFn(this);\r\n      }\r\n\r\n      this.startPosition = startPositions[this.startRow];\r\n\r\n      if (this.startPosition === void 0) {\r\n        this.startPosition = null;\r\n      } // If totalRows exceeded its total rows size set endRow to the latest item\r\n\r\n\r\n      if (totalRows < this.endRow) {\r\n        this.endRow = totalRows - 1;\r\n      }\r\n\r\n      if (this.startRow !== null) {\r\n        this.count = this.endRow - this.startRow + 1;\r\n      }\r\n    }\r\n  }], [{\r\n    key: \"DEFAULT_HEIGHT\",\r\n    get:\r\n    /**\r\n     * Default row height.\r\n     *\r\n     * @type {number}\r\n     */\r\n    function get() {\r\n      return 23;\r\n    }\r\n  }]);\r\n\r\n  return ViewportRowsCalculator;\r\n}();\r\n\r\nexport default ViewportRowsCalculator;"]},"metadata":{},"sourceType":"module"}