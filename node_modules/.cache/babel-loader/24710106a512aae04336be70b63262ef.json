{"ast":null,"code":"import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.concat\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.includes\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.array.slice\";\nimport \"core-js/modules/es.function.name\";\nimport \"core-js/modules/es.number.constructor\";\nimport \"core-js/modules/es.number.is-integer\";\nimport \"core-js/modules/es.object.freeze\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.set\";\nimport \"core-js/modules/es.string.includes\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.for-each\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nvar _templateObject;\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport Highlight from \"./highlight/highlight.mjs\";\nimport { AREA_TYPE, HEADER_TYPE, CELL_TYPE } from \"./highlight/constants.mjs\";\nimport SelectionRange from \"./range.mjs\";\nimport { CellCoords } from \"./../3rdparty/walkontable/src/index.mjs\";\nimport { isPressedCtrlKey } from \"./../utils/keyStateObserver.mjs\";\nimport { createObjectPropListener, mixin } from \"./../helpers/object.mjs\";\nimport { isUndefined } from \"./../helpers/mixed.mjs\";\nimport { arrayEach } from \"./../helpers/array.mjs\";\nimport localHooks from \"./../mixins/localHooks.mjs\";\nimport Transformation from \"./transformation.mjs\";\nimport { detectSelectionType, isValidCoord, normalizeSelectionFactory, SELECTION_TYPE_EMPTY, SELECTION_TYPE_UNRECOGNIZED } from \"./utils.mjs\";\nimport { toSingleLine } from \"./../helpers/templateLiteralTag.mjs\";\n/**\r\n * @class Selection\r\n * @util\r\n */\n\nvar Selection = /*#__PURE__*/function () {\n  function Selection(settings, tableProps) {\n    var _this = this;\n\n    _classCallCheck(this, Selection);\n    /**\r\n     * Handsontable settings instance.\r\n     *\r\n     * @type {GridSettings}\r\n     */\n\n\n    this.settings = settings;\n    /**\r\n     * An additional object with dynamically defined properties which describes table state.\r\n     *\r\n     * @type {object}\r\n     */\n\n    this.tableProps = tableProps;\n    /**\r\n     * The flag which determines if the selection is in progress.\r\n     *\r\n     * @type {boolean}\r\n     */\n\n    this.inProgress = false;\n    /**\r\n     * The flag indicates that selection was performed by clicking the corner overlay.\r\n     *\r\n     * @type {boolean}\r\n     */\n\n    this.selectedByCorner = false;\n    /**\r\n     * The collection of the selection layer levels where the whole row was selected using the row header or\r\n     * the corner header.\r\n     *\r\n     * @type {Set.<number>}\r\n     */\n\n    this.selectedByRowHeader = new Set();\n    /**\r\n     * The collection of the selection layer levels where the whole column was selected using the column header or\r\n     * the corner header.\r\n     *\r\n     * @type {Set.<number>}\r\n     */\n\n    this.selectedByColumnHeader = new Set();\n    /**\r\n     * Selection data layer (handle visual coordinates).\r\n     *\r\n     * @type {SelectionRange}\r\n     */\n\n    this.selectedRange = new SelectionRange();\n    /**\r\n     * Visualization layer.\r\n     *\r\n     * @type {Highlight}\r\n     */\n\n    this.highlight = new Highlight({\n      headerClassName: settings.currentHeaderClassName,\n      activeHeaderClassName: settings.activeHeaderClassName,\n      rowClassName: settings.currentRowClassName,\n      columnClassName: settings.currentColClassName,\n      disabledCellSelection: function disabledCellSelection(row, column) {\n        return _this.tableProps.isDisabledCellSelection(row, column);\n      },\n      cellCornerVisible: function cellCornerVisible() {\n        return _this.isCellCornerVisible.apply(_this, arguments);\n      },\n      areaCornerVisible: function areaCornerVisible() {\n        return _this.isAreaCornerVisible.apply(_this, arguments);\n      },\n      visualToRenderableCoords: function visualToRenderableCoords(coords) {\n        return _this.tableProps.visualToRenderableCoords(coords);\n      },\n      renderableToVisualCoords: function renderableToVisualCoords(coords) {\n        return _this.tableProps.renderableToVisualCoords(coords);\n      }\n    });\n    /**\r\n     * The module for modifying coordinates.\r\n     *\r\n     * @type {Transformation}\r\n     */\n\n    this.transformation = new Transformation(this.selectedRange, {\n      countRows: function countRows() {\n        return _this.tableProps.countRowsTranslated();\n      },\n      countCols: function countCols() {\n        return _this.tableProps.countColsTranslated();\n      },\n      visualToRenderableCoords: function visualToRenderableCoords(coords) {\n        return _this.tableProps.visualToRenderableCoords(coords);\n      },\n      renderableToVisualCoords: function renderableToVisualCoords(coords) {\n        return _this.tableProps.renderableToVisualCoords(coords);\n      },\n      fixedRowsBottom: function fixedRowsBottom() {\n        return settings.fixedRowsBottom;\n      },\n      minSpareRows: function minSpareRows() {\n        return settings.minSpareRows;\n      },\n      minSpareCols: function minSpareCols() {\n        return settings.minSpareCols;\n      },\n      autoWrapRow: function autoWrapRow() {\n        return settings.autoWrapRow;\n      },\n      autoWrapCol: function autoWrapCol() {\n        return settings.autoWrapCol;\n      }\n    });\n    this.transformation.addLocalHook('beforeTransformStart', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformStart', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('beforeTransformEnd', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('insertRowRequire', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['insertRowRequire'].concat(args));\n    });\n    this.transformation.addLocalHook('insertColRequire', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['insertColRequire'].concat(args));\n    });\n  }\n  /**\r\n   * Get data layer for current selection.\r\n   *\r\n   * @returns {SelectionRange}\r\n   */\n\n\n  _createClass(Selection, [{\n    key: \"getSelectedRange\",\n    value: function getSelectedRange() {\n      return this.selectedRange;\n    }\n    /**\r\n     * Indicate that selection process began. It sets internaly `.inProgress` property to `true`.\r\n     */\n\n  }, {\n    key: \"begin\",\n    value: function begin() {\n      this.inProgress = true;\n    }\n    /**\r\n     * Indicate that selection process finished. It sets internaly `.inProgress` property to `false`.\r\n     */\n\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.runLocalHooks('afterSelectionFinished', Array.from(this.selectedRange));\n      this.inProgress = false;\n    }\n    /**\r\n     * Check if the process of selecting the cell/cells is in progress.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isInProgress\",\n    value: function isInProgress() {\n      return this.inProgress;\n    }\n    /**\r\n     * Starts selection range on given coordinate object.\r\n     *\r\n     * @param {CellCoords} coords Visual coords.\r\n     * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\r\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\r\n     *                                      the default trigger will be used (isPressedCtrlKey() helper).\r\n     * @param {boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the\r\n     *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.\r\n     */\n\n  }, {\n    key: \"setRangeStart\",\n    value: function setRangeStart(coords, multipleSelection) {\n      var fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var isMultipleMode = this.settings.selectionMode === 'multiple';\n      var isMultipleSelection = isUndefined(multipleSelection) ? isPressedCtrlKey() : multipleSelection;\n      var isRowNegative = coords.row < 0;\n      var isColumnNegative = coords.col < 0;\n      var selectedByCorner = isRowNegative && isColumnNegative;\n      this.selectedByCorner = selectedByCorner;\n      this.runLocalHooks(\"beforeSetRangeStart\".concat(fragment ? 'Only' : ''), coords);\n\n      if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined(multipleSelection)) {\n        this.selectedRange.clear();\n      }\n\n      this.selectedRange.add(coords);\n\n      if (this.getLayerLevel() === 0) {\n        this.selectedByRowHeader.clear();\n        this.selectedByColumnHeader.clear();\n      }\n\n      if (!selectedByCorner && isColumnNegative) {\n        this.selectedByRowHeader.add(this.getLayerLevel());\n      }\n\n      if (!selectedByCorner && isRowNegative) {\n        this.selectedByColumnHeader.add(this.getLayerLevel());\n      }\n\n      if (!fragment) {\n        this.setRangeEnd(coords);\n      }\n    }\n    /**\r\n     * Starts selection range on given coordinate object.\r\n     *\r\n     * @param {CellCoords} coords Visual coords.\r\n     * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\r\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\r\n     *                                      the default trigger will be used (isPressedCtrlKey() helper).\r\n     */\n\n  }, {\n    key: \"setRangeStartOnly\",\n    value: function setRangeStartOnly(coords, multipleSelection) {\n      this.setRangeStart(coords, multipleSelection, true);\n    }\n    /**\r\n     * Ends selection range on given coordinate object.\r\n     *\r\n     * @param {CellCoords} coords Visual coords.\r\n     */\n\n  }, {\n    key: \"setRangeEnd\",\n    value: function setRangeEnd(coords) {\n      if (this.selectedRange.isEmpty()) {\n        return;\n      }\n\n      this.runLocalHooks('beforeSetRangeEnd', coords);\n      this.begin();\n      var cellRange = this.selectedRange.current();\n\n      if (this.settings.selectionMode !== 'single') {\n        cellRange.setTo(new CellCoords(coords.row, coords.col));\n      } // Set up current selection.\n\n\n      this.highlight.getCell().clear();\n\n      if (this.highlight.isEnabledFor(CELL_TYPE, cellRange.highlight)) {\n        this.highlight.getCell().add(this.selectedRange.current().highlight).commit().adjustCoordinates(cellRange);\n      }\n\n      var layerLevel = this.getLayerLevel(); // If the next layer level is lower than previous then clear all area and header highlights. This is the\n      // indication that the new selection is performing.\n\n      if (layerLevel < this.highlight.layerLevel) {\n        arrayEach(this.highlight.getAreas(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getActiveHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n      }\n\n      this.highlight.useLayerLevel(layerLevel);\n      var areaHighlight = this.highlight.createOrGetArea();\n      var headerHighlight = this.highlight.createOrGetHeader();\n      var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\n      areaHighlight.clear();\n      headerHighlight.clear();\n      activeHeaderHighlight.clear();\n\n      if (this.highlight.isEnabledFor(AREA_TYPE, cellRange.highlight) && (this.isMultiple() || layerLevel >= 1)) {\n        areaHighlight.add(cellRange.from).add(cellRange.to).commit();\n\n        if (layerLevel === 1) {\n          // For single cell selection in the same layer, we do not create area selection to prevent blue background.\n          // When non-consecutive selection is performed we have to add that missing area selection to the previous layer\n          // based on previous coordinates. It only occurs when the previous selection wasn't select multiple cells.\n          var previousRange = this.selectedRange.previous();\n          this.highlight.useLayerLevel(layerLevel - 1).createOrGetArea().add(previousRange.from).commit() // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).\n          .adjustCoordinates(previousRange);\n          this.highlight.useLayerLevel(layerLevel);\n        }\n      }\n\n      if (this.highlight.isEnabledFor(HEADER_TYPE, cellRange.highlight)) {\n        // The header selection generally contains cell selection. In a case when all rows (or columns)\n        // are hidden that visual coordinates are translated to renderable coordinates that do not exist.\n        // Hence no header highlight is generated. In that case, to make a column (or a row) header\n        // highlight, the row and column index has to point to the header (the negative value). See #7052.\n        var areAnyRowsRendered = this.tableProps.countRowsTranslated() === 0;\n        var areAnyColumnsRendered = this.tableProps.countColsTranslated() === 0;\n        var headerCellRange = cellRange;\n\n        if (areAnyRowsRendered || areAnyColumnsRendered) {\n          headerCellRange = cellRange.clone();\n        }\n\n        if (areAnyRowsRendered) {\n          headerCellRange.from.row = -1;\n        }\n\n        if (areAnyColumnsRendered) {\n          headerCellRange.from.col = -1;\n        }\n\n        if (this.settings.selectionMode === 'single') {\n          if (this.isSelectedByAnyHeader()) {\n            headerCellRange.from.normalize();\n          }\n\n          headerHighlight.add(headerCellRange.from).commit();\n        } else {\n          headerHighlight.add(headerCellRange.from).add(headerCellRange.to).commit();\n        }\n\n        if (this.isEntireRowSelected()) {\n          var isRowSelected = this.tableProps.countCols() === cellRange.getWidth(); // Make sure that the whole row is selected (in case where selectionMode is set to 'single')\n\n          if (isRowSelected) {\n            activeHeaderHighlight.add(new CellCoords(cellRange.from.row, -1)).add(new CellCoords(cellRange.to.row, -1)).commit();\n          }\n        }\n\n        if (this.isEntireColumnSelected()) {\n          var isColumnSelected = this.tableProps.countRows() === cellRange.getHeight(); // Make sure that the whole column is selected (in case where selectionMode is set to 'single')\n\n          if (isColumnSelected) {\n            activeHeaderHighlight.add(new CellCoords(-1, cellRange.from.col)).add(new CellCoords(-1, cellRange.to.col)).commit();\n          }\n        }\n      }\n\n      this.runLocalHooks('afterSetRangeEnd', coords);\n    }\n    /**\r\n     * Returns information if we have a multiselection. This method check multiselection only on the latest layer of\r\n     * the selection.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isMultiple\",\n    value: function isMultiple() {\n      var isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());\n      this.runLocalHooks('afterIsMultipleSelection', isMultipleListener);\n      return isMultipleListener.value;\n    }\n    /**\r\n     * Selects cell relative to the current cell (if possible).\r\n     *\r\n     * @param {number} rowDelta Rows number to move, value can be passed as negative number.\r\n     * @param {number} colDelta Columns number to move, value can be passed as negative number.\r\n     * @param {boolean} force If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\r\n     *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\r\n     */\n\n  }, {\n    key: \"transformStart\",\n    value: function transformStart(rowDelta, colDelta, force) {\n      this.setRangeStart(this.transformation.transformStart(rowDelta, colDelta, force));\n    }\n    /**\r\n     * Sets selection end cell relative to the current selection end cell (if possible).\r\n     *\r\n     * @param {number} rowDelta Rows number to move, value can be passed as negative number.\r\n     * @param {number} colDelta Columns number to move, value can be passed as negative number.\r\n     */\n\n  }, {\n    key: \"transformEnd\",\n    value: function transformEnd(rowDelta, colDelta) {\n      this.setRangeEnd(this.transformation.transformEnd(rowDelta, colDelta));\n    }\n    /**\r\n     * Returns currently used layer level.\r\n     *\r\n     * @returns {number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.\r\n     */\n\n  }, {\n    key: \"getLayerLevel\",\n    value: function getLayerLevel() {\n      return this.selectedRange.size() - 1;\n    }\n    /**\r\n     * Returns `true` if currently there is a selection on the screen, `false` otherwise.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      return !this.selectedRange.isEmpty();\n    }\n    /**\r\n     * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`\r\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any row header\r\n     * was clicked on any selection layer level.\r\n     *\r\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isSelectedByRowHeader\",\n    value: function isSelectedByRowHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return !this.isSelectedByCorner(layerLevel) && this.isEntireRowSelected(layerLevel);\n    }\n    /**\r\n     * Returns `true` if the selection consists of entire rows (including their headers). If the `layerLevel`\r\n     * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\r\n     *\r\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isEntireRowSelected\",\n    value: function isEntireRowSelected() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel);\n    }\n    /**\r\n     * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`\r\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any column header\r\n     * was clicked on any selection layer level.\r\n     *\r\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isSelectedByColumnHeader\",\n    value: function isSelectedByColumnHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return !this.isSelectedByCorner() && this.isEntireColumnSelected(layerLevel);\n    }\n    /**\r\n     * Returns `true` if the selection consists of entire columns (including their headers). If the `layerLevel`\r\n     * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\r\n     *\r\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isEntireColumnSelected\",\n    value: function isEntireColumnSelected() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel);\n    }\n    /**\r\n     * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isSelectedByAnyHeader\",\n    value: function isSelectedByAnyHeader() {\n      return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1) || this.isSelectedByCorner();\n    }\n    /**\r\n     * Returns `true` if the selection was applied by clicking on the left-top corner overlay.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isSelectedByCorner\",\n    value: function isSelectedByCorner() {\n      return this.selectedByCorner;\n    }\n    /**\r\n     * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\r\n     * the coords object is within selection range.\r\n     *\r\n     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"inInSelection\",\n    value: function inInSelection(coords) {\n      return this.selectedRange.includes(coords);\n    }\n    /**\r\n     * Returns `true` if the cell corner should be visible.\r\n     *\r\n     * @private\r\n     * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\r\n     */\n\n  }, {\n    key: \"isCellCornerVisible\",\n    value: function isCellCornerVisible() {\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();\n    }\n    /**\r\n     * Returns `true` if the area corner should be visible.\r\n     *\r\n     * @param {number} layerLevel The layer level.\r\n     * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\r\n     */\n\n  }, {\n    key: \"isAreaCornerVisible\",\n    value: function isAreaCornerVisible(layerLevel) {\n      if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {\n        return false;\n      }\n\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();\n    }\n    /**\r\n     * Clear the selection by resetting the collected ranges and highlights.\r\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      // TODO: collections selectedByColumnHeader and selectedByRowHeader should be clear too.\n      this.selectedRange.clear();\n      this.highlight.clear();\n    }\n    /**\r\n     * Deselects all selected cells.\r\n     */\n\n  }, {\n    key: \"deselect\",\n    value: function deselect() {\n      if (!this.isSelected()) {\n        return;\n      }\n\n      this.inProgress = false;\n      this.clear();\n      this.runLocalHooks('afterDeselect');\n    }\n    /**\r\n     * Select all cells.\r\n     *\r\n     * @param {boolean} [includeRowHeaders=false] `true` If the selection should include the row headers, `false`\r\n     * otherwise.\r\n     * @param {boolean} [includeColumnHeaders=false] `true` If the selection should include the column headers, `false`\r\n     * otherwise.\r\n     */\n\n  }, {\n    key: \"selectAll\",\n    value: function selectAll() {\n      var includeRowHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var includeColumnHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols(); // We can't select cells when there is no data.\n\n      if (!includeRowHeaders && !includeColumnHeaders && (nrOfRows === 0 || nrOfColumns === 0)) {\n        return;\n      }\n\n      var startCoords = new CellCoords(includeColumnHeaders ? -1 : 0, includeRowHeaders ? -1 : 0);\n      this.clear();\n      this.setRangeStartOnly(startCoords);\n      this.selectedByRowHeader.add(this.getLayerLevel());\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n      this.setRangeEnd(new CellCoords(nrOfRows - 1, nrOfColumns - 1));\n      this.finish();\n    }\n    /**\r\n     * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\r\n     * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such\r\n     * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.\r\n     * If the passed ranges have another format the exception will be thrown.\r\n     *\r\n     * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.\r\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\r\n     */\n\n  }, {\n    key: \"selectCells\",\n    value: function selectCells(selectionRanges) {\n      var _this2 = this;\n\n      var selectionType = detectSelectionType(selectionRanges);\n\n      if (selectionType === SELECTION_TYPE_EMPTY) {\n        return false;\n      } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {\n        throw new Error(toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"Unsupported format of the selection ranges was passed. To select cells pass \\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd, \\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.\"], [\"Unsupported format of the selection ranges was passed. To select cells pass\\\\x20\\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd,\\\\x20\\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.\"]))));\n      }\n\n      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n        propToCol: function propToCol(prop) {\n          return _this2.tableProps.propToCol(prop);\n        },\n        keepDirection: true\n      });\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols(); // Check if every layer of the coordinates are valid.\n\n      var isValid = !selectionRanges.some(function (selection) {\n        var _selectionSchemaNorma = selectionSchemaNormalizer(selection),\n            _selectionSchemaNorma2 = _slicedToArray(_selectionSchemaNorma, 4),\n            rowStart = _selectionSchemaNorma2[0],\n            columnStart = _selectionSchemaNorma2[1],\n            rowEnd = _selectionSchemaNorma2[2],\n            columnEnd = _selectionSchemaNorma2[3];\n\n        var _isValid = isValidCoord(rowStart, nrOfRows) && isValidCoord(columnStart, nrOfColumns) && isValidCoord(rowEnd, nrOfRows) && isValidCoord(columnEnd, nrOfColumns);\n\n        return !_isValid;\n      });\n\n      if (isValid) {\n        this.clear();\n        arrayEach(selectionRanges, function (selection) {\n          var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection),\n              _selectionSchemaNorma4 = _slicedToArray(_selectionSchemaNorma3, 4),\n              rowStart = _selectionSchemaNorma4[0],\n              columnStart = _selectionSchemaNorma4[1],\n              rowEnd = _selectionSchemaNorma4[2],\n              columnEnd = _selectionSchemaNorma4[3];\n\n          _this2.setRangeStartOnly(new CellCoords(rowStart, columnStart), false);\n\n          _this2.setRangeEnd(new CellCoords(rowEnd, columnEnd));\n\n          _this2.finish();\n        });\n      }\n\n      return isValid;\n    }\n    /**\r\n     * Select column specified by `startColumn` visual index or column property or a range of columns finishing at\r\n     * `endColumn`.\r\n     *\r\n     * @param {number|string} startColumn Visual column index or column property from which the selection starts.\r\n     * @param {number|string} [endColumn] Visual column index or column property from to the selection finishes.\r\n     * @param {number} [headerLevel=-1] A row header index that triggers the column selection. The value can\r\n     *                                  take -1 to -N, where -1 means the header closest to the cells.\r\n     *\r\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\r\n     */\n\n  }, {\n    key: \"selectColumns\",\n    value: function selectColumns(startColumn) {\n      var endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n      var headerLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var start = typeof startColumn === 'string' ? this.tableProps.propToCol(startColumn) : startColumn;\n      var end = typeof endColumn === 'string' ? this.tableProps.propToCol(endColumn) : endColumn;\n      var nrOfColumns = this.tableProps.countCols();\n      var nrOfRows = this.tableProps.countRows();\n      var isValid = isValidCoord(start, nrOfColumns) && isValidCoord(end, nrOfColumns);\n\n      if (isValid) {\n        this.setRangeStartOnly(new CellCoords(headerLevel, start));\n        this.setRangeEnd(new CellCoords(nrOfRows - 1, end));\n        this.finish();\n      }\n\n      return isValid;\n    }\n    /**\r\n     * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\r\n     *\r\n     * @param {number} startRow Visual row index from which the selection starts.\r\n     * @param {number} [endRow] Visual row index from to the selection finishes.\r\n     * @param {number} [headerLevel=-1] A column header index that triggers the row selection.\r\n     *                                  The value can take -1 to -N, where -1 means the header\r\n     *                                  closest to the cells.\r\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\r\n     */\n\n  }, {\n    key: \"selectRows\",\n    value: function selectRows(startRow) {\n      var endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n      var headerLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols();\n      var isValid = isValidCoord(startRow, nrOfRows) && isValidCoord(endRow, nrOfRows);\n\n      if (isValid) {\n        this.setRangeStartOnly(new CellCoords(startRow, headerLevel));\n        this.setRangeEnd(new CellCoords(endRow, nrOfColumns - 1));\n        this.finish();\n      }\n\n      return isValid;\n    }\n    /**\r\n     * Rewrite the rendered state of the selection as visual selection may have a new representation in the DOM.\r\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var customSelections = this.highlight.getCustomSelections();\n      customSelections.forEach(function (customSelection) {\n        customSelection.commit();\n      });\n\n      if (!this.isSelected()) {\n        return;\n      }\n\n      var cellHighlight = this.highlight.getCell();\n      var currentLayer = this.getLayerLevel();\n      cellHighlight.commit().adjustCoordinates(this.selectedRange.current()); // Rewriting rendered ranges going through all layers.\n\n      for (var layerLevel = 0; layerLevel < this.selectedRange.size(); layerLevel += 1) {\n        this.highlight.useLayerLevel(layerLevel);\n        var areaHighlight = this.highlight.createOrGetArea();\n        var headerHighlight = this.highlight.createOrGetHeader();\n        var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\n        areaHighlight.commit();\n        headerHighlight.commit();\n        activeHeaderHighlight.commit();\n      } // Reverting starting layer for the Highlight.\n\n\n      this.highlight.useLayerLevel(currentLayer);\n    }\n  }]);\n\n  return Selection;\n}();\n\nmixin(Selection, localHooks);\nexport default Selection;","map":{"version":3,"sources":["C:/xampp/htdocs/isotracker-dev/isotracker-react/node_modules/handsontable/selection/selection.mjs"],"names":["_templateObject","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","len","length","arr2","_i","Symbol","iterator","_arr","_n","_d","_s","_e","next","done","push","value","err","isArray","_taggedTemplateLiteral","strings","raw","freeze","defineProperties","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","Highlight","AREA_TYPE","HEADER_TYPE","CELL_TYPE","SelectionRange","CellCoords","isPressedCtrlKey","createObjectPropListener","mixin","isUndefined","arrayEach","localHooks","Transformation","detectSelectionType","isValidCoord","normalizeSelectionFactory","SELECTION_TYPE_EMPTY","SELECTION_TYPE_UNRECOGNIZED","toSingleLine","Selection","settings","tableProps","_this","inProgress","selectedByCorner","selectedByRowHeader","Set","selectedByColumnHeader","selectedRange","highlight","headerClassName","currentHeaderClassName","activeHeaderClassName","rowClassName","currentRowClassName","columnClassName","currentColClassName","disabledCellSelection","row","column","isDisabledCellSelection","cellCornerVisible","isCellCornerVisible","apply","arguments","areaCornerVisible","isAreaCornerVisible","visualToRenderableCoords","coords","renderableToVisualCoords","transformation","countRows","countRowsTranslated","countCols","countColsTranslated","fixedRowsBottom","minSpareRows","minSpareCols","autoWrapRow","autoWrapCol","addLocalHook","_len","args","_key","runLocalHooks","concat","_len2","_key2","_len3","_key3","_len4","_key4","_len5","_key5","_len6","_key6","getSelectedRange","begin","finish","isInProgress","setRangeStart","multipleSelection","fragment","undefined","isMultipleMode","selectionMode","isMultipleSelection","isRowNegative","isColumnNegative","col","clear","add","getLayerLevel","setRangeEnd","setRangeStartOnly","isEmpty","cellRange","current","setTo","getCell","isEnabledFor","commit","adjustCoordinates","layerLevel","getAreas","getHeaders","getActiveHeaders","useLayerLevel","areaHighlight","createOrGetArea","headerHighlight","createOrGetHeader","activeHeaderHighlight","createOrGetActiveHeader","isMultiple","to","previousRange","previous","areAnyRowsRendered","areAnyColumnsRendered","headerCellRange","clone","isSelectedByAnyHeader","normalize","isEntireRowSelected","isRowSelected","getWidth","isEntireColumnSelected","isColumnSelected","getHeight","isMultipleListener","isSingle","transformStart","rowDelta","colDelta","force","transformEnd","size","isSelected","isSelectedByRowHeader","isSelectedByCorner","has","isSelectedByColumnHeader","inInSelection","includes","fillHandle","isEditorOpened","Number","isInteger","deselect","selectAll","includeRowHeaders","includeColumnHeaders","nrOfRows","nrOfColumns","startCoords","selectCells","selectionRanges","_this2","selectionType","Error","selectionSchemaNormalizer","propToCol","prop","keepDirection","isValid","some","selection","_selectionSchemaNorma","_selectionSchemaNorma2","rowStart","columnStart","rowEnd","columnEnd","_isValid","_selectionSchemaNorma3","_selectionSchemaNorma4","selectColumns","startColumn","endColumn","headerLevel","start","end","selectRows","startRow","endRow","refresh","customSelections","getCustomSelections","forEach","customSelection","cellHighlight","currentLayer"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.slice.js\";\r\nimport \"core-js/modules/es.object.freeze.js\";\r\nimport \"core-js/modules/es.symbol.js\";\r\nimport \"core-js/modules/es.symbol.description.js\";\r\nimport \"core-js/modules/es.symbol.iterator.js\";\r\nimport \"core-js/modules/es.function.name.js\";\r\n\r\nvar _templateObject;\r\n\r\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\r\n\r\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\r\n\r\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\r\n\r\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\r\n\r\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\r\n\r\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\r\n\r\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\r\n\r\nimport \"core-js/modules/es.array.iterator.js\";\r\nimport \"core-js/modules/es.object.to-string.js\";\r\nimport \"core-js/modules/es.set.js\";\r\nimport \"core-js/modules/es.string.iterator.js\";\r\nimport \"core-js/modules/web.dom-collections.iterator.js\";\r\nimport \"core-js/modules/es.array.concat.js\";\r\nimport \"core-js/modules/es.array.from.js\";\r\nimport \"core-js/modules/es.array.includes.js\";\r\nimport \"core-js/modules/es.string.includes.js\";\r\nimport \"core-js/modules/es.number.is-integer.js\";\r\nimport \"core-js/modules/es.number.constructor.js\";\r\nimport \"core-js/modules/web.dom-collections.for-each.js\";\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport Highlight from \"./highlight/highlight.mjs\";\r\nimport { AREA_TYPE, HEADER_TYPE, CELL_TYPE } from \"./highlight/constants.mjs\";\r\nimport SelectionRange from \"./range.mjs\";\r\nimport { CellCoords } from \"./../3rdparty/walkontable/src/index.mjs\";\r\nimport { isPressedCtrlKey } from \"./../utils/keyStateObserver.mjs\";\r\nimport { createObjectPropListener, mixin } from \"./../helpers/object.mjs\";\r\nimport { isUndefined } from \"./../helpers/mixed.mjs\";\r\nimport { arrayEach } from \"./../helpers/array.mjs\";\r\nimport localHooks from \"./../mixins/localHooks.mjs\";\r\nimport Transformation from \"./transformation.mjs\";\r\nimport { detectSelectionType, isValidCoord, normalizeSelectionFactory, SELECTION_TYPE_EMPTY, SELECTION_TYPE_UNRECOGNIZED } from \"./utils.mjs\";\r\nimport { toSingleLine } from \"./../helpers/templateLiteralTag.mjs\";\r\n/**\r\n * @class Selection\r\n * @util\r\n */\r\n\r\nvar Selection = /*#__PURE__*/function () {\r\n  function Selection(settings, tableProps) {\r\n    var _this = this;\r\n\r\n    _classCallCheck(this, Selection);\r\n\r\n    /**\r\n     * Handsontable settings instance.\r\n     *\r\n     * @type {GridSettings}\r\n     */\r\n    this.settings = settings;\r\n    /**\r\n     * An additional object with dynamically defined properties which describes table state.\r\n     *\r\n     * @type {object}\r\n     */\r\n\r\n    this.tableProps = tableProps;\r\n    /**\r\n     * The flag which determines if the selection is in progress.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n\r\n    this.inProgress = false;\r\n    /**\r\n     * The flag indicates that selection was performed by clicking the corner overlay.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n\r\n    this.selectedByCorner = false;\r\n    /**\r\n     * The collection of the selection layer levels where the whole row was selected using the row header or\r\n     * the corner header.\r\n     *\r\n     * @type {Set.<number>}\r\n     */\r\n\r\n    this.selectedByRowHeader = new Set();\r\n    /**\r\n     * The collection of the selection layer levels where the whole column was selected using the column header or\r\n     * the corner header.\r\n     *\r\n     * @type {Set.<number>}\r\n     */\r\n\r\n    this.selectedByColumnHeader = new Set();\r\n    /**\r\n     * Selection data layer (handle visual coordinates).\r\n     *\r\n     * @type {SelectionRange}\r\n     */\r\n\r\n    this.selectedRange = new SelectionRange();\r\n    /**\r\n     * Visualization layer.\r\n     *\r\n     * @type {Highlight}\r\n     */\r\n\r\n    this.highlight = new Highlight({\r\n      headerClassName: settings.currentHeaderClassName,\r\n      activeHeaderClassName: settings.activeHeaderClassName,\r\n      rowClassName: settings.currentRowClassName,\r\n      columnClassName: settings.currentColClassName,\r\n      disabledCellSelection: function disabledCellSelection(row, column) {\r\n        return _this.tableProps.isDisabledCellSelection(row, column);\r\n      },\r\n      cellCornerVisible: function cellCornerVisible() {\r\n        return _this.isCellCornerVisible.apply(_this, arguments);\r\n      },\r\n      areaCornerVisible: function areaCornerVisible() {\r\n        return _this.isAreaCornerVisible.apply(_this, arguments);\r\n      },\r\n      visualToRenderableCoords: function visualToRenderableCoords(coords) {\r\n        return _this.tableProps.visualToRenderableCoords(coords);\r\n      },\r\n      renderableToVisualCoords: function renderableToVisualCoords(coords) {\r\n        return _this.tableProps.renderableToVisualCoords(coords);\r\n      }\r\n    });\r\n    /**\r\n     * The module for modifying coordinates.\r\n     *\r\n     * @type {Transformation}\r\n     */\r\n\r\n    this.transformation = new Transformation(this.selectedRange, {\r\n      countRows: function countRows() {\r\n        return _this.tableProps.countRowsTranslated();\r\n      },\r\n      countCols: function countCols() {\r\n        return _this.tableProps.countColsTranslated();\r\n      },\r\n      visualToRenderableCoords: function visualToRenderableCoords(coords) {\r\n        return _this.tableProps.visualToRenderableCoords(coords);\r\n      },\r\n      renderableToVisualCoords: function renderableToVisualCoords(coords) {\r\n        return _this.tableProps.renderableToVisualCoords(coords);\r\n      },\r\n      fixedRowsBottom: function fixedRowsBottom() {\r\n        return settings.fixedRowsBottom;\r\n      },\r\n      minSpareRows: function minSpareRows() {\r\n        return settings.minSpareRows;\r\n      },\r\n      minSpareCols: function minSpareCols() {\r\n        return settings.minSpareCols;\r\n      },\r\n      autoWrapRow: function autoWrapRow() {\r\n        return settings.autoWrapRow;\r\n      },\r\n      autoWrapCol: function autoWrapCol() {\r\n        return settings.autoWrapCol;\r\n      }\r\n    });\r\n    this.transformation.addLocalHook('beforeTransformStart', function () {\r\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n        args[_key] = arguments[_key];\r\n      }\r\n\r\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformStart'].concat(args));\r\n    });\r\n    this.transformation.addLocalHook('afterTransformStart', function () {\r\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\r\n        args[_key2] = arguments[_key2];\r\n      }\r\n\r\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformStart'].concat(args));\r\n    });\r\n    this.transformation.addLocalHook('beforeTransformEnd', function () {\r\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\r\n        args[_key3] = arguments[_key3];\r\n      }\r\n\r\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformEnd'].concat(args));\r\n    });\r\n    this.transformation.addLocalHook('afterTransformEnd', function () {\r\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\r\n        args[_key4] = arguments[_key4];\r\n      }\r\n\r\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformEnd'].concat(args));\r\n    });\r\n    this.transformation.addLocalHook('insertRowRequire', function () {\r\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\r\n        args[_key5] = arguments[_key5];\r\n      }\r\n\r\n      return _this.runLocalHooks.apply(_this, ['insertRowRequire'].concat(args));\r\n    });\r\n    this.transformation.addLocalHook('insertColRequire', function () {\r\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\r\n        args[_key6] = arguments[_key6];\r\n      }\r\n\r\n      return _this.runLocalHooks.apply(_this, ['insertColRequire'].concat(args));\r\n    });\r\n  }\r\n  /**\r\n   * Get data layer for current selection.\r\n   *\r\n   * @returns {SelectionRange}\r\n   */\r\n\r\n\r\n  _createClass(Selection, [{\r\n    key: \"getSelectedRange\",\r\n    value: function getSelectedRange() {\r\n      return this.selectedRange;\r\n    }\r\n    /**\r\n     * Indicate that selection process began. It sets internaly `.inProgress` property to `true`.\r\n     */\r\n\r\n  }, {\r\n    key: \"begin\",\r\n    value: function begin() {\r\n      this.inProgress = true;\r\n    }\r\n    /**\r\n     * Indicate that selection process finished. It sets internaly `.inProgress` property to `false`.\r\n     */\r\n\r\n  }, {\r\n    key: \"finish\",\r\n    value: function finish() {\r\n      this.runLocalHooks('afterSelectionFinished', Array.from(this.selectedRange));\r\n      this.inProgress = false;\r\n    }\r\n    /**\r\n     * Check if the process of selecting the cell/cells is in progress.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isInProgress\",\r\n    value: function isInProgress() {\r\n      return this.inProgress;\r\n    }\r\n    /**\r\n     * Starts selection range on given coordinate object.\r\n     *\r\n     * @param {CellCoords} coords Visual coords.\r\n     * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\r\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\r\n     *                                      the default trigger will be used (isPressedCtrlKey() helper).\r\n     * @param {boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the\r\n     *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.\r\n     */\r\n\r\n  }, {\r\n    key: \"setRangeStart\",\r\n    value: function setRangeStart(coords, multipleSelection) {\r\n      var fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n      var isMultipleMode = this.settings.selectionMode === 'multiple';\r\n      var isMultipleSelection = isUndefined(multipleSelection) ? isPressedCtrlKey() : multipleSelection;\r\n      var isRowNegative = coords.row < 0;\r\n      var isColumnNegative = coords.col < 0;\r\n      var selectedByCorner = isRowNegative && isColumnNegative;\r\n      this.selectedByCorner = selectedByCorner;\r\n      this.runLocalHooks(\"beforeSetRangeStart\".concat(fragment ? 'Only' : ''), coords);\r\n\r\n      if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined(multipleSelection)) {\r\n        this.selectedRange.clear();\r\n      }\r\n\r\n      this.selectedRange.add(coords);\r\n\r\n      if (this.getLayerLevel() === 0) {\r\n        this.selectedByRowHeader.clear();\r\n        this.selectedByColumnHeader.clear();\r\n      }\r\n\r\n      if (!selectedByCorner && isColumnNegative) {\r\n        this.selectedByRowHeader.add(this.getLayerLevel());\r\n      }\r\n\r\n      if (!selectedByCorner && isRowNegative) {\r\n        this.selectedByColumnHeader.add(this.getLayerLevel());\r\n      }\r\n\r\n      if (!fragment) {\r\n        this.setRangeEnd(coords);\r\n      }\r\n    }\r\n    /**\r\n     * Starts selection range on given coordinate object.\r\n     *\r\n     * @param {CellCoords} coords Visual coords.\r\n     * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\r\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\r\n     *                                      the default trigger will be used (isPressedCtrlKey() helper).\r\n     */\r\n\r\n  }, {\r\n    key: \"setRangeStartOnly\",\r\n    value: function setRangeStartOnly(coords, multipleSelection) {\r\n      this.setRangeStart(coords, multipleSelection, true);\r\n    }\r\n    /**\r\n     * Ends selection range on given coordinate object.\r\n     *\r\n     * @param {CellCoords} coords Visual coords.\r\n     */\r\n\r\n  }, {\r\n    key: \"setRangeEnd\",\r\n    value: function setRangeEnd(coords) {\r\n      if (this.selectedRange.isEmpty()) {\r\n        return;\r\n      }\r\n\r\n      this.runLocalHooks('beforeSetRangeEnd', coords);\r\n      this.begin();\r\n      var cellRange = this.selectedRange.current();\r\n\r\n      if (this.settings.selectionMode !== 'single') {\r\n        cellRange.setTo(new CellCoords(coords.row, coords.col));\r\n      } // Set up current selection.\r\n\r\n\r\n      this.highlight.getCell().clear();\r\n\r\n      if (this.highlight.isEnabledFor(CELL_TYPE, cellRange.highlight)) {\r\n        this.highlight.getCell().add(this.selectedRange.current().highlight).commit().adjustCoordinates(cellRange);\r\n      }\r\n\r\n      var layerLevel = this.getLayerLevel(); // If the next layer level is lower than previous then clear all area and header highlights. This is the\r\n      // indication that the new selection is performing.\r\n\r\n      if (layerLevel < this.highlight.layerLevel) {\r\n        arrayEach(this.highlight.getAreas(), function (highlight) {\r\n          return void highlight.clear();\r\n        });\r\n        arrayEach(this.highlight.getHeaders(), function (highlight) {\r\n          return void highlight.clear();\r\n        });\r\n        arrayEach(this.highlight.getActiveHeaders(), function (highlight) {\r\n          return void highlight.clear();\r\n        });\r\n      }\r\n\r\n      this.highlight.useLayerLevel(layerLevel);\r\n      var areaHighlight = this.highlight.createOrGetArea();\r\n      var headerHighlight = this.highlight.createOrGetHeader();\r\n      var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\r\n      areaHighlight.clear();\r\n      headerHighlight.clear();\r\n      activeHeaderHighlight.clear();\r\n\r\n      if (this.highlight.isEnabledFor(AREA_TYPE, cellRange.highlight) && (this.isMultiple() || layerLevel >= 1)) {\r\n        areaHighlight.add(cellRange.from).add(cellRange.to).commit();\r\n\r\n        if (layerLevel === 1) {\r\n          // For single cell selection in the same layer, we do not create area selection to prevent blue background.\r\n          // When non-consecutive selection is performed we have to add that missing area selection to the previous layer\r\n          // based on previous coordinates. It only occurs when the previous selection wasn't select multiple cells.\r\n          var previousRange = this.selectedRange.previous();\r\n          this.highlight.useLayerLevel(layerLevel - 1).createOrGetArea().add(previousRange.from).commit() // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).\r\n          .adjustCoordinates(previousRange);\r\n          this.highlight.useLayerLevel(layerLevel);\r\n        }\r\n      }\r\n\r\n      if (this.highlight.isEnabledFor(HEADER_TYPE, cellRange.highlight)) {\r\n        // The header selection generally contains cell selection. In a case when all rows (or columns)\r\n        // are hidden that visual coordinates are translated to renderable coordinates that do not exist.\r\n        // Hence no header highlight is generated. In that case, to make a column (or a row) header\r\n        // highlight, the row and column index has to point to the header (the negative value). See #7052.\r\n        var areAnyRowsRendered = this.tableProps.countRowsTranslated() === 0;\r\n        var areAnyColumnsRendered = this.tableProps.countColsTranslated() === 0;\r\n        var headerCellRange = cellRange;\r\n\r\n        if (areAnyRowsRendered || areAnyColumnsRendered) {\r\n          headerCellRange = cellRange.clone();\r\n        }\r\n\r\n        if (areAnyRowsRendered) {\r\n          headerCellRange.from.row = -1;\r\n        }\r\n\r\n        if (areAnyColumnsRendered) {\r\n          headerCellRange.from.col = -1;\r\n        }\r\n\r\n        if (this.settings.selectionMode === 'single') {\r\n          if (this.isSelectedByAnyHeader()) {\r\n            headerCellRange.from.normalize();\r\n          }\r\n\r\n          headerHighlight.add(headerCellRange.from).commit();\r\n        } else {\r\n          headerHighlight.add(headerCellRange.from).add(headerCellRange.to).commit();\r\n        }\r\n\r\n        if (this.isEntireRowSelected()) {\r\n          var isRowSelected = this.tableProps.countCols() === cellRange.getWidth(); // Make sure that the whole row is selected (in case where selectionMode is set to 'single')\r\n\r\n          if (isRowSelected) {\r\n            activeHeaderHighlight.add(new CellCoords(cellRange.from.row, -1)).add(new CellCoords(cellRange.to.row, -1)).commit();\r\n          }\r\n        }\r\n\r\n        if (this.isEntireColumnSelected()) {\r\n          var isColumnSelected = this.tableProps.countRows() === cellRange.getHeight(); // Make sure that the whole column is selected (in case where selectionMode is set to 'single')\r\n\r\n          if (isColumnSelected) {\r\n            activeHeaderHighlight.add(new CellCoords(-1, cellRange.from.col)).add(new CellCoords(-1, cellRange.to.col)).commit();\r\n          }\r\n        }\r\n      }\r\n\r\n      this.runLocalHooks('afterSetRangeEnd', coords);\r\n    }\r\n    /**\r\n     * Returns information if we have a multiselection. This method check multiselection only on the latest layer of\r\n     * the selection.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isMultiple\",\r\n    value: function isMultiple() {\r\n      var isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());\r\n      this.runLocalHooks('afterIsMultipleSelection', isMultipleListener);\r\n      return isMultipleListener.value;\r\n    }\r\n    /**\r\n     * Selects cell relative to the current cell (if possible).\r\n     *\r\n     * @param {number} rowDelta Rows number to move, value can be passed as negative number.\r\n     * @param {number} colDelta Columns number to move, value can be passed as negative number.\r\n     * @param {boolean} force If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\r\n     *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\r\n     */\r\n\r\n  }, {\r\n    key: \"transformStart\",\r\n    value: function transformStart(rowDelta, colDelta, force) {\r\n      this.setRangeStart(this.transformation.transformStart(rowDelta, colDelta, force));\r\n    }\r\n    /**\r\n     * Sets selection end cell relative to the current selection end cell (if possible).\r\n     *\r\n     * @param {number} rowDelta Rows number to move, value can be passed as negative number.\r\n     * @param {number} colDelta Columns number to move, value can be passed as negative number.\r\n     */\r\n\r\n  }, {\r\n    key: \"transformEnd\",\r\n    value: function transformEnd(rowDelta, colDelta) {\r\n      this.setRangeEnd(this.transformation.transformEnd(rowDelta, colDelta));\r\n    }\r\n    /**\r\n     * Returns currently used layer level.\r\n     *\r\n     * @returns {number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.\r\n     */\r\n\r\n  }, {\r\n    key: \"getLayerLevel\",\r\n    value: function getLayerLevel() {\r\n      return this.selectedRange.size() - 1;\r\n    }\r\n    /**\r\n     * Returns `true` if currently there is a selection on the screen, `false` otherwise.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isSelected\",\r\n    value: function isSelected() {\r\n      return !this.selectedRange.isEmpty();\r\n    }\r\n    /**\r\n     * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`\r\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any row header\r\n     * was clicked on any selection layer level.\r\n     *\r\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isSelectedByRowHeader\",\r\n    value: function isSelectedByRowHeader() {\r\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\r\n      return !this.isSelectedByCorner(layerLevel) && this.isEntireRowSelected(layerLevel);\r\n    }\r\n    /**\r\n     * Returns `true` if the selection consists of entire rows (including their headers). If the `layerLevel`\r\n     * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\r\n     *\r\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isEntireRowSelected\",\r\n    value: function isEntireRowSelected() {\r\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\r\n      return layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel);\r\n    }\r\n    /**\r\n     * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`\r\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any column header\r\n     * was clicked on any selection layer level.\r\n     *\r\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isSelectedByColumnHeader\",\r\n    value: function isSelectedByColumnHeader() {\r\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\r\n      return !this.isSelectedByCorner() && this.isEntireColumnSelected(layerLevel);\r\n    }\r\n    /**\r\n     * Returns `true` if the selection consists of entire columns (including their headers). If the `layerLevel`\r\n     * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\r\n     *\r\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isEntireColumnSelected\",\r\n    value: function isEntireColumnSelected() {\r\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\r\n      return layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel);\r\n    }\r\n    /**\r\n     * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isSelectedByAnyHeader\",\r\n    value: function isSelectedByAnyHeader() {\r\n      return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1) || this.isSelectedByCorner();\r\n    }\r\n    /**\r\n     * Returns `true` if the selection was applied by clicking on the left-top corner overlay.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isSelectedByCorner\",\r\n    value: function isSelectedByCorner() {\r\n      return this.selectedByCorner;\r\n    }\r\n    /**\r\n     * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\r\n     * the coords object is within selection range.\r\n     *\r\n     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"inInSelection\",\r\n    value: function inInSelection(coords) {\r\n      return this.selectedRange.includes(coords);\r\n    }\r\n    /**\r\n     * Returns `true` if the cell corner should be visible.\r\n     *\r\n     * @private\r\n     * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\r\n     */\r\n\r\n  }, {\r\n    key: \"isCellCornerVisible\",\r\n    value: function isCellCornerVisible() {\r\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();\r\n    }\r\n    /**\r\n     * Returns `true` if the area corner should be visible.\r\n     *\r\n     * @param {number} layerLevel The layer level.\r\n     * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\r\n     */\r\n\r\n  }, {\r\n    key: \"isAreaCornerVisible\",\r\n    value: function isAreaCornerVisible(layerLevel) {\r\n      if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {\r\n        return false;\r\n      }\r\n\r\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();\r\n    }\r\n    /**\r\n     * Clear the selection by resetting the collected ranges and highlights.\r\n     */\r\n\r\n  }, {\r\n    key: \"clear\",\r\n    value: function clear() {\r\n      // TODO: collections selectedByColumnHeader and selectedByRowHeader should be clear too.\r\n      this.selectedRange.clear();\r\n      this.highlight.clear();\r\n    }\r\n    /**\r\n     * Deselects all selected cells.\r\n     */\r\n\r\n  }, {\r\n    key: \"deselect\",\r\n    value: function deselect() {\r\n      if (!this.isSelected()) {\r\n        return;\r\n      }\r\n\r\n      this.inProgress = false;\r\n      this.clear();\r\n      this.runLocalHooks('afterDeselect');\r\n    }\r\n    /**\r\n     * Select all cells.\r\n     *\r\n     * @param {boolean} [includeRowHeaders=false] `true` If the selection should include the row headers, `false`\r\n     * otherwise.\r\n     * @param {boolean} [includeColumnHeaders=false] `true` If the selection should include the column headers, `false`\r\n     * otherwise.\r\n     */\r\n\r\n  }, {\r\n    key: \"selectAll\",\r\n    value: function selectAll() {\r\n      var includeRowHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\r\n      var includeColumnHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n      var nrOfRows = this.tableProps.countRows();\r\n      var nrOfColumns = this.tableProps.countCols(); // We can't select cells when there is no data.\r\n\r\n      if (!includeRowHeaders && !includeColumnHeaders && (nrOfRows === 0 || nrOfColumns === 0)) {\r\n        return;\r\n      }\r\n\r\n      var startCoords = new CellCoords(includeColumnHeaders ? -1 : 0, includeRowHeaders ? -1 : 0);\r\n      this.clear();\r\n      this.setRangeStartOnly(startCoords);\r\n      this.selectedByRowHeader.add(this.getLayerLevel());\r\n      this.selectedByColumnHeader.add(this.getLayerLevel());\r\n      this.setRangeEnd(new CellCoords(nrOfRows - 1, nrOfColumns - 1));\r\n      this.finish();\r\n    }\r\n    /**\r\n     * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\r\n     * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such\r\n     * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.\r\n     * If the passed ranges have another format the exception will be thrown.\r\n     *\r\n     * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.\r\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\r\n     */\r\n\r\n  }, {\r\n    key: \"selectCells\",\r\n    value: function selectCells(selectionRanges) {\r\n      var _this2 = this;\r\n\r\n      var selectionType = detectSelectionType(selectionRanges);\r\n\r\n      if (selectionType === SELECTION_TYPE_EMPTY) {\r\n        return false;\r\n      } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {\r\n        throw new Error(toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"Unsupported format of the selection ranges was passed. To select cells pass \\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd, \\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.\"], [\"Unsupported format of the selection ranges was passed. To select cells pass\\\\x20\\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd,\\\\x20\\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.\"]))));\r\n      }\r\n\r\n      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\r\n        propToCol: function propToCol(prop) {\r\n          return _this2.tableProps.propToCol(prop);\r\n        },\r\n        keepDirection: true\r\n      });\r\n      var nrOfRows = this.tableProps.countRows();\r\n      var nrOfColumns = this.tableProps.countCols(); // Check if every layer of the coordinates are valid.\r\n\r\n      var isValid = !selectionRanges.some(function (selection) {\r\n        var _selectionSchemaNorma = selectionSchemaNormalizer(selection),\r\n            _selectionSchemaNorma2 = _slicedToArray(_selectionSchemaNorma, 4),\r\n            rowStart = _selectionSchemaNorma2[0],\r\n            columnStart = _selectionSchemaNorma2[1],\r\n            rowEnd = _selectionSchemaNorma2[2],\r\n            columnEnd = _selectionSchemaNorma2[3];\r\n\r\n        var _isValid = isValidCoord(rowStart, nrOfRows) && isValidCoord(columnStart, nrOfColumns) && isValidCoord(rowEnd, nrOfRows) && isValidCoord(columnEnd, nrOfColumns);\r\n\r\n        return !_isValid;\r\n      });\r\n\r\n      if (isValid) {\r\n        this.clear();\r\n        arrayEach(selectionRanges, function (selection) {\r\n          var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection),\r\n              _selectionSchemaNorma4 = _slicedToArray(_selectionSchemaNorma3, 4),\r\n              rowStart = _selectionSchemaNorma4[0],\r\n              columnStart = _selectionSchemaNorma4[1],\r\n              rowEnd = _selectionSchemaNorma4[2],\r\n              columnEnd = _selectionSchemaNorma4[3];\r\n\r\n          _this2.setRangeStartOnly(new CellCoords(rowStart, columnStart), false);\r\n\r\n          _this2.setRangeEnd(new CellCoords(rowEnd, columnEnd));\r\n\r\n          _this2.finish();\r\n        });\r\n      }\r\n\r\n      return isValid;\r\n    }\r\n    /**\r\n     * Select column specified by `startColumn` visual index or column property or a range of columns finishing at\r\n     * `endColumn`.\r\n     *\r\n     * @param {number|string} startColumn Visual column index or column property from which the selection starts.\r\n     * @param {number|string} [endColumn] Visual column index or column property from to the selection finishes.\r\n     * @param {number} [headerLevel=-1] A row header index that triggers the column selection. The value can\r\n     *                                  take -1 to -N, where -1 means the header closest to the cells.\r\n     *\r\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\r\n     */\r\n\r\n  }, {\r\n    key: \"selectColumns\",\r\n    value: function selectColumns(startColumn) {\r\n      var endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\r\n      var headerLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\r\n      var start = typeof startColumn === 'string' ? this.tableProps.propToCol(startColumn) : startColumn;\r\n      var end = typeof endColumn === 'string' ? this.tableProps.propToCol(endColumn) : endColumn;\r\n      var nrOfColumns = this.tableProps.countCols();\r\n      var nrOfRows = this.tableProps.countRows();\r\n      var isValid = isValidCoord(start, nrOfColumns) && isValidCoord(end, nrOfColumns);\r\n\r\n      if (isValid) {\r\n        this.setRangeStartOnly(new CellCoords(headerLevel, start));\r\n        this.setRangeEnd(new CellCoords(nrOfRows - 1, end));\r\n        this.finish();\r\n      }\r\n\r\n      return isValid;\r\n    }\r\n    /**\r\n     * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\r\n     *\r\n     * @param {number} startRow Visual row index from which the selection starts.\r\n     * @param {number} [endRow] Visual row index from to the selection finishes.\r\n     * @param {number} [headerLevel=-1] A column header index that triggers the row selection.\r\n     *                                  The value can take -1 to -N, where -1 means the header\r\n     *                                  closest to the cells.\r\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\r\n     */\r\n\r\n  }, {\r\n    key: \"selectRows\",\r\n    value: function selectRows(startRow) {\r\n      var endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\r\n      var headerLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\r\n      var nrOfRows = this.tableProps.countRows();\r\n      var nrOfColumns = this.tableProps.countCols();\r\n      var isValid = isValidCoord(startRow, nrOfRows) && isValidCoord(endRow, nrOfRows);\r\n\r\n      if (isValid) {\r\n        this.setRangeStartOnly(new CellCoords(startRow, headerLevel));\r\n        this.setRangeEnd(new CellCoords(endRow, nrOfColumns - 1));\r\n        this.finish();\r\n      }\r\n\r\n      return isValid;\r\n    }\r\n    /**\r\n     * Rewrite the rendered state of the selection as visual selection may have a new representation in the DOM.\r\n     */\r\n\r\n  }, {\r\n    key: \"refresh\",\r\n    value: function refresh() {\r\n      var customSelections = this.highlight.getCustomSelections();\r\n      customSelections.forEach(function (customSelection) {\r\n        customSelection.commit();\r\n      });\r\n\r\n      if (!this.isSelected()) {\r\n        return;\r\n      }\r\n\r\n      var cellHighlight = this.highlight.getCell();\r\n      var currentLayer = this.getLayerLevel();\r\n      cellHighlight.commit().adjustCoordinates(this.selectedRange.current()); // Rewriting rendered ranges going through all layers.\r\n\r\n      for (var layerLevel = 0; layerLevel < this.selectedRange.size(); layerLevel += 1) {\r\n        this.highlight.useLayerLevel(layerLevel);\r\n        var areaHighlight = this.highlight.createOrGetArea();\r\n        var headerHighlight = this.highlight.createOrGetHeader();\r\n        var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\r\n        areaHighlight.commit();\r\n        headerHighlight.commit();\r\n        activeHeaderHighlight.commit();\r\n      } // Reverting starting layer for the Highlight.\r\n\r\n\r\n      this.highlight.useLayerLevel(currentLayer);\r\n    }\r\n  }]);\r\n\r\n  return Selection;\r\n}();\r\n\r\nmixin(Selection, localHooks);\r\nexport default Selection;"]},"metadata":{},"sourceType":"module"}