{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { CellCoords, CellRange } from \"../../../3rdparty/walkontable/src/index.mjs\";\n/**\r\n * Class responsible for all of the Selection-related operations on merged cells.\r\n *\r\n * @class SelectionCalculations\r\n * @plugin MergeCells\r\n * @util\r\n */\n\nvar SelectionCalculations = /*#__PURE__*/function () {\n  function SelectionCalculations(plugin) {\n    _classCallCheck(this, SelectionCalculations);\n    /**\r\n     * Reference to the Merge Cells plugin.\r\n     *\r\n     * @type {MergeCells}\r\n     */\n\n\n    this.plugin = plugin;\n    /**\r\n     * Class name used for fully selected merged cells.\r\n     *\r\n     * @type {string}\r\n     */\n\n    this.fullySelectedMergedCellClassName = 'fullySelectedMergedCell';\n  }\n  /**\r\n   * \"Snap\" the delta value according to defined merged cells. (In other words, compensate the rowspan -\r\n   * e.g. Going up with `delta.row = -1` over a merged cell with `rowspan = 3`, `delta.row` should change to `-3`.).\r\n   *\r\n   * @param {object} delta The delta object containing `row` and `col` properties.\r\n   * @param {CellRange} selectionRange The selection range.\r\n   * @param {object} mergedCell A merged cell object.\r\n   */\n\n\n  _createClass(SelectionCalculations, [{\n    key: \"snapDelta\",\n    value: function snapDelta(delta, selectionRange, mergedCell) {\n      var cellCoords = selectionRange.to;\n      var newRow = cellCoords.row + delta.row;\n      var newColumn = cellCoords.col + delta.col;\n\n      if (delta.row) {\n        this.jumpOverMergedCell(delta, mergedCell, newRow);\n      } else if (delta.col) {\n        this.jumpOverMergedCell(delta, mergedCell, newColumn);\n      }\n    }\n    /**\r\n     * \"Jump\" over the merged cell (compensate for the indexes within the merged cell to get past it).\r\n     *\r\n     * @private\r\n     * @param {object} delta The delta object.\r\n     * @param {MergedCellCoords} mergedCell The merge cell object.\r\n     * @param {number} newIndex New row/column index, created with the delta.\r\n     */\n\n  }, {\n    key: \"jumpOverMergedCell\",\n    value: function jumpOverMergedCell(delta, mergedCell, newIndex) {\n      var flatDelta = delta.row || delta.col;\n      var includesIndex = null;\n      var firstIndex = null;\n      var lastIndex = null;\n\n      if (delta.row) {\n        includesIndex = mergedCell.includesVertically(newIndex);\n        firstIndex = mergedCell.row;\n        lastIndex = mergedCell.getLastRow();\n      } else if (delta.col) {\n        includesIndex = mergedCell.includesHorizontally(newIndex);\n        firstIndex = mergedCell.col;\n        lastIndex = mergedCell.getLastColumn();\n      }\n\n      if (flatDelta === 0) {\n        return;\n      } else if (flatDelta > 0) {\n        if (includesIndex && newIndex !== firstIndex) {\n          flatDelta += lastIndex - newIndex + 1;\n        }\n      } else if (includesIndex && newIndex !== lastIndex) {\n        flatDelta -= newIndex - firstIndex + 1;\n      }\n\n      if (delta.row) {\n        delta.row = flatDelta;\n      } else if (delta.col) {\n        delta.col = flatDelta;\n      }\n    }\n    /**\r\n     * Get a selection range with `to` property incremented by the provided delta.\r\n     *\r\n     * @param {CellRange} oldSelectionRange The base selection range.\r\n     * @param {object} delta The delta object with `row` and `col` properties.\r\n     * @returns {CellRange} A new `CellRange` object.\r\n     */\n\n  }, {\n    key: \"getUpdatedSelectionRange\",\n    value: function getUpdatedSelectionRange(oldSelectionRange, delta) {\n      return new CellRange(oldSelectionRange.highlight, oldSelectionRange.from, new CellCoords(oldSelectionRange.to.row + delta.row, oldSelectionRange.to.col + delta.col));\n    }\n    /**\r\n     * Generate an additional class name for the entirely-selected merged cells.\r\n     *\r\n     * @param {number} currentRow Visual row index of the currently processed cell.\r\n     * @param {number} currentColumn Visual column index of the currently cell.\r\n     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\r\n     * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.\r\n     * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.\r\n     */\n\n  }, {\n    key: \"getSelectedMergedCellClassName\",\n    value: function getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n      var startRow = Math.min(cornersOfSelection[0], cornersOfSelection[2]);\n      var startColumn = Math.min(cornersOfSelection[1], cornersOfSelection[3]);\n      var endRow = Math.max(cornersOfSelection[0], cornersOfSelection[2]);\n      var endColumn = Math.max(cornersOfSelection[1], cornersOfSelection[3]);\n\n      if (layerLevel === void 0) {\n        return;\n      }\n\n      var isFirstRenderableMergedCell = this.plugin.mergedCellsCollection.isFirstRenderableMergedCell(currentRow, currentColumn); // We add extra classes just to the first renderable merged cell.\n\n      if (!isFirstRenderableMergedCell) {\n        return;\n      }\n\n      var mergedCell = this.plugin.mergedCellsCollection.get(currentRow, currentColumn);\n\n      if (!mergedCell) {\n        return;\n      }\n\n      var mergeRowEnd = mergedCell.getLastRow();\n      var mergeColumnEnd = mergedCell.getLastColumn();\n      var fullMergeAreaWithinSelection = startRow <= mergedCell.row && startColumn <= mergedCell.col && endRow >= mergeRowEnd && endColumn >= mergeColumnEnd;\n\n      if (fullMergeAreaWithinSelection) {\n        return \"\".concat(this.fullySelectedMergedCellClassName, \"-\").concat(layerLevel);\n      } else if (this.plugin.selectionCalculations.isMergeCellFullySelected(mergedCell, this.plugin.hot.getSelectedRange())) {\n        // eslint-disable-line max-len\n        return \"\".concat(this.fullySelectedMergedCellClassName, \"-multiple\");\n      }\n    }\n    /**\r\n     * Check if the provided merged cell is fully selected (by one or many layers of selection).\r\n     *\r\n     * @param {MergedCellCoords} mergedCell The merged cell to be processed.\r\n     * @param {CellRange[]} selectionRangesArray Array of selection ranges.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isMergeCellFullySelected\",\n    value: function isMergeCellFullySelected(mergedCell, selectionRangesArray) {\n      var mergedCellIndividualCoords = [];\n\n      if (!selectionRangesArray || !mergedCell) {\n        return false;\n      }\n\n      for (var r = 0; r < mergedCell.rowspan; r += 1) {\n        for (var c = 0; c < mergedCell.colspan; c += 1) {\n          mergedCellIndividualCoords.push(new CellCoords(mergedCell.row + r, mergedCell.col + c));\n        }\n      }\n\n      for (var i = 0; i < mergedCellIndividualCoords.length; i += 1) {\n        var insideSelections = [];\n\n        for (var s = 0; s < selectionRangesArray.length; s += 1) {\n          insideSelections[s] = selectionRangesArray[s].includes(mergedCellIndividualCoords[i]);\n        }\n\n        if (!insideSelections.includes(true)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\r\n     * Generate an array of the entirely-selected merged cells' class names.\r\n     *\r\n     * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\r\n     */\n\n  }, {\n    key: \"getSelectedMergedCellClassNameToRemove\",\n    value: function getSelectedMergedCellClassNameToRemove() {\n      var classNames = [];\n\n      for (var i = 0; i <= 7; i += 1) {\n        classNames.push(\"\".concat(this.fullySelectedMergedCellClassName, \"-\").concat(i));\n      }\n\n      classNames.push(\"\".concat(this.fullySelectedMergedCellClassName, \"-multiple\"));\n      return classNames;\n    }\n  }]);\n\n  return SelectionCalculations;\n}();\n\nexport default SelectionCalculations;","map":{"version":3,"sources":["C:/Users/ssaez1/technip-repositories/isotracker/isotracker-react/node_modules/handsontable/plugins/mergeCells/calculations/selection.mjs"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","CellCoords","CellRange","SelectionCalculations","plugin","fullySelectedMergedCellClassName","value","snapDelta","delta","selectionRange","mergedCell","cellCoords","to","newRow","row","newColumn","col","jumpOverMergedCell","newIndex","flatDelta","includesIndex","firstIndex","lastIndex","includesVertically","getLastRow","includesHorizontally","getLastColumn","getUpdatedSelectionRange","oldSelectionRange","highlight","from","getSelectedMergedCellClassName","currentRow","currentColumn","cornersOfSelection","layerLevel","startRow","Math","min","startColumn","endRow","max","endColumn","isFirstRenderableMergedCell","mergedCellsCollection","get","mergeRowEnd","mergeColumnEnd","fullMergeAreaWithinSelection","concat","selectionCalculations","isMergeCellFullySelected","hot","getSelectedRange","selectionRangesArray","mergedCellIndividualCoords","r","rowspan","c","colspan","push","insideSelections","s","includes","getSelectedMergedCellClassNameToRemove","classNames"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.concat.js\";\r\nimport \"core-js/modules/es.array.includes.js\";\r\nimport \"core-js/modules/es.string.includes.js\";\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport { CellCoords, CellRange } from \"../../../3rdparty/walkontable/src/index.mjs\";\r\n/**\r\n * Class responsible for all of the Selection-related operations on merged cells.\r\n *\r\n * @class SelectionCalculations\r\n * @plugin MergeCells\r\n * @util\r\n */\r\n\r\nvar SelectionCalculations = /*#__PURE__*/function () {\r\n  function SelectionCalculations(plugin) {\r\n    _classCallCheck(this, SelectionCalculations);\r\n\r\n    /**\r\n     * Reference to the Merge Cells plugin.\r\n     *\r\n     * @type {MergeCells}\r\n     */\r\n    this.plugin = plugin;\r\n    /**\r\n     * Class name used for fully selected merged cells.\r\n     *\r\n     * @type {string}\r\n     */\r\n\r\n    this.fullySelectedMergedCellClassName = 'fullySelectedMergedCell';\r\n  }\r\n  /**\r\n   * \"Snap\" the delta value according to defined merged cells. (In other words, compensate the rowspan -\r\n   * e.g. Going up with `delta.row = -1` over a merged cell with `rowspan = 3`, `delta.row` should change to `-3`.).\r\n   *\r\n   * @param {object} delta The delta object containing `row` and `col` properties.\r\n   * @param {CellRange} selectionRange The selection range.\r\n   * @param {object} mergedCell A merged cell object.\r\n   */\r\n\r\n\r\n  _createClass(SelectionCalculations, [{\r\n    key: \"snapDelta\",\r\n    value: function snapDelta(delta, selectionRange, mergedCell) {\r\n      var cellCoords = selectionRange.to;\r\n      var newRow = cellCoords.row + delta.row;\r\n      var newColumn = cellCoords.col + delta.col;\r\n\r\n      if (delta.row) {\r\n        this.jumpOverMergedCell(delta, mergedCell, newRow);\r\n      } else if (delta.col) {\r\n        this.jumpOverMergedCell(delta, mergedCell, newColumn);\r\n      }\r\n    }\r\n    /**\r\n     * \"Jump\" over the merged cell (compensate for the indexes within the merged cell to get past it).\r\n     *\r\n     * @private\r\n     * @param {object} delta The delta object.\r\n     * @param {MergedCellCoords} mergedCell The merge cell object.\r\n     * @param {number} newIndex New row/column index, created with the delta.\r\n     */\r\n\r\n  }, {\r\n    key: \"jumpOverMergedCell\",\r\n    value: function jumpOverMergedCell(delta, mergedCell, newIndex) {\r\n      var flatDelta = delta.row || delta.col;\r\n      var includesIndex = null;\r\n      var firstIndex = null;\r\n      var lastIndex = null;\r\n\r\n      if (delta.row) {\r\n        includesIndex = mergedCell.includesVertically(newIndex);\r\n        firstIndex = mergedCell.row;\r\n        lastIndex = mergedCell.getLastRow();\r\n      } else if (delta.col) {\r\n        includesIndex = mergedCell.includesHorizontally(newIndex);\r\n        firstIndex = mergedCell.col;\r\n        lastIndex = mergedCell.getLastColumn();\r\n      }\r\n\r\n      if (flatDelta === 0) {\r\n        return;\r\n      } else if (flatDelta > 0) {\r\n        if (includesIndex && newIndex !== firstIndex) {\r\n          flatDelta += lastIndex - newIndex + 1;\r\n        }\r\n      } else if (includesIndex && newIndex !== lastIndex) {\r\n        flatDelta -= newIndex - firstIndex + 1;\r\n      }\r\n\r\n      if (delta.row) {\r\n        delta.row = flatDelta;\r\n      } else if (delta.col) {\r\n        delta.col = flatDelta;\r\n      }\r\n    }\r\n    /**\r\n     * Get a selection range with `to` property incremented by the provided delta.\r\n     *\r\n     * @param {CellRange} oldSelectionRange The base selection range.\r\n     * @param {object} delta The delta object with `row` and `col` properties.\r\n     * @returns {CellRange} A new `CellRange` object.\r\n     */\r\n\r\n  }, {\r\n    key: \"getUpdatedSelectionRange\",\r\n    value: function getUpdatedSelectionRange(oldSelectionRange, delta) {\r\n      return new CellRange(oldSelectionRange.highlight, oldSelectionRange.from, new CellCoords(oldSelectionRange.to.row + delta.row, oldSelectionRange.to.col + delta.col));\r\n    }\r\n    /**\r\n     * Generate an additional class name for the entirely-selected merged cells.\r\n     *\r\n     * @param {number} currentRow Visual row index of the currently processed cell.\r\n     * @param {number} currentColumn Visual column index of the currently cell.\r\n     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\r\n     * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.\r\n     * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.\r\n     */\r\n\r\n  }, {\r\n    key: \"getSelectedMergedCellClassName\",\r\n    value: function getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel) {\r\n      var startRow = Math.min(cornersOfSelection[0], cornersOfSelection[2]);\r\n      var startColumn = Math.min(cornersOfSelection[1], cornersOfSelection[3]);\r\n      var endRow = Math.max(cornersOfSelection[0], cornersOfSelection[2]);\r\n      var endColumn = Math.max(cornersOfSelection[1], cornersOfSelection[3]);\r\n\r\n      if (layerLevel === void 0) {\r\n        return;\r\n      }\r\n\r\n      var isFirstRenderableMergedCell = this.plugin.mergedCellsCollection.isFirstRenderableMergedCell(currentRow, currentColumn); // We add extra classes just to the first renderable merged cell.\r\n\r\n      if (!isFirstRenderableMergedCell) {\r\n        return;\r\n      }\r\n\r\n      var mergedCell = this.plugin.mergedCellsCollection.get(currentRow, currentColumn);\r\n\r\n      if (!mergedCell) {\r\n        return;\r\n      }\r\n\r\n      var mergeRowEnd = mergedCell.getLastRow();\r\n      var mergeColumnEnd = mergedCell.getLastColumn();\r\n      var fullMergeAreaWithinSelection = startRow <= mergedCell.row && startColumn <= mergedCell.col && endRow >= mergeRowEnd && endColumn >= mergeColumnEnd;\r\n\r\n      if (fullMergeAreaWithinSelection) {\r\n        return \"\".concat(this.fullySelectedMergedCellClassName, \"-\").concat(layerLevel);\r\n      } else if (this.plugin.selectionCalculations.isMergeCellFullySelected(mergedCell, this.plugin.hot.getSelectedRange())) {\r\n        // eslint-disable-line max-len\r\n        return \"\".concat(this.fullySelectedMergedCellClassName, \"-multiple\");\r\n      }\r\n    }\r\n    /**\r\n     * Check if the provided merged cell is fully selected (by one or many layers of selection).\r\n     *\r\n     * @param {MergedCellCoords} mergedCell The merged cell to be processed.\r\n     * @param {CellRange[]} selectionRangesArray Array of selection ranges.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"isMergeCellFullySelected\",\r\n    value: function isMergeCellFullySelected(mergedCell, selectionRangesArray) {\r\n      var mergedCellIndividualCoords = [];\r\n\r\n      if (!selectionRangesArray || !mergedCell) {\r\n        return false;\r\n      }\r\n\r\n      for (var r = 0; r < mergedCell.rowspan; r += 1) {\r\n        for (var c = 0; c < mergedCell.colspan; c += 1) {\r\n          mergedCellIndividualCoords.push(new CellCoords(mergedCell.row + r, mergedCell.col + c));\r\n        }\r\n      }\r\n\r\n      for (var i = 0; i < mergedCellIndividualCoords.length; i += 1) {\r\n        var insideSelections = [];\r\n\r\n        for (var s = 0; s < selectionRangesArray.length; s += 1) {\r\n          insideSelections[s] = selectionRangesArray[s].includes(mergedCellIndividualCoords[i]);\r\n        }\r\n\r\n        if (!insideSelections.includes(true)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    }\r\n    /**\r\n     * Generate an array of the entirely-selected merged cells' class names.\r\n     *\r\n     * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\r\n     */\r\n\r\n  }, {\r\n    key: \"getSelectedMergedCellClassNameToRemove\",\r\n    value: function getSelectedMergedCellClassNameToRemove() {\r\n      var classNames = [];\r\n\r\n      for (var i = 0; i <= 7; i += 1) {\r\n        classNames.push(\"\".concat(this.fullySelectedMergedCellClassName, \"-\").concat(i));\r\n      }\r\n\r\n      classNames.push(\"\".concat(this.fullySelectedMergedCellClassName, \"-multiple\"));\r\n      return classNames;\r\n    }\r\n  }]);\r\n\r\n  return SelectionCalculations;\r\n}();\r\n\r\nexport default SelectionCalculations;"]},"metadata":{},"sourceType":"module"}